; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_ll_usb.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_ll_usb.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_ll_usb.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c]
                          THUMB

                          AREA ||i.USB_ActivateDedicatedEndpoint||, CODE, READONLY, ALIGN=2

                  USB_ActivateDedicatedEndpoint PROC
;;;585      */
;;;586    HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;587    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;588      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;589      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;590    
;;;591      /* Read DEPCTLn register */
;;;592      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d12c              BNE      |L1.106|
;;;593      {
;;;594        if (((USBx_INEP(epnum)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f4004000          AND      r0,r0,#0x8000
00001e  b9b0              CBNZ     r0,|L1.78|
;;;595        {
;;;596          USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
000020  8918              LDRH     r0,[r3,#8]
000022  f3c0000a          UBFX     r0,r0,#0,#11
000026  78dd              LDRB     r5,[r3,#3]
000028  ea404085          ORR      r0,r0,r5,LSL #18
00002c  ea405081          ORR      r0,r0,r1,LSL #22
000030  f0405080          ORR      r0,r0,#0x10000000
000034  f4404000          ORR      r0,r0,#0x8000
000038  f5026510          ADD      r5,r2,#0x900
00003c  eb051541          ADD      r5,r5,r1,LSL #5
000040  682d              LDR      r5,[r5,#0]
000042  4328              ORRS     r0,r0,r5
000044  f5026510          ADD      r5,r2,#0x900
000048  eb051541          ADD      r5,r5,r1,LSL #5
00004c  6028              STR      r0,[r5,#0]
                  |L1.78|
;;;597                                       ((uint32_t)ep->type << 18) | (epnum << 22) |
;;;598                                       USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;599                                       USB_OTG_DIEPCTL_USBAEP;
;;;600        }
;;;601    
;;;602        USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
00004e  f640003c          MOV      r0,#0x83c
000052  5880              LDR      r0,[r0,r2]
000054  781d              LDRB     r5,[r3,#0]
000056  f005060f          AND      r6,r5,#0xf
00005a  2501              MOVS     r5,#1
00005c  40b5              LSLS     r5,r5,r6
00005e  b2ad              UXTH     r5,r5
000060  4328              ORRS     r0,r0,r5
000062  f640053c          MOV      r5,#0x83c
000066  50a8              STR      r0,[r5,r2]
000068  e02b              B        |L1.194|
                  |L1.106|
;;;603      }
;;;604      else
;;;605      {
;;;606        if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
00006a  f5026030          ADD      r0,r2,#0xb00
00006e  eb001041          ADD      r0,r0,r1,LSL #5
000072  6800              LDR      r0,[r0,#0]
000074  f4004000          AND      r0,r0,#0x8000
000078  b9a0              CBNZ     r0,|L1.164|
;;;607        {
;;;608          USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
00007a  8918              LDRH     r0,[r3,#8]
00007c  f3c0000a          UBFX     r0,r0,#0,#11
000080  78dd              LDRB     r5,[r3,#3]
000082  ea404085          ORR      r0,r0,r5,LSL #18
000086  ea405081          ORR      r0,r0,r1,LSL #22
00008a  f4404000          ORR      r0,r0,#0x8000
00008e  f5026530          ADD      r5,r2,#0xb00
000092  eb051541          ADD      r5,r5,r1,LSL #5
000096  682d              LDR      r5,[r5,#0]
000098  4328              ORRS     r0,r0,r5
00009a  f5026530          ADD      r5,r2,#0xb00
00009e  eb051541          ADD      r5,r5,r1,LSL #5
0000a2  6028              STR      r0,[r5,#0]
                  |L1.164|
;;;609                                        ((uint32_t)ep->type << 18) | (epnum << 22) |
;;;610                                        USB_OTG_DOEPCTL_USBAEP;
;;;611        }
;;;612    
;;;613        USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
0000a4  f640003c          MOV      r0,#0x83c
0000a8  5880              LDR      r0,[r0,r2]
0000aa  781d              LDRB     r5,[r3,#0]
0000ac  f005060f          AND      r6,r5,#0xf
0000b0  2501              MOVS     r5,#1
0000b2  40b5              LSLS     r5,r5,r6
0000b4  4e04              LDR      r6,|L1.200|
0000b6  ea064505          AND      r5,r6,r5,LSL #16
0000ba  4328              ORRS     r0,r0,r5
0000bc  f640053c          MOV      r5,#0x83c
0000c0  50a8              STR      r0,[r5,r2]
                  |L1.194|
;;;614      }
;;;615    
;;;616      return HAL_OK;
0000c2  2000              MOVS     r0,#0
;;;617    }
0000c4  bd70              POP      {r4-r6,pc}
;;;618    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L1.200|
                          DCD      0xffff0000

                          AREA ||i.USB_ActivateEndpoint||, CODE, READONLY, ALIGN=2

                  USB_ActivateEndpoint PROC
;;;547      */
;;;548    HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;549    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;550      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;551      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;552    
;;;553      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d12c              BNE      |L2.106|
;;;554      {
;;;555        USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
000010  f640001c          MOV      r0,#0x81c
000014  5880              LDR      r0,[r0,r2]
000016  781d              LDRB     r5,[r3,#0]
000018  f005060f          AND      r6,r5,#0xf
00001c  2501              MOVS     r5,#1
00001e  40b5              LSLS     r5,r5,r6
000020  b2ad              UXTH     r5,r5
000022  4328              ORRS     r0,r0,r5
000024  f640051c          MOV      r5,#0x81c
000028  50a8              STR      r0,[r5,r2]
;;;556    
;;;557        if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
00002a  f5026010          ADD      r0,r2,#0x900
00002e  eb001041          ADD      r0,r0,r1,LSL #5
000032  6800              LDR      r0,[r0,#0]
000034  f4004000          AND      r0,r0,#0x8000
000038  bbf0              CBNZ     r0,|L2.184|
;;;558        {
;;;559          USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
00003a  8918              LDRH     r0,[r3,#8]
00003c  f3c0000a          UBFX     r0,r0,#0,#11
000040  78dd              LDRB     r5,[r3,#3]
000042  ea404085          ORR      r0,r0,r5,LSL #18
000046  ea405081          ORR      r0,r0,r1,LSL #22
00004a  f0405080          ORR      r0,r0,#0x10000000
00004e  f4404000          ORR      r0,r0,#0x8000
000052  f5026510          ADD      r5,r2,#0x900
000056  eb051541          ADD      r5,r5,r1,LSL #5
00005a  682d              LDR      r5,[r5,#0]
00005c  4328              ORRS     r0,r0,r5
00005e  f5026510          ADD      r5,r2,#0x900
000062  eb051541          ADD      r5,r5,r1,LSL #5
000066  6028              STR      r0,[r5,#0]
000068  e02d              B        |L2.198|
                  |L2.106|
;;;560                                       ((uint32_t)ep->type << 18) | (epnum << 22) |
;;;561                                       USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;562                                       USB_OTG_DIEPCTL_USBAEP;
;;;563        }
;;;564      }
;;;565      else
;;;566      {
;;;567        USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
00006a  f640001c          MOV      r0,#0x81c
00006e  5880              LDR      r0,[r0,r2]
000070  781d              LDRB     r5,[r3,#0]
000072  f005060f          AND      r6,r5,#0xf
000076  2501              MOVS     r5,#1
000078  40b5              LSLS     r5,r5,r6
00007a  4e14              LDR      r6,|L2.204|
00007c  ea064505          AND      r5,r6,r5,LSL #16
000080  4328              ORRS     r0,r0,r5
000082  f640051c          MOV      r5,#0x81c
000086  50a8              STR      r0,[r5,r2]
;;;568    
;;;569        if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
000088  f5026030          ADD      r0,r2,#0xb00
00008c  eb001041          ADD      r0,r0,r1,LSL #5
000090  6800              LDR      r0,[r0,#0]
000092  f4004000          AND      r0,r0,#0x8000
000096  b978              CBNZ     r0,|L2.184|
;;;570        {
;;;571          USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
000098  8918              LDRH     r0,[r3,#8]
00009a  f3c0000a          UBFX     r0,r0,#0,#11
00009e  78dd              LDRB     r5,[r3,#3]
0000a0  ea404085          ORR      r0,r0,r5,LSL #18
0000a4  f0405080          ORR      r0,r0,#0x10000000
0000a8  f4404000          ORR      r0,r0,#0x8000
0000ac  f5026530          ADD      r5,r2,#0xb00
0000b0  eb051541          ADD      r5,r5,r1,LSL #5
0000b4  682d              LDR      r5,[r5,#0]
0000b6  e000              B        |L2.186|
                  |L2.184|
0000b8  e005              B        |L2.198|
                  |L2.186|
0000ba  4328              ORRS     r0,r0,r5
0000bc  f5026530          ADD      r5,r2,#0xb00
0000c0  eb051541          ADD      r5,r5,r1,LSL #5
0000c4  6028              STR      r0,[r5,#0]
                  |L2.198|
;;;572                                        ((uint32_t)ep->type << 18) |
;;;573                                        USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;574                                        USB_OTG_DOEPCTL_USBAEP;
;;;575        }
;;;576      }
;;;577      return HAL_OK;
0000c6  2000              MOVS     r0,#0
;;;578    }
0000c8  bd70              POP      {r4-r6,pc}
;;;579    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L2.204|
                          DCD      0xffff0000

                          AREA ||i.USB_ActivateRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USB_ActivateRemoteWakeup PROC
;;;1994     */
;;;1995   HAL_StatusTypeDef USB_ActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1996   {
;;;1997     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1998   
;;;1999     if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
000004  f6400008          MOV      r0,#0x808
000008  5880              LDR      r0,[r0,r2]
00000a  f0000001          AND      r0,r0,#1
00000e  b138              CBZ      r0,|L3.32|
;;;2000     {
;;;2001       /* active Remote wakeup signalling */
;;;2002       USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
000010  f6400004          MOV      r0,#0x804
000014  5880              LDR      r0,[r0,r2]
000016  f0400301          ORR      r3,r0,#1
00001a  f6400004          MOV      r0,#0x804
00001e  5083              STR      r3,[r0,r2]
                  |L3.32|
;;;2003     }
;;;2004   
;;;2005     return HAL_OK;
000020  2000              MOVS     r0,#0
;;;2006   }
000022  4770              BX       lr
;;;2007   
                          ENDP


                          AREA ||i.USB_ActivateSetup||, CODE, READONLY, ALIGN=1

                  USB_ActivateSetup PROC
;;;1263     */
;;;1264   HAL_StatusTypeDef  USB_ActivateSetup(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1265   {
;;;1266     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1267   
;;;1268     /* Set the MPS of the IN EP0 to 64 bytes */
;;;1269     USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
000004  f44f6010          MOV      r0,#0x900
000008  5880              LDR      r0,[r0,r2]
00000a  0ac3              LSRS     r3,r0,#11
00000c  02db              LSLS     r3,r3,#11
00000e  f44f6010          MOV      r0,#0x900
000012  5083              STR      r3,[r0,r2]
;;;1270   
;;;1271     USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
000014  f6400004          MOV      r0,#0x804
000018  5880              LDR      r0,[r0,r2]
00001a  f4407380          ORR      r3,r0,#0x100
00001e  f6400004          MOV      r0,#0x804
000022  5083              STR      r3,[r0,r2]
;;;1272   
;;;1273     return HAL_OK;
000024  2000              MOVS     r0,#0
;;;1274   }
000026  4770              BX       lr
;;;1275   
                          ENDP


                          AREA ||i.USB_ClearInterrupts||, CODE, READONLY, ALIGN=1

                  USB_ClearInterrupts PROC
;;;1240     */
;;;1241   void  USB_ClearInterrupts(USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
000000  6942              LDR      r2,[r0,#0x14]
;;;1242   {
;;;1243     USBx->GINTSTS |= interrupt;
000002  430a              ORRS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;1244   }
000006  4770              BX       lr
;;;1245   
                          ENDP


                          AREA ||i.USB_CoreInit||, CODE, READONLY, ALIGN=2

                  USB_CoreInit PROC
;;;81       */
;;;82     HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  b40f              PUSH     {r0-r3}
;;;83     {
000002  b570              PUSH     {r4-r6,lr}
000004  4604              MOV      r4,r0
;;;84       HAL_StatusTypeDef ret;
;;;85     
;;;86       if (cfg.phy_itface == USB_OTG_ULPI_PHY)
000006  980a              LDR      r0,[sp,#0x28]
000008  2801              CMP      r0,#1
00000a  d117              BNE      |L6.60|
;;;87       {
;;;88         USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  f4203080          BIC      r0,r0,#0x10000
000012  63a0              STR      r0,[r4,#0x38]
;;;89     
;;;90         /* Init The ULPI Interface */
;;;91         USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
000014  68e0              LDR      r0,[r4,#0xc]
000016  491a              LDR      r1,|L6.128|
000018  4008              ANDS     r0,r0,r1
00001a  60e0              STR      r0,[r4,#0xc]
;;;92     
;;;93         /* Select vbus source */
;;;94         USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  f4201040          BIC      r0,r0,#0x300000
000022  60e0              STR      r0,[r4,#0xc]
;;;95         if (cfg.use_external_vbus == 1U)
000024  9811              LDR      r0,[sp,#0x44]
000026  2801              CMP      r0,#1
000028  d103              BNE      |L6.50|
;;;96         {
;;;97           USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  f4401080          ORR      r0,r0,#0x100000
000030  60e0              STR      r0,[r4,#0xc]
                  |L6.50|
;;;98         }
;;;99         /* Reset after a PHY select  */
;;;100        ret = USB_CoreReset(USBx);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       USB_CoreReset
000038  4605              MOV      r5,r0
00003a  e012              B        |L6.98|
                  |L6.60|
;;;101      }
;;;102      else /* FS interface (embedded Phy) */
;;;103      {
;;;104        /* Select FS Embedded PHY */
;;;105        USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  f0400040          ORR      r0,r0,#0x40
000042  60e0              STR      r0,[r4,#0xc]
;;;106    
;;;107        /* Reset after a PHY select */
;;;108        ret = USB_CoreReset(USBx);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       USB_CoreReset
00004a  4605              MOV      r5,r0
;;;109    
;;;110        if (cfg.battery_charging_enable == 0U)
00004c  980e              LDR      r0,[sp,#0x38]
00004e  b920              CBNZ     r0,|L6.90|
;;;111        {
;;;112          /* Activate the USB Transceiver */
;;;113          USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
000050  6ba0              LDR      r0,[r4,#0x38]
000052  f4403080          ORR      r0,r0,#0x10000
000056  63a0              STR      r0,[r4,#0x38]
000058  e003              B        |L6.98|
                  |L6.90|
;;;114        }
;;;115        else
;;;116        {
;;;117          /* Deactivate the USB Transceiver */
;;;118          USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
00005a  6ba0              LDR      r0,[r4,#0x38]
00005c  f4203080          BIC      r0,r0,#0x10000
000060  63a0              STR      r0,[r4,#0x38]
                  |L6.98|
;;;119        }
;;;120      }
;;;121    
;;;122      if (cfg.dma_enable == 1U)
000062  9808              LDR      r0,[sp,#0x20]
000064  2801              CMP      r0,#1
000066  d107              BNE      |L6.120|
;;;123      {
;;;124        USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
000068  68a0              LDR      r0,[r4,#8]
00006a  f0400006          ORR      r0,r0,#6
00006e  60a0              STR      r0,[r4,#8]
;;;125        USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
000070  68a0              LDR      r0,[r4,#8]
000072  f0400020          ORR      r0,r0,#0x20
000076  60a0              STR      r0,[r4,#8]
                  |L6.120|
;;;126      }
;;;127    
;;;128      return ret;
000078  4628              MOV      r0,r5
;;;129    }
00007a  bc70              POP      {r4-r6}
00007c  f85dfb14          LDR      pc,[sp],#0x14
;;;130    
                          ENDP

                  |L6.128|
                          DCD      0xffbdffbf

                          AREA ||i.USB_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_CoreReset PROC
;;;1318     */
;;;1319   static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1320   {
;;;1321     uint32_t count = 0U;
000002  2200              MOVS     r2,#0
;;;1322   
;;;1323     /* Wait for AHB master IDLE state. */
;;;1324     do
000004  bf00              NOP      
                  |L7.6|
;;;1325     {
;;;1326       if (++count > 200000U)
000006  1c50              ADDS     r0,r2,#1
000008  4602              MOV      r2,r0
00000a  4b0f              LDR      r3,|L7.72|
00000c  4298              CMP      r0,r3
00000e  d901              BLS      |L7.20|
;;;1327       {
;;;1328         return HAL_TIMEOUT;
000010  2003              MOVS     r0,#3
                  |L7.18|
;;;1329       }
;;;1330     } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
;;;1331   
;;;1332     /* Core Soft Reset */
;;;1333     count = 0U;
;;;1334     USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
;;;1335   
;;;1336     do
;;;1337     {
;;;1338       if (++count > 200000U)
;;;1339       {
;;;1340         return HAL_TIMEOUT;
;;;1341       }
;;;1342     } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
;;;1343   
;;;1344     return HAL_OK;
;;;1345   }
000012  4770              BX       lr
                  |L7.20|
000014  6908              LDR      r0,[r1,#0x10]         ;1330
000016  f0004000          AND      r0,r0,#0x80000000     ;1330
00001a  2800              CMP      r0,#0                 ;1330
00001c  d0f3              BEQ      |L7.6|
00001e  2200              MOVS     r2,#0                 ;1333
000020  6908              LDR      r0,[r1,#0x10]         ;1334
000022  f0400001          ORR      r0,r0,#1              ;1334
000026  6108              STR      r0,[r1,#0x10]         ;1334
000028  bf00              NOP                            ;1336
                  |L7.42|
00002a  1c50              ADDS     r0,r2,#1              ;1338
00002c  4602              MOV      r2,r0                 ;1338
00002e  4b06              LDR      r3,|L7.72|
000030  4298              CMP      r0,r3                 ;1338
000032  d901              BLS      |L7.56|
000034  2003              MOVS     r0,#3                 ;1340
000036  e7ec              B        |L7.18|
                  |L7.56|
000038  6908              LDR      r0,[r1,#0x10]         ;1342
00003a  f0000001          AND      r0,r0,#1              ;1342
00003e  2800              CMP      r0,#0                 ;1342
000040  d1f3              BNE      |L7.42|
000042  bf00              NOP                            ;1344
000044  e7e5              B        |L7.18|
;;;1346   
                          ENDP

000046  0000              DCW      0x0000
                  |L7.72|
                          DCD      0x00030d40

                          AREA ||i.USB_DeActivateRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USB_DeActivateRemoteWakeup PROC
;;;2012     */
;;;2013   HAL_StatusTypeDef USB_DeActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;2014   {
;;;2015     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;2016   
;;;2017     /* active Remote wakeup signalling */
;;;2018     USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
000004  f6400004          MOV      r0,#0x804
000008  5880              LDR      r0,[r0,r2]
00000a  f0200301          BIC      r3,r0,#1
00000e  f6400004          MOV      r0,#0x804
000012  5083              STR      r3,[r0,r2]
;;;2019   
;;;2020     return HAL_OK;
000014  2000              MOVS     r0,#0
;;;2021   }
000016  4770              BX       lr
;;;2022   #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
                          ENDP


                          AREA ||i.USB_DeactivateDedicatedEndpoint||, CODE, READONLY, ALIGN=2

                  USB_DeactivateDedicatedEndpoint PROC
;;;671      */
;;;672    HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;673    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;674      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;675      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;676    
;;;677      /* Read DEPCTLn register */
;;;678      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d13b              BNE      |L9.136|
;;;679      {
;;;680        if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  f1b04f00          CMP      r0,#0x80000000
000022  d117              BNE      |L9.84|
;;;681        {
;;;682          USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_SNAK;
000024  f5026010          ADD      r0,r2,#0x900
000028  eb001041          ADD      r0,r0,r1,LSL #5
00002c  6800              LDR      r0,[r0,#0]
00002e  f0406500          ORR      r5,r0,#0x8000000
000032  f5026010          ADD      r0,r2,#0x900
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6005              STR      r5,[r0,#0]
;;;683          USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_EPDIS;
00003c  f5026010          ADD      r0,r2,#0x900
000040  eb001041          ADD      r0,r0,r1,LSL #5
000044  6800              LDR      r0,[r0,#0]
000046  f0404580          ORR      r5,r0,#0x40000000
00004a  f5026010          ADD      r0,r2,#0x900
00004e  eb001041          ADD      r0,r0,r1,LSL #5
000052  6005              STR      r5,[r0,#0]
                  |L9.84|
;;;684        }
;;;685    
;;;686        USBx_INEP(epnum)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
000054  f5026010          ADD      r0,r2,#0x900
000058  eb001041          ADD      r0,r0,r1,LSL #5
00005c  6800              LDR      r0,[r0,#0]
00005e  f4204500          BIC      r5,r0,#0x8000
000062  f5026010          ADD      r0,r2,#0x900
000066  eb001041          ADD      r0,r0,r1,LSL #5
00006a  6005              STR      r5,[r0,#0]
;;;687        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
00006c  f640001c          MOV      r0,#0x81c
000070  5880              LDR      r0,[r0,r2]
000072  781d              LDRB     r5,[r3,#0]
000074  f005060f          AND      r6,r5,#0xf
000078  2501              MOVS     r5,#1
00007a  40b5              LSLS     r5,r5,r6
00007c  b2ad              UXTH     r5,r5
00007e  43a8              BICS     r0,r0,r5
000080  f640051c          MOV      r5,#0x81c
000084  50a8              STR      r0,[r5,r2]
000086  e03c              B        |L9.258|
                  |L9.136|
;;;688      }
;;;689      else
;;;690      {
;;;691        if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
000088  f5026030          ADD      r0,r2,#0xb00
00008c  eb001041          ADD      r0,r0,r1,LSL #5
000090  6800              LDR      r0,[r0,#0]
000092  f0004000          AND      r0,r0,#0x80000000
000096  f1b04f00          CMP      r0,#0x80000000
00009a  d117              BNE      |L9.204|
;;;692        {
;;;693          USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_SNAK;
00009c  f5026030          ADD      r0,r2,#0xb00
0000a0  eb001041          ADD      r0,r0,r1,LSL #5
0000a4  6800              LDR      r0,[r0,#0]
0000a6  f0406500          ORR      r5,r0,#0x8000000
0000aa  f5026030          ADD      r0,r2,#0xb00
0000ae  eb001041          ADD      r0,r0,r1,LSL #5
0000b2  6005              STR      r5,[r0,#0]
;;;694          USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_EPDIS;
0000b4  f5026030          ADD      r0,r2,#0xb00
0000b8  eb001041          ADD      r0,r0,r1,LSL #5
0000bc  6800              LDR      r0,[r0,#0]
0000be  f0404580          ORR      r5,r0,#0x40000000
0000c2  f5026030          ADD      r0,r2,#0xb00
0000c6  eb001041          ADD      r0,r0,r1,LSL #5
0000ca  6005              STR      r5,[r0,#0]
                  |L9.204|
;;;695        }
;;;696    
;;;697        USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;
0000cc  f5026030          ADD      r0,r2,#0xb00
0000d0  eb001041          ADD      r0,r0,r1,LSL #5
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f4204500          BIC      r5,r0,#0x8000
0000da  f5026030          ADD      r0,r2,#0xb00
0000de  eb001041          ADD      r0,r0,r1,LSL #5
0000e2  6005              STR      r5,[r0,#0]
;;;698        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
0000e4  f640001c          MOV      r0,#0x81c
0000e8  5885              LDR      r5,[r0,r2]
0000ea  7818              LDRB     r0,[r3,#0]
0000ec  f000060f          AND      r6,r0,#0xf
0000f0  2001              MOVS     r0,#1
0000f2  40b0              LSLS     r0,r0,r6
0000f4  4e04              LDR      r6,|L9.264|
0000f6  ea064000          AND      r0,r6,r0,LSL #16
0000fa  4385              BICS     r5,r5,r0
0000fc  f640001c          MOV      r0,#0x81c
000100  5085              STR      r5,[r0,r2]
                  |L9.258|
;;;699      }
;;;700    
;;;701      return HAL_OK;
000102  2000              MOVS     r0,#0
;;;702    }
000104  bd70              POP      {r4-r6,pc}
;;;703    
                          ENDP

000106  0000              DCW      0x0000
                  |L9.264|
                          DCD      0xffff0000

                          AREA ||i.USB_DeactivateEndpoint||, CODE, READONLY, ALIGN=2

                  USB_DeactivateEndpoint PROC
;;;624      */
;;;625    HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;626    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;627      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;628      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;629    
;;;630      /* Read DEPCTLn register */
;;;631      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d148              BNE      |L10.162|
;;;632      {
;;;633        if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  f1b04f00          CMP      r0,#0x80000000
000022  d117              BNE      |L10.84|
;;;634        {
;;;635          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
000024  f5026010          ADD      r0,r2,#0x900
000028  eb001041          ADD      r0,r0,r1,LSL #5
00002c  6800              LDR      r0,[r0,#0]
00002e  f0406500          ORR      r5,r0,#0x8000000
000032  f5026010          ADD      r0,r2,#0x900
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6005              STR      r5,[r0,#0]
;;;636          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
00003c  f5026010          ADD      r0,r2,#0x900
000040  eb001041          ADD      r0,r0,r1,LSL #5
000044  6800              LDR      r0,[r0,#0]
000046  f0404580          ORR      r5,r0,#0x40000000
00004a  f5026010          ADD      r0,r2,#0x900
00004e  eb001041          ADD      r0,r0,r1,LSL #5
000052  6005              STR      r5,[r0,#0]
                  |L10.84|
;;;637        }
;;;638    
;;;639        USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
000054  f640003c          MOV      r0,#0x83c
000058  5880              LDR      r0,[r0,r2]
00005a  781d              LDRB     r5,[r3,#0]
00005c  f005060f          AND      r6,r5,#0xf
000060  2501              MOVS     r5,#1
000062  40b5              LSLS     r5,r5,r6
000064  b2ad              UXTH     r5,r5
000066  43a8              BICS     r0,r0,r5
000068  f640053c          MOV      r5,#0x83c
00006c  50a8              STR      r0,[r5,r2]
;;;640        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
00006e  f640001c          MOV      r0,#0x81c
000072  5880              LDR      r0,[r0,r2]
000074  781d              LDRB     r5,[r3,#0]
000076  f005060f          AND      r6,r5,#0xf
00007a  2501              MOVS     r5,#1
00007c  40b5              LSLS     r5,r5,r6
00007e  b2ad              UXTH     r5,r5
000080  43a8              BICS     r0,r0,r5
000082  f640051c          MOV      r5,#0x81c
000086  50a8              STR      r0,[r5,r2]
;;;641        USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
000088  f5026010          ADD      r0,r2,#0x900
00008c  eb001041          ADD      r0,r0,r1,LSL #5
000090  6800              LDR      r0,[r0,#0]
000092  4d2b              LDR      r5,|L10.320|
000094  4028              ANDS     r0,r0,r5
000096  f5026510          ADD      r5,r2,#0x900
00009a  eb051541          ADD      r5,r5,r1,LSL #5
00009e  6028              STR      r0,[r5,#0]
0000a0  e04b              B        |L10.314|
                  |L10.162|
;;;642                                       USB_OTG_DIEPCTL_MPSIZ |
;;;643                                       USB_OTG_DIEPCTL_TXFNUM |
;;;644                                       USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;645                                       USB_OTG_DIEPCTL_EPTYP);
;;;646      }
;;;647      else
;;;648      {
;;;649        if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
0000a2  f5026030          ADD      r0,r2,#0xb00
0000a6  eb001041          ADD      r0,r0,r1,LSL #5
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0004000          AND      r0,r0,#0x80000000
0000b0  f1b04f00          CMP      r0,#0x80000000
0000b4  d117              BNE      |L10.230|
;;;650        {
;;;651          USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
0000b6  f5026030          ADD      r0,r2,#0xb00
0000ba  eb001041          ADD      r0,r0,r1,LSL #5
0000be  6800              LDR      r0,[r0,#0]
0000c0  f0406500          ORR      r5,r0,#0x8000000
0000c4  f5026030          ADD      r0,r2,#0xb00
0000c8  eb001041          ADD      r0,r0,r1,LSL #5
0000cc  6005              STR      r5,[r0,#0]
;;;652          USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
0000ce  f5026030          ADD      r0,r2,#0xb00
0000d2  eb001041          ADD      r0,r0,r1,LSL #5
0000d6  6800              LDR      r0,[r0,#0]
0000d8  f0404580          ORR      r5,r0,#0x40000000
0000dc  f5026030          ADD      r0,r2,#0xb00
0000e0  eb001041          ADD      r0,r0,r1,LSL #5
0000e4  6005              STR      r5,[r0,#0]
                  |L10.230|
;;;653        }
;;;654    
;;;655        USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
0000e6  f640003c          MOV      r0,#0x83c
0000ea  5880              LDR      r0,[r0,r2]
0000ec  781d              LDRB     r5,[r3,#0]
0000ee  f005060f          AND      r6,r5,#0xf
0000f2  2501              MOVS     r5,#1
0000f4  40b5              LSLS     r5,r5,r6
0000f6  4e13              LDR      r6,|L10.324|
0000f8  ea064505          AND      r5,r6,r5,LSL #16
0000fc  43a8              BICS     r0,r0,r5
0000fe  f640053c          MOV      r5,#0x83c
000102  50a8              STR      r0,[r5,r2]
;;;656        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
000104  f640001c          MOV      r0,#0x81c
000108  5885              LDR      r5,[r0,r2]
00010a  7818              LDRB     r0,[r3,#0]
00010c  f000060f          AND      r6,r0,#0xf
000110  2001              MOVS     r0,#1
000112  40b0              LSLS     r0,r0,r6
000114  4e0b              LDR      r6,|L10.324|
000116  ea064000          AND      r0,r6,r0,LSL #16
00011a  4385              BICS     r5,r5,r0
00011c  f640001c          MOV      r0,#0x81c
000120  5085              STR      r5,[r0,r2]
;;;657        USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
000122  f5026030          ADD      r0,r2,#0xb00
000126  eb001041          ADD      r0,r0,r1,LSL #5
00012a  6800              LDR      r0,[r0,#0]
00012c  4d06              LDR      r5,|L10.328|
00012e  4028              ANDS     r0,r0,r5
000130  f5026530          ADD      r5,r2,#0xb00
000134  eb051541          ADD      r5,r5,r1,LSL #5
000138  6028              STR      r0,[r5,#0]
                  |L10.314|
;;;658                                        USB_OTG_DOEPCTL_MPSIZ |
;;;659                                        USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
;;;660                                        USB_OTG_DOEPCTL_EPTYP);
;;;661      }
;;;662    
;;;663      return HAL_OK;
00013a  2000              MOVS     r0,#0
;;;664    }
00013c  bd70              POP      {r4-r6,pc}
;;;665    
                          ENDP

00013e  0000              DCW      0x0000
                  |L10.320|
                          DCD      0xec337800
                  |L10.324|
                          DCD      0xffff0000
                  |L10.328|
                          DCD      0xeff37800

                          AREA ||i.USB_DevConnect||, CODE, READONLY, ALIGN=1

                  USB_DevConnect PROC
;;;1120     */
;;;1121   HAL_StatusTypeDef  USB_DevConnect(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1122   {
;;;1123     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1124   
;;;1125     /* In case phy is stopped, ensure to ungate and restore the phy CLK */
;;;1126     USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
000004  f8d20e00          LDR      r0,[r2,#0xe00]
000008  f0200003          BIC      r0,r0,#3
00000c  f8c20e00          STR      r0,[r2,#0xe00]
;;;1127   
;;;1128     USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
000010  f6400004          MOV      r0,#0x804
000014  5880              LDR      r0,[r0,r2]
000016  f0200302          BIC      r3,r0,#2
00001a  f6400004          MOV      r0,#0x804
00001e  5083              STR      r3,[r0,r2]
;;;1129   
;;;1130     return HAL_OK;
000020  2000              MOVS     r0,#0
;;;1131   }
000022  4770              BX       lr
;;;1132   
                          ENDP


                          AREA ||i.USB_DevDisconnect||, CODE, READONLY, ALIGN=1

                  USB_DevDisconnect PROC
;;;1137     */
;;;1138   HAL_StatusTypeDef  USB_DevDisconnect(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1139   {
;;;1140     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1141   
;;;1142     /* In case phy is stopped, ensure to ungate and restore the phy CLK */
;;;1143     USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
000004  f8d20e00          LDR      r0,[r2,#0xe00]
000008  f0200003          BIC      r0,r0,#3
00000c  f8c20e00          STR      r0,[r2,#0xe00]
;;;1144   
;;;1145     USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
000010  f6400004          MOV      r0,#0x804
000014  5880              LDR      r0,[r0,r2]
000016  f0400302          ORR      r3,r0,#2
00001a  f6400004          MOV      r0,#0x804
00001e  5083              STR      r3,[r0,r2]
;;;1146   
;;;1147     return HAL_OK;
000020  2000              MOVS     r0,#0
;;;1148   }
000022  4770              BX       lr
;;;1149   
                          ENDP


                          AREA ||i.USB_DevInit||, CODE, READONLY, ALIGN=2

                  USB_DevInit PROC
;;;276      */
;;;277    HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  b40f              PUSH     {r0-r3}
;;;278    {
000002  b5f0              PUSH     {r4-r7,lr}
000004  4606              MOV      r6,r0
;;;279      HAL_StatusTypeDef ret = HAL_OK;
000006  2700              MOVS     r7,#0
;;;280      uint32_t USBx_BASE = (uint32_t)USBx;
000008  4635              MOV      r5,r6
;;;281      uint32_t i;
;;;282    
;;;283      for (i = 0U; i < 15U; i++)
00000a  2400              MOVS     r4,#0
00000c  e005              B        |L13.26|
                  |L13.14|
;;;284      {
;;;285        USBx->DIEPTXF[i] = 0U;
00000e  2100              MOVS     r1,#0
000010  f5067082          ADD      r0,r6,#0x104
000014  f8401024          STR      r1,[r0,r4,LSL #2]
000018  1c64              ADDS     r4,r4,#1              ;283
                  |L13.26|
00001a  2c0f              CMP      r4,#0xf               ;283
00001c  d3f7              BCC      |L13.14|
;;;286      }
;;;287    
;;;288    #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;289      /* VBUS Sensing setup */
;;;290      if (cfg.vbus_sensing_enable == 0U)
00001e  9810              LDR      r0,[sp,#0x40]
000020  b9a0              CBNZ     r0,|L13.76|
;;;291      {
;;;292        USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
000022  f6400004          MOV      r0,#0x804
000026  5940              LDR      r0,[r0,r5]
000028  f0400102          ORR      r1,r0,#2
00002c  f6400004          MOV      r0,#0x804
000030  5141              STR      r1,[r0,r5]
;;;293    
;;;294        /* Deactivate VBUS Sensing B */
;;;295        USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
000032  6bb0              LDR      r0,[r6,#0x38]
000034  f4201000          BIC      r0,r0,#0x200000
000038  63b0              STR      r0,[r6,#0x38]
;;;296    
;;;297        /* B-peripheral session valid override enable */
;;;298        USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
00003a  6830              LDR      r0,[r6,#0]
00003c  f0400040          ORR      r0,r0,#0x40
000040  6030              STR      r0,[r6,#0]
;;;299        USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
000042  6830              LDR      r0,[r6,#0]
000044  f0400080          ORR      r0,r0,#0x80
000048  6030              STR      r0,[r6,#0]
00004a  e003              B        |L13.84|
                  |L13.76|
;;;300      }
;;;301      else
;;;302      {
;;;303        /* Enable HW VBUS sensing */
;;;304        USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
00004c  6bb0              LDR      r0,[r6,#0x38]
00004e  f4401000          ORR      r0,r0,#0x200000
000052  63b0              STR      r0,[r6,#0x38]
                  |L13.84|
;;;305      }
;;;306    #else
;;;307      /* VBUS Sensing setup */
;;;308      if (cfg.vbus_sensing_enable == 0U)
;;;309      {
;;;310        /*
;;;311         * Disable HW VBUS sensing. VBUS is internally considered to be always
;;;312         * at VBUS-Valid level (5V).
;;;313         */
;;;314        USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
;;;315        USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
;;;316        USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
;;;317        USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
;;;318      }
;;;319      else
;;;320      {
;;;321        /* Enable HW VBUS sensing */
;;;322        USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
;;;323        USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
;;;324      }
;;;325    #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;326    
;;;327      /* Restart the Phy Clock */
;;;328      USBx_PCGCCTL = 0U;
000054  2000              MOVS     r0,#0
000056  f8c50e00          STR      r0,[r5,#0xe00]
;;;329    
;;;330      /* Device mode configuration */
;;;331      USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
00005a  f8d50800          LDR      r0,[r5,#0x800]
00005e  f8c50800          STR      r0,[r5,#0x800]
;;;332    
;;;333      if (cfg.phy_itface == USB_OTG_ULPI_PHY)
000062  980b              LDR      r0,[sp,#0x2c]
000064  2801              CMP      r0,#1
000066  d10b              BNE      |L13.128|
;;;334      {
;;;335        if (cfg.speed == USBD_HS_SPEED)
000068  9808              LDR      r0,[sp,#0x20]
00006a  b920              CBNZ     r0,|L13.118|
;;;336        {
;;;337          /* Set Core speed to High speed mode */
;;;338          (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
00006c  2100              MOVS     r1,#0
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       USB_SetDevSpeed
000074  e008              B        |L13.136|
                  |L13.118|
;;;339        }
;;;340        else
;;;341        {
;;;342          /* Set Core speed to Full speed mode */
;;;343          (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
000076  2101              MOVS     r1,#1
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       USB_SetDevSpeed
00007e  e003              B        |L13.136|
                  |L13.128|
;;;344        }
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Set Core speed to Full speed mode */
;;;349        (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
000080  2103              MOVS     r1,#3
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       USB_SetDevSpeed
                  |L13.136|
;;;350      }
;;;351    
;;;352      /* Flush the FIFOs */
;;;353      if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
000088  2110              MOVS     r1,#0x10
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       USB_FlushTxFifo
000090  b100              CBZ      r0,|L13.148|
;;;354      {
;;;355        ret = HAL_ERROR;
000092  2701              MOVS     r7,#1
                  |L13.148|
;;;356      }
;;;357    
;;;358      if (USB_FlushRxFifo(USBx) != HAL_OK)
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       USB_FlushRxFifo
00009a  b100              CBZ      r0,|L13.158|
;;;359      {
;;;360        ret = HAL_ERROR;
00009c  2701              MOVS     r7,#1
                  |L13.158|
;;;361      }
;;;362    
;;;363      /* Clear all pending Device Interrupts */
;;;364      USBx_DEVICE->DIEPMSK = 0U;
00009e  2100              MOVS     r1,#0
0000a0  f44f6001          MOV      r0,#0x810
0000a4  5141              STR      r1,[r0,r5]
;;;365      USBx_DEVICE->DOEPMSK = 0U;
0000a6  1d00              ADDS     r0,r0,#4
0000a8  5141              STR      r1,[r0,r5]
;;;366      USBx_DEVICE->DAINTMSK = 0U;
0000aa  f640001c          MOV      r0,#0x81c
0000ae  5141              STR      r1,[r0,r5]
;;;367    
;;;368      for (i = 0U; i < cfg.dev_endpoints; i++)
0000b0  2400              MOVS     r4,#0
0000b2  e02e              B        |L13.274|
                  |L13.180|
;;;369      {
;;;370        if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
0000b4  f5056010          ADD      r0,r5,#0x900
0000b8  eb001044          ADD      r0,r0,r4,LSL #5
0000bc  6800              LDR      r0,[r0,#0]
0000be  f0004000          AND      r0,r0,#0x80000000
0000c2  f1b04f00          CMP      r0,#0x80000000
0000c6  d110              BNE      |L13.234|
;;;371        {
;;;372          if (i == 0U)
0000c8  b93c              CBNZ     r4,|L13.218|
;;;373          {
;;;374            USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
0000ca  f04f6100          MOV      r1,#0x8000000
0000ce  f5056010          ADD      r0,r5,#0x900
0000d2  eb001044          ADD      r0,r0,r4,LSL #5
0000d6  6001              STR      r1,[r0,#0]
0000d8  e00d              B        |L13.246|
                  |L13.218|
;;;375          }
;;;376          else
;;;377          {
;;;378            USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
0000da  f04f4190          MOV      r1,#0x48000000
0000de  f5056010          ADD      r0,r5,#0x900
0000e2  eb001044          ADD      r0,r0,r4,LSL #5
0000e6  6001              STR      r1,[r0,#0]
0000e8  e005              B        |L13.246|
                  |L13.234|
;;;379          }
;;;380        }
;;;381        else
;;;382        {
;;;383          USBx_INEP(i)->DIEPCTL = 0U;
0000ea  2100              MOVS     r1,#0
0000ec  f5056010          ADD      r0,r5,#0x900
0000f0  eb001044          ADD      r0,r0,r4,LSL #5
0000f4  6001              STR      r1,[r0,#0]
                  |L13.246|
;;;384        }
;;;385    
;;;386        USBx_INEP(i)->DIEPTSIZ = 0U;
0000f6  2100              MOVS     r1,#0
0000f8  f5056010          ADD      r0,r5,#0x900
0000fc  eb001044          ADD      r0,r0,r4,LSL #5
000100  6101              STR      r1,[r0,#0x10]
;;;387        USBx_INEP(i)->DIEPINT  = 0xFB7FU;
000102  f64f317f          MOV      r1,#0xfb7f
000106  f5056010          ADD      r0,r5,#0x900
00010a  eb001044          ADD      r0,r0,r4,LSL #5
00010e  6081              STR      r1,[r0,#8]
000110  1c64              ADDS     r4,r4,#1              ;368
                  |L13.274|
000112  9806              LDR      r0,[sp,#0x18]         ;368
000114  42a0              CMP      r0,r4                 ;368
000116  d8cd              BHI      |L13.180|
;;;388      }
;;;389    
;;;390      for (i = 0U; i < cfg.dev_endpoints; i++)
000118  2400              MOVS     r4,#0
00011a  e02e              B        |L13.378|
                  |L13.284|
;;;391      {
;;;392        if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
00011c  f5056030          ADD      r0,r5,#0xb00
000120  eb001044          ADD      r0,r0,r4,LSL #5
000124  6800              LDR      r0,[r0,#0]
000126  f0004000          AND      r0,r0,#0x80000000
00012a  f1b04f00          CMP      r0,#0x80000000
00012e  d110              BNE      |L13.338|
;;;393        {
;;;394          if (i == 0U)
000130  b93c              CBNZ     r4,|L13.322|
;;;395          {
;;;396            USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
000132  f04f6100          MOV      r1,#0x8000000
000136  f5056030          ADD      r0,r5,#0xb00
00013a  eb001044          ADD      r0,r0,r4,LSL #5
00013e  6001              STR      r1,[r0,#0]
000140  e00d              B        |L13.350|
                  |L13.322|
;;;397          }
;;;398          else
;;;399          {
;;;400            USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
000142  f04f4190          MOV      r1,#0x48000000
000146  f5056030          ADD      r0,r5,#0xb00
00014a  eb001044          ADD      r0,r0,r4,LSL #5
00014e  6001              STR      r1,[r0,#0]
000150  e005              B        |L13.350|
                  |L13.338|
;;;401          }
;;;402        }
;;;403        else
;;;404        {
;;;405          USBx_OUTEP(i)->DOEPCTL = 0U;
000152  2100              MOVS     r1,#0
000154  f5056030          ADD      r0,r5,#0xb00
000158  eb001044          ADD      r0,r0,r4,LSL #5
00015c  6001              STR      r1,[r0,#0]
                  |L13.350|
;;;406        }
;;;407    
;;;408        USBx_OUTEP(i)->DOEPTSIZ = 0U;
00015e  2100              MOVS     r1,#0
000160  f5056030          ADD      r0,r5,#0xb00
000164  eb001044          ADD      r0,r0,r4,LSL #5
000168  6101              STR      r1,[r0,#0x10]
;;;409        USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
00016a  f64f317f          MOV      r1,#0xfb7f
00016e  f5056030          ADD      r0,r5,#0xb00
000172  eb001044          ADD      r0,r0,r4,LSL #5
000176  6081              STR      r1,[r0,#8]
000178  1c64              ADDS     r4,r4,#1              ;390
                  |L13.378|
00017a  9806              LDR      r0,[sp,#0x18]         ;390
00017c  42a0              CMP      r0,r4                 ;390
00017e  d8cd              BHI      |L13.284|
;;;410      }
;;;411    
;;;412      USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
000180  f44f6001          MOV      r0,#0x810
000184  5940              LDR      r0,[r0,r5]
000186  f4207180          BIC      r1,r0,#0x100
00018a  f44f6001          MOV      r0,#0x810
00018e  5141              STR      r1,[r0,r5]
;;;413    
;;;414      /* Disable all interrupts. */
;;;415      USBx->GINTMSK = 0U;
000190  2000              MOVS     r0,#0
000192  61b0              STR      r0,[r6,#0x18]
;;;416    
;;;417      /* Clear any pending interrupts */
;;;418      USBx->GINTSTS = 0xBFFFFFFFU;
000194  f06f4080          MVN      r0,#0x40000000
000198  6170              STR      r0,[r6,#0x14]
;;;419    
;;;420      /* Enable the common interrupts */
;;;421      if (cfg.dma_enable == 0U)
00019a  9809              LDR      r0,[sp,#0x24]
00019c  b918              CBNZ     r0,|L13.422|
;;;422      {
;;;423        USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
00019e  69b0              LDR      r0,[r6,#0x18]
0001a0  f0400010          ORR      r0,r0,#0x10
0001a4  61b0              STR      r0,[r6,#0x18]
                  |L13.422|
;;;424      }
;;;425    
;;;426      /* Enable interrupts matching to the Device mode ONLY */
;;;427      USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
0001a6  69b0              LDR      r0,[r6,#0x18]
0001a8  4909              LDR      r1,|L13.464|
0001aa  4308              ORRS     r0,r0,r1
0001ac  61b0              STR      r0,[r6,#0x18]
;;;428                       USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
;;;429                       USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
;;;430                       USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;
;;;431    
;;;432      if (cfg.Sof_enable != 0U)
0001ae  980c              LDR      r0,[sp,#0x30]
0001b0  b118              CBZ      r0,|L13.442|
;;;433      {
;;;434        USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
0001b2  69b0              LDR      r0,[r6,#0x18]
0001b4  f0400008          ORR      r0,r0,#8
0001b8  61b0              STR      r0,[r6,#0x18]
                  |L13.442|
;;;435      }
;;;436    
;;;437      if (cfg.vbus_sensing_enable == 1U)
0001ba  9810              LDR      r0,[sp,#0x40]
0001bc  2801              CMP      r0,#1
0001be  d103              BNE      |L13.456|
;;;438      {
;;;439        USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
0001c0  69b0              LDR      r0,[r6,#0x18]
0001c2  4904              LDR      r1,|L13.468|
0001c4  4308              ORRS     r0,r0,r1
0001c6  61b0              STR      r0,[r6,#0x18]
                  |L13.456|
;;;440      }
;;;441    
;;;442      return ret;
0001c8  4638              MOV      r0,r7
;;;443    }
0001ca  bcf0              POP      {r4-r7}
0001cc  f85dfb14          LDR      pc,[sp],#0x14
;;;444    
                          ENDP

                  |L13.464|
                          DCD      0x803c3800
                  |L13.468|
                          DCD      0x40000004

                          AREA ||i.USB_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_DisableGlobalInt PROC
;;;232      */
;;;233    HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;234    {
;;;235      USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
000002  6888              LDR      r0,[r1,#8]
000004  f0200001          BIC      r0,r0,#1
000008  6088              STR      r0,[r1,#8]
;;;236      return HAL_OK;
00000a  2000              MOVS     r0,#0
;;;237    }
00000c  4770              BX       lr
;;;238    
                          ENDP


                          AREA ||i.USB_DoPing||, CODE, READONLY, ALIGN=2

                  USB_DoPing PROC
;;;1915     */
;;;1916   HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1917   {
000002  4603              MOV      r3,r0
;;;1918     uint32_t USBx_BASE = (uint32_t)USBx;
000004  461c              MOV      r4,r3
;;;1919     uint32_t chnum = (uint32_t)ch_num;
000006  460a              MOV      r2,r1
;;;1920     uint32_t num_packets = 1U;
000008  2601              MOVS     r6,#1
;;;1921     uint32_t tmpreg;
;;;1922   
;;;1923     USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
00000a  480d              LDR      r0,|L15.64|
00000c  ea0040c6          AND      r0,r0,r6,LSL #19
000010  f0404700          ORR      r7,r0,#0x80000000
000014  4611              MOV      r1,r2
000016  f50460a0          ADD      r0,r4,#0x500
00001a  eb001041          ADD      r0,r0,r1,LSL #5
00001e  6107              STR      r7,[r0,#0x10]
;;;1924                              USB_OTG_HCTSIZ_DOPING;
;;;1925   
;;;1926     /* Set host channel enable */
;;;1927     tmpreg = USBx_HC(chnum)->HCCHAR;
000020  f50460a0          ADD      r0,r4,#0x500
000024  eb001041          ADD      r0,r0,r1,LSL #5
000028  6805              LDR      r5,[r0,#0]
;;;1928     tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
00002a  f0254580          BIC      r5,r5,#0x40000000
;;;1929     tmpreg |= USB_OTG_HCCHAR_CHENA;
00002e  f0454500          ORR      r5,r5,#0x80000000
;;;1930     USBx_HC(chnum)->HCCHAR = tmpreg;
000032  f50460a0          ADD      r0,r4,#0x500
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6005              STR      r5,[r0,#0]
;;;1931   
;;;1932     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;1933   }
00003e  bdf0              POP      {r4-r7,pc}
;;;1934   
                          ENDP

                  |L15.64|
                          DCD      0x1ff80000

                          AREA ||i.USB_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_DriveVbus PROC
;;;1516     */
;;;1517   HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
000000  b508              PUSH     {r3,lr}
;;;1518   {
000002  4602              MOV      r2,r0
;;;1519     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4613              MOV      r3,r2
;;;1520     __IO uint32_t hprt0 = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1521   
;;;1522     hprt0 = USBx_HPRT0;
00000a  f8d30440          LDR      r0,[r3,#0x440]
00000e  9000              STR      r0,[sp,#0]
;;;1523   
;;;1524     hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
000010  9800              LDR      r0,[sp,#0]
000012  f020002e          BIC      r0,r0,#0x2e
000016  9000              STR      r0,[sp,#0]
;;;1525                USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);
;;;1526   
;;;1527     if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
000018  9800              LDR      r0,[sp,#0]
00001a  f4005080          AND      r0,r0,#0x1000
00001e  b930              CBNZ     r0,|L16.46|
000020  2901              CMP      r1,#1
000022  d104              BNE      |L16.46|
;;;1528     {
;;;1529       USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
000024  9800              LDR      r0,[sp,#0]
000026  f4405080          ORR      r0,r0,#0x1000
00002a  f8c30440          STR      r0,[r3,#0x440]
                  |L16.46|
;;;1530     }
;;;1531     if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
00002e  9800              LDR      r0,[sp,#0]
000030  f4005080          AND      r0,r0,#0x1000
000034  f5b05f80          CMP      r0,#0x1000
000038  d105              BNE      |L16.70|
00003a  b921              CBNZ     r1,|L16.70|
;;;1532     {
;;;1533       USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
00003c  9800              LDR      r0,[sp,#0]
00003e  f4205080          BIC      r0,r0,#0x1000
000042  f8c30440          STR      r0,[r3,#0x440]
                  |L16.70|
;;;1534     }
;;;1535     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;1536   }
000048  bd08              POP      {r3,pc}
;;;1537   
                          ENDP


                          AREA ||i.USB_EP0StartXfer||, CODE, READONLY, ALIGN=2

                  USB_EP0StartXfer PROC
;;;855      */
;;;856    HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
000000  b5f0              PUSH     {r4-r7,lr}
;;;857    {
000002  4605              MOV      r5,r0
000004  460b              MOV      r3,r1
000006  4614              MOV      r4,r2
;;;858      uint32_t USBx_BASE = (uint32_t)USBx;
000008  462a              MOV      r2,r5
;;;859      uint32_t epnum = (uint32_t)ep->num;
00000a  7819              LDRB     r1,[r3,#0]
;;;860    
;;;861      /* IN endpoint */
;;;862      if (ep->is_in == 1U)
00000c  7858              LDRB     r0,[r3,#1]
00000e  2801              CMP      r0,#1
000010  d175              BNE      |L17.254|
;;;863      {
;;;864        /* Zero Length Packet? */
;;;865        if (ep->xfer_len == 0U)
000012  6958              LDR      r0,[r3,#0x14]
000014  bb20              CBNZ     r0,|L17.96|
;;;866        {
;;;867          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
000016  f5026010          ADD      r0,r2,#0x900
00001a  eb001041          ADD      r0,r0,r1,LSL #5
00001e  6900              LDR      r0,[r0,#0x10]
000020  4e6c              LDR      r6,|L17.468|
000022  4030              ANDS     r0,r0,r6
000024  f5026610          ADD      r6,r2,#0x900
000028  eb061641          ADD      r6,r6,r1,LSL #5
00002c  6130              STR      r0,[r6,#0x10]
;;;868          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
00002e  f5026010          ADD      r0,r2,#0x900
000032  eb001041          ADD      r0,r0,r1,LSL #5
000036  6900              LDR      r0,[r0,#0x10]
000038  f4402600          ORR      r6,r0,#0x80000
00003c  f5026010          ADD      r0,r2,#0x900
000040  eb001041          ADD      r0,r0,r1,LSL #5
000044  6106              STR      r6,[r0,#0x10]
;;;869          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000046  f5026010          ADD      r0,r2,#0x900
00004a  eb001041          ADD      r0,r0,r1,LSL #5
00004e  6900              LDR      r0,[r0,#0x10]
000050  0cc6              LSRS     r6,r0,#19
000052  04f6              LSLS     r6,r6,#19
000054  f5026010          ADD      r0,r2,#0x900
000058  eb001041          ADD      r0,r0,r1,LSL #5
00005c  6106              STR      r6,[r0,#0x10]
00005e  e037              B        |L17.208|
                  |L17.96|
;;;870        }
;;;871        else
;;;872        {
;;;873          /* Program the transfer size and packet count
;;;874          * as follows: xfersize = N * maxpacket +
;;;875          * short_packet pktcnt = N + (short_packet
;;;876          * exist ? 1 : 0)
;;;877          */
;;;878          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000060  f5026010          ADD      r0,r2,#0x900
000064  eb001041          ADD      r0,r0,r1,LSL #5
000068  6900              LDR      r0,[r0,#0x10]
00006a  0cc6              LSRS     r6,r0,#19
00006c  04f6              LSLS     r6,r6,#19
00006e  f5026010          ADD      r0,r2,#0x900
000072  eb001041          ADD      r0,r0,r1,LSL #5
000076  6106              STR      r6,[r0,#0x10]
;;;879          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
000078  f5026010          ADD      r0,r2,#0x900
00007c  eb001041          ADD      r0,r0,r1,LSL #5
000080  6900              LDR      r0,[r0,#0x10]
000082  4e54              LDR      r6,|L17.468|
000084  4030              ANDS     r0,r0,r6
000086  f5026610          ADD      r6,r2,#0x900
00008a  eb061641          ADD      r6,r6,r1,LSL #5
00008e  6130              STR      r0,[r6,#0x10]
;;;880    
;;;881          if (ep->xfer_len > ep->maxpacket)
000090  689e              LDR      r6,[r3,#8]
000092  6958              LDR      r0,[r3,#0x14]
000094  42b0              CMP      r0,r6
000096  d901              BLS      |L17.156|
;;;882          {
;;;883            ep->xfer_len = ep->maxpacket;
000098  6898              LDR      r0,[r3,#8]
00009a  6158              STR      r0,[r3,#0x14]
                  |L17.156|
;;;884          }
;;;885          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
00009c  f5026010          ADD      r0,r2,#0x900
0000a0  eb001041          ADD      r0,r0,r1,LSL #5
0000a4  6900              LDR      r0,[r0,#0x10]
0000a6  f4402600          ORR      r6,r0,#0x80000
0000aa  f5026010          ADD      r0,r2,#0x900
0000ae  eb001041          ADD      r0,r0,r1,LSL #5
0000b2  6106              STR      r6,[r0,#0x10]
;;;886          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
0000b4  f5026010          ADD      r0,r2,#0x900
0000b8  eb001041          ADD      r0,r0,r1,LSL #5
0000bc  6900              LDR      r0,[r0,#0x10]
0000be  695e              LDR      r6,[r3,#0x14]
0000c0  f3c60612          UBFX     r6,r6,#0,#19
0000c4  4330              ORRS     r0,r0,r6
0000c6  f5026610          ADD      r6,r2,#0x900
0000ca  eb061641          ADD      r6,r6,r1,LSL #5
0000ce  6130              STR      r0,[r6,#0x10]
                  |L17.208|
;;;887        }
;;;888    
;;;889        if (dma == 1U)
0000d0  2c01              CMP      r4,#1
0000d2  d115              BNE      |L17.256|
;;;890        {
;;;891          if ((uint32_t)ep->dma_addr != 0U)
0000d4  6918              LDR      r0,[r3,#0x10]
0000d6  b128              CBZ      r0,|L17.228|
;;;892          {
;;;893            USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
0000d8  f5026010          ADD      r0,r2,#0x900
0000dc  eb001041          ADD      r0,r0,r1,LSL #5
0000e0  691e              LDR      r6,[r3,#0x10]
0000e2  6146              STR      r6,[r0,#0x14]
                  |L17.228|
;;;894          }
;;;895    
;;;896          /* EP enable, IN data in FIFO */
;;;897          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
0000e4  f5026010          ADD      r0,r2,#0x900
0000e8  eb001041          ADD      r0,r0,r1,LSL #5
0000ec  6800              LDR      r0,[r0,#0]
0000ee  f0404604          ORR      r6,r0,#0x84000000
0000f2  f5026010          ADD      r0,r2,#0x900
0000f6  eb001041          ADD      r0,r0,r1,LSL #5
0000fa  6006              STR      r6,[r0,#0]
0000fc  e068              B        |L17.464|
                  |L17.254|
0000fe  e01b              B        |L17.312|
                  |L17.256|
;;;898        }
;;;899        else
;;;900        {
;;;901          /* EP enable, IN data in FIFO */
;;;902          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
000100  f5026010          ADD      r0,r2,#0x900
000104  eb001041          ADD      r0,r0,r1,LSL #5
000108  6800              LDR      r0,[r0,#0]
00010a  f0404604          ORR      r6,r0,#0x84000000
00010e  f5026010          ADD      r0,r2,#0x900
000112  eb001041          ADD      r0,r0,r1,LSL #5
000116  6006              STR      r6,[r0,#0]
;;;903    
;;;904          /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;905          if (ep->xfer_len > 0U)
000118  6958              LDR      r0,[r3,#0x14]
00011a  2800              CMP      r0,#0
00011c  d058              BEQ      |L17.464|
;;;906          {
;;;907            USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
00011e  f6400034          MOV      r0,#0x834
000122  5880              LDR      r0,[r0,r2]
000124  781e              LDRB     r6,[r3,#0]
000126  f006070f          AND      r7,r6,#0xf
00012a  2601              MOVS     r6,#1
00012c  40be              LSLS     r6,r6,r7
00012e  4330              ORRS     r0,r0,r6
000130  f6400634          MOV      r6,#0x834
000134  50b0              STR      r0,[r6,r2]
000136  e04b              B        |L17.464|
                  |L17.312|
;;;908          }
;;;909        }
;;;910      }
;;;911      else /* OUT endpoint */
;;;912      {
;;;913        /* Program the transfer size and packet count as follows:
;;;914        * pktcnt = N
;;;915        * xfersize = N * maxpacket
;;;916        */
;;;917        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
000138  f5026030          ADD      r0,r2,#0xb00
00013c  eb001041          ADD      r0,r0,r1,LSL #5
000140  6900              LDR      r0,[r0,#0x10]
000142  0cc6              LSRS     r6,r0,#19
000144  04f6              LSLS     r6,r6,#19
000146  f5026030          ADD      r0,r2,#0xb00
00014a  eb001041          ADD      r0,r0,r1,LSL #5
00014e  6106              STR      r6,[r0,#0x10]
;;;918        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
000150  f5026030          ADD      r0,r2,#0xb00
000154  eb001041          ADD      r0,r0,r1,LSL #5
000158  6900              LDR      r0,[r0,#0x10]
00015a  4e1e              LDR      r6,|L17.468|
00015c  4030              ANDS     r0,r0,r6
00015e  f5026630          ADD      r6,r2,#0xb00
000162  eb061641          ADD      r6,r6,r1,LSL #5
000166  6130              STR      r0,[r6,#0x10]
;;;919    
;;;920        if (ep->xfer_len > 0U)
000168  6958              LDR      r0,[r3,#0x14]
00016a  b108              CBZ      r0,|L17.368|
;;;921        {
;;;922          ep->xfer_len = ep->maxpacket;
00016c  6898              LDR      r0,[r3,#8]
00016e  6158              STR      r0,[r3,#0x14]
                  |L17.368|
;;;923        }
;;;924    
;;;925        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
000170  f5026030          ADD      r0,r2,#0xb00
000174  eb001041          ADD      r0,r0,r1,LSL #5
000178  6900              LDR      r0,[r0,#0x10]
00017a  f4402600          ORR      r6,r0,#0x80000
00017e  f5026030          ADD      r0,r2,#0xb00
000182  eb001041          ADD      r0,r0,r1,LSL #5
000186  6106              STR      r6,[r0,#0x10]
;;;926        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
000188  f5026030          ADD      r0,r2,#0xb00
00018c  eb001041          ADD      r0,r0,r1,LSL #5
000190  6900              LDR      r0,[r0,#0x10]
000192  689e              LDR      r6,[r3,#8]
000194  f3c60612          UBFX     r6,r6,#0,#19
000198  4330              ORRS     r0,r0,r6
00019a  f5026630          ADD      r6,r2,#0xb00
00019e  eb061641          ADD      r6,r6,r1,LSL #5
0001a2  6130              STR      r0,[r6,#0x10]
;;;927    
;;;928        if (dma == 1U)
0001a4  2c01              CMP      r4,#1
0001a6  d107              BNE      |L17.440|
;;;929        {
;;;930          if ((uint32_t)ep->xfer_buff != 0U)
0001a8  68d8              LDR      r0,[r3,#0xc]
0001aa  b128              CBZ      r0,|L17.440|
;;;931          {
;;;932            USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
0001ac  f5026030          ADD      r0,r2,#0xb00
0001b0  eb001041          ADD      r0,r0,r1,LSL #5
0001b4  68de              LDR      r6,[r3,#0xc]
0001b6  6146              STR      r6,[r0,#0x14]
                  |L17.440|
;;;933          }
;;;934        }
;;;935    
;;;936        /* EP enable */
;;;937        USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
0001b8  f5026030          ADD      r0,r2,#0xb00
0001bc  eb001041          ADD      r0,r0,r1,LSL #5
0001c0  6800              LDR      r0,[r0,#0]
0001c2  f0404604          ORR      r6,r0,#0x84000000
0001c6  f5026030          ADD      r0,r2,#0xb00
0001ca  eb001041          ADD      r0,r0,r1,LSL #5
0001ce  6006              STR      r6,[r0,#0]
                  |L17.464|
;;;938      }
;;;939    
;;;940      return HAL_OK;
0001d0  2000              MOVS     r0,#0
;;;941    }
0001d2  bdf0              POP      {r4-r7,pc}
;;;942    
                          ENDP

                  |L17.468|
                          DCD      0xe007ffff

                          AREA ||i.USB_EP0_OutStart||, CODE, READONLY, ALIGN=2

                  USB_EP0_OutStart PROC
;;;1285     */
;;;1286   HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
000000  b570              PUSH     {r4-r6,lr}
;;;1287   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1288     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4619              MOV      r1,r3
;;;1289     uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
000008  6c1d              LDR      r5,[r3,#0x40]
;;;1290   
;;;1291     if (gSNPSiD > USB_OTG_CORE_ID_300A)
00000a  4818              LDR      r0,|L18.108|
00000c  4285              CMP      r5,r0
00000e  d909              BLS      |L18.36|
;;;1292     {
;;;1293       if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
000010  f44f6030          MOV      r0,#0xb00
000014  5840              LDR      r0,[r0,r1]
000016  f0004000          AND      r0,r0,#0x80000000
00001a  f1b04f00          CMP      r0,#0x80000000
00001e  d101              BNE      |L18.36|
;;;1294       {
;;;1295         return HAL_OK;
000020  2000              MOVS     r0,#0
                  |L18.34|
;;;1296       }
;;;1297     }
;;;1298   
;;;1299     USBx_OUTEP(0U)->DOEPTSIZ = 0U;
;;;1300     USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
;;;1301     USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
;;;1302     USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
;;;1303   
;;;1304     if (dma == 1U)
;;;1305     {
;;;1306       USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
;;;1307       /* EP enable */
;;;1308       USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
;;;1309     }
;;;1310   
;;;1311     return HAL_OK;
;;;1312   }
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  2600              MOVS     r6,#0                 ;1299
000026  f8c16b10          STR      r6,[r1,#0xb10]        ;1299
00002a  f8d10b10          LDR      r0,[r1,#0xb10]        ;1300
00002e  f4402600          ORR      r6,r0,#0x80000        ;1300
000032  f8c16b10          STR      r6,[r1,#0xb10]        ;1300
000036  f8d10b10          LDR      r0,[r1,#0xb10]        ;1301
00003a  f0400618          ORR      r6,r0,#0x18           ;1301
00003e  f8c16b10          STR      r6,[r1,#0xb10]        ;1301
000042  f8d10b10          LDR      r0,[r1,#0xb10]        ;1302
000046  f04046c0          ORR      r6,r0,#0x60000000     ;1302
00004a  f8c16b10          STR      r6,[r1,#0xb10]        ;1302
00004e  2c01              CMP      r4,#1                 ;1304
000050  d109              BNE      |L18.102|
000052  f8c12b14          STR      r2,[r1,#0xb14]        ;1306
000056  f44f6030          MOV      r0,#0xb00             ;1308
00005a  5840              LDR      r0,[r0,r1]            ;1308
00005c  f0402680          ORR      r6,r0,#0x80008000     ;1308
000060  f44f6030          MOV      r0,#0xb00             ;1308
000064  5046              STR      r6,[r0,r1]            ;1308
                  |L18.102|
000066  2000              MOVS     r0,#0                 ;1311
000068  e7db              B        |L18.34|
;;;1313   
                          ENDP

00006a  0000              DCW      0x0000
                  |L18.108|
                          DCD      0x4f54300a

                          AREA ||i.USB_EPClearStall||, CODE, READONLY, ALIGN=1

                  USB_EPClearStall PROC
;;;1035     */
;;;1036   HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b530              PUSH     {r4,r5,lr}
;;;1037   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1038     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;1039     uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;1040   
;;;1041     if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d11e              BNE      |L19.78|
;;;1042     {
;;;1043       USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f4201500          BIC      r5,r0,#0x200000
00001e  f5026010          ADD      r0,r2,#0x900
000022  eb001041          ADD      r0,r0,r1,LSL #5
000026  6005              STR      r5,[r0,#0]
;;;1044       if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
000028  78d8              LDRB     r0,[r3,#3]
00002a  2803              CMP      r0,#3
00002c  d002              BEQ      |L19.52|
00002e  78d8              LDRB     r0,[r3,#3]
000030  2802              CMP      r0,#2
000032  d12a              BNE      |L19.138|
                  |L19.52|
;;;1045       {
;;;1046         USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
000034  f5026010          ADD      r0,r2,#0x900
000038  eb001041          ADD      r0,r0,r1,LSL #5
00003c  6800              LDR      r0,[r0,#0]
00003e  f0405580          ORR      r5,r0,#0x10000000
000042  f5026010          ADD      r0,r2,#0x900
000046  eb001041          ADD      r0,r0,r1,LSL #5
00004a  6005              STR      r5,[r0,#0]
00004c  e01d              B        |L19.138|
                  |L19.78|
;;;1047       }
;;;1048     }
;;;1049     else
;;;1050     {
;;;1051       USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
00004e  f5026030          ADD      r0,r2,#0xb00
000052  eb001041          ADD      r0,r0,r1,LSL #5
000056  6800              LDR      r0,[r0,#0]
000058  f4201500          BIC      r5,r0,#0x200000
00005c  f5026030          ADD      r0,r2,#0xb00
000060  eb001041          ADD      r0,r0,r1,LSL #5
000064  6005              STR      r5,[r0,#0]
;;;1052       if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
000066  78d8              LDRB     r0,[r3,#3]
000068  2803              CMP      r0,#3
00006a  d002              BEQ      |L19.114|
00006c  78d8              LDRB     r0,[r3,#3]
00006e  2802              CMP      r0,#2
000070  d10b              BNE      |L19.138|
                  |L19.114|
;;;1053       {
;;;1054         USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
000072  f5026030          ADD      r0,r2,#0xb00
000076  eb001041          ADD      r0,r0,r1,LSL #5
00007a  6800              LDR      r0,[r0,#0]
00007c  f0405580          ORR      r5,r0,#0x10000000
000080  f5026030          ADD      r0,r2,#0xb00
000084  eb001041          ADD      r0,r0,r1,LSL #5
000088  6005              STR      r5,[r0,#0]
                  |L19.138|
;;;1055       }
;;;1056     }
;;;1057     return HAL_OK;
00008a  2000              MOVS     r0,#0
;;;1058   }
00008c  bd30              POP      {r4,r5,pc}
;;;1059   
                          ENDP


                          AREA ||i.USB_EPSetStall||, CODE, READONLY, ALIGN=1

                  USB_EPSetStall PROC
;;;1004     */
;;;1005   HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b530              PUSH     {r4,r5,lr}
;;;1006   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1007     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;1008     uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;1009   
;;;1010     if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d121              BNE      |L20.84|
;;;1011     {
;;;1012       if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  b960              CBNZ     r0,|L20.58|
000020  b159              CBZ      r1,|L20.58|
;;;1013       {
;;;1014         USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
000022  f5026010          ADD      r0,r2,#0x900
000026  eb001041          ADD      r0,r0,r1,LSL #5
00002a  6800              LDR      r0,[r0,#0]
00002c  f0204580          BIC      r5,r0,#0x40000000
000030  f5026010          ADD      r0,r2,#0x900
000034  eb001041          ADD      r0,r0,r1,LSL #5
000038  6005              STR      r5,[r0,#0]
                  |L20.58|
;;;1015       }
;;;1016       USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
00003a  f5026010          ADD      r0,r2,#0x900
00003e  eb001041          ADD      r0,r0,r1,LSL #5
000042  6800              LDR      r0,[r0,#0]
000044  f4401500          ORR      r5,r0,#0x200000
000048  f5026010          ADD      r0,r2,#0x900
00004c  eb001041          ADD      r0,r0,r1,LSL #5
000050  6005              STR      r5,[r0,#0]
000052  e020              B        |L20.150|
                  |L20.84|
;;;1017     }
;;;1018     else
;;;1019     {
;;;1020       if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
000054  f5026030          ADD      r0,r2,#0xb00
000058  eb001041          ADD      r0,r0,r1,LSL #5
00005c  6800              LDR      r0,[r0,#0]
00005e  f0004000          AND      r0,r0,#0x80000000
000062  b960              CBNZ     r0,|L20.126|
000064  b159              CBZ      r1,|L20.126|
;;;1021       {
;;;1022         USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
000066  f5026030          ADD      r0,r2,#0xb00
00006a  eb001041          ADD      r0,r0,r1,LSL #5
00006e  6800              LDR      r0,[r0,#0]
000070  f0204580          BIC      r5,r0,#0x40000000
000074  f5026030          ADD      r0,r2,#0xb00
000078  eb001041          ADD      r0,r0,r1,LSL #5
00007c  6005              STR      r5,[r0,#0]
                  |L20.126|
;;;1023       }
;;;1024       USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
00007e  f5026030          ADD      r0,r2,#0xb00
000082  eb001041          ADD      r0,r0,r1,LSL #5
000086  6800              LDR      r0,[r0,#0]
000088  f4401500          ORR      r5,r0,#0x200000
00008c  f5026030          ADD      r0,r2,#0xb00
000090  eb001041          ADD      r0,r0,r1,LSL #5
000094  6005              STR      r5,[r0,#0]
                  |L20.150|
;;;1025     }
;;;1026   
;;;1027     return HAL_OK;
000096  2000              MOVS     r0,#0
;;;1028   }
000098  bd30              POP      {r4,r5,pc}
;;;1029   
                          ENDP


                          AREA ||i.USB_EPStartXfer||, CODE, READONLY, ALIGN=2

                  USB_EPStartXfer PROC
;;;713      */
;;;714    HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;715    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;716      uint32_t USBx_BASE = (uint32_t)USBx;
00000a  464d              MOV      r5,r9
;;;717      uint32_t epnum = (uint32_t)ep->num;
00000c  7834              LDRB     r4,[r6,#0]
;;;718      uint16_t pktcnt;
;;;719    
;;;720      /* IN endpoint */
;;;721      if (ep->is_in == 1U)
00000e  7870              LDRB     r0,[r6,#1]
000010  2801              CMP      r0,#1
000012  d17d              BNE      |L21.272|
;;;722      {
;;;723        /* Zero Length Packet? */
;;;724        if (ep->xfer_len == 0U)
000014  6970              LDR      r0,[r6,#0x14]
000016  bb20              CBNZ     r0,|L21.98|
;;;725        {
;;;726          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
000018  f5056010          ADD      r0,r5,#0x900
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  6900              LDR      r0,[r0,#0x10]
000022  49c7              LDR      r1,|L21.832|
000024  4008              ANDS     r0,r0,r1
000026  f5056110          ADD      r1,r5,#0x900
00002a  eb011144          ADD      r1,r1,r4,LSL #5
00002e  6108              STR      r0,[r1,#0x10]
;;;727          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
000030  f5056010          ADD      r0,r5,#0x900
000034  eb001044          ADD      r0,r0,r4,LSL #5
000038  6900              LDR      r0,[r0,#0x10]
00003a  f4402100          ORR      r1,r0,#0x80000
00003e  f5056010          ADD      r0,r5,#0x900
000042  eb001044          ADD      r0,r0,r4,LSL #5
000046  6101              STR      r1,[r0,#0x10]
;;;728          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000048  f5056010          ADD      r0,r5,#0x900
00004c  eb001044          ADD      r0,r0,r4,LSL #5
000050  6900              LDR      r0,[r0,#0x10]
000052  0cc1              LSRS     r1,r0,#19
000054  04c9              LSLS     r1,r1,#19
000056  f5056010          ADD      r0,r5,#0x900
00005a  eb001044          ADD      r0,r0,r4,LSL #5
00005e  6101              STR      r1,[r0,#0x10]
000060  e055              B        |L21.270|
                  |L21.98|
;;;729        }
;;;730        else
;;;731        {
;;;732          /* Program the transfer size and packet count
;;;733          * as follows: xfersize = N * maxpacket +
;;;734          * short_packet pktcnt = N + (short_packet
;;;735          * exist ? 1 : 0)
;;;736          */
;;;737          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000062  f5056010          ADD      r0,r5,#0x900
000066  eb001044          ADD      r0,r0,r4,LSL #5
00006a  6900              LDR      r0,[r0,#0x10]
00006c  0cc1              LSRS     r1,r0,#19
00006e  04c9              LSLS     r1,r1,#19
000070  f5056010          ADD      r0,r5,#0x900
000074  eb001044          ADD      r0,r0,r4,LSL #5
000078  6101              STR      r1,[r0,#0x10]
;;;738          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
00007a  f5056010          ADD      r0,r5,#0x900
00007e  eb001044          ADD      r0,r0,r4,LSL #5
000082  6900              LDR      r0,[r0,#0x10]
000084  49ae              LDR      r1,|L21.832|
000086  4008              ANDS     r0,r0,r1
000088  f5056110          ADD      r1,r5,#0x900
00008c  eb011144          ADD      r1,r1,r4,LSL #5
000090  6108              STR      r0,[r1,#0x10]
;;;739          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
000092  68b1              LDR      r1,[r6,#8]
000094  6970              LDR      r0,[r6,#0x14]
000096  4408              ADD      r0,r0,r1
000098  1e40              SUBS     r0,r0,#1
00009a  fbb0f0f1          UDIV     r0,r0,r1
00009e  49a8              LDR      r1,|L21.832|
0000a0  43c9              MVNS     r1,r1
0000a2  ea0140c0          AND      r0,r1,r0,LSL #19
0000a6  f5056110          ADD      r1,r5,#0x900
0000aa  eb011144          ADD      r1,r1,r4,LSL #5
0000ae  6909              LDR      r1,[r1,#0x10]
0000b0  4308              ORRS     r0,r0,r1
0000b2  f5056110          ADD      r1,r5,#0x900
0000b6  eb011144          ADD      r1,r1,r4,LSL #5
0000ba  6108              STR      r0,[r1,#0x10]
;;;740          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
0000bc  f5056010          ADD      r0,r5,#0x900
0000c0  eb001044          ADD      r0,r0,r4,LSL #5
0000c4  6900              LDR      r0,[r0,#0x10]
0000c6  6971              LDR      r1,[r6,#0x14]
0000c8  f3c10112          UBFX     r1,r1,#0,#19
0000cc  4308              ORRS     r0,r0,r1
0000ce  f5056110          ADD      r1,r5,#0x900
0000d2  eb011144          ADD      r1,r1,r4,LSL #5
0000d6  6108              STR      r0,[r1,#0x10]
;;;741    
;;;742          if (ep->type == EP_TYPE_ISOC)
0000d8  78f0              LDRB     r0,[r6,#3]
0000da  2801              CMP      r0,#1
0000dc  d117              BNE      |L21.270|
;;;743          {
;;;744            USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
0000de  f5056010          ADD      r0,r5,#0x900
0000e2  eb001044          ADD      r0,r0,r4,LSL #5
0000e6  6900              LDR      r0,[r0,#0x10]
0000e8  f02041c0          BIC      r1,r0,#0x60000000
0000ec  f5056010          ADD      r0,r5,#0x900
0000f0  eb001044          ADD      r0,r0,r4,LSL #5
0000f4  6101              STR      r1,[r0,#0x10]
;;;745            USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
0000f6  f5056010          ADD      r0,r5,#0x900
0000fa  eb001044          ADD      r0,r0,r4,LSL #5
0000fe  6900              LDR      r0,[r0,#0x10]
000100  f0405100          ORR      r1,r0,#0x20000000
000104  f5056010          ADD      r0,r5,#0x900
000108  eb001044          ADD      r0,r0,r4,LSL #5
00010c  6101              STR      r1,[r0,#0x10]
                  |L21.270|
;;;746          }
;;;747        }
;;;748    
;;;749        if (dma == 1U)
00010e  e000              B        |L21.274|
                  |L21.272|
000110  e07f              B        |L21.530|
                  |L21.274|
000112  2f01              CMP      r7,#1
000114  d136              BNE      |L21.388|
;;;750        {
;;;751          if ((uint32_t)ep->dma_addr != 0U)
000116  6930              LDR      r0,[r6,#0x10]
000118  b128              CBZ      r0,|L21.294|
;;;752          {
;;;753            USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
00011a  f5056010          ADD      r0,r5,#0x900
00011e  eb001044          ADD      r0,r0,r4,LSL #5
000122  6931              LDR      r1,[r6,#0x10]
000124  6141              STR      r1,[r0,#0x14]
                  |L21.294|
;;;754          }
;;;755    
;;;756          if (ep->type == EP_TYPE_ISOC)
000126  78f0              LDRB     r0,[r6,#3]
000128  2801              CMP      r0,#1
00012a  d11e              BNE      |L21.362|
;;;757          {
;;;758            if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
00012c  f6400008          MOV      r0,#0x808
000130  5940              LDR      r0,[r0,r5]
000132  f4007080          AND      r0,r0,#0x100
000136  b960              CBNZ     r0,|L21.338|
;;;759            {
;;;760              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
000138  f5056010          ADD      r0,r5,#0x900
00013c  eb001044          ADD      r0,r0,r4,LSL #5
000140  6800              LDR      r0,[r0,#0]
000142  f0405100          ORR      r1,r0,#0x20000000
000146  f5056010          ADD      r0,r5,#0x900
00014a  eb001044          ADD      r0,r0,r4,LSL #5
00014e  6001              STR      r1,[r0,#0]
000150  e00b              B        |L21.362|
                  |L21.338|
;;;761            }
;;;762            else
;;;763            {
;;;764              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
000152  f5056010          ADD      r0,r5,#0x900
000156  eb001044          ADD      r0,r0,r4,LSL #5
00015a  6800              LDR      r0,[r0,#0]
00015c  f0405180          ORR      r1,r0,#0x10000000
000160  f5056010          ADD      r0,r5,#0x900
000164  eb001044          ADD      r0,r0,r4,LSL #5
000168  6001              STR      r1,[r0,#0]
                  |L21.362|
;;;765            }
;;;766          }
;;;767    
;;;768          /* EP enable, IN data in FIFO */
;;;769          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
00016a  f5056010          ADD      r0,r5,#0x900
00016e  eb001044          ADD      r0,r0,r4,LSL #5
000172  6800              LDR      r0,[r0,#0]
000174  f0404104          ORR      r1,r0,#0x84000000
000178  f5056010          ADD      r0,r5,#0x900
00017c  eb001044          ADD      r0,r0,r4,LSL #5
000180  6001              STR      r1,[r0,#0]
                  |L21.386|
000182  e0da              B        |L21.826|
                  |L21.388|
;;;770        }
;;;771        else
;;;772        {
;;;773          /* EP enable, IN data in FIFO */
;;;774          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
000184  f5056010          ADD      r0,r5,#0x900
000188  eb001044          ADD      r0,r0,r4,LSL #5
00018c  6800              LDR      r0,[r0,#0]
00018e  f0404104          ORR      r1,r0,#0x84000000
000192  f5056010          ADD      r0,r5,#0x900
000196  eb001044          ADD      r0,r0,r4,LSL #5
00019a  6001              STR      r1,[r0,#0]
;;;775    
;;;776          if (ep->type != EP_TYPE_ISOC)
00019c  78f0              LDRB     r0,[r6,#3]
00019e  2801              CMP      r0,#1
0001a0  d00f              BEQ      |L21.450|
;;;777          {
;;;778            /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;779            if (ep->xfer_len > 0U)
0001a2  6970              LDR      r0,[r6,#0x14]
0001a4  2800              CMP      r0,#0
0001a6  d0ec              BEQ      |L21.386|
;;;780            {
;;;781              USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
0001a8  f6400034          MOV      r0,#0x834
0001ac  5940              LDR      r0,[r0,r5]
0001ae  7831              LDRB     r1,[r6,#0]
0001b0  f001020f          AND      r2,r1,#0xf
0001b4  2101              MOVS     r1,#1
0001b6  4091              LSLS     r1,r1,r2
0001b8  4308              ORRS     r0,r0,r1
0001ba  f6400134          MOV      r1,#0x834
0001be  5148              STR      r0,[r1,r5]
0001c0  e0bb              B        |L21.826|
                  |L21.450|
;;;782            }
;;;783          }
;;;784          else
;;;785          {
;;;786            if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
0001c2  f6400008          MOV      r0,#0x808
0001c6  5940              LDR      r0,[r0,r5]
0001c8  f4007080          AND      r0,r0,#0x100
0001cc  b960              CBNZ     r0,|L21.488|
;;;787            {
;;;788              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
0001ce  f5056010          ADD      r0,r5,#0x900
0001d2  eb001044          ADD      r0,r0,r4,LSL #5
0001d6  6800              LDR      r0,[r0,#0]
0001d8  f0405100          ORR      r1,r0,#0x20000000
0001dc  f5056010          ADD      r0,r5,#0x900
0001e0  eb001044          ADD      r0,r0,r4,LSL #5
0001e4  6001              STR      r1,[r0,#0]
0001e6  e00b              B        |L21.512|
                  |L21.488|
;;;789            }
;;;790            else
;;;791            {
;;;792              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
0001e8  f5056010          ADD      r0,r5,#0x900
0001ec  eb001044          ADD      r0,r0,r4,LSL #5
0001f0  6800              LDR      r0,[r0,#0]
0001f2  f0405180          ORR      r1,r0,#0x10000000
0001f6  f5056010          ADD      r0,r5,#0x900
0001fa  eb001044          ADD      r0,r0,r4,LSL #5
0001fe  6001              STR      r1,[r0,#0]
                  |L21.512|
;;;793            }
;;;794    
;;;795            (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
000200  9700              STR      r7,[sp,#0]
000202  8ab0              LDRH     r0,[r6,#0x14]
000204  b283              UXTH     r3,r0
000206  7832              LDRB     r2,[r6,#0]
000208  4648              MOV      r0,r9
00020a  68f1              LDR      r1,[r6,#0xc]
00020c  f7fffffe          BL       USB_WritePacket
000210  e093              B        |L21.826|
                  |L21.530|
;;;796          }
;;;797        }
;;;798      }
;;;799      else /* OUT endpoint */
;;;800      {
;;;801        /* Program the transfer size and packet count as follows:
;;;802        * pktcnt = N
;;;803        * xfersize = N * maxpacket
;;;804        */
;;;805        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
000212  f5056030          ADD      r0,r5,#0xb00
000216  eb001044          ADD      r0,r0,r4,LSL #5
00021a  6900              LDR      r0,[r0,#0x10]
00021c  0cc1              LSRS     r1,r0,#19
00021e  04c9              LSLS     r1,r1,#19
000220  f5056030          ADD      r0,r5,#0xb00
000224  eb001044          ADD      r0,r0,r4,LSL #5
000228  6101              STR      r1,[r0,#0x10]
;;;806        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
00022a  f5056030          ADD      r0,r5,#0xb00
00022e  eb001044          ADD      r0,r0,r4,LSL #5
000232  6900              LDR      r0,[r0,#0x10]
000234  4942              LDR      r1,|L21.832|
000236  4008              ANDS     r0,r0,r1
000238  f5056130          ADD      r1,r5,#0xb00
00023c  eb011144          ADD      r1,r1,r4,LSL #5
000240  6108              STR      r0,[r1,#0x10]
;;;807    
;;;808        if (ep->xfer_len == 0U)
000242  6970              LDR      r0,[r6,#0x14]
000244  b9d0              CBNZ     r0,|L21.636|
;;;809        {
;;;810          USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
000246  f5056030          ADD      r0,r5,#0xb00
00024a  eb001044          ADD      r0,r0,r4,LSL #5
00024e  6900              LDR      r0,[r0,#0x10]
000250  68b1              LDR      r1,[r6,#8]
000252  f3c10112          UBFX     r1,r1,#0,#19
000256  4308              ORRS     r0,r0,r1
000258  f5056130          ADD      r1,r5,#0xb00
00025c  eb011144          ADD      r1,r1,r4,LSL #5
000260  6108              STR      r0,[r1,#0x10]
;;;811          USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
000262  f5056030          ADD      r0,r5,#0xb00
000266  eb001044          ADD      r0,r0,r4,LSL #5
00026a  6900              LDR      r0,[r0,#0x10]
00026c  f4402100          ORR      r1,r0,#0x80000
000270  f5056030          ADD      r0,r5,#0xb00
000274  eb001044          ADD      r0,r0,r4,LSL #5
000278  6101              STR      r1,[r0,#0x10]
00027a  e026              B        |L21.714|
                  |L21.636|
;;;812        }
;;;813        else
;;;814        {
;;;815          pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
00027c  68b1              LDR      r1,[r6,#8]
00027e  6970              LDR      r0,[r6,#0x14]
000280  4408              ADD      r0,r0,r1
000282  1e40              SUBS     r0,r0,#1
000284  fbb0f0f1          UDIV     r0,r0,r1
000288  fa1ff880          UXTH     r8,r0
;;;816          USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
00028c  f5056030          ADD      r0,r5,#0xb00
000290  eb001044          ADD      r0,r0,r4,LSL #5
000294  6900              LDR      r0,[r0,#0x10]
000296  492a              LDR      r1,|L21.832|
000298  43c9              MVNS     r1,r1
00029a  ea0141c8          AND      r1,r1,r8,LSL #19
00029e  4308              ORRS     r0,r0,r1
0002a0  f5056130          ADD      r1,r5,#0xb00
0002a4  eb011144          ADD      r1,r1,r4,LSL #5
0002a8  6108              STR      r0,[r1,#0x10]
;;;817          USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
0002aa  f5056030          ADD      r0,r5,#0xb00
0002ae  eb001044          ADD      r0,r0,r4,LSL #5
0002b2  6900              LDR      r0,[r0,#0x10]
0002b4  68b1              LDR      r1,[r6,#8]
0002b6  fb01f108          MUL      r1,r1,r8
0002ba  f3c10112          UBFX     r1,r1,#0,#19
0002be  4308              ORRS     r0,r0,r1
0002c0  f5056130          ADD      r1,r5,#0xb00
0002c4  eb011144          ADD      r1,r1,r4,LSL #5
0002c8  6108              STR      r0,[r1,#0x10]
                  |L21.714|
;;;818        }
;;;819    
;;;820        if (dma == 1U)
0002ca  2f01              CMP      r7,#1
0002cc  d107              BNE      |L21.734|
;;;821        {
;;;822          if ((uint32_t)ep->xfer_buff != 0U)
0002ce  68f0              LDR      r0,[r6,#0xc]
0002d0  b128              CBZ      r0,|L21.734|
;;;823          {
;;;824            USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
0002d2  f5056030          ADD      r0,r5,#0xb00
0002d6  eb001044          ADD      r0,r0,r4,LSL #5
0002da  68f1              LDR      r1,[r6,#0xc]
0002dc  6141              STR      r1,[r0,#0x14]
                  |L21.734|
;;;825          }
;;;826        }
;;;827    
;;;828        if (ep->type == EP_TYPE_ISOC)
0002de  78f0              LDRB     r0,[r6,#3]
0002e0  2801              CMP      r0,#1
0002e2  d11e              BNE      |L21.802|
;;;829        {
;;;830          if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
0002e4  f6400008          MOV      r0,#0x808
0002e8  5940              LDR      r0,[r0,r5]
0002ea  f4007080          AND      r0,r0,#0x100
0002ee  b960              CBNZ     r0,|L21.778|
;;;831          {
;;;832            USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
0002f0  f5056030          ADD      r0,r5,#0xb00
0002f4  eb001044          ADD      r0,r0,r4,LSL #5
0002f8  6800              LDR      r0,[r0,#0]
0002fa  f0405100          ORR      r1,r0,#0x20000000
0002fe  f5056030          ADD      r0,r5,#0xb00
000302  eb001044          ADD      r0,r0,r4,LSL #5
000306  6001              STR      r1,[r0,#0]
000308  e00b              B        |L21.802|
                  |L21.778|
;;;833          }
;;;834          else
;;;835          {
;;;836            USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
00030a  f5056030          ADD      r0,r5,#0xb00
00030e  eb001044          ADD      r0,r0,r4,LSL #5
000312  6800              LDR      r0,[r0,#0]
000314  f0405180          ORR      r1,r0,#0x10000000
000318  f5056030          ADD      r0,r5,#0xb00
00031c  eb001044          ADD      r0,r0,r4,LSL #5
000320  6001              STR      r1,[r0,#0]
                  |L21.802|
;;;837          }
;;;838        }
;;;839        /* EP enable */
;;;840        USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
000322  f5056030          ADD      r0,r5,#0xb00
000326  eb001044          ADD      r0,r0,r4,LSL #5
00032a  6800              LDR      r0,[r0,#0]
00032c  f0404104          ORR      r1,r0,#0x84000000
000330  f5056030          ADD      r0,r5,#0xb00
000334  eb001044          ADD      r0,r0,r4,LSL #5
000338  6001              STR      r1,[r0,#0]
                  |L21.826|
;;;841      }
;;;842    
;;;843      return HAL_OK;
00033a  2000              MOVS     r0,#0
;;;844    }
00033c  e8bd83f8          POP      {r3-r9,pc}
;;;845    
                          ENDP

                  |L21.832|
                          DCD      0xe007ffff

                          AREA ||i.USB_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_EnableGlobalInt PROC
;;;220      */
;;;221    HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;222    {
;;;223      USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
000002  6888              LDR      r0,[r1,#8]
000004  f0400001          ORR      r0,r0,#1
000008  6088              STR      r0,[r1,#8]
;;;224      return HAL_OK;
00000a  2000              MOVS     r0,#0
;;;225    }
00000c  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.USB_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_FlushRxFifo PROC
;;;474      */
;;;475    HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;476    {
;;;477      uint32_t count = 0;
000002  2200              MOVS     r2,#0
;;;478    
;;;479      USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
000004  2010              MOVS     r0,#0x10
000006  6108              STR      r0,[r1,#0x10]
;;;480    
;;;481      do
000008  bf00              NOP      
                  |L23.10|
;;;482      {
;;;483        if (++count > 200000U)
00000a  1c50              ADDS     r0,r2,#1
00000c  4602              MOV      r2,r0
00000e  4b06              LDR      r3,|L23.40|
000010  4298              CMP      r0,r3
000012  d901              BLS      |L23.24|
;;;484        {
;;;485          return HAL_TIMEOUT;
000014  2003              MOVS     r0,#3
                  |L23.22|
;;;486        }
;;;487      } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
;;;488    
;;;489      return HAL_OK;
;;;490    }
000016  4770              BX       lr
                  |L23.24|
000018  6908              LDR      r0,[r1,#0x10]         ;487
00001a  f0000010          AND      r0,r0,#0x10           ;487
00001e  2810              CMP      r0,#0x10              ;487
000020  d0f3              BEQ      |L23.10|
000022  2000              MOVS     r0,#0                 ;489
000024  e7f7              B        |L23.22|
;;;491    
                          ENDP

000026  0000              DCW      0x0000
                  |L23.40|
                          DCD      0x00030d40

                          AREA ||i.USB_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_FlushTxFifo PROC
;;;452      */
;;;453    HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
000000  b510              PUSH     {r4,lr}
;;;454    {
000002  4602              MOV      r2,r0
;;;455      uint32_t count = 0U;
000004  2300              MOVS     r3,#0
;;;456    
;;;457      USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
000006  2020              MOVS     r0,#0x20
000008  ea401081          ORR      r0,r0,r1,LSL #6
00000c  6110              STR      r0,[r2,#0x10]
;;;458    
;;;459      do
00000e  bf00              NOP      
                  |L24.16|
;;;460      {
;;;461        if (++count > 200000U)
000010  1c58              ADDS     r0,r3,#1
000012  4603              MOV      r3,r0
000014  4c05              LDR      r4,|L24.44|
000016  42a0              CMP      r0,r4
000018  d901              BLS      |L24.30|
;;;462        {
;;;463          return HAL_TIMEOUT;
00001a  2003              MOVS     r0,#3
                  |L24.28|
;;;464        }
;;;465      } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
;;;466    
;;;467      return HAL_OK;
;;;468    }
00001c  bd10              POP      {r4,pc}
                  |L24.30|
00001e  6910              LDR      r0,[r2,#0x10]         ;465
000020  f0000020          AND      r0,r0,#0x20           ;465
000024  2820              CMP      r0,#0x20              ;465
000026  d0f3              BEQ      |L24.16|
000028  2000              MOVS     r0,#0                 ;467
00002a  e7f7              B        |L24.28|
;;;469    
                          ENDP

                  |L24.44|
                          DCD      0x00030d40

                          AREA ||i.USB_GetCurrentFrame||, CODE, READONLY, ALIGN=1

                  USB_GetCurrentFrame PROC
;;;1560     */
;;;1561   uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1562   {
;;;1563     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1564   
;;;1565     return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
000004  f44f6081          MOV      r0,#0x408
000008  5880              LDR      r0,[r0,r2]
00000a  b280              UXTH     r0,r0
;;;1566   }
00000c  4770              BX       lr
;;;1567   
                          ENDP


                          AREA ||i.USB_GetDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_GetDevSpeed PROC
;;;518      */
;;;519    uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
000000  b510              PUSH     {r4,lr}
;;;520    {
000002  4601              MOV      r1,r0
;;;521      uint32_t USBx_BASE = (uint32_t)USBx;
000004  460b              MOV      r3,r1
;;;522      uint8_t speed;
;;;523      uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
000006  f6400408          MOV      r4,#0x808
00000a  58e4              LDR      r4,[r4,r3]
00000c  f0040206          AND      r2,r4,#6
;;;524    
;;;525      if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
000010  b90a              CBNZ     r2,|L26.22|
;;;526      {
;;;527        speed = USBD_HS_SPEED;
000012  2000              MOVS     r0,#0
000014  e006              B        |L26.36|
                  |L26.22|
;;;528      }
;;;529      else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
000016  2a02              CMP      r2,#2
000018  d001              BEQ      |L26.30|
;;;530               (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
00001a  2a06              CMP      r2,#6
00001c  d101              BNE      |L26.34|
                  |L26.30|
;;;531      {
;;;532        speed = USBD_FS_SPEED;
00001e  2002              MOVS     r0,#2
000020  e000              B        |L26.36|
                  |L26.34|
;;;533      }
;;;534      else
;;;535      {
;;;536        speed = 0xFU;
000022  200f              MOVS     r0,#0xf
                  |L26.36|
;;;537      }
;;;538    
;;;539      return speed;
;;;540    }
000024  bd10              POP      {r4,pc}
;;;541    
                          ENDP


                          AREA ||i.USB_GetHostSpeed||, CODE, READONLY, ALIGN=1

                  USB_GetHostSpeed PROC
;;;1546     */
;;;1547   uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
000000  b508              PUSH     {r3,lr}
;;;1548   {
000002  4601              MOV      r1,r0
;;;1549     uint32_t USBx_BASE = (uint32_t)USBx;
000004  460a              MOV      r2,r1
;;;1550     __IO uint32_t hprt0 = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1551   
;;;1552     hprt0 = USBx_HPRT0;
00000a  f8d20440          LDR      r0,[r2,#0x440]
00000e  9000              STR      r0,[sp,#0]
;;;1553     return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
000010  9800              LDR      r0,[sp,#0]
000012  f3c04041          UBFX     r0,r0,#17,#2
;;;1554   }
000016  bd08              POP      {r3,pc}
;;;1555   
                          ENDP


                          AREA ||i.USB_GetMode||, CODE, READONLY, ALIGN=1

                  USB_GetMode PROC
;;;1253     */
;;;1254   uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1255   {
;;;1256     return ((USBx->GINTSTS) & 0x1U);
000002  6948              LDR      r0,[r1,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;1257   }
000008  4770              BX       lr
;;;1258   
                          ENDP


                          AREA ||i.USB_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_HC_Halt PROC
;;;1852     */
;;;1853   HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1854   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1855     uint32_t USBx_BASE = (uint32_t)USBx;
000006  461a              MOV      r2,r3
;;;1856     uint32_t hcnum = (uint32_t)hc_num;
000008  4621              MOV      r1,r4
;;;1857     uint32_t count = 0U;
00000a  2500              MOVS     r5,#0
;;;1858     uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
00000c  f50260a0          ADD      r0,r2,#0x500
000010  eb001041          ADD      r0,r0,r1,LSL #5
000014  6800              LDR      r0,[r0,#0]
000016  f3c04681          UBFX     r6,r0,#18,#2
;;;1859   
;;;1860     /* Check for space in the request queue to issue the halt. */
;;;1861     if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
00001a  b10e              CBZ      r6,|L29.32|
00001c  2e02              CMP      r6,#2
00001e  d153              BNE      |L29.200|
                  |L29.32|
;;;1862     {
;;;1863       USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
000020  f50260a0          ADD      r0,r2,#0x500
000024  eb001041          ADD      r0,r0,r1,LSL #5
000028  6800              LDR      r0,[r0,#0]
00002a  f0404780          ORR      r7,r0,#0x40000000
00002e  f50260a0          ADD      r0,r2,#0x500
000032  eb001041          ADD      r0,r0,r1,LSL #5
000036  6007              STR      r7,[r0,#0]
;;;1864   
;;;1865       if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
000038  6ad8              LDR      r0,[r3,#0x2c]
00003a  f400007f          AND      r0,r0,#0xff0000
00003e  bba8              CBNZ     r0,|L29.172|
;;;1866       {
;;;1867         USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
000040  f50260a0          ADD      r0,r2,#0x500
000044  eb001041          ADD      r0,r0,r1,LSL #5
000048  6800              LDR      r0,[r0,#0]
00004a  f0204700          BIC      r7,r0,#0x80000000
00004e  f50260a0          ADD      r0,r2,#0x500
000052  eb001041          ADD      r0,r0,r1,LSL #5
000056  6007              STR      r7,[r0,#0]
;;;1868         USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
000058  f50260a0          ADD      r0,r2,#0x500
00005c  eb001041          ADD      r0,r0,r1,LSL #5
000060  6800              LDR      r0,[r0,#0]
000062  f0404700          ORR      r7,r0,#0x80000000
000066  f50260a0          ADD      r0,r2,#0x500
00006a  eb001041          ADD      r0,r0,r1,LSL #5
00006e  6007              STR      r7,[r0,#0]
;;;1869         USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
000070  f50260a0          ADD      r0,r2,#0x500
000074  eb001041          ADD      r0,r0,r1,LSL #5
000078  6800              LDR      r0,[r0,#0]
00007a  f4204700          BIC      r7,r0,#0x8000
00007e  f50260a0          ADD      r0,r2,#0x500
000082  eb001041          ADD      r0,r0,r1,LSL #5
000086  6007              STR      r7,[r0,#0]
;;;1870         do
000088  bf00              NOP      
                  |L29.138|
;;;1871         {
;;;1872           if (++count > 1000U)
00008a  1c68              ADDS     r0,r5,#1
00008c  4605              MOV      r5,r0
00008e  f5b07f7a          CMP      r0,#0x3e8
000092  d900              BLS      |L29.150|
;;;1873           {
;;;1874             break;
000094  e009              B        |L29.170|
                  |L29.150|
;;;1875           }
;;;1876         } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
000096  f50260a0          ADD      r0,r2,#0x500
00009a  eb001041          ADD      r0,r0,r1,LSL #5
00009e  6800              LDR      r0,[r0,#0]
0000a0  f0004000          AND      r0,r0,#0x80000000
0000a4  f1b04f00          CMP      r0,#0x80000000
0000a8  d0ef              BEQ      |L29.138|
                  |L29.170|
0000aa  e062              B        |L29.370|
                  |L29.172|
0000ac  e7ff              B        |L29.174|
                  |L29.174|
;;;1877       }
;;;1878       else
;;;1879       {
;;;1880         USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
0000ae  f50260a0          ADD      r0,r2,#0x500
0000b2  eb001041          ADD      r0,r0,r1,LSL #5
0000b6  6800              LDR      r0,[r0,#0]
0000b8  f0404700          ORR      r7,r0,#0x80000000
0000bc  f50260a0          ADD      r0,r2,#0x500
0000c0  eb001041          ADD      r0,r0,r1,LSL #5
0000c4  6007              STR      r7,[r0,#0]
0000c6  e054              B        |L29.370|
                  |L29.200|
;;;1881       }
;;;1882     }
;;;1883     else
;;;1884     {
;;;1885       USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
0000c8  f50260a0          ADD      r0,r2,#0x500
0000cc  eb001041          ADD      r0,r0,r1,LSL #5
0000d0  6800              LDR      r0,[r0,#0]
0000d2  f0404780          ORR      r7,r0,#0x40000000
0000d6  f50260a0          ADD      r0,r2,#0x500
0000da  eb001041          ADD      r0,r0,r1,LSL #5
0000de  6007              STR      r7,[r0,#0]
;;;1886   
;;;1887       if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
0000e0  f44f6082          MOV      r0,#0x410
0000e4  5880              LDR      r0,[r0,r2]
0000e6  f400007f          AND      r0,r0,#0xff0000
0000ea  bba8              CBNZ     r0,|L29.344|
;;;1888       {
;;;1889         USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
0000ec  f50260a0          ADD      r0,r2,#0x500
0000f0  eb001041          ADD      r0,r0,r1,LSL #5
0000f4  6800              LDR      r0,[r0,#0]
0000f6  f0204700          BIC      r7,r0,#0x80000000
0000fa  f50260a0          ADD      r0,r2,#0x500
0000fe  eb001041          ADD      r0,r0,r1,LSL #5
000102  6007              STR      r7,[r0,#0]
;;;1890         USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
000104  f50260a0          ADD      r0,r2,#0x500
000108  eb001041          ADD      r0,r0,r1,LSL #5
00010c  6800              LDR      r0,[r0,#0]
00010e  f0404700          ORR      r7,r0,#0x80000000
000112  f50260a0          ADD      r0,r2,#0x500
000116  eb001041          ADD      r0,r0,r1,LSL #5
00011a  6007              STR      r7,[r0,#0]
;;;1891         USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
00011c  f50260a0          ADD      r0,r2,#0x500
000120  eb001041          ADD      r0,r0,r1,LSL #5
000124  6800              LDR      r0,[r0,#0]
000126  f4204700          BIC      r7,r0,#0x8000
00012a  f50260a0          ADD      r0,r2,#0x500
00012e  eb001041          ADD      r0,r0,r1,LSL #5
000132  6007              STR      r7,[r0,#0]
;;;1892         do
000134  bf00              NOP      
                  |L29.310|
;;;1893         {
;;;1894           if (++count > 1000U)
000136  1c68              ADDS     r0,r5,#1
000138  4605              MOV      r5,r0
00013a  f5b07f7a          CMP      r0,#0x3e8
00013e  d900              BLS      |L29.322|
;;;1895           {
;;;1896             break;
000140  e009              B        |L29.342|
                  |L29.322|
;;;1897           }
;;;1898         } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
000142  f50260a0          ADD      r0,r2,#0x500
000146  eb001041          ADD      r0,r0,r1,LSL #5
00014a  6800              LDR      r0,[r0,#0]
00014c  f0004000          AND      r0,r0,#0x80000000
000150  f1b04f00          CMP      r0,#0x80000000
000154  d0ef              BEQ      |L29.310|
                  |L29.342|
000156  e00c              B        |L29.370|
                  |L29.344|
000158  e7ff              B        |L29.346|
                  |L29.346|
;;;1899       }
;;;1900       else
;;;1901       {
;;;1902         USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
00015a  f50260a0          ADD      r0,r2,#0x500
00015e  eb001041          ADD      r0,r0,r1,LSL #5
000162  6800              LDR      r0,[r0,#0]
000164  f0404700          ORR      r7,r0,#0x80000000
000168  f50260a0          ADD      r0,r2,#0x500
00016c  eb001041          ADD      r0,r0,r1,LSL #5
000170  6007              STR      r7,[r0,#0]
                  |L29.370|
;;;1903       }
;;;1904     }
;;;1905   
;;;1906     return HAL_OK;
000172  2000              MOVS     r0,#0
;;;1907   }
000174  bdf0              POP      {r4-r7,pc}
;;;1908   
                          ENDP


                          AREA ||i.USB_HC_Init||, CODE, READONLY, ALIGN=1

                  USB_HC_Init PROC
;;;1591     */
;;;1592   HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1593                                 uint8_t epnum, uint8_t dev_address, uint8_t speed,
;;;1594                                 uint8_t ep_type, uint16_t mps)
;;;1595   {
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
000008  469c              MOV      r12,r3
00000a  e9dd690a          LDRD     r6,r9,[sp,#0x28]
00000e  f8dd8024          LDR      r8,[sp,#0x24]
;;;1596     HAL_StatusTypeDef ret = HAL_OK;
000012  2000              MOVS     r0,#0
;;;1597     uint32_t USBx_BASE = (uint32_t)USBx;
000014  4622              MOV      r2,r4
;;;1598     uint32_t HCcharEpDir, HCcharLowSpeed;
;;;1599   
;;;1600     /* Clear old interrupt conditions for this host channel. */
;;;1601     USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
000016  f04f3aff          MOV      r10,#0xffffffff
00001a  f5026ba0          ADD      r11,r2,#0x500
00001e  eb0b1b41          ADD      r11,r11,r1,LSL #5
000022  f8cba008          STR      r10,[r11,#8]
;;;1602   
;;;1603     /* Enable channel interrupts required for this transfer. */
;;;1604     switch (ep_type)
000026  b136              CBZ      r6,|L30.54|
000028  2e01              CMP      r6,#1
00002a  d053              BEQ      |L30.212|
00002c  2e02              CMP      r6,#2
00002e  d003              BEQ      |L30.56|
000030  2e03              CMP      r6,#3
000032  d16b              BNE      |L30.268|
000034  e032              B        |L30.156|
                  |L30.54|
;;;1605     {
;;;1606       case EP_TYPE_CTRL:
;;;1607       case EP_TYPE_BULK:
000036  bf00              NOP      
                  |L30.56|
;;;1608         USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
000038  f2404a9d          MOV      r10,#0x49d
00003c  f5026ba0          ADD      r11,r2,#0x500
000040  eb0b1b41          ADD      r11,r11,r1,LSL #5
000044  f8cba00c          STR      r10,[r11,#0xc]
;;;1609                                               USB_OTG_HCINTMSK_STALLM |
;;;1610                                               USB_OTG_HCINTMSK_TXERRM |
;;;1611                                               USB_OTG_HCINTMSK_DTERRM |
;;;1612                                               USB_OTG_HCINTMSK_AHBERR |
;;;1613                                               USB_OTG_HCINTMSK_NAKM;
;;;1614   
;;;1615         if ((epnum & 0x80U) == 0x80U)
000048  f0050a80          AND      r10,r5,#0x80
00004c  f1ba0f80          CMP      r10,#0x80
000050  d10e              BNE      |L30.112|
;;;1616         {
;;;1617           USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
000052  f5026aa0          ADD      r10,r2,#0x500
000056  eb0a1a41          ADD      r10,r10,r1,LSL #5
00005a  f8daa00c          LDR      r10,[r10,#0xc]
00005e  f44a7a80          ORR      r10,r10,#0x100
000062  f5026ba0          ADD      r11,r2,#0x500
000066  eb0b1b41          ADD      r11,r11,r1,LSL #5
00006a  f8cba00c          STR      r10,[r11,#0xc]
00006e  e014              B        |L30.154|
                  |L30.112|
;;;1618         }
;;;1619         else
;;;1620         {
;;;1621           if ((USBx->CID & (0x1U << 8)) != 0U)
000070  f8d4a03c          LDR      r10,[r4,#0x3c]
000074  f40a7a80          AND      r10,r10,#0x100
000078  f1ba0f00          CMP      r10,#0
00007c  d00d              BEQ      |L30.154|
;;;1622           {
;;;1623             USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
00007e  f5026aa0          ADD      r10,r2,#0x500
000082  eb0a1a41          ADD      r10,r10,r1,LSL #5
000086  f8daa00c          LDR      r10,[r10,#0xc]
00008a  f04a0a60          ORR      r10,r10,#0x60
00008e  f5026ba0          ADD      r11,r2,#0x500
000092  eb0b1b41          ADD      r11,r11,r1,LSL #5
000096  f8cba00c          STR      r10,[r11,#0xc]
                  |L30.154|
;;;1624           }
;;;1625         }
;;;1626         break;
00009a  e039              B        |L30.272|
                  |L30.156|
;;;1627   
;;;1628       case EP_TYPE_INTR:
;;;1629         USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
00009c  f2406a9d          MOV      r10,#0x69d
0000a0  f5026ba0          ADD      r11,r2,#0x500
0000a4  eb0b1b41          ADD      r11,r11,r1,LSL #5
0000a8  f8cba00c          STR      r10,[r11,#0xc]
;;;1630                                               USB_OTG_HCINTMSK_STALLM |
;;;1631                                               USB_OTG_HCINTMSK_TXERRM |
;;;1632                                               USB_OTG_HCINTMSK_DTERRM |
;;;1633                                               USB_OTG_HCINTMSK_NAKM   |
;;;1634                                               USB_OTG_HCINTMSK_AHBERR |
;;;1635                                               USB_OTG_HCINTMSK_FRMORM;
;;;1636   
;;;1637         if ((epnum & 0x80U) == 0x80U)
0000ac  f0050a80          AND      r10,r5,#0x80
0000b0  f1ba0f80          CMP      r10,#0x80
0000b4  d10d              BNE      |L30.210|
;;;1638         {
;;;1639           USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
0000b6  f5026aa0          ADD      r10,r2,#0x500
0000ba  eb0a1a41          ADD      r10,r10,r1,LSL #5
0000be  f8daa00c          LDR      r10,[r10,#0xc]
0000c2  f44a7a80          ORR      r10,r10,#0x100
0000c6  f5026ba0          ADD      r11,r2,#0x500
0000ca  eb0b1b41          ADD      r11,r11,r1,LSL #5
0000ce  f8cba00c          STR      r10,[r11,#0xc]
                  |L30.210|
;;;1640         }
;;;1641   
;;;1642         break;
0000d2  e01d              B        |L30.272|
                  |L30.212|
;;;1643   
;;;1644       case EP_TYPE_ISOC:
;;;1645         USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
0000d4  f2402a25          MOV      r10,#0x225
0000d8  f5026ba0          ADD      r11,r2,#0x500
0000dc  eb0b1b41          ADD      r11,r11,r1,LSL #5
0000e0  f8cba00c          STR      r10,[r11,#0xc]
;;;1646                                               USB_OTG_HCINTMSK_ACKM   |
;;;1647                                               USB_OTG_HCINTMSK_AHBERR |
;;;1648                                               USB_OTG_HCINTMSK_FRMORM;
;;;1649   
;;;1650         if ((epnum & 0x80U) == 0x80U)
0000e4  f0050a80          AND      r10,r5,#0x80
0000e8  f1ba0f80          CMP      r10,#0x80
0000ec  d10d              BNE      |L30.266|
;;;1651         {
;;;1652           USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
0000ee  f5026aa0          ADD      r10,r2,#0x500
0000f2  eb0a1a41          ADD      r10,r10,r1,LSL #5
0000f6  f8daa00c          LDR      r10,[r10,#0xc]
0000fa  f44a7ac0          ORR      r10,r10,#0x180
0000fe  f5026ba0          ADD      r11,r2,#0x500
000102  eb0b1b41          ADD      r11,r11,r1,LSL #5
000106  f8cba00c          STR      r10,[r11,#0xc]
                  |L30.266|
;;;1653         }
;;;1654         break;
00010a  e001              B        |L30.272|
                  |L30.268|
;;;1655   
;;;1656       default:
;;;1657         ret = HAL_ERROR;
00010c  2001              MOVS     r0,#1
;;;1658         break;
00010e  bf00              NOP      
                  |L30.272|
000110  bf00              NOP                            ;1626
;;;1659     }
;;;1660   
;;;1661     /* Enable the top level host channel interrupt. */
;;;1662     USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
000112  f8d2a418          LDR      r10,[r2,#0x418]
000116  f0010e0f          AND      lr,r1,#0xf
00011a  f04f0b01          MOV      r11,#1
00011e  fa0bfb0e          LSL      r11,r11,lr
000122  ea4a0a0b          ORR      r10,r10,r11
000126  f8c2a418          STR      r10,[r2,#0x418]
;;;1663   
;;;1664     /* Make sure host channel interrupts are enabled. */
;;;1665     USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
00012a  f8d4a018          LDR      r10,[r4,#0x18]
00012e  f04a7a00          ORR      r10,r10,#0x2000000
000132  f8c4a018          STR      r10,[r4,#0x18]
;;;1666   
;;;1667     /* Program the HCCHAR register */
;;;1668     if ((epnum & 0x80U) == 0x80U)
000136  f0050a80          AND      r10,r5,#0x80
00013a  f1ba0f80          CMP      r10,#0x80
00013e  d102              BNE      |L30.326|
;;;1669     {
;;;1670       HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
000140  f44f4300          MOV      r3,#0x8000
000144  e000              B        |L30.328|
                  |L30.326|
;;;1671     }
;;;1672     else
;;;1673     {
;;;1674       HCcharEpDir = 0U;
000146  2300              MOVS     r3,#0
                  |L30.328|
;;;1675     }
;;;1676   
;;;1677     if (speed == HPRT0_PRTSPD_LOW_SPEED)
000148  f1b80f02          CMP      r8,#2
00014c  d102              BNE      |L30.340|
;;;1678     {
;;;1679       HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
00014e  f44f3700          MOV      r7,#0x20000
000152  e000              B        |L30.342|
                  |L30.340|
;;;1680     }
;;;1681     else
;;;1682     {
;;;1683       HCcharLowSpeed = 0U;
000154  2700              MOVS     r7,#0
                  |L30.342|
;;;1684     }
;;;1685   
;;;1686     USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
000156  f04f5afe          MOV      r10,#0x1fc00000
00015a  ea0a5a8c          AND      r10,r10,r12,LSL #22
00015e  f44f4bf0          MOV      r11,#0x7800
000162  ea0b2bc5          AND      r11,r11,r5,LSL #11
000166  ea4a0a0b          ORR      r10,r10,r11
00016a  f44f2b40          MOV      r11,#0xc0000
00016e  ea0b4b86          AND      r11,r11,r6,LSL #18
000172  ea4a0a0b          ORR      r10,r10,r11
000176  f3c90b0a          UBFX     r11,r9,#0,#11
00017a  ea4a0a0b          ORR      r10,r10,r11
00017e  ea4a0a03          ORR      r10,r10,r3
000182  ea4a0a07          ORR      r10,r10,r7
000186  f5026ba0          ADD      r11,r2,#0x500
00018a  eb0b1b41          ADD      r11,r11,r1,LSL #5
00018e  f8cba000          STR      r10,[r11,#0]
;;;1687                                         ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
;;;1688                                         (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
;;;1689                                         ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
;;;1690   
;;;1691     if (ep_type == EP_TYPE_INTR)
000192  2e03              CMP      r6,#3
000194  d10d              BNE      |L30.434|
;;;1692     {
;;;1693       USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
000196  f5026aa0          ADD      r10,r2,#0x500
00019a  eb0a1a41          ADD      r10,r10,r1,LSL #5
00019e  f8daa000          LDR      r10,[r10,#0]
0001a2  f04a5a00          ORR      r10,r10,#0x20000000
0001a6  f5026ba0          ADD      r11,r2,#0x500
0001aa  eb0b1b41          ADD      r11,r11,r1,LSL #5
0001ae  f8cba000          STR      r10,[r11,#0]
                  |L30.434|
;;;1694     }
;;;1695   
;;;1696     return ret;
;;;1697   }
0001b2  e8bd8ff0          POP      {r4-r11,pc}
;;;1698   
                          ENDP


                          AREA ||i.USB_HC_ReadInterrupt||, CODE, READONLY, ALIGN=1

                  USB_HC_ReadInterrupt PROC
;;;1838     */
;;;1839   uint32_t USB_HC_ReadInterrupt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1840   {
;;;1841     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1842   
;;;1843     return ((USBx_HOST->HAINT) & 0xFFFFU);
000004  f2404014          MOV      r0,#0x414
000008  5880              LDR      r0,[r0,r2]
00000a  b280              UXTH     r0,r0
;;;1844   }
00000c  4770              BX       lr
;;;1845   
                          ENDP


                          AREA ||i.USB_HC_StartXfer||, CODE, READONLY, ALIGN=2

                  USB_HC_StartXfer PROC
;;;1708     */
;;;1709   HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;1710   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
;;;1711     uint32_t USBx_BASE = (uint32_t)USBx;
00000a  463e              MOV      r6,r7
;;;1712     uint32_t ch_num = (uint32_t)hc->ch_num;
00000c  7865              LDRB     r5,[r4,#1]
;;;1713     static __IO uint32_t tmpreg = 0U;
;;;1714     uint8_t  is_oddframe;
;;;1715     uint16_t len_words;
;;;1716     uint16_t num_packets;
;;;1717     uint16_t max_hc_pkt_count = 256U;
00000e  f44f7b80          MOV      r11,#0x100
;;;1718   
;;;1719     if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
000012  6bf8              LDR      r0,[r7,#0x3c]
000014  f4007080          AND      r0,r0,#0x100
000018  b1f8              CBZ      r0,|L32.90|
00001a  7920              LDRB     r0,[r4,#4]
00001c  b9e8              CBNZ     r0,|L32.90|
;;;1720     {
;;;1721       if ((dma == 0U) && (hc->do_ping == 1U))
00001e  f1b90f00          CMP      r9,#0
000022  d109              BNE      |L32.56|
000024  7960              LDRB     r0,[r4,#5]
000026  2801              CMP      r0,#1
000028  d106              BNE      |L32.56|
;;;1722       {
;;;1723         (void)USB_DoPing(USBx, hc->ch_num);
00002a  7861              LDRB     r1,[r4,#1]
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       USB_DoPing
;;;1724         return HAL_OK;
000032  2000              MOVS     r0,#0
                  |L32.52|
;;;1725       }
;;;1726       else if (dma == 1U)
;;;1727       {
;;;1728         USBx_HC(ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
;;;1729         hc->do_ping = 0U;
;;;1730       }
;;;1731       else
;;;1732       {
;;;1733         /* ... */
;;;1734       }
;;;1735     }
;;;1736   
;;;1737     /* Compute the expected number of packets associated to the transfer */
;;;1738     if (hc->xfer_len > 0U)
;;;1739     {
;;;1740       num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
;;;1741   
;;;1742       if (num_packets > max_hc_pkt_count)
;;;1743       {
;;;1744         num_packets = max_hc_pkt_count;
;;;1745         hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
;;;1746       }
;;;1747     }
;;;1748     else
;;;1749     {
;;;1750       num_packets = 1U;
;;;1751     }
;;;1752     if (hc->ep_is_in != 0U)
;;;1753     {
;;;1754       hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
;;;1755     }
;;;1756   
;;;1757     /* Initialize the HCTSIZn register */
;;;1758     USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
;;;1759                               (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
;;;1760                               (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
;;;1761   
;;;1762     if (dma != 0U)
;;;1763     {
;;;1764       /* xfer_buff MUST be 32-bits aligned */
;;;1765       USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
;;;1766     }
;;;1767   
;;;1768     is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
;;;1769     USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
;;;1770     USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
;;;1771   
;;;1772     /* Set host channel enable */
;;;1773     tmpreg = USBx_HC(ch_num)->HCCHAR;
;;;1774     tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
;;;1775   
;;;1776     /* make sure to set the correct ep direction */
;;;1777     if (hc->ep_is_in != 0U)
;;;1778     {
;;;1779       tmpreg |= USB_OTG_HCCHAR_EPDIR;
;;;1780     }
;;;1781     else
;;;1782     {
;;;1783       tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
;;;1784     }
;;;1785     tmpreg |= USB_OTG_HCCHAR_CHENA;
;;;1786     USBx_HC(ch_num)->HCCHAR = tmpreg;
;;;1787   
;;;1788     if (dma != 0U) /* dma mode */
;;;1789     {
;;;1790       return HAL_OK;
;;;1791     }
;;;1792   
;;;1793     if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
;;;1794     {
;;;1795       switch (hc->ep_type)
;;;1796       {
;;;1797         /* Non periodic transfer */
;;;1798         case EP_TYPE_CTRL:
;;;1799         case EP_TYPE_BULK:
;;;1800   
;;;1801           len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
;;;1802   
;;;1803           /* check if there is enough space in FIFO space */
;;;1804           if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
;;;1805           {
;;;1806             /* need to process data in nptxfempty interrupt */
;;;1807             USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
;;;1808           }
;;;1809           break;
;;;1810   
;;;1811         /* Periodic transfer */
;;;1812         case EP_TYPE_INTR:
;;;1813         case EP_TYPE_ISOC:
;;;1814           len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
;;;1815           /* check if there is enough space in FIFO space */
;;;1816           if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
;;;1817           {
;;;1818             /* need to process data in ptxfempty interrupt */
;;;1819             USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
;;;1820           }
;;;1821           break;
;;;1822   
;;;1823         default:
;;;1824           break;
;;;1825       }
;;;1826   
;;;1827       /* Write packet into the Tx FIFO. */
;;;1828       (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
;;;1829     }
;;;1830   
;;;1831     return HAL_OK;
;;;1832   }
000034  e8bd8ffc          POP      {r2-r11,pc}
                  |L32.56|
000038  f1b90f01          CMP      r9,#1                 ;1726
00003c  d10d              BNE      |L32.90|
00003e  f50660a0          ADD      r0,r6,#0x500          ;1728
000042  eb001045          ADD      r0,r0,r5,LSL #5       ;1728
000046  68c0              LDR      r0,[r0,#0xc]          ;1728
000048  f0200160          BIC      r1,r0,#0x60           ;1728
00004c  f50660a0          ADD      r0,r6,#0x500          ;1728
000050  eb001045          ADD      r0,r0,r5,LSL #5       ;1728
000054  60c1              STR      r1,[r0,#0xc]          ;1728
000056  2000              MOVS     r0,#0                 ;1729
000058  7160              STRB     r0,[r4,#5]            ;1729
                  |L32.90|
00005a  6920              LDR      r0,[r4,#0x10]         ;1738
00005c  b178              CBZ      r0,|L32.126|
00005e  8921              LDRH     r1,[r4,#8]            ;1740
000060  6920              LDR      r0,[r4,#0x10]         ;1740
000062  4408              ADD      r0,r0,r1              ;1740
000064  1e40              SUBS     r0,r0,#1              ;1740
000066  fbb0f0f1          UDIV     r0,r0,r1              ;1740
00006a  fa1ff880          UXTH     r8,r0                 ;1740
00006e  45d8              CMP      r8,r11                ;1742
000070  dd07              BLE      |L32.130|
000072  46d8              MOV      r8,r11                ;1744
000074  8920              LDRH     r0,[r4,#8]            ;1745
000076  fb00f008          MUL      r0,r0,r8              ;1745
00007a  6120              STR      r0,[r4,#0x10]         ;1745
00007c  e001              B        |L32.130|
                  |L32.126|
00007e  f04f0801          MOV      r8,#1                 ;1750
                  |L32.130|
000082  78e0              LDRB     r0,[r4,#3]            ;1752
000084  b118              CBZ      r0,|L32.142|
000086  8920              LDRH     r0,[r4,#8]            ;1754
000088  fb00f008          MUL      r0,r0,r8              ;1754
00008c  6120              STR      r0,[r4,#0x10]         ;1754
                  |L32.142|
00008e  6920              LDR      r0,[r4,#0x10]         ;1758
000090  f3c00012          UBFX     r0,r0,#0,#19          ;1758
000094  494e              LDR      r1,|L32.464|
000096  ea0141c8          AND      r1,r1,r8,LSL #19      ;1758
00009a  4308              ORRS     r0,r0,r1              ;1758
00009c  7aa1              LDRB     r1,[r4,#0xa]          ;1758
00009e  f04f42c0          MOV      r2,#0x60000000        ;1758
0000a2  ea027141          AND      r1,r2,r1,LSL #29      ;1758
0000a6  4308              ORRS     r0,r0,r1              ;1758
0000a8  f50661a0          ADD      r1,r6,#0x500          ;1758
0000ac  eb011145          ADD      r1,r1,r5,LSL #5       ;1758
0000b0  6108              STR      r0,[r1,#0x10]         ;1758
0000b2  f1b90f00          CMP      r9,#0                 ;1762
0000b6  d005              BEQ      |L32.196|
0000b8  f50660a0          ADD      r0,r6,#0x500          ;1765
0000bc  eb001045          ADD      r0,r0,r5,LSL #5       ;1765
0000c0  68e1              LDR      r1,[r4,#0xc]          ;1765
0000c2  6141              STR      r1,[r0,#0x14]         ;1765
                  |L32.196|
0000c4  f44f6081          MOV      r0,#0x408             ;1768
0000c8  5980              LDR      r0,[r0,r6]            ;1768
0000ca  f0000001          AND      r0,r0,#1              ;1768
0000ce  f0800001          EOR      r0,r0,#1              ;1768
0000d2  9001              STR      r0,[sp,#4]            ;1768
0000d4  f50660a0          ADD      r0,r6,#0x500          ;1769
0000d8  eb001045          ADD      r0,r0,r5,LSL #5       ;1769
0000dc  6800              LDR      r0,[r0,#0]            ;1769
0000de  f0205100          BIC      r1,r0,#0x20000000     ;1769
0000e2  f50660a0          ADD      r0,r6,#0x500          ;1769
0000e6  eb001045          ADD      r0,r0,r5,LSL #5       ;1769
0000ea  6001              STR      r1,[r0,#0]            ;1769
0000ec  f50660a0          ADD      r0,r6,#0x500          ;1770
0000f0  eb001045          ADD      r0,r0,r5,LSL #5       ;1770
0000f4  6801              LDR      r1,[r0,#0]            ;1770
0000f6  9801              LDR      r0,[sp,#4]            ;1770
0000f8  ea417140          ORR      r1,r1,r0,LSL #29      ;1770
0000fc  f50660a0          ADD      r0,r6,#0x500          ;1770
000100  eb001045          ADD      r0,r0,r5,LSL #5       ;1770
000104  6001              STR      r1,[r0,#0]            ;1770
000106  f50660a0          ADD      r0,r6,#0x500          ;1773
00010a  eb001045          ADD      r0,r0,r5,LSL #5       ;1773
00010e  6800              LDR      r0,[r0,#0]            ;1773
000110  4930              LDR      r1,|L32.468|
000112  6008              STR      r0,[r1,#0]            ;1773  ; tmpreg
000114  4608              MOV      r0,r1                 ;1774
000116  6800              LDR      r0,[r0,#0]            ;1774  ; tmpreg
000118  f0204080          BIC      r0,r0,#0x40000000     ;1774
00011c  6008              STR      r0,[r1,#0]            ;1774  ; tmpreg
00011e  78e0              LDRB     r0,[r4,#3]            ;1777
000120  b128              CBZ      r0,|L32.302|
000122  4608              MOV      r0,r1                 ;1779
000124  6800              LDR      r0,[r0,#0]            ;1779  ; tmpreg
000126  f4404000          ORR      r0,r0,#0x8000         ;1779
00012a  6008              STR      r0,[r1,#0]            ;1779  ; tmpreg
00012c  e005              B        |L32.314|
                  |L32.302|
00012e  4829              LDR      r0,|L32.468|
000130  6800              LDR      r0,[r0,#0]            ;1783  ; tmpreg
000132  f4204000          BIC      r0,r0,#0x8000         ;1783
000136  4927              LDR      r1,|L32.468|
000138  6008              STR      r0,[r1,#0]            ;1783  ; tmpreg
                  |L32.314|
00013a  4826              LDR      r0,|L32.468|
00013c  6800              LDR      r0,[r0,#0]            ;1785  ; tmpreg
00013e  f0404000          ORR      r0,r0,#0x80000000     ;1785
000142  4924              LDR      r1,|L32.468|
000144  6008              STR      r0,[r1,#0]            ;1785  ; tmpreg
000146  4608              MOV      r0,r1                 ;1786
000148  6801              LDR      r1,[r0,#0]            ;1786  ; tmpreg
00014a  f50660a0          ADD      r0,r6,#0x500          ;1786
00014e  eb001045          ADD      r0,r0,r5,LSL #5       ;1786
000152  6001              STR      r1,[r0,#0]            ;1786
000154  f1b90f00          CMP      r9,#0                 ;1788
000158  d001              BEQ      |L32.350|
00015a  2000              MOVS     r0,#0                 ;1790
00015c  e76a              B        |L32.52|
                  |L32.350|
00015e  78e0              LDRB     r0,[r4,#3]            ;1793
000160  bb98              CBNZ     r0,|L32.458|
000162  6920              LDR      r0,[r4,#0x10]         ;1793
000164  b388              CBZ      r0,|L32.458|
000166  79e0              LDRB     r0,[r4,#7]            ;1795
000168  b130              CBZ      r0,|L32.376|
00016a  2801              CMP      r0,#1                 ;1795
00016c  d013              BEQ      |L32.406|
00016e  2802              CMP      r0,#2                 ;1795
000170  d003              BEQ      |L32.378|
000172  2803              CMP      r0,#3                 ;1795
000174  d11e              BNE      |L32.436|
000176  e00d              B        |L32.404|
                  |L32.376|
000178  bf00              NOP                            ;1799
                  |L32.378|
00017a  6920              LDR      r0,[r4,#0x10]         ;1801
00017c  1cc0              ADDS     r0,r0,#3              ;1801
00017e  f3c00a8f          UBFX     r10,r0,#2,#16         ;1801
000182  6af8              LDR      r0,[r7,#0x2c]         ;1804
000184  b280              UXTH     r0,r0                 ;1804
000186  4550              CMP      r0,r10                ;1804
000188  d203              BCS      |L32.402|
00018a  69b8              LDR      r0,[r7,#0x18]         ;1807
00018c  f0400020          ORR      r0,r0,#0x20           ;1807
000190  61b8              STR      r0,[r7,#0x18]         ;1807
                  |L32.402|
000192  e010              B        |L32.438|
                  |L32.404|
000194  bf00              NOP                            ;1813
                  |L32.406|
000196  6920              LDR      r0,[r4,#0x10]         ;1814
000198  1cc0              ADDS     r0,r0,#3              ;1814
00019a  f3c00a8f          UBFX     r10,r0,#2,#16         ;1814
00019e  f44f6082          MOV      r0,#0x410             ;1816
0001a2  5980              LDR      r0,[r0,r6]            ;1816
0001a4  b280              UXTH     r0,r0                 ;1816
0001a6  4550              CMP      r0,r10                ;1816
0001a8  d203              BCS      |L32.434|
0001aa  69b8              LDR      r0,[r7,#0x18]         ;1819
0001ac  f0406080          ORR      r0,r0,#0x4000000      ;1819
0001b0  61b8              STR      r0,[r7,#0x18]         ;1819
                  |L32.434|
0001b2  e000              B        |L32.438|
                  |L32.436|
0001b4  bf00              NOP                            ;1824
                  |L32.438|
0001b6  bf00              NOP                            ;1809
0001b8  2000              MOVS     r0,#0                 ;1828
0001ba  9000              STR      r0,[sp,#0]            ;1828
0001bc  8a20              LDRH     r0,[r4,#0x10]         ;1828
0001be  b283              UXTH     r3,r0                 ;1828
0001c0  7862              LDRB     r2,[r4,#1]            ;1828
0001c2  4638              MOV      r0,r7                 ;1828
0001c4  68e1              LDR      r1,[r4,#0xc]          ;1828
0001c6  f7fffffe          BL       USB_WritePacket
                  |L32.458|
0001ca  2000              MOVS     r0,#0                 ;1831
0001cc  e732              B        |L32.52|
;;;1833   
                          ENDP

0001ce  0000              DCW      0x0000
                  |L32.464|
                          DCD      0x1ff80000
                  |L32.468|
                          DCD      tmpreg

                          AREA ||i.USB_HostInit||, CODE, READONLY, ALIGN=2

                  USB_HostInit PROC
;;;1354     */
;;;1355   HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  b40f              PUSH     {r0-r3}
;;;1356   {
000002  b570              PUSH     {r4-r6,lr}
000004  4604              MOV      r4,r0
;;;1357     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4625              MOV      r5,r4
;;;1358     uint32_t i;
;;;1359   
;;;1360     /* Restart the Phy Clock */
;;;1361     USBx_PCGCCTL = 0U;
000008  2000              MOVS     r0,#0
00000a  f8c50e00          STR      r0,[r5,#0xe00]
;;;1362   
;;;1363   #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;1364     /* Disable HW VBUS sensing */
;;;1365     USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  f4201000          BIC      r0,r0,#0x200000
000014  63a0              STR      r0,[r4,#0x38]
;;;1366   #else
;;;1367     /*
;;;1368     * Disable HW VBUS sensing. VBUS is internally considered to be always
;;;1369     * at VBUS-Valid level (5V).
;;;1370     */
;;;1371     USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
;;;1372     USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
;;;1373     USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
;;;1374   #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;1375   #if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;1376     /* Disable Battery chargin detector */
;;;1377     USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
000016  6ba0              LDR      r0,[r4,#0x38]
000018  f4203000          BIC      r0,r0,#0x20000
00001c  63a0              STR      r0,[r4,#0x38]
;;;1378   #endif /* defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;1379   
;;;1380     if ((USBx->CID & (0x1U << 8)) != 0U)
00001e  6be0              LDR      r0,[r4,#0x3c]
000020  f4007080          AND      r0,r0,#0x100
000024  b180              CBZ      r0,|L33.72|
;;;1381     {
;;;1382       if (cfg.speed == USBH_FSLS_SPEED)
000026  9807              LDR      r0,[sp,#0x1c]
000028  2801              CMP      r0,#1
00002a  d106              BNE      |L33.58|
;;;1383       {
;;;1384         /* Force Device Enumeration to FS/LS mode only */
;;;1385         USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
00002c  f8d50400          LDR      r0,[r5,#0x400]
000030  f0400004          ORR      r0,r0,#4
000034  f8c50400          STR      r0,[r5,#0x400]
000038  e00c              B        |L33.84|
                  |L33.58|
;;;1386       }
;;;1387       else
;;;1388       {
;;;1389         /* Set default Max speed support */
;;;1390         USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
00003a  f8d50400          LDR      r0,[r5,#0x400]
00003e  f0200004          BIC      r0,r0,#4
000042  f8c50400          STR      r0,[r5,#0x400]
000046  e005              B        |L33.84|
                  |L33.72|
;;;1391       }
;;;1392     }
;;;1393     else
;;;1394     {
;;;1395       /* Set default Max speed support */
;;;1396       USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
000048  f8d50400          LDR      r0,[r5,#0x400]
00004c  f0200004          BIC      r0,r0,#4
000050  f8c50400          STR      r0,[r5,#0x400]
                  |L33.84|
;;;1397     }
;;;1398   
;;;1399     /* Make sure the FIFOs are flushed. */
;;;1400     (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
000054  2110              MOVS     r1,#0x10
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       USB_FlushTxFifo
;;;1401     (void)USB_FlushRxFifo(USBx);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       USB_FlushRxFifo
;;;1402   
;;;1403     /* Clear all pending HC Interrupts */
;;;1404     for (i = 0U; i < cfg.Host_channels; i++)
000062  2600              MOVS     r6,#0
000064  e00d              B        |L33.130|
                  |L33.102|
;;;1405     {
;;;1406       USBx_HC(i)->HCINT = 0xFFFFFFFFU;
000066  f04f31ff          MOV      r1,#0xffffffff
00006a  f50560a0          ADD      r0,r5,#0x500
00006e  eb001046          ADD      r0,r0,r6,LSL #5
000072  6081              STR      r1,[r0,#8]
;;;1407       USBx_HC(i)->HCINTMSK = 0U;
000074  2100              MOVS     r1,#0
000076  f50560a0          ADD      r0,r5,#0x500
00007a  eb001046          ADD      r0,r0,r6,LSL #5
00007e  60c1              STR      r1,[r0,#0xc]
000080  1c76              ADDS     r6,r6,#1              ;1404
                  |L33.130|
000082  9806              LDR      r0,[sp,#0x18]         ;1404
000084  42b0              CMP      r0,r6                 ;1404
000086  d8ee              BHI      |L33.102|
;;;1408     }
;;;1409   
;;;1410     /* Enable VBUS driving */
;;;1411     (void)USB_DriveVbus(USBx, 1U);
000088  2101              MOVS     r1,#1
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       USB_DriveVbus
;;;1412   
;;;1413     HAL_Delay(200U);
000090  20c8              MOVS     r0,#0xc8
000092  f7fffffe          BL       HAL_Delay
;;;1414   
;;;1415     /* Disable all interrupts. */
;;;1416     USBx->GINTMSK = 0U;
000096  2000              MOVS     r0,#0
000098  61a0              STR      r0,[r4,#0x18]
;;;1417   
;;;1418     /* Clear any pending interrupts */
;;;1419     USBx->GINTSTS = 0xFFFFFFFFU;
00009a  1e40              SUBS     r0,r0,#1
00009c  6160              STR      r0,[r4,#0x14]
;;;1420   
;;;1421     if ((USBx->CID & (0x1U << 8)) != 0U)
00009e  6be0              LDR      r0,[r4,#0x3c]
0000a0  f4007080          AND      r0,r0,#0x100
0000a4  b140              CBZ      r0,|L33.184|
;;;1422     {
;;;1423       /* set Rx FIFO size */
;;;1424       USBx->GRXFSIZ  = 0x200U;
0000a6  f44f7000          MOV      r0,#0x200
0000aa  6260              STR      r0,[r4,#0x24]
;;;1425       USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
0000ac  480d              LDR      r0,|L33.228|
0000ae  62a0              STR      r0,[r4,#0x28]
;;;1426       USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
0000b0  480d              LDR      r0,|L33.232|
0000b2  f8c40100          STR      r0,[r4,#0x100]
0000b6  e006              B        |L33.198|
                  |L33.184|
;;;1427     }
;;;1428     else
;;;1429     {
;;;1430       /* set Rx FIFO size */
;;;1431       USBx->GRXFSIZ  = 0x80U;
0000b8  2080              MOVS     r0,#0x80
0000ba  6260              STR      r0,[r4,#0x24]
;;;1432       USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
0000bc  480b              LDR      r0,|L33.236|
0000be  62a0              STR      r0,[r4,#0x28]
;;;1433       USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
0000c0  480b              LDR      r0,|L33.240|
0000c2  f8c40100          STR      r0,[r4,#0x100]
                  |L33.198|
;;;1434     }
;;;1435   
;;;1436     /* Enable the common interrupts */
;;;1437     if (cfg.dma_enable == 0U)
0000c6  9808              LDR      r0,[sp,#0x20]
0000c8  b918              CBNZ     r0,|L33.210|
;;;1438     {
;;;1439       USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
0000ca  69a0              LDR      r0,[r4,#0x18]
0000cc  f0400010          ORR      r0,r0,#0x10
0000d0  61a0              STR      r0,[r4,#0x18]
                  |L33.210|
;;;1440     }
;;;1441   
;;;1442     /* Enable interrupts matching to the Host mode ONLY */
;;;1443     USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
0000d2  69a0              LDR      r0,[r4,#0x18]
0000d4  4907              LDR      r1,|L33.244|
0000d6  4308              ORRS     r0,r0,r1
0000d8  61a0              STR      r0,[r4,#0x18]
;;;1444                       USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
;;;1445                       USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
;;;1446   
;;;1447     return HAL_OK;
0000da  2000              MOVS     r0,#0
;;;1448   }
0000dc  bc70              POP      {r4-r6}
0000de  f85dfb14          LDR      pc,[sp],#0x14
;;;1449   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L33.228|
                          DCD      0x01000200
                  |L33.232|
                          DCD      0x00e00300
                  |L33.236|
                          DCD      0x00600080
                  |L33.240|
                          DCD      0x004000e0
                  |L33.244|
                          DCD      0xa3200008

                          AREA ||i.USB_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_InitFSLSPClkSel PROC
;;;1459     */
;;;1460   HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
000000  b510              PUSH     {r4,lr}
;;;1461   {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;1462     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4611              MOV      r1,r2
;;;1463   
;;;1464     USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
000008  f8d10400          LDR      r0,[r1,#0x400]
00000c  f0200003          BIC      r0,r0,#3
000010  f8c10400          STR      r0,[r1,#0x400]
;;;1465     USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
000014  f8d10400          LDR      r0,[r1,#0x400]
000018  f0030403          AND      r4,r3,#3
00001c  4320              ORRS     r0,r0,r4
00001e  f8c10400          STR      r0,[r1,#0x400]
;;;1466   
;;;1467     if (freq == HCFG_48_MHZ)
000022  2b01              CMP      r3,#1
000024  d105              BNE      |L34.50|
;;;1468     {
;;;1469       USBx_HOST->HFIR = 48000U;
000026  f64b3480          MOV      r4,#0xbb80
00002a  f2404004          MOV      r0,#0x404
00002e  5044              STR      r4,[r0,r1]
000030  e006              B        |L34.64|
                  |L34.50|
;;;1470     }
;;;1471     else if (freq == HCFG_6_MHZ)
000032  2b02              CMP      r3,#2
000034  d104              BNE      |L34.64|
;;;1472     {
;;;1473       USBx_HOST->HFIR = 6000U;
000036  f2417470          MOV      r4,#0x1770
00003a  f2404004          MOV      r0,#0x404
00003e  5044              STR      r4,[r0,r1]
                  |L34.64|
;;;1474     }
;;;1475     else
;;;1476     {
;;;1477       /* ... */
;;;1478     }
;;;1479   
;;;1480     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1481   }
000042  bd10              POP      {r4,pc}
;;;1482   
                          ENDP


                          AREA ||i.USB_ReadDevAllInEpInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevAllInEpInterrupt PROC
;;;1185     */
;;;1186   uint32_t USB_ReadDevAllInEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1187   {
;;;1188     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460b              MOV      r3,r1
;;;1189     uint32_t tmpreg;
;;;1190   
;;;1191     tmpreg  = USBx_DEVICE->DAINT;
000004  f6400018          MOV      r0,#0x818
000008  58c2              LDR      r2,[r0,r3]
;;;1192     tmpreg &= USBx_DEVICE->DAINTMSK;
00000a  1d00              ADDS     r0,r0,#4
00000c  58c0              LDR      r0,[r0,r3]
00000e  4002              ANDS     r2,r2,r0
;;;1193   
;;;1194     return ((tmpreg & 0xFFFFU));
000010  b290              UXTH     r0,r2
;;;1195   }
000012  4770              BX       lr
;;;1196   
                          ENDP


                          AREA ||i.USB_ReadDevAllOutEpInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevAllOutEpInterrupt PROC
;;;1169     */
;;;1170   uint32_t USB_ReadDevAllOutEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1171   {
;;;1172     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460b              MOV      r3,r1
;;;1173     uint32_t tmpreg;
;;;1174   
;;;1175     tmpreg  = USBx_DEVICE->DAINT;
000004  f6400018          MOV      r0,#0x818
000008  58c2              LDR      r2,[r0,r3]
;;;1176     tmpreg &= USBx_DEVICE->DAINTMSK;
00000a  1d00              ADDS     r0,r0,#4
00000c  58c0              LDR      r0,[r0,r3]
00000e  4002              ANDS     r2,r2,r0
;;;1177   
;;;1178     return ((tmpreg & 0xffff0000U) >> 16);
000010  0c10              LSRS     r0,r2,#16
;;;1179   }
000012  4770              BX       lr
;;;1180   
                          ENDP


                          AREA ||i.USB_ReadDevInEPInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevInEPInterrupt PROC
;;;1221     */
;;;1222   uint32_t USB_ReadDevInEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
000000  b570              PUSH     {r4-r6,lr}
;;;1223   {
000002  4602              MOV      r2,r0
;;;1224     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4613              MOV      r3,r2
;;;1225     uint32_t tmpreg, msk, emp;
;;;1226   
;;;1227     msk = USBx_DEVICE->DIEPMSK;
000006  f44f6601          MOV      r6,#0x810
00000a  58f4              LDR      r4,[r6,r3]
;;;1228     emp = USBx_DEVICE->DIEPEMPMSK;
00000c  f6400634          MOV      r6,#0x834
000010  58f5              LDR      r5,[r6,r3]
;;;1229     msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
000012  f001060f          AND      r6,r1,#0xf
000016  fa25f606          LSR      r6,r5,r6
00001a  f0060601          AND      r6,r6,#1
00001e  ea4414c6          ORR      r4,r4,r6,LSL #7
;;;1230     tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
000022  f5036610          ADD      r6,r3,#0x900
000026  eb061641          ADD      r6,r6,r1,LSL #5
00002a  68b6              LDR      r6,[r6,#8]
00002c  ea060004          AND      r0,r6,r4
;;;1231   
;;;1232     return tmpreg;
;;;1233   }
000030  bd70              POP      {r4-r6,pc}
;;;1234   
                          ENDP


                          AREA ||i.USB_ReadDevOutEPInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevOutEPInterrupt PROC
;;;1203     */
;;;1204   uint32_t USB_ReadDevOutEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
000000  b510              PUSH     {r4,lr}
;;;1205   {
000002  4602              MOV      r2,r0
;;;1206     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4613              MOV      r3,r2
;;;1207     uint32_t tmpreg;
;;;1208   
;;;1209     tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
000006  f5036430          ADD      r4,r3,#0xb00
00000a  eb041441          ADD      r4,r4,r1,LSL #5
00000e  68a0              LDR      r0,[r4,#8]
;;;1210     tmpreg &= USBx_DEVICE->DOEPMSK;
000010  f6400414          MOV      r4,#0x814
000014  58e4              LDR      r4,[r4,r3]
000016  4020              ANDS     r0,r0,r4
;;;1211   
;;;1212     return tmpreg;
;;;1213   }
000018  bd10              POP      {r4,pc}
;;;1214   
                          ENDP


                          AREA ||i.USB_ReadInterrupts||, CODE, READONLY, ALIGN=1

                  USB_ReadInterrupts PROC
;;;1154     */
;;;1155   uint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1156   {
;;;1157     uint32_t tmpreg;
;;;1158   
;;;1159     tmpreg = USBx->GINTSTS;
000002  6948              LDR      r0,[r1,#0x14]
;;;1160     tmpreg &= USBx->GINTMSK;
000004  698a              LDR      r2,[r1,#0x18]
000006  4010              ANDS     r0,r0,r2
;;;1161   
;;;1162     return tmpreg;
;;;1163   }
000008  4770              BX       lr
;;;1164   
                          ENDP


                          AREA ||i.USB_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_ReadPacket PROC
;;;982      */
;;;983    void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;984    {
000002  4603              MOV      r3,r0
;;;985      uint32_t USBx_BASE = (uint32_t)USBx;
000004  461e              MOV      r6,r3
;;;986      uint32_t *pDest = (uint32_t *)dest;
000006  4608              MOV      r0,r1
;;;987      uint32_t i;
;;;988      uint32_t count32b = ((uint32_t)len + 3U) / 4U;
000008  1cd7              ADDS     r7,r2,#3
00000a  08bd              LSRS     r5,r7,#2
;;;989    
;;;990      for (i = 0U; i < count32b; i++)
00000c  2400              MOVS     r4,#0
00000e  e005              B        |L40.28|
                  |L40.16|
;;;991      {
;;;992        __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
000010  f44f5780          MOV      r7,#0x1000
000014  59bf              LDR      r7,[r7,r6]
000016  6007              STR      r7,[r0,#0]
;;;993        pDest++;
000018  1d00              ADDS     r0,r0,#4
00001a  1c64              ADDS     r4,r4,#1              ;990
                  |L40.28|
00001c  42ac              CMP      r4,r5                 ;990
00001e  d3f7              BCC      |L40.16|
;;;994      }
;;;995    
;;;996      return ((void *)pDest);
;;;997    }
000020  bdf0              POP      {r4-r7,pc}
;;;998    
                          ENDP


                          AREA ||i.USB_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_ResetPort PROC
;;;1489     */
;;;1490   HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
000000  b538              PUSH     {r3-r5,lr}
;;;1491   {
000002  4604              MOV      r4,r0
;;;1492     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4625              MOV      r5,r4
;;;1493   
;;;1494     __IO uint32_t hprt0 = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1495   
;;;1496     hprt0 = USBx_HPRT0;
00000a  f8d50440          LDR      r0,[r5,#0x440]
00000e  9000              STR      r0,[sp,#0]
;;;1497   
;;;1498     hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
000010  9800              LDR      r0,[sp,#0]
000012  f020002e          BIC      r0,r0,#0x2e
000016  9000              STR      r0,[sp,#0]
;;;1499                USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);
;;;1500   
;;;1501     USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
000018  9800              LDR      r0,[sp,#0]
00001a  f4407080          ORR      r0,r0,#0x100
00001e  f8c50440          STR      r0,[r5,#0x440]
;;;1502     HAL_Delay(100U);                                 /* See Note #1 */
000022  2064              MOVS     r0,#0x64
000024  f7fffffe          BL       HAL_Delay
;;;1503     USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
000028  9800              LDR      r0,[sp,#0]
00002a  f4207080          BIC      r0,r0,#0x100
00002e  f8c50440          STR      r0,[r5,#0x440]
;;;1504     HAL_Delay(10U);
000032  200a              MOVS     r0,#0xa
000034  f7fffffe          BL       HAL_Delay
;;;1505   
;;;1506     return HAL_OK;
000038  2000              MOVS     r0,#0
;;;1507   }
00003a  bd38              POP      {r3-r5,pc}
;;;1508   
                          ENDP


                          AREA ||i.USB_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_SetCurrentMode PROC
;;;247      */
;;;248    HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
000000  b570              PUSH     {r4-r6,lr}
;;;249    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;250      USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
000006  68e0              LDR      r0,[r4,#0xc]
000008  f02040c0          BIC      r0,r0,#0x60000000
00000c  60e0              STR      r0,[r4,#0xc]
;;;251    
;;;252      if (mode == USB_HOST_MODE)
00000e  2d01              CMP      r5,#1
000010  d104              BNE      |L42.28|
;;;253      {
;;;254        USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
000012  68e0              LDR      r0,[r4,#0xc]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  60e0              STR      r0,[r4,#0xc]
00001a  e007              B        |L42.44|
                  |L42.28|
;;;255      }
;;;256      else if (mode == USB_DEVICE_MODE)
00001c  b925              CBNZ     r5,|L42.40|
;;;257      {
;;;258        USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
00001e  68e0              LDR      r0,[r4,#0xc]
000020  f0404080          ORR      r0,r0,#0x40000000
000024  60e0              STR      r0,[r4,#0xc]
000026  e001              B        |L42.44|
                  |L42.40|
;;;259      }
;;;260      else
;;;261      {
;;;262        return HAL_ERROR;
000028  2001              MOVS     r0,#1
                  |L42.42|
;;;263      }
;;;264      HAL_Delay(50U);
;;;265    
;;;266      return HAL_OK;
;;;267    }
00002a  bd70              POP      {r4-r6,pc}
                  |L42.44|
00002c  2032              MOVS     r0,#0x32              ;264
00002e  f7fffffe          BL       HAL_Delay
000032  2000              MOVS     r0,#0                 ;266
000034  e7f9              B        |L42.42|
;;;268    
                          ENDP


                          AREA ||i.USB_SetDevAddress||, CODE, READONLY, ALIGN=1

                  USB_SetDevAddress PROC
;;;1105     */
;;;1106   HAL_StatusTypeDef  USB_SetDevAddress(USB_OTG_GlobalTypeDef *USBx, uint8_t address)
000000  b510              PUSH     {r4,lr}
;;;1107   {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;1108     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4611              MOV      r1,r2
;;;1109   
;;;1110     USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
000008  f8d10800          LDR      r0,[r1,#0x800]
00000c  f42060fe          BIC      r0,r0,#0x7f0
000010  f8c10800          STR      r0,[r1,#0x800]
;;;1111     USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
000014  f8d10800          LDR      r0,[r1,#0x800]
000018  f44f64fe          MOV      r4,#0x7f0
00001c  ea041403          AND      r4,r4,r3,LSL #4
000020  4320              ORRS     r0,r0,r4
000022  f8c10800          STR      r0,[r1,#0x800]
;;;1112   
;;;1113     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;1114   }
000028  bd10              POP      {r4,pc}
;;;1115   
                          ENDP


                          AREA ||i.USB_SetDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_SetDevSpeed PROC
;;;502      */
;;;503    HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
000000  4602              MOV      r2,r0
;;;504    {
;;;505      uint32_t USBx_BASE = (uint32_t)USBx;
000002  4613              MOV      r3,r2
;;;506    
;;;507      USBx_DEVICE->DCFG |= speed;
000004  f8d30800          LDR      r0,[r3,#0x800]
000008  4308              ORRS     r0,r0,r1
00000a  f8c30800          STR      r0,[r3,#0x800]
;;;508      return HAL_OK;
00000e  2000              MOVS     r0,#0
;;;509    }
000010  4770              BX       lr
;;;510    
                          ENDP


                          AREA ||i.USB_SetTurnaroundTime||, CODE, READONLY, ALIGN=2

                  USB_SetTurnaroundTime PROC
;;;137      */
;;;138    HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
000000  b530              PUSH     {r4,r5,lr}
;;;139                                            uint32_t hclk, uint8_t speed)
;;;140    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;141      uint32_t UsbTrd;
;;;142    
;;;143      /* The USBTRD is configured according to the tables below, depending on AHB frequency
;;;144      used by application. In the low AHB frequency range it is used to stretch enough the USB response
;;;145      time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
;;;146      latency to the Data FIFO */
;;;147      if (speed == USBD_FS_SPEED)
000006  2c02              CMP      r4,#2
000008  d149              BNE      |L45.158|
;;;148      {
;;;149        if ((hclk >= 14200000U) && (hclk < 15000000U))
00000a  482d              LDR      r0,|L45.192|
00000c  4281              CMP      r1,r0
00000e  d304              BCC      |L45.26|
000010  482c              LDR      r0,|L45.196|
000012  4281              CMP      r1,r0
000014  d201              BCS      |L45.26|
;;;150        {
;;;151          /* hclk Clock Range between 14.2-15 MHz */
;;;152          UsbTrd = 0xFU;
000016  220f              MOVS     r2,#0xf
000018  e045              B        |L45.166|
                  |L45.26|
;;;153        }
;;;154        else if ((hclk >= 15000000U) && (hclk < 16000000U))
00001a  482a              LDR      r0,|L45.196|
00001c  4281              CMP      r1,r0
00001e  d304              BCC      |L45.42|
000020  4829              LDR      r0,|L45.200|
000022  4281              CMP      r1,r0
000024  d201              BCS      |L45.42|
;;;155        {
;;;156          /* hclk Clock Range between 15-16 MHz */
;;;157          UsbTrd = 0xEU;
000026  220e              MOVS     r2,#0xe
000028  e03d              B        |L45.166|
                  |L45.42|
;;;158        }
;;;159        else if ((hclk >= 16000000U) && (hclk < 17200000U))
00002a  4827              LDR      r0,|L45.200|
00002c  4281              CMP      r1,r0
00002e  d304              BCC      |L45.58|
000030  4826              LDR      r0,|L45.204|
000032  4281              CMP      r1,r0
000034  d201              BCS      |L45.58|
;;;160        {
;;;161          /* hclk Clock Range between 16-17.2 MHz */
;;;162          UsbTrd = 0xDU;
000036  220d              MOVS     r2,#0xd
000038  e035              B        |L45.166|
                  |L45.58|
;;;163        }
;;;164        else if ((hclk >= 17200000U) && (hclk < 18500000U))
00003a  4824              LDR      r0,|L45.204|
00003c  4281              CMP      r1,r0
00003e  d304              BCC      |L45.74|
000040  4823              LDR      r0,|L45.208|
000042  4281              CMP      r1,r0
000044  d201              BCS      |L45.74|
;;;165        {
;;;166          /* hclk Clock Range between 17.2-18.5 MHz */
;;;167          UsbTrd = 0xCU;
000046  220c              MOVS     r2,#0xc
000048  e02d              B        |L45.166|
                  |L45.74|
;;;168        }
;;;169        else if ((hclk >= 18500000U) && (hclk < 20000000U))
00004a  4821              LDR      r0,|L45.208|
00004c  4281              CMP      r1,r0
00004e  d304              BCC      |L45.90|
000050  4820              LDR      r0,|L45.212|
000052  4281              CMP      r1,r0
000054  d201              BCS      |L45.90|
;;;170        {
;;;171          /* hclk Clock Range between 18.5-20 MHz */
;;;172          UsbTrd = 0xBU;
000056  220b              MOVS     r2,#0xb
000058  e025              B        |L45.166|
                  |L45.90|
;;;173        }
;;;174        else if ((hclk >= 20000000U) && (hclk < 21800000U))
00005a  481e              LDR      r0,|L45.212|
00005c  4281              CMP      r1,r0
00005e  d304              BCC      |L45.106|
000060  481d              LDR      r0,|L45.216|
000062  4281              CMP      r1,r0
000064  d201              BCS      |L45.106|
;;;175        {
;;;176          /* hclk Clock Range between 20-21.8 MHz */
;;;177          UsbTrd = 0xAU;
000066  220a              MOVS     r2,#0xa
000068  e01d              B        |L45.166|
                  |L45.106|
;;;178        }
;;;179        else if ((hclk >= 21800000U) && (hclk < 24000000U))
00006a  481b              LDR      r0,|L45.216|
00006c  4281              CMP      r1,r0
00006e  d304              BCC      |L45.122|
000070  481a              LDR      r0,|L45.220|
000072  4281              CMP      r1,r0
000074  d201              BCS      |L45.122|
;;;180        {
;;;181          /* hclk Clock Range between 21.8-24 MHz */
;;;182          UsbTrd = 0x9U;
000076  2209              MOVS     r2,#9
000078  e015              B        |L45.166|
                  |L45.122|
;;;183        }
;;;184        else if ((hclk >= 24000000U) && (hclk < 27700000U))
00007a  4818              LDR      r0,|L45.220|
00007c  4281              CMP      r1,r0
00007e  d304              BCC      |L45.138|
000080  4817              LDR      r0,|L45.224|
000082  4281              CMP      r1,r0
000084  d201              BCS      |L45.138|
;;;185        {
;;;186          /* hclk Clock Range between 24-27.7 MHz */
;;;187          UsbTrd = 0x8U;
000086  2208              MOVS     r2,#8
000088  e00d              B        |L45.166|
                  |L45.138|
;;;188        }
;;;189        else if ((hclk >= 27700000U) && (hclk < 32000000U))
00008a  4815              LDR      r0,|L45.224|
00008c  4281              CMP      r1,r0
00008e  d304              BCC      |L45.154|
000090  4814              LDR      r0,|L45.228|
000092  4281              CMP      r1,r0
000094  d201              BCS      |L45.154|
;;;190        {
;;;191          /* hclk Clock Range between 27.7-32 MHz */
;;;192          UsbTrd = 0x7U;
000096  2207              MOVS     r2,#7
000098  e005              B        |L45.166|
                  |L45.154|
;;;193        }
;;;194        else /* if(hclk >= 32000000) */
;;;195        {
;;;196          /* hclk Clock Range between 32-200 MHz */
;;;197          UsbTrd = 0x6U;
00009a  2206              MOVS     r2,#6
00009c  e003              B        |L45.166|
                  |L45.158|
;;;198        }
;;;199      }
;;;200      else if (speed == USBD_HS_SPEED)
00009e  b90c              CBNZ     r4,|L45.164|
;;;201      {
;;;202        UsbTrd = USBD_HS_TRDT_VALUE;
0000a0  2209              MOVS     r2,#9
0000a2  e000              B        |L45.166|
                  |L45.164|
;;;203      }
;;;204      else
;;;205      {
;;;206        UsbTrd = USBD_DEFAULT_TRDT_VALUE;
0000a4  2209              MOVS     r2,#9
                  |L45.166|
;;;207      }
;;;208    
;;;209      USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
0000a6  68d8              LDR      r0,[r3,#0xc]
0000a8  f4205070          BIC      r0,r0,#0x3c00
0000ac  60d8              STR      r0,[r3,#0xc]
;;;210      USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
0000ae  68d8              LDR      r0,[r3,#0xc]
0000b0  f44f5570          MOV      r5,#0x3c00
0000b4  ea052582          AND      r5,r5,r2,LSL #10
0000b8  4328              ORRS     r0,r0,r5
0000ba  60d8              STR      r0,[r3,#0xc]
;;;211    
;;;212      return HAL_OK;
0000bc  2000              MOVS     r0,#0
;;;213    }
0000be  bd30              POP      {r4,r5,pc}
;;;214    
                          ENDP

                  |L45.192|
                          DCD      0x00d8acc0
                  |L45.196|
                          DCD      0x00e4e1c0
                  |L45.200|
                          DCD      0x00f42400
                  |L45.204|
                          DCD      0x01067380
                  |L45.208|
                          DCD      0x011a49a0
                  |L45.212|
                          DCD      0x01312d00
                  |L45.216|
                          DCD      0x014ca440
                  |L45.220|
                          DCD      0x016e3600
                  |L45.224|
                          DCD      0x01a6ab20
                  |L45.228|
                          DCD      0x01e84800

                          AREA ||i.USB_StopDevice||, CODE, READONLY, ALIGN=1

                  USB_StopDevice PROC
;;;1064     */
;;;1065   HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1066   {
000002  4607              MOV      r7,r0
;;;1067     HAL_StatusTypeDef ret;
;;;1068     uint32_t USBx_BASE = (uint32_t)USBx;
000004  463d              MOV      r5,r7
;;;1069     uint32_t i;
;;;1070   
;;;1071     /* Clear Pending interrupt */
;;;1072     for (i = 0U; i < 15U; i++)
000006  2400              MOVS     r4,#0
000008  e00c              B        |L46.36|
                  |L46.10|
;;;1073     {
;;;1074       USBx_INEP(i)->DIEPINT = 0xFB7FU;
00000a  f64f317f          MOV      r1,#0xfb7f
00000e  f5056010          ADD      r0,r5,#0x900
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  6081              STR      r1,[r0,#8]
;;;1075       USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
000018  f5056030          ADD      r0,r5,#0xb00
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  6081              STR      r1,[r0,#8]
000022  1c64              ADDS     r4,r4,#1              ;1072
                  |L46.36|
000024  2c0f              CMP      r4,#0xf               ;1072
000026  d3f0              BCC      |L46.10|
;;;1076     }
;;;1077   
;;;1078     /* Clear interrupt masks */
;;;1079     USBx_DEVICE->DIEPMSK  = 0U;
000028  2100              MOVS     r1,#0
00002a  f44f6001          MOV      r0,#0x810
00002e  5141              STR      r1,[r0,r5]
;;;1080     USBx_DEVICE->DOEPMSK  = 0U;
000030  1d00              ADDS     r0,r0,#4
000032  5141              STR      r1,[r0,r5]
;;;1081     USBx_DEVICE->DAINTMSK = 0U;
000034  f640001c          MOV      r0,#0x81c
000038  5141              STR      r1,[r0,r5]
;;;1082   
;;;1083     /* Flush the FIFO */
;;;1084     ret = USB_FlushRxFifo(USBx);
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       USB_FlushRxFifo
000040  4606              MOV      r6,r0
;;;1085     if (ret != HAL_OK)
000042  b10e              CBZ      r6,|L46.72|
;;;1086     {
;;;1087       return ret;
000044  4630              MOV      r0,r6
                  |L46.70|
;;;1088     }
;;;1089   
;;;1090     ret = USB_FlushTxFifo(USBx,  0x10U);
;;;1091     if (ret != HAL_OK)
;;;1092     {
;;;1093       return ret;
;;;1094     }
;;;1095   
;;;1096     return ret;
;;;1097   }
000046  bdf0              POP      {r4-r7,pc}
                  |L46.72|
000048  2110              MOVS     r1,#0x10              ;1090
00004a  4638              MOV      r0,r7                 ;1090
00004c  f7fffffe          BL       USB_FlushTxFifo
000050  4606              MOV      r6,r0                 ;1090
000052  b10e              CBZ      r6,|L46.88|
000054  4630              MOV      r0,r6                 ;1093
000056  e7f6              B        |L46.70|
                  |L46.88|
000058  4630              MOV      r0,r6                 ;1096
00005a  e7f4              B        |L46.70|
;;;1098   
                          ENDP


                          AREA ||i.USB_StopHost||, CODE, READONLY, ALIGN=1

                  USB_StopHost PROC
;;;1939     */
;;;1940   HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1941   {
000004  4607              MOV      r7,r0
;;;1942     uint32_t USBx_BASE = (uint32_t)USBx;
000006  463e              MOV      r6,r7
;;;1943     uint32_t count = 0U;
000008  f04f0800          MOV      r8,#0
;;;1944     uint32_t value;
;;;1945     uint32_t i;
;;;1946   
;;;1947     (void)USB_DisableGlobalInt(USBx);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       USB_DisableGlobalInt
;;;1948   
;;;1949     /* Flush FIFO */
;;;1950     (void)USB_FlushTxFifo(USBx, 0x10U);
000012  2110              MOVS     r1,#0x10
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       USB_FlushTxFifo
;;;1951     (void)USB_FlushRxFifo(USBx);
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       USB_FlushRxFifo
;;;1952   
;;;1953     /* Flush out any leftover queued requests. */
;;;1954     for (i = 0U; i <= 15U; i++)
000020  2400              MOVS     r4,#0
000022  e010              B        |L47.70|
                  |L47.36|
;;;1955     {
;;;1956       value = USBx_HC(i)->HCCHAR;
000024  f50660a0          ADD      r0,r6,#0x500
000028  eb001044          ADD      r0,r0,r4,LSL #5
00002c  6805              LDR      r5,[r0,#0]
;;;1957       value |=  USB_OTG_HCCHAR_CHDIS;
00002e  f0454580          ORR      r5,r5,#0x40000000
;;;1958       value &= ~USB_OTG_HCCHAR_CHENA;
000032  f0254500          BIC      r5,r5,#0x80000000
;;;1959       value &= ~USB_OTG_HCCHAR_EPDIR;
000036  f4254500          BIC      r5,r5,#0x8000
;;;1960       USBx_HC(i)->HCCHAR = value;
00003a  f50660a0          ADD      r0,r6,#0x500
00003e  eb001044          ADD      r0,r0,r4,LSL #5
000042  6005              STR      r5,[r0,#0]
000044  1c64              ADDS     r4,r4,#1              ;1954
                  |L47.70|
000046  2c0f              CMP      r4,#0xf               ;1954
000048  d9ec              BLS      |L47.36|
;;;1961     }
;;;1962   
;;;1963     /* Halt all channels to put them into a known state. */
;;;1964     for (i = 0U; i <= 15U; i++)
00004a  2400              MOVS     r4,#0
00004c  e023              B        |L47.150|
                  |L47.78|
;;;1965     {
;;;1966       value = USBx_HC(i)->HCCHAR;
00004e  f50660a0          ADD      r0,r6,#0x500
000052  eb001044          ADD      r0,r0,r4,LSL #5
000056  6805              LDR      r5,[r0,#0]
;;;1967       value |= USB_OTG_HCCHAR_CHDIS;
000058  f0454580          ORR      r5,r5,#0x40000000
;;;1968       value |= USB_OTG_HCCHAR_CHENA;
00005c  f0454500          ORR      r5,r5,#0x80000000
;;;1969       value &= ~USB_OTG_HCCHAR_EPDIR;
000060  f4254500          BIC      r5,r5,#0x8000
;;;1970       USBx_HC(i)->HCCHAR = value;
000064  f50660a0          ADD      r0,r6,#0x500
000068  eb001044          ADD      r0,r0,r4,LSL #5
00006c  6005              STR      r5,[r0,#0]
;;;1971   
;;;1972       do
00006e  bf00              NOP      
                  |L47.112|
;;;1973       {
;;;1974         if (++count > 1000U)
000070  f1080001          ADD      r0,r8,#1
000074  4680              MOV      r8,r0
000076  f5b07f7a          CMP      r0,#0x3e8
00007a  d900              BLS      |L47.126|
;;;1975         {
;;;1976           break;
00007c  e009              B        |L47.146|
                  |L47.126|
;;;1977         }
;;;1978       } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
00007e  f50660a0          ADD      r0,r6,#0x500
000082  eb001044          ADD      r0,r0,r4,LSL #5
000086  6800              LDR      r0,[r0,#0]
000088  f0004000          AND      r0,r0,#0x80000000
00008c  f1b04f00          CMP      r0,#0x80000000
000090  d0ee              BEQ      |L47.112|
                  |L47.146|
000092  bf00              NOP                            ;1976
000094  1c64              ADDS     r4,r4,#1              ;1964
                  |L47.150|
000096  2c0f              CMP      r4,#0xf               ;1964
000098  d9d9              BLS      |L47.78|
;;;1979     }
;;;1980   
;;;1981     /* Clear any pending Host interrupts */
;;;1982     USBx_HOST->HAINT = 0xFFFFFFFFU;
00009a  f04f31ff          MOV      r1,#0xffffffff
00009e  f2404014          MOV      r0,#0x414
0000a2  5181              STR      r1,[r0,r6]
;;;1983     USBx->GINTSTS = 0xFFFFFFFFU;
0000a4  4608              MOV      r0,r1
0000a6  6178              STR      r0,[r7,#0x14]
;;;1984   
;;;1985     (void)USB_EnableGlobalInt(USBx);
0000a8  4638              MOV      r0,r7
0000aa  f7fffffe          BL       USB_EnableGlobalInt
;;;1986   
;;;1987     return HAL_OK;
0000ae  2000              MOVS     r0,#0
;;;1988   }
0000b0  e8bd81f0          POP      {r4-r8,pc}
;;;1989   
                          ENDP


                          AREA ||i.USB_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_WritePacket PROC
;;;955      */
;;;956    HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;957                                      uint8_t ch_ep_num, uint16_t len, uint8_t dma)
;;;958    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  f8ddc01c          LDR      r12,[sp,#0x1c]
;;;959      uint32_t USBx_BASE = (uint32_t)USBx;
00000c  46a0              MOV      r8,r4
;;;960      uint32_t *pSrc = (uint32_t *)src;
00000e  462e              MOV      r6,r5
;;;961      uint32_t count32b, i;
;;;962    
;;;963      if (dma == 0U)
000010  f1bc0f00          CMP      r12,#0
000014  d10f              BNE      |L48.54|
;;;964      {
;;;965        count32b = ((uint32_t)len + 3U) / 4U;
000016  1cd8              ADDS     r0,r3,#3
000018  0887              LSRS     r7,r0,#2
;;;966        for (i = 0U; i < count32b; i++)
00001a  2100              MOVS     r1,#0
00001c  e009              B        |L48.50|
                  |L48.30|
;;;967        {
;;;968          USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
00001e  f5085080          ADD      r0,r8,#0x1000
000022  eb003002          ADD      r0,r0,r2,LSL #12
000026  f8d69000          LDR      r9,[r6,#0]
00002a  f8c09000          STR      r9,[r0,#0]
;;;969          pSrc++;
00002e  1d36              ADDS     r6,r6,#4
000030  1c49              ADDS     r1,r1,#1              ;966
                  |L48.50|
000032  42b9              CMP      r1,r7                 ;966
000034  d3f3              BCC      |L48.30|
                  |L48.54|
;;;970        }
;;;971      }
;;;972    
;;;973      return HAL_OK;
000036  2000              MOVS     r0,#0
;;;974    }
000038  e8bd83f0          POP      {r4-r9,pc}
;;;975    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  tmpreg
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_usb_c_832330cf____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_usb_c_832330cf____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_usb_c_832330cf____REVSH|
#line 478
|__asm___18_stm32f4xx_ll_usb_c_832330cf____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_usb_c_832330cf____RRX|
#line 665
|__asm___18_stm32f4xx_ll_usb_c_832330cf____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
