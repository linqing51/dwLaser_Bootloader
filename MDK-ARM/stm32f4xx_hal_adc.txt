; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_adc.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_adc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_adc.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;1942     */
;;;1943   static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1944   {
000002  4605              MOV      r5,r0
;;;1945     /* Retrieve ADC handle corresponding to current DMA handle */
;;;1946     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1947     
;;;1948     /* Update state machine on conversion status if not in error state */
;;;1949     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
000006  6c20              LDR      r0,[r4,#0x40]
000008  f0000050          AND      r0,r0,#0x50
00000c  bb50              CBNZ     r0,|L1.100|
;;;1950     {
;;;1951       /* Update ADC state machine */
;;;1952       SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
00000e  6c20              LDR      r0,[r4,#0x40]
000010  f4407000          ORR      r0,r0,#0x200
000014  6420              STR      r0,[r4,#0x40]
;;;1953       
;;;1954       /* Determine whether any further conversion upcoming on group regular   */
;;;1955       /* by external trigger, continuous mode or scan sequence on going.      */
;;;1956       /* Note: On STM32F4, there is no independent flag of end of sequence.   */
;;;1957       /*       The test of scan sequence on going is done either with scan    */
;;;1958       /*       sequence disabled or with end of conversion flag set to        */
;;;1959       /*       of end of sequence.                                            */
;;;1960       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f0005040          AND      r0,r0,#0x30000000
00001e  b9e8              CBNZ     r0,|L1.92|
;;;1961          (hadc->Init.ContinuousConvMode == DISABLE)            &&
000020  7e20              LDRB     r0,[r4,#0x18]
000022  b9d8              CBNZ     r0,|L1.92|
;;;1962          (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
000024  6820              LDR      r0,[r4,#0]
000026  6ac0              LDR      r0,[r0,#0x2c]
000028  f4000070          AND      r0,r0,#0xf00000
00002c  b120              CBZ      r0,|L1.56|
;;;1963           HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
00002e  6820              LDR      r0,[r4,#0]
000030  6880              LDR      r0,[r0,#8]
000032  f4006080          AND      r0,r0,#0x400
000036  b988              CBNZ     r0,|L1.92|
                  |L1.56|
;;;1964       {
;;;1965         /* Disable ADC end of single conversion interrupt on group regular */
;;;1966         /* Note: Overrun interrupt was enabled with EOC interrupt in          */
;;;1967         /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
;;;1968         /* by overrun IRQ process below.                                      */
;;;1969         __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000038  6820              LDR      r0,[r4,#0]
00003a  6840              LDR      r0,[r0,#4]
00003c  f0200020          BIC      r0,r0,#0x20
000040  6821              LDR      r1,[r4,#0]
000042  6048              STR      r0,[r1,#4]
;;;1970         
;;;1971         /* Set ADC state */
;;;1972         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
000044  6c20              LDR      r0,[r4,#0x40]
000046  f4207080          BIC      r0,r0,#0x100
00004a  6420              STR      r0,[r4,#0x40]
;;;1973         
;;;1974         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f4005080          AND      r0,r0,#0x1000
000052  b918              CBNZ     r0,|L1.92|
;;;1975         {
;;;1976           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
000054  6c20              LDR      r0,[r4,#0x40]
000056  f0400001          ORR      r0,r0,#1
00005a  6420              STR      r0,[r4,#0x40]
                  |L1.92|
;;;1977         }
;;;1978       }
;;;1979       
;;;1980       /* Conversion complete callback */
;;;1981   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1982       hadc->ConvCpltCallback(hadc);
;;;1983   #else
;;;1984       HAL_ADC_ConvCpltCallback(hadc);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
000062  e00b              B        |L1.124|
                  |L1.100|
;;;1985   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1986     }
;;;1987     else /* DMA and-or internal error occurred */
;;;1988     {
;;;1989       if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
000064  6c20              LDR      r0,[r4,#0x40]
000066  f0000010          AND      r0,r0,#0x10
00006a  b118              CBZ      r0,|L1.116|
;;;1990       {
;;;1991         /* Call HAL ADC Error Callback function */
;;;1992   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1993         hadc->ErrorCallback(hadc);
;;;1994   #else
;;;1995         HAL_ADC_ErrorCallback(hadc);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_ADC_ErrorCallback
000072  e003              B        |L1.124|
                  |L1.116|
;;;1996   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1997       }
;;;1998   	else
;;;1999   	{
;;;2000         /* Call DMA error callback */
;;;2001         hadc->DMA_Handle->XferErrorCallback(hdma);
000074  6ba0              LDR      r0,[r4,#0x38]
000076  6cc1              LDR      r1,[r0,#0x4c]
000078  4628              MOV      r0,r5
00007a  4788              BLX      r1
                  |L1.124|
;;;2002       }
;;;2003     }
;;;2004   }
00007c  bd70              POP      {r4-r6,pc}
;;;2005   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;2028     */
;;;2029   static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2030   {
000002  4605              MOV      r5,r0
;;;2031     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2032     hadc->State= HAL_ADC_STATE_ERROR_DMA;
000006  2040              MOVS     r0,#0x40
000008  6420              STR      r0,[r4,#0x40]
;;;2033     /* Set ADC error code to DMA error */
;;;2034     hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
00000a  6c60              LDR      r0,[r4,#0x44]
00000c  f0400004          ORR      r0,r0,#4
000010  6460              STR      r0,[r4,#0x44]
;;;2035      /* Error callback */
;;;2036   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2037     hadc->ErrorCallback(hadc);
;;;2038   #else
;;;2039     HAL_ADC_ErrorCallback(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;2040   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2041   }
000018  bd70              POP      {r4-r6,pc}
;;;2042   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;2011     */
;;;2012   static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2013   {
000002  4604              MOV      r4,r0
;;;2014     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2015      /* Half conversion callback */
;;;2016   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2017     hadc->ConvHalfCpltCallback(hadc);
;;;2018   #else
;;;2019     HAL_ADC_ConvHalfCpltCallback(hadc);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;2020   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2021   }
00000c  bd70              POP      {r4-r6,pc}
;;;2022   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;1854     */
;;;1855   static void ADC_Init(ADC_HandleTypeDef* hadc)
000000  4955              LDR      r1,|L4.344|
;;;1856   {
;;;1857     ADC_Common_TypeDef *tmpADC_Common;
;;;1858     
;;;1859     /* Set ADC parameters */
;;;1860     /* Pointer to the common control register to which is belonging hadc    */
;;;1861     /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1862     /* control register)                                                    */
;;;1863     tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1864     
;;;1865     /* Set the ADC clock prescaler */
;;;1866     tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
000002  684a              LDR      r2,[r1,#4]
000004  f4223240          BIC      r2,r2,#0x30000
000008  604a              STR      r2,[r1,#4]
;;;1867     tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
00000a  684a              LDR      r2,[r1,#4]
00000c  6843              LDR      r3,[r0,#4]
00000e  431a              ORRS     r2,r2,r3
000010  604a              STR      r2,[r1,#4]
;;;1868     
;;;1869     /* Set ADC scan mode */
;;;1870     hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
000012  6802              LDR      r2,[r0,#0]
000014  6852              LDR      r2,[r2,#4]
000016  f4227280          BIC      r2,r2,#0x100
00001a  6803              LDR      r3,[r0,#0]
00001c  605a              STR      r2,[r3,#4]
;;;1871     hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
00001e  6802              LDR      r2,[r0,#0]
000020  6853              LDR      r3,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
000024  ea432202          ORR      r2,r3,r2,LSL #8
000028  6803              LDR      r3,[r0,#0]
00002a  605a              STR      r2,[r3,#4]
;;;1872     
;;;1873     /* Set ADC resolution */
;;;1874     hadc->Instance->CR1 &= ~(ADC_CR1_RES);
00002c  6802              LDR      r2,[r0,#0]
00002e  6852              LDR      r2,[r2,#4]
000030  f0227240          BIC      r2,r2,#0x3000000
000034  6803              LDR      r3,[r0,#0]
000036  605a              STR      r2,[r3,#4]
;;;1875     hadc->Instance->CR1 |=  hadc->Init.Resolution;
000038  6802              LDR      r2,[r0,#0]
00003a  6852              LDR      r2,[r2,#4]
00003c  6883              LDR      r3,[r0,#8]
00003e  431a              ORRS     r2,r2,r3
000040  6803              LDR      r3,[r0,#0]
000042  605a              STR      r2,[r3,#4]
;;;1876     
;;;1877     /* Set ADC data alignment */
;;;1878     hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
000044  6802              LDR      r2,[r0,#0]
000046  6892              LDR      r2,[r2,#8]
000048  f4226200          BIC      r2,r2,#0x800
00004c  6803              LDR      r3,[r0,#0]
00004e  609a              STR      r2,[r3,#8]
;;;1879     hadc->Instance->CR2 |= hadc->Init.DataAlign;
000050  6802              LDR      r2,[r0,#0]
000052  6892              LDR      r2,[r2,#8]
000054  68c3              LDR      r3,[r0,#0xc]
000056  431a              ORRS     r2,r2,r3
000058  6803              LDR      r3,[r0,#0]
00005a  609a              STR      r2,[r3,#8]
;;;1880     
;;;1881     /* Enable external trigger if trigger selection is different of software  */
;;;1882     /* start.                                                                 */
;;;1883     /* Note: This configuration keeps the hardware feature of parameter       */
;;;1884     /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
;;;1885     /*       software start.                                                  */
;;;1886     if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
00005c  4b3f              LDR      r3,|L4.348|
00005e  6a82              LDR      r2,[r0,#0x28]
000060  429a              CMP      r2,r3
000062  d018              BEQ      |L4.150|
;;;1887     {
;;;1888       /* Select external trigger to start conversion */
;;;1889       hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
000064  6802              LDR      r2,[r0,#0]
000066  6892              LDR      r2,[r2,#8]
000068  f0226270          BIC      r2,r2,#0xf000000
00006c  6803              LDR      r3,[r0,#0]
00006e  609a              STR      r2,[r3,#8]
;;;1890       hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
000070  6802              LDR      r2,[r0,#0]
000072  6892              LDR      r2,[r2,#8]
000074  6a83              LDR      r3,[r0,#0x28]
000076  431a              ORRS     r2,r2,r3
000078  6803              LDR      r3,[r0,#0]
00007a  609a              STR      r2,[r3,#8]
;;;1891       
;;;1892       /* Select external trigger polarity */
;;;1893       hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
00007c  6802              LDR      r2,[r0,#0]
00007e  6892              LDR      r2,[r2,#8]
000080  f0225240          BIC      r2,r2,#0x30000000
000084  6803              LDR      r3,[r0,#0]
000086  609a              STR      r2,[r3,#8]
;;;1894       hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
000088  6802              LDR      r2,[r0,#0]
00008a  6892              LDR      r2,[r2,#8]
00008c  6ac3              LDR      r3,[r0,#0x2c]
00008e  431a              ORRS     r2,r2,r3
000090  6803              LDR      r3,[r0,#0]
000092  609a              STR      r2,[r3,#8]
000094  e00b              B        |L4.174|
                  |L4.150|
;;;1895     }
;;;1896     else
;;;1897     {
;;;1898       /* Reset the external trigger */
;;;1899       hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
000096  6802              LDR      r2,[r0,#0]
000098  6892              LDR      r2,[r2,#8]
00009a  f0226270          BIC      r2,r2,#0xf000000
00009e  6803              LDR      r3,[r0,#0]
0000a0  609a              STR      r2,[r3,#8]
;;;1900       hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
0000a2  6802              LDR      r2,[r0,#0]
0000a4  6892              LDR      r2,[r2,#8]
0000a6  f0225240          BIC      r2,r2,#0x30000000
0000aa  6803              LDR      r3,[r0,#0]
0000ac  609a              STR      r2,[r3,#8]
                  |L4.174|
;;;1901     }
;;;1902     
;;;1903     /* Enable or disable ADC continuous conversion mode */
;;;1904     hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
0000ae  6802              LDR      r2,[r0,#0]
0000b0  6892              LDR      r2,[r2,#8]
0000b2  f0220202          BIC      r2,r2,#2
0000b6  6803              LDR      r3,[r0,#0]
0000b8  609a              STR      r2,[r3,#8]
;;;1905     hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
0000ba  6802              LDR      r2,[r0,#0]
0000bc  6893              LDR      r3,[r2,#8]
0000be  7e02              LDRB     r2,[r0,#0x18]
0000c0  ea430242          ORR      r2,r3,r2,LSL #1
0000c4  6803              LDR      r3,[r0,#0]
0000c6  609a              STR      r2,[r3,#8]
;;;1906     
;;;1907     if(hadc->Init.DiscontinuousConvMode != DISABLE)
0000c8  2220              MOVS     r2,#0x20
0000ca  5c12              LDRB     r2,[r2,r0]
0000cc  b1a2              CBZ      r2,|L4.248|
;;;1908     {
;;;1909       assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;1910     
;;;1911       /* Enable the selected ADC regular discontinuous mode */
;;;1912       hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
0000ce  6802              LDR      r2,[r0,#0]
0000d0  6852              LDR      r2,[r2,#4]
0000d2  f4426200          ORR      r2,r2,#0x800
0000d6  6803              LDR      r3,[r0,#0]
0000d8  605a              STR      r2,[r3,#4]
;;;1913       
;;;1914       /* Set the number of channels to be converted in discontinuous mode */
;;;1915       hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
0000da  6802              LDR      r2,[r0,#0]
0000dc  6852              LDR      r2,[r2,#4]
0000de  f4224260          BIC      r2,r2,#0xe000
0000e2  6803              LDR      r3,[r0,#0]
0000e4  605a              STR      r2,[r3,#4]
;;;1916       hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
0000e6  6802              LDR      r2,[r0,#0]
0000e8  6853              LDR      r3,[r2,#4]
0000ea  6a42              LDR      r2,[r0,#0x24]
0000ec  1e52              SUBS     r2,r2,#1
0000ee  ea433242          ORR      r2,r3,r2,LSL #13
0000f2  6803              LDR      r3,[r0,#0]
0000f4  605a              STR      r2,[r3,#4]
0000f6  e005              B        |L4.260|
                  |L4.248|
;;;1917     }
;;;1918     else
;;;1919     {
;;;1920       /* Disable the selected ADC regular discontinuous mode */
;;;1921       hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
0000f8  6802              LDR      r2,[r0,#0]
0000fa  6852              LDR      r2,[r2,#4]
0000fc  f4226200          BIC      r2,r2,#0x800
000100  6803              LDR      r3,[r0,#0]
000102  605a              STR      r2,[r3,#4]
                  |L4.260|
;;;1922     }
;;;1923     
;;;1924     /* Set ADC number of conversion */
;;;1925     hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
000104  6802              LDR      r2,[r0,#0]
000106  6ad2              LDR      r2,[r2,#0x2c]
000108  f4220270          BIC      r2,r2,#0xf00000
00010c  6803              LDR      r3,[r0,#0]
00010e  62da              STR      r2,[r3,#0x2c]
;;;1926     hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
000110  6802              LDR      r2,[r0,#0]
000112  6ad3              LDR      r3,[r2,#0x2c]
000114  8b82              LDRH     r2,[r0,#0x1c]
000116  1e52              SUBS     r2,r2,#1
000118  ea435202          ORR      r2,r3,r2,LSL #20
00011c  6803              LDR      r3,[r0,#0]
00011e  62da              STR      r2,[r3,#0x2c]
;;;1927     
;;;1928     /* Enable or disable ADC DMA continuous request */
;;;1929     hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
000120  6802              LDR      r2,[r0,#0]
000122  6892              LDR      r2,[r2,#8]
000124  f4227200          BIC      r2,r2,#0x200
000128  6803              LDR      r3,[r0,#0]
00012a  609a              STR      r2,[r3,#8]
;;;1930     hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
00012c  6802              LDR      r2,[r0,#0]
00012e  6893              LDR      r3,[r2,#8]
000130  f8902030          LDRB     r2,[r0,#0x30]
000134  ea432242          ORR      r2,r3,r2,LSL #9
000138  6803              LDR      r3,[r0,#0]
00013a  609a              STR      r2,[r3,#8]
;;;1931     
;;;1932     /* Enable or disable ADC end of conversion selection */
;;;1933     hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
00013c  6802              LDR      r2,[r0,#0]
00013e  6892              LDR      r2,[r2,#8]
000140  f4226280          BIC      r2,r2,#0x400
000144  6803              LDR      r3,[r0,#0]
000146  609a              STR      r2,[r3,#8]
;;;1934     hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
000148  6802              LDR      r2,[r0,#0]
00014a  6893              LDR      r3,[r2,#8]
00014c  6942              LDR      r2,[r0,#0x14]
00014e  ea432282          ORR      r2,r3,r2,LSL #10
000152  6803              LDR      r3,[r0,#0]
000154  609a              STR      r2,[r3,#8]
;;;1935   }
000156  4770              BX       lr
;;;1936   
                          ENDP

                  |L4.344|
                          DCD      0x40012300
                  |L4.348|
                          DCD      0x0f000001

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;1740     */
;;;1741   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  4602              MOV      r2,r0
;;;1742   {
;;;1743   #ifdef USE_FULL_ASSERT  
;;;1744     uint32_t tmp = 0U;
;;;1745   #endif /* USE_FULL_ASSERT  */  
;;;1746     
;;;1747     /* Check the parameters */
;;;1748     assert_param(IS_ADC_ANALOG_WATCHDOG(AnalogWDGConfig->WatchdogMode));
;;;1749     assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
;;;1750     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;1751   
;;;1752   #ifdef USE_FULL_ASSERT  
;;;1753     tmp = ADC_GET_RESOLUTION(hadc);
;;;1754     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->HighThreshold));
;;;1755     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->LowThreshold));
;;;1756   #endif /* USE_FULL_ASSERT  */
;;;1757     
;;;1758     /* Process locked */
;;;1759     __HAL_LOCK(hadc);
000002  bf00              NOP      
000004  f892003c          LDRB     r0,[r2,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;1760     
;;;1761     if(AnalogWDGConfig->ITMode == ENABLE)
;;;1762     {
;;;1763       /* Enable the ADC Analog watchdog interrupt */
;;;1764       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;1765     }
;;;1766     else
;;;1767     {
;;;1768       /* Disable the ADC Analog watchdog interrupt */
;;;1769       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
;;;1770     }
;;;1771     
;;;1772     /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;1773     hadc->Instance->CR1 &=  ~(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN);
;;;1774     
;;;1775     /* Set the analog watchdog enable mode */
;;;1776     hadc->Instance->CR1 |= AnalogWDGConfig->WatchdogMode;
;;;1777     
;;;1778     /* Set the high threshold */
;;;1779     hadc->Instance->HTR = AnalogWDGConfig->HighThreshold;
;;;1780     
;;;1781     /* Set the low threshold */
;;;1782     hadc->Instance->LTR = AnalogWDGConfig->LowThreshold;
;;;1783     
;;;1784     /* Clear the Analog watchdog channel select bits */
;;;1785     hadc->Instance->CR1 &= ~ADC_CR1_AWDCH;
;;;1786     
;;;1787     /* Set the Analog watchdog channel */
;;;1788     hadc->Instance->CR1 |= (uint32_t)((uint16_t)(AnalogWDGConfig->Channel));
;;;1789     
;;;1790     /* Process unlocked */
;;;1791     __HAL_UNLOCK(hadc);
;;;1792     
;;;1793     /* Return function status */
;;;1794     return HAL_OK;
;;;1795   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;1759
000012  f882003c          STRB     r0,[r2,#0x3c]         ;1759
000016  bf00              NOP                            ;1759
000018  7c08              LDRB     r0,[r1,#0x10]         ;1761
00001a  2801              CMP      r0,#1                 ;1761
00001c  d106              BNE      |L5.44|
00001e  6810              LDR      r0,[r2,#0]            ;1764
000020  6840              LDR      r0,[r0,#4]            ;1764
000022  f0400040          ORR      r0,r0,#0x40           ;1764
000026  6813              LDR      r3,[r2,#0]            ;1764
000028  6058              STR      r0,[r3,#4]            ;1764
00002a  e005              B        |L5.56|
                  |L5.44|
00002c  6810              LDR      r0,[r2,#0]            ;1769
00002e  6840              LDR      r0,[r0,#4]            ;1769
000030  f0200040          BIC      r0,r0,#0x40           ;1769
000034  6813              LDR      r3,[r2,#0]            ;1769
000036  6058              STR      r0,[r3,#4]            ;1769
                  |L5.56|
000038  6810              LDR      r0,[r2,#0]            ;1773
00003a  6840              LDR      r0,[r0,#4]            ;1773
00003c  4b11              LDR      r3,|L5.132|
00003e  4018              ANDS     r0,r0,r3              ;1773
000040  6813              LDR      r3,[r2,#0]            ;1773
000042  6058              STR      r0,[r3,#4]            ;1773
000044  6810              LDR      r0,[r2,#0]            ;1776
000046  6840              LDR      r0,[r0,#4]            ;1776
000048  680b              LDR      r3,[r1,#0]            ;1776
00004a  4318              ORRS     r0,r0,r3              ;1776
00004c  6813              LDR      r3,[r2,#0]            ;1776
00004e  6058              STR      r0,[r3,#4]            ;1776
000050  6848              LDR      r0,[r1,#4]            ;1779
000052  6813              LDR      r3,[r2,#0]            ;1779
000054  6258              STR      r0,[r3,#0x24]         ;1779
000056  6888              LDR      r0,[r1,#8]            ;1782
000058  6813              LDR      r3,[r2,#0]            ;1782
00005a  6298              STR      r0,[r3,#0x28]         ;1782
00005c  6810              LDR      r0,[r2,#0]            ;1785
00005e  6840              LDR      r0,[r0,#4]            ;1785
000060  f020001f          BIC      r0,r0,#0x1f           ;1785
000064  6813              LDR      r3,[r2,#0]            ;1785
000066  6058              STR      r0,[r3,#4]            ;1785
000068  6810              LDR      r0,[r2,#0]            ;1788
00006a  6840              LDR      r0,[r0,#4]            ;1788
00006c  898b              LDRH     r3,[r1,#0xc]          ;1788
00006e  b29b              UXTH     r3,r3                 ;1788
000070  4318              ORRS     r0,r0,r3              ;1788
000072  6813              LDR      r3,[r2,#0]            ;1788
000074  6058              STR      r0,[r3,#4]            ;1788
000076  bf00              NOP                            ;1791
000078  2000              MOVS     r0,#0                 ;1791
00007a  f882003c          STRB     r0,[r2,#0x3c]         ;1791
00007e  bf00              NOP                            ;1791
000080  bf00              NOP                            ;1794
000082  e7c4              B        |L5.14|
;;;1796   
                          ENDP

                  |L5.132|
                          DCD      0xff3ffdff

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;1617     */
;;;1618   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000000  b538              PUSH     {r3-r5,lr}
;;;1619   {
000002  4602              MOV      r2,r0
;;;1620     __IO uint32_t counter = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1621     ADC_Common_TypeDef *tmpADC_Common;
;;;1622     
;;;1623     /* Check the parameters */
;;;1624     assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;1625     assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;1626     assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;1627     
;;;1628     /* Process locked */
;;;1629     __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f892003c          LDRB     r0,[r2,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L6.22|
000012  2002              MOVS     r0,#2
                  |L6.20|
;;;1630       
;;;1631     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1632     if (sConfig->Channel > ADC_CHANNEL_9)
;;;1633     {
;;;1634       /* Clear the old sample time */
;;;1635       hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
;;;1636       
;;;1637       /* Set the new sample time */
;;;1638       hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
;;;1639     }
;;;1640     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1641     {
;;;1642       /* Clear the old sample time */
;;;1643       hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
;;;1644       
;;;1645       /* Set the new sample time */
;;;1646       hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
;;;1647     }
;;;1648     
;;;1649     /* For Rank 1 to 6 */
;;;1650     if (sConfig->Rank < 7U)
;;;1651     {
;;;1652       /* Clear the old SQx bits for the selected rank */
;;;1653       hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
;;;1654       
;;;1655       /* Set the SQx bits for the selected rank */
;;;1656       hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
;;;1657     }
;;;1658     /* For Rank 7 to 12 */
;;;1659     else if (sConfig->Rank < 13U)
;;;1660     {
;;;1661       /* Clear the old SQx bits for the selected rank */
;;;1662       hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
;;;1663       
;;;1664       /* Set the SQx bits for the selected rank */
;;;1665       hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
;;;1666     }
;;;1667     /* For Rank 13 to 16 */
;;;1668     else
;;;1669     {
;;;1670       /* Clear the old SQx bits for the selected rank */
;;;1671       hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
;;;1672       
;;;1673       /* Set the SQx bits for the selected rank */
;;;1674       hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
;;;1675     }
;;;1676   
;;;1677       /* Pointer to the common control register to which is belonging hadc    */
;;;1678       /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1679       /* control register)                                                    */
;;;1680       tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1681   
;;;1682     /* if ADC1 Channel_18 is selected for VBAT Channel ennable VBATE */
;;;1683     if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
;;;1684     {
;;;1685       /* Disable the TEMPSENSOR channel in case of using board with multiplixed ADC_CHANNEL_VBAT & ADC_CHANNEL_TEMPSENSOR*/    
;;;1686       if ((uint16_t)ADC_CHANNEL_TEMPSENSOR == (uint16_t)ADC_CHANNEL_VBAT)
;;;1687       {
;;;1688         tmpADC_Common->CCR &= ~ADC_CCR_TSVREFE;
;;;1689       }
;;;1690       /* Enable the VBAT channel*/
;;;1691       tmpADC_Common->CCR |= ADC_CCR_VBATE;
;;;1692     }
;;;1693     
;;;1694     /* if ADC1 Channel_16 or Channel_18 is selected for Temperature sensor or 
;;;1695        Channel_17 is selected for VREFINT enable TSVREFE */
;;;1696     if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
;;;1697     {
;;;1698       /* Disable the VBAT channel in case of using board with multiplixed ADC_CHANNEL_VBAT & ADC_CHANNEL_TEMPSENSOR*/
;;;1699       if ((uint16_t)ADC_CHANNEL_TEMPSENSOR == (uint16_t)ADC_CHANNEL_VBAT)
;;;1700       {
;;;1701         tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
;;;1702       }
;;;1703       /* Enable the Temperature sensor and VREFINT channel*/
;;;1704       tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
;;;1705       
;;;1706       if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
;;;1707       {
;;;1708         /* Delay for temperature sensor stabilization time */
;;;1709         /* Compute number of CPU cycles to wait for */
;;;1710         counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
;;;1711         while(counter != 0U)
;;;1712         {
;;;1713           counter--;
;;;1714         }
;;;1715       }
;;;1716     }
;;;1717     
;;;1718     /* Process unlocked */
;;;1719     __HAL_UNLOCK(hadc);
;;;1720     
;;;1721     /* Return function status */
;;;1722     return HAL_OK;
;;;1723   }
000014  bd38              POP      {r3-r5,pc}
                  |L6.22|
000016  2001              MOVS     r0,#1                 ;1629
000018  f882003c          STRB     r0,[r2,#0x3c]         ;1629
00001c  bf00              NOP                            ;1629
00001e  6808              LDR      r0,[r1,#0]            ;1632
000020  2809              CMP      r0,#9                 ;1632
000022  d916              BLS      |L6.82|
000024  6810              LDR      r0,[r2,#0]            ;1635
000026  68c0              LDR      r0,[r0,#0xc]          ;1635
000028  780c              LDRB     r4,[r1,#0]            ;1635
00002a  3c0a              SUBS     r4,r4,#0xa            ;1635
00002c  eb040544          ADD      r5,r4,r4,LSL #1       ;1635
000030  2407              MOVS     r4,#7                 ;1635
000032  40ac              LSLS     r4,r4,r5              ;1635
000034  43a0              BICS     r0,r0,r4              ;1635
000036  6814              LDR      r4,[r2,#0]            ;1635
000038  60e0              STR      r0,[r4,#0xc]          ;1635
00003a  780c              LDRB     r4,[r1,#0]            ;1638
00003c  3c0a              SUBS     r4,r4,#0xa            ;1638
00003e  eb040444          ADD      r4,r4,r4,LSL #1       ;1638
000042  6888              LDR      r0,[r1,#8]            ;1638
000044  40a0              LSLS     r0,r0,r4              ;1638
000046  6814              LDR      r4,[r2,#0]            ;1638
000048  68e4              LDR      r4,[r4,#0xc]          ;1638
00004a  4320              ORRS     r0,r0,r4              ;1638
00004c  6814              LDR      r4,[r2,#0]            ;1638
00004e  60e0              STR      r0,[r4,#0xc]          ;1638
000050  e013              B        |L6.122|
                  |L6.82|
000052  6810              LDR      r0,[r2,#0]            ;1643
000054  6900              LDR      r0,[r0,#0x10]         ;1643
000056  780c              LDRB     r4,[r1,#0]            ;1643
000058  eb040544          ADD      r5,r4,r4,LSL #1       ;1643
00005c  2407              MOVS     r4,#7                 ;1643
00005e  40ac              LSLS     r4,r4,r5              ;1643
000060  43a0              BICS     r0,r0,r4              ;1643
000062  6814              LDR      r4,[r2,#0]            ;1643
000064  6120              STR      r0,[r4,#0x10]         ;1643
000066  780c              LDRB     r4,[r1,#0]            ;1646
000068  eb040444          ADD      r4,r4,r4,LSL #1       ;1646
00006c  6888              LDR      r0,[r1,#8]            ;1646
00006e  40a0              LSLS     r0,r0,r4              ;1646
000070  6814              LDR      r4,[r2,#0]            ;1646
000072  6924              LDR      r4,[r4,#0x10]         ;1646
000074  4320              ORRS     r0,r0,r4              ;1646
000076  6814              LDR      r4,[r2,#0]            ;1646
000078  6120              STR      r0,[r4,#0x10]         ;1646
                  |L6.122|
00007a  6848              LDR      r0,[r1,#4]            ;1650
00007c  2807              CMP      r0,#7                 ;1650
00007e  d217              BCS      |L6.176|
000080  6810              LDR      r0,[r2,#0]            ;1653
000082  6b40              LDR      r0,[r0,#0x34]         ;1653
000084  790c              LDRB     r4,[r1,#4]            ;1653
000086  1e64              SUBS     r4,r4,#1              ;1653
000088  eb040584          ADD      r5,r4,r4,LSL #2       ;1653
00008c  241f              MOVS     r4,#0x1f              ;1653
00008e  40ac              LSLS     r4,r4,r5              ;1653
000090  43a0              BICS     r0,r0,r4              ;1653
000092  6814              LDR      r4,[r2,#0]            ;1653
000094  6360              STR      r0,[r4,#0x34]         ;1653
000096  8808              LDRH     r0,[r1,#0]            ;1656
000098  b280              UXTH     r0,r0                 ;1656
00009a  790c              LDRB     r4,[r1,#4]            ;1656
00009c  1e64              SUBS     r4,r4,#1              ;1656
00009e  eb040484          ADD      r4,r4,r4,LSL #2       ;1656
0000a2  40a0              LSLS     r0,r0,r4              ;1656
0000a4  6814              LDR      r4,[r2,#0]            ;1656
0000a6  6b64              LDR      r4,[r4,#0x34]         ;1656
0000a8  4320              ORRS     r0,r0,r4              ;1656
0000aa  6814              LDR      r4,[r2,#0]            ;1656
0000ac  6360              STR      r0,[r4,#0x34]         ;1656
0000ae  e031              B        |L6.276|
                  |L6.176|
0000b0  6848              LDR      r0,[r1,#4]            ;1659
0000b2  280d              CMP      r0,#0xd               ;1659
0000b4  d217              BCS      |L6.230|
0000b6  6810              LDR      r0,[r2,#0]            ;1662
0000b8  6b00              LDR      r0,[r0,#0x30]         ;1662
0000ba  790c              LDRB     r4,[r1,#4]            ;1662
0000bc  1fe4              SUBS     r4,r4,#7              ;1662
0000be  eb040584          ADD      r5,r4,r4,LSL #2       ;1662
0000c2  241f              MOVS     r4,#0x1f              ;1662
0000c4  40ac              LSLS     r4,r4,r5              ;1662
0000c6  43a0              BICS     r0,r0,r4              ;1662
0000c8  6814              LDR      r4,[r2,#0]            ;1662
0000ca  6320              STR      r0,[r4,#0x30]         ;1662
0000cc  8808              LDRH     r0,[r1,#0]            ;1665
0000ce  b280              UXTH     r0,r0                 ;1665
0000d0  790c              LDRB     r4,[r1,#4]            ;1665
0000d2  1fe4              SUBS     r4,r4,#7              ;1665
0000d4  eb040484          ADD      r4,r4,r4,LSL #2       ;1665
0000d8  40a0              LSLS     r0,r0,r4              ;1665
0000da  6814              LDR      r4,[r2,#0]            ;1665
0000dc  6b24              LDR      r4,[r4,#0x30]         ;1665
0000de  4320              ORRS     r0,r0,r4              ;1665
0000e0  6814              LDR      r4,[r2,#0]            ;1665
0000e2  6320              STR      r0,[r4,#0x30]         ;1665
0000e4  e016              B        |L6.276|
                  |L6.230|
0000e6  6810              LDR      r0,[r2,#0]            ;1671
0000e8  6ac0              LDR      r0,[r0,#0x2c]         ;1671
0000ea  790c              LDRB     r4,[r1,#4]            ;1671
0000ec  3c0d              SUBS     r4,r4,#0xd            ;1671
0000ee  eb040584          ADD      r5,r4,r4,LSL #2       ;1671
0000f2  241f              MOVS     r4,#0x1f              ;1671
0000f4  40ac              LSLS     r4,r4,r5              ;1671
0000f6  43a0              BICS     r0,r0,r4              ;1671
0000f8  6814              LDR      r4,[r2,#0]            ;1671
0000fa  62e0              STR      r0,[r4,#0x2c]         ;1671
0000fc  8808              LDRH     r0,[r1,#0]            ;1674
0000fe  b280              UXTH     r0,r0                 ;1674
000100  790c              LDRB     r4,[r1,#4]            ;1674
000102  3c0d              SUBS     r4,r4,#0xd            ;1674
000104  eb040484          ADD      r4,r4,r4,LSL #2       ;1674
000108  40a0              LSLS     r0,r0,r4              ;1674
00010a  6814              LDR      r4,[r2,#0]            ;1674
00010c  6ae4              LDR      r4,[r4,#0x2c]         ;1674
00010e  4320              ORRS     r0,r0,r4              ;1674
000110  6814              LDR      r4,[r2,#0]            ;1674
000112  62e0              STR      r0,[r4,#0x2c]         ;1674
                  |L6.276|
000114  4b1e              LDR      r3,|L6.400|
000116  4c1f              LDR      r4,|L6.404|
000118  6810              LDR      r0,[r2,#0]            ;1683
00011a  42a0              CMP      r0,r4                 ;1683
00011c  d10a              BNE      |L6.308|
00011e  6808              LDR      r0,[r1,#0]            ;1683
000120  2812              CMP      r0,#0x12              ;1683
000122  d107              BNE      |L6.308|
000124  6858              LDR      r0,[r3,#4]            ;1688
000126  f4200000          BIC      r0,r0,#0x800000       ;1688
00012a  6058              STR      r0,[r3,#4]            ;1688
00012c  6858              LDR      r0,[r3,#4]            ;1691
00012e  f4400080          ORR      r0,r0,#0x400000       ;1691
000132  6058              STR      r0,[r3,#4]            ;1691
                  |L6.308|
000134  4c17              LDR      r4,|L6.404|
000136  6810              LDR      r0,[r2,#0]            ;1696
000138  42a0              CMP      r0,r4                 ;1696
00013a  d122              BNE      |L6.386|
00013c  4c16              LDR      r4,|L6.408|
00013e  6808              LDR      r0,[r1,#0]            ;1696
000140  42a0              CMP      r0,r4                 ;1696
000142  d002              BEQ      |L6.330|
000144  6808              LDR      r0,[r1,#0]            ;1696
000146  2811              CMP      r0,#0x11              ;1696
000148  d11b              BNE      |L6.386|
                  |L6.330|
00014a  6858              LDR      r0,[r3,#4]            ;1701
00014c  f4200080          BIC      r0,r0,#0x400000       ;1701
000150  6058              STR      r0,[r3,#4]            ;1701
000152  6858              LDR      r0,[r3,#4]            ;1704
000154  f4400000          ORR      r0,r0,#0x800000       ;1704
000158  6058              STR      r0,[r3,#4]            ;1704
00015a  4c0f              LDR      r4,|L6.408|
00015c  6808              LDR      r0,[r1,#0]            ;1706
00015e  42a0              CMP      r0,r4                 ;1706
000160  d10f              BNE      |L6.386|
000162  480e              LDR      r0,|L6.412|
000164  6800              LDR      r0,[r0,#0]            ;1710  ; SystemCoreClock
000166  4c0e              LDR      r4,|L6.416|
000168  fbb0f0f4          UDIV     r0,r0,r4              ;1710
00016c  eb000080          ADD      r0,r0,r0,LSL #2       ;1710
000170  0040              LSLS     r0,r0,#1              ;1710
000172  9000              STR      r0,[sp,#0]            ;1710
000174  e002              B        |L6.380|
                  |L6.374|
000176  9800              LDR      r0,[sp,#0]            ;1713
000178  1e40              SUBS     r0,r0,#1              ;1713
00017a  9000              STR      r0,[sp,#0]            ;1713
                  |L6.380|
00017c  9800              LDR      r0,[sp,#0]            ;1711
00017e  2800              CMP      r0,#0                 ;1711
000180  d1f9              BNE      |L6.374|
                  |L6.386|
000182  bf00              NOP                            ;1719
000184  2000              MOVS     r0,#0                 ;1719
000186  f882003c          STRB     r0,[r2,#0x3c]         ;1719
00018a  bf00              NOP                            ;1719
00018c  bf00              NOP                            ;1722
00018e  e741              B        |L6.20|
;;;1724   
                          ENDP

                  |L6.400|
                          DCD      0x40012300
                  |L6.404|
                          DCD      0x40012000
                  |L6.408|
                          DCD      0x10000012
                  |L6.412|
                          DCD      SystemCoreClock
                  |L6.416|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;1528     */
;;;1529   __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1530   {
;;;1531     /* Prevent unused argument(s) compilation warning */
;;;1532     UNUSED(hadc);
;;;1533     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1534               the HAL_ADC_ConvCpltCallback could be implemented in the user file
;;;1535      */
;;;1536   }
;;;1537   
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;1543     */
;;;1544   __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1545   {
;;;1546     /* Prevent unused argument(s) compilation warning */
;;;1547     UNUSED(hadc);
;;;1548     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1549               the HAL_ADC_ConvHalfCpltCallback could be implemented in the user file
;;;1550      */
;;;1551   }
;;;1552   
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_DeInit PROC
;;;405      */
;;;406    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;407    {
000002  4604              MOV      r4,r0
;;;408      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;409      
;;;410      /* Check ADC handle */
;;;411      if(hadc == NULL)
000006  b90c              CBNZ     r4,|L9.12|
;;;412      {
;;;413        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L9.10|
;;;414      }
;;;415      
;;;416      /* Check the parameters */
;;;417      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;418      
;;;419      /* Set ADC state */
;;;420      SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
;;;421      
;;;422      /* Stop potential conversion on going, on regular and injected groups */
;;;423      /* Disable ADC peripheral */
;;;424      __HAL_ADC_DISABLE(hadc);
;;;425      
;;;426      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;427      /* correctly completed.                                                     */
;;;428      if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;429      {
;;;430    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;431      if (hadc->MspDeInitCallback == NULL)
;;;432      {
;;;433        hadc->MspDeInitCallback = HAL_ADC_MspDeInit; /* Legacy weak MspDeInit  */
;;;434      }
;;;435    
;;;436      /* DeInit the low level hardware: RCC clock, NVIC */
;;;437      hadc->MspDeInitCallback(hadc);
;;;438    #else
;;;439      /* DeInit the low level hardware: RCC clock, NVIC */
;;;440      HAL_ADC_MspDeInit(hadc);
;;;441    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;442        
;;;443        /* Set ADC error code to none */
;;;444        ADC_CLEAR_ERRORCODE(hadc);
;;;445        
;;;446        /* Set ADC state */
;;;447        hadc->State = HAL_ADC_STATE_RESET;
;;;448      }
;;;449      
;;;450      /* Process unlocked */
;;;451      __HAL_UNLOCK(hadc);
;;;452      
;;;453      /* Return function status */
;;;454      return tmp_hal_status;
;;;455    }
00000a  bd70              POP      {r4-r6,pc}
                  |L9.12|
00000c  6c20              LDR      r0,[r4,#0x40]         ;420
00000e  f0400002          ORR      r0,r0,#2              ;420
000012  6420              STR      r0,[r4,#0x40]         ;420
000014  6820              LDR      r0,[r4,#0]            ;424
000016  6880              LDR      r0,[r0,#8]            ;424
000018  f0200001          BIC      r0,r0,#1              ;424
00001c  6821              LDR      r1,[r4,#0]            ;424
00001e  6088              STR      r0,[r1,#8]            ;424
000020  6820              LDR      r0,[r4,#0]            ;428
000022  6880              LDR      r0,[r0,#8]            ;428
000024  f0000001          AND      r0,r0,#1              ;428
000028  b928              CBNZ     r0,|L9.54|
00002a  4620              MOV      r0,r4                 ;440
00002c  f7fffffe          BL       HAL_ADC_MspDeInit
000030  2000              MOVS     r0,#0                 ;444
000032  6460              STR      r0,[r4,#0x44]         ;444
000034  6420              STR      r0,[r4,#0x40]         ;447
                  |L9.54|
000036  bf00              NOP                            ;451
000038  2000              MOVS     r0,#0                 ;451
00003a  f884003c          STRB     r0,[r4,#0x3c]         ;451
00003e  bf00              NOP                            ;451
000040  4628              MOV      r0,r5                 ;454
000042  e7e2              B        |L9.10|
;;;456    
                          ENDP


                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;1579     */
;;;1580   __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1581   {
;;;1582     /* Prevent unused argument(s) compilation warning */
;;;1583     UNUSED(hadc);
;;;1584     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1585               the HAL_ADC_ErrorCallback could be implemented in the user file
;;;1586      */
;;;1587   }
;;;1588   
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;1834     */
;;;1835   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  4601              MOV      r1,r0
;;;1836   {
;;;1837     return hadc->ErrorCode;
000002  6c48              LDR      r0,[r1,#0x44]
;;;1838   }
000004  4770              BX       lr
;;;1839   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;1822     */
;;;1823   uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1824   {
;;;1825     /* Return ADC state */
;;;1826     return hadc->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;1827   }
000004  4770              BX       lr
;;;1828   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;1516     */
;;;1517   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1518   {       
;;;1519     /* Return the selected ADC converted value */ 
;;;1520     return hadc->Instance->DR;
000002  6808              LDR      r0,[r1,#0]
000004  6cc0              LDR      r0,[r0,#0x4c]
;;;1521   }
000006  4770              BX       lr
;;;1522   
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ADC_IRQHandler PROC
;;;1175     */
;;;1176   void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1177   {
000002  4604              MOV      r4,r0
;;;1178     uint32_t tmp1 = 0U, tmp2 = 0U;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;1179     
;;;1180     /* Check the parameters */
;;;1181     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1182     assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;1183     assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;1184     
;;;1185     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
000008  6820              LDR      r0,[r4,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f3c00540          UBFX     r5,r0,#1,#1
;;;1186     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
000010  6820              LDR      r0,[r4,#0]
000012  6840              LDR      r0,[r0,#4]
000014  f3c01640          UBFX     r6,r0,#5,#1
;;;1187     /* Check End of conversion flag for regular channels */
;;;1188     if(tmp1 && tmp2)
000018  b395              CBZ      r5,|L14.128|
00001a  b38e              CBZ      r6,|L14.128|
;;;1189     {
;;;1190       /* Update state machine on conversion status if not in error state */
;;;1191       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
00001c  6c20              LDR      r0,[r4,#0x40]
00001e  f0000010          AND      r0,r0,#0x10
000022  b918              CBNZ     r0,|L14.44|
;;;1192       {
;;;1193         /* Set ADC state */
;;;1194         SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
000024  6c20              LDR      r0,[r4,#0x40]
000026  f4407000          ORR      r0,r0,#0x200
00002a  6420              STR      r0,[r4,#0x40]
                  |L14.44|
;;;1195       }
;;;1196       
;;;1197       /* Determine whether any further conversion upcoming on group regular   */
;;;1198       /* by external trigger, continuous mode or scan sequence on going.      */
;;;1199       /* Note: On STM32F4, there is no independent flag of end of sequence.   */
;;;1200       /*       The test of scan sequence on going is done either with scan    */
;;;1201       /*       sequence disabled or with end of conversion flag set to        */
;;;1202       /*       of end of sequence.                                            */
;;;1203       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0005040          AND      r0,r0,#0x30000000
000034  b9e8              CBNZ     r0,|L14.114|
;;;1204          (hadc->Init.ContinuousConvMode == DISABLE)            &&
000036  7e20              LDRB     r0,[r4,#0x18]
000038  b9d8              CBNZ     r0,|L14.114|
;;;1205          (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
00003a  6820              LDR      r0,[r4,#0]
00003c  6ac0              LDR      r0,[r0,#0x2c]
00003e  f4000070          AND      r0,r0,#0xf00000
000042  b120              CBZ      r0,|L14.78|
;;;1206           HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  f4006080          AND      r0,r0,#0x400
00004c  b988              CBNZ     r0,|L14.114|
                  |L14.78|
;;;1207       {
;;;1208         /* Disable ADC end of single conversion interrupt on group regular */
;;;1209         /* Note: Overrun interrupt was enabled with EOC interrupt in          */
;;;1210         /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
;;;1211         /* by overrun IRQ process below.                                      */
;;;1212         __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
00004e  6820              LDR      r0,[r4,#0]
000050  6840              LDR      r0,[r0,#4]
000052  f0200020          BIC      r0,r0,#0x20
000056  6821              LDR      r1,[r4,#0]
000058  6048              STR      r0,[r1,#4]
;;;1213         
;;;1214         /* Set ADC state */
;;;1215         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f4207080          BIC      r0,r0,#0x100
000060  6420              STR      r0,[r4,#0x40]
;;;1216         
;;;1217         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
000062  6c20              LDR      r0,[r4,#0x40]
000064  f4005080          AND      r0,r0,#0x1000
000068  b918              CBNZ     r0,|L14.114|
;;;1218         {
;;;1219           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
00006a  6c20              LDR      r0,[r4,#0x40]
00006c  f0400001          ORR      r0,r0,#1
000070  6420              STR      r0,[r4,#0x40]
                  |L14.114|
;;;1220         }
;;;1221       }
;;;1222       
;;;1223       /* Conversion complete callback */
;;;1224   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1225       hadc->ConvCpltCallback(hadc);
;;;1226   #else
;;;1227       HAL_ADC_ConvCpltCallback(hadc);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1228   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1229       
;;;1230       /* Clear regular group conversion flag */
;;;1231       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
000078  f06f0012          MVN      r0,#0x12
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L14.128|
;;;1232     }
;;;1233     
;;;1234     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f3c00580          UBFX     r5,r0,#2,#1
;;;1235     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
000088  6820              LDR      r0,[r4,#0]
00008a  6840              LDR      r0,[r0,#4]
00008c  f3c016c0          UBFX     r6,r0,#7,#1
;;;1236     /* Check End of conversion flag for injected channels */
;;;1237     if(tmp1 && tmp2)
000090  b3e5              CBZ      r5,|L14.268|
000092  b3de              CBZ      r6,|L14.268|
;;;1238     {
;;;1239       /* Update state machine on conversion status if not in error state */
;;;1240       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
000094  6c20              LDR      r0,[r4,#0x40]
000096  f0000010          AND      r0,r0,#0x10
00009a  b918              CBNZ     r0,|L14.164|
;;;1241       {
;;;1242         /* Set ADC state */
;;;1243         SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
00009c  6c20              LDR      r0,[r4,#0x40]
00009e  f4405000          ORR      r0,r0,#0x2000
0000a2  6420              STR      r0,[r4,#0x40]
                  |L14.164|
;;;1244       }
;;;1245   
;;;1246       /* Determine whether any further conversion upcoming on group injected  */
;;;1247       /* by external trigger, scan sequence on going or by automatic injected */
;;;1248       /* conversion from group regular (same conditions as group regular      */
;;;1249       /* interruption disabling above).                                       */
;;;1250       if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6880              LDR      r0,[r0,#8]
0000a8  f4001040          AND      r0,r0,#0x300000
0000ac  bb38              CBNZ     r0,|L14.254|
;;;1251          (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
0000ae  6820              LDR      r0,[r4,#0]
0000b0  6b80              LDR      r0,[r0,#0x38]
0000b2  f4001040          AND      r0,r0,#0x300000
0000b6  b120              CBZ      r0,|L14.194|
;;;1252           HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6880              LDR      r0,[r0,#8]
0000bc  f4006080          AND      r0,r0,#0x400
0000c0  b9e8              CBNZ     r0,|L14.254|
                  |L14.194|
;;;1253          (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
0000c2  6820              LDR      r0,[r4,#0]
0000c4  6840              LDR      r0,[r0,#4]
0000c6  f4006080          AND      r0,r0,#0x400
0000ca  b9c0              CBNZ     r0,|L14.254|
;;;1254           (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
0000cc  6820              LDR      r0,[r4,#0]
0000ce  6880              LDR      r0,[r0,#8]
0000d0  f0005040          AND      r0,r0,#0x30000000
0000d4  b998              CBNZ     r0,|L14.254|
;;;1255           (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
0000d6  7e20              LDRB     r0,[r4,#0x18]
0000d8  b988              CBNZ     r0,|L14.254|
;;;1256       {
;;;1257         /* Disable ADC end of single conversion interrupt on group injected */
;;;1258         __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
0000da  6820              LDR      r0,[r4,#0]
0000dc  6840              LDR      r0,[r0,#4]
0000de  f0200080          BIC      r0,r0,#0x80
0000e2  6821              LDR      r1,[r4,#0]
0000e4  6048              STR      r0,[r1,#4]
;;;1259         
;;;1260         /* Set ADC state */
;;;1261         CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
0000e6  6c20              LDR      r0,[r4,#0x40]
0000e8  f4205080          BIC      r0,r0,#0x1000
0000ec  6420              STR      r0,[r4,#0x40]
;;;1262   
;;;1263         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
0000ee  6c20              LDR      r0,[r4,#0x40]
0000f0  f4007080          AND      r0,r0,#0x100
0000f4  b918              CBNZ     r0,|L14.254|
;;;1264         { 
;;;1265           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
0000f6  6c20              LDR      r0,[r4,#0x40]
0000f8  f0400001          ORR      r0,r0,#1
0000fc  6420              STR      r0,[r4,#0x40]
                  |L14.254|
;;;1266         }
;;;1267       }
;;;1268   
;;;1269       /* Conversion complete callback */ 
;;;1270       /* Conversion complete callback */ 
;;;1271   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1272         hadc->InjectedConvCpltCallback(hadc);
;;;1273   #else
;;;1274         HAL_ADCEx_InjectedConvCpltCallback(hadc);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;1275   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1276       
;;;1277       /* Clear injected group conversion flag */
;;;1278       __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
000104  f06f000c          MVN      r0,#0xc
000108  6821              LDR      r1,[r4,#0]
00010a  6008              STR      r0,[r1,#0]
                  |L14.268|
;;;1279     }
;;;1280     
;;;1281     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
00010c  6820              LDR      r0,[r4,#0]
00010e  6800              LDR      r0,[r0,#0]
000110  f0000501          AND      r5,r0,#1
;;;1282     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
000114  6820              LDR      r0,[r4,#0]
000116  6840              LDR      r0,[r0,#4]
000118  f3c01680          UBFX     r6,r0,#6,#1
;;;1283     /* Check Analog watchdog flag */
;;;1284     if(tmp1 && tmp2)
00011c  b185              CBZ      r5,|L14.320|
00011e  b17e              CBZ      r6,|L14.320|
;;;1285     {
;;;1286       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
000120  6820              LDR      r0,[r4,#0]
000122  6800              LDR      r0,[r0,#0]
000124  f0000001          AND      r0,r0,#1
000128  b150              CBZ      r0,|L14.320|
;;;1287       {
;;;1288         /* Set ADC state */
;;;1289         SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
00012a  6c20              LDR      r0,[r4,#0x40]
00012c  f4403080          ORR      r0,r0,#0x10000
000130  6420              STR      r0,[r4,#0x40]
;;;1290         
;;;1291         /* Level out of window callback */
;;;1292   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1293         hadc->LevelOutOfWindowCallback(hadc);
;;;1294   #else
;;;1295         HAL_ADC_LevelOutOfWindowCallback(hadc);
000132  4620              MOV      r0,r4
000134  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
;;;1296   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1297         
;;;1298         /* Clear the ADC analog watchdog flag */
;;;1299         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
000138  f06f0001          MVN      r0,#1
00013c  6821              LDR      r1,[r4,#0]
00013e  6008              STR      r0,[r1,#0]
                  |L14.320|
;;;1300       }
;;;1301     }
;;;1302     
;;;1303     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
000140  6820              LDR      r0,[r4,#0]
000142  6800              LDR      r0,[r0,#0]
000144  f3c01540          UBFX     r5,r0,#5,#1
;;;1304     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
000148  6820              LDR      r0,[r4,#0]
00014a  6840              LDR      r0,[r0,#4]
00014c  f3c06680          UBFX     r6,r0,#26,#1
;;;1305     /* Check Overrun flag */
;;;1306     if(tmp1 && tmp2)
000150  b17d              CBZ      r5,|L14.370|
000152  b176              CBZ      r6,|L14.370|
;;;1307     {
;;;1308       /* Note: On STM32F4, ADC overrun can be set through other parameters    */
;;;1309       /*       refer to description of parameter "EOCSelection" for more      */
;;;1310       /*       details.                                                       */
;;;1311       
;;;1312       /* Set ADC error code to overrun */
;;;1313       SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
000154  6c60              LDR      r0,[r4,#0x44]
000156  f0400002          ORR      r0,r0,#2
00015a  6460              STR      r0,[r4,#0x44]
;;;1314       
;;;1315       /* Clear ADC overrun flag */
;;;1316       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
00015c  f06f0020          MVN      r0,#0x20
000160  6821              LDR      r1,[r4,#0]
000162  6008              STR      r0,[r1,#0]
;;;1317       
;;;1318       /* Error callback */ 
;;;1319   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1320         hadc->ErrorCallback(hadc);
;;;1321   #else
;;;1322         HAL_ADC_ErrorCallback(hadc);
000164  4620              MOV      r0,r4
000166  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;1323   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1324       
;;;1325       /* Clear the Overrun flag */
;;;1326       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
00016a  f06f0020          MVN      r0,#0x20
00016e  6821              LDR      r1,[r4,#0]
000170  6008              STR      r0,[r1,#0]
                  |L14.370|
;;;1327     }
;;;1328   }
000172  bd70              POP      {r4-r6,pc}
;;;1329   
                          ENDP


                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Init PROC
;;;311      */
;;;312    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;313    {
000002  4604              MOV      r4,r0
;;;314      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;315      
;;;316      /* Check ADC handle */
;;;317      if(hadc == NULL)
000006  b90c              CBNZ     r4,|L15.12|
;;;318      {
;;;319        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L15.10|
;;;320      }
;;;321      
;;;322      /* Check the parameters */
;;;323      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;324      assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
;;;325      assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
;;;326      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ScanConvMode));
;;;327      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;328      assert_param(IS_ADC_EXT_TRIG(hadc->Init.ExternalTrigConv));
;;;329      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;330      assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;331      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;332      assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;333      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;334      
;;;335      if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
;;;336      {
;;;337        assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;338      }
;;;339      
;;;340      if(hadc->State == HAL_ADC_STATE_RESET)
;;;341      {
;;;342    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;343        /* Init the ADC Callback settings */
;;;344        hadc->ConvCpltCallback              = HAL_ADC_ConvCpltCallback;                 /* Legacy weak callback */
;;;345        hadc->ConvHalfCpltCallback          = HAL_ADC_ConvHalfCpltCallback;             /* Legacy weak callback */
;;;346        hadc->LevelOutOfWindowCallback      = HAL_ADC_LevelOutOfWindowCallback;         /* Legacy weak callback */
;;;347        hadc->ErrorCallback                 = HAL_ADC_ErrorCallback;                    /* Legacy weak callback */
;;;348        hadc->InjectedConvCpltCallback      = HAL_ADCEx_InjectedConvCpltCallback;       /* Legacy weak callback */
;;;349        if (hadc->MspInitCallback == NULL)
;;;350        {
;;;351          hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit  */
;;;352        }
;;;353    
;;;354        /* Init the low level hardware */
;;;355        hadc->MspInitCallback(hadc);
;;;356    #else
;;;357        /* Init the low level hardware */
;;;358        HAL_ADC_MspInit(hadc);
;;;359    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;360    
;;;361        /* Initialize ADC error code */
;;;362        ADC_CLEAR_ERRORCODE(hadc);
;;;363        
;;;364        /* Allocate lock resource and initialize it */
;;;365        hadc->Lock = HAL_UNLOCKED;
;;;366      }
;;;367      
;;;368      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;369      /* correctly completed.                                                     */
;;;370      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
;;;371      {
;;;372        /* Set ADC state */
;;;373        ADC_STATE_CLR_SET(hadc->State,
;;;374                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;375                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;376        
;;;377        /* Set ADC parameters */
;;;378        ADC_Init(hadc);
;;;379        
;;;380        /* Set ADC error code to none */
;;;381        ADC_CLEAR_ERRORCODE(hadc);
;;;382        
;;;383        /* Set the ADC state */
;;;384        ADC_STATE_CLR_SET(hadc->State,
;;;385                          HAL_ADC_STATE_BUSY_INTERNAL,
;;;386                          HAL_ADC_STATE_READY);
;;;387      }
;;;388      else
;;;389      {
;;;390        tmp_hal_status = HAL_ERROR;
;;;391      }
;;;392      
;;;393      /* Release Lock */
;;;394      __HAL_UNLOCK(hadc);
;;;395    
;;;396      /* Return function status */
;;;397      return tmp_hal_status;
;;;398    }
00000a  bd70              POP      {r4-r6,pc}
                  |L15.12|
00000c  4915              LDR      r1,|L15.100|
00000e  6aa0              LDR      r0,[r4,#0x28]         ;335
000010  4288              CMP      r0,r1                 ;335
000012  d000              BEQ      |L15.22|
000014  bf00              NOP                            ;337
                  |L15.22|
000016  6c20              LDR      r0,[r4,#0x40]         ;340
000018  b930              CBNZ     r0,|L15.40|
00001a  4620              MOV      r0,r4                 ;358
00001c  f7fffffe          BL       HAL_ADC_MspInit
000020  2000              MOVS     r0,#0                 ;362
000022  6460              STR      r0,[r4,#0x44]         ;362
000024  f884003c          STRB     r0,[r4,#0x3c]         ;365
                  |L15.40|
000028  6c20              LDR      r0,[r4,#0x40]         ;370
00002a  f0000010          AND      r0,r0,#0x10           ;370
00002e  b988              CBNZ     r0,|L15.84|
000030  6c20              LDR      r0,[r4,#0x40]         ;373
000032  f4205088          BIC      r0,r0,#0x1100         ;373
000036  f0400002          ORR      r0,r0,#2              ;373
00003a  6420              STR      r0,[r4,#0x40]         ;373
00003c  4620              MOV      r0,r4                 ;378
00003e  f7fffffe          BL       ADC_Init
000042  2000              MOVS     r0,#0                 ;381
000044  6460              STR      r0,[r4,#0x44]         ;381
000046  6c20              LDR      r0,[r4,#0x40]         ;384
000048  f0200002          BIC      r0,r0,#2              ;384
00004c  f0400001          ORR      r0,r0,#1              ;384
000050  6420              STR      r0,[r4,#0x40]         ;384
000052  e000              B        |L15.86|
                  |L15.84|
000054  2501              MOVS     r5,#1                 ;390
                  |L15.86|
000056  bf00              NOP                            ;394
000058  2000              MOVS     r0,#0                 ;394
00005a  f884003c          STRB     r0,[r4,#0x3c]         ;394
00005e  bf00              NOP                            ;394
000060  4628              MOV      r0,r5                 ;397
000062  e7d2              B        |L15.10|
;;;399    
                          ENDP

                  |L15.100|
                          DCD      0x0f000001

                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;1558     */
;;;1559   __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1560   {
;;;1561     /* Prevent unused argument(s) compilation warning */
;;;1562     UNUSED(hadc);
;;;1563     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1564               the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
;;;1565      */
;;;1566   }
;;;1567   
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;677      */
;;;678    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;679    {
;;;680      /* Prevent unused argument(s) compilation warning */
;;;681      UNUSED(hadc);
;;;682      /* NOTE : This function Should not be modified, when the callback is needed,
;;;683                the HAL_ADC_MspDeInit could be implemented in the user file
;;;684       */ 
;;;685    }
;;;686    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;662      */
;;;663    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;664    {
;;;665      /* Prevent unused argument(s) compilation warning */
;;;666      UNUSED(hadc);
;;;667      /* NOTE : This function Should not be modified, when the callback is needed,
;;;668                the HAL_ADC_MspInit could be implemented in the user file
;;;669       */ 
;;;670    }
;;;671    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForConversion PROC
;;;874      */
;;;875    HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;876    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;877      uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;878     
;;;879      /* Verification that ADC configuration is compliant with polling for      */
;;;880      /* each conversion:                                                       */
;;;881      /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
;;;882      /* several ranks and polling for end of each conversion.                  */
;;;883      /* For code simplicity sake, this particular case is generalized to       */
;;;884      /* ADC configured in DMA mode and polling for end of each conversion.     */
;;;885      if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
000008  6820              LDR      r0,[r4,#0]
00000a  6880              LDR      r0,[r0,#8]
00000c  f4006080          AND      r0,r0,#0x400
000010  f5b06f80          CMP      r0,#0x400
000014  d111              BNE      |L19.58|
;;;886          HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f4007080          AND      r0,r0,#0x100
00001e  f5b07f80          CMP      r0,#0x100
000022  d10a              BNE      |L19.58|
;;;887      {
;;;888        /* Update ADC state machine to error */
;;;889        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
000024  6c20              LDR      r0,[r4,#0x40]
000026  f0400020          ORR      r0,r0,#0x20
00002a  6420              STR      r0,[r4,#0x40]
;;;890        
;;;891        /* Process unlocked */
;;;892        __HAL_UNLOCK(hadc);
00002c  bf00              NOP      
00002e  2000              MOVS     r0,#0
000030  f884003c          STRB     r0,[r4,#0x3c]
000034  bf00              NOP      
;;;893        
;;;894        return HAL_ERROR;
000036  2001              MOVS     r0,#1
                  |L19.56|
;;;895      }
;;;896    
;;;897      /* Get tick */ 
;;;898      tickstart = HAL_GetTick();
;;;899    
;;;900      /* Check End of conversion flag */
;;;901      while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
;;;902      {
;;;903        /* Check if timeout is disabled (set to infinite wait) */
;;;904        if(Timeout != HAL_MAX_DELAY)
;;;905        {
;;;906          if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
;;;907          {
;;;908            /* Update ADC state machine to timeout */
;;;909            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;910            
;;;911            /* Process unlocked */
;;;912            __HAL_UNLOCK(hadc);
;;;913            
;;;914            return HAL_TIMEOUT;
;;;915          }
;;;916        }
;;;917      }
;;;918      
;;;919      /* Clear regular group conversion flag */
;;;920      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
;;;921      
;;;922      /* Update ADC state machine */
;;;923      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;924      
;;;925      /* Determine whether any further conversion upcoming on group regular       */
;;;926      /* by external trigger, continuous mode or scan sequence on going.          */
;;;927      /* Note: On STM32F4, there is no independent flag of end of sequence.       */
;;;928      /*       The test of scan sequence on going is done either with scan        */
;;;929      /*       sequence disabled or with end of conversion flag set to            */
;;;930      /*       of end of sequence.                                                */
;;;931      if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
;;;932         (hadc->Init.ContinuousConvMode == DISABLE)            &&
;;;933         (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
;;;934          HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
;;;935      {
;;;936        /* Set ADC state */
;;;937        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
;;;938        
;;;939        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;940        { 
;;;941          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;942        }
;;;943      }
;;;944      
;;;945      /* Return ADC state */
;;;946      return HAL_OK;
;;;947    }
000038  bd70              POP      {r4-r6,pc}
                  |L19.58|
00003a  f7fffffe          BL       HAL_GetTick
00003e  4606              MOV      r6,r0                 ;898
000040  e012              B        |L19.104|
                  |L19.66|
000042  1c68              ADDS     r0,r5,#1              ;904
000044  b180              CBZ      r0,|L19.104|
000046  b125              CBZ      r5,|L19.82|
000048  f7fffffe          BL       HAL_GetTick
00004c  1b80              SUBS     r0,r0,r6              ;906
00004e  42a8              CMP      r0,r5                 ;906
000050  d90a              BLS      |L19.104|
                  |L19.82|
000052  6c20              LDR      r0,[r4,#0x40]         ;909
000054  f0400004          ORR      r0,r0,#4              ;909
000058  6420              STR      r0,[r4,#0x40]         ;909
00005a  bf00              NOP                            ;912
00005c  2000              MOVS     r0,#0                 ;912
00005e  f884003c          STRB     r0,[r4,#0x3c]         ;912
000062  bf00              NOP                            ;912
000064  2003              MOVS     r0,#3                 ;914
000066  e7e7              B        |L19.56|
                  |L19.104|
000068  6820              LDR      r0,[r4,#0]            ;901
00006a  6800              LDR      r0,[r0,#0]            ;901
00006c  f0000002          AND      r0,r0,#2              ;901
000070  2802              CMP      r0,#2                 ;901
000072  d1e6              BNE      |L19.66|
000074  f06f0012          MVN      r0,#0x12              ;920
000078  6821              LDR      r1,[r4,#0]            ;920
00007a  6008              STR      r0,[r1,#0]            ;920
00007c  6c20              LDR      r0,[r4,#0x40]         ;923
00007e  f4407000          ORR      r0,r0,#0x200          ;923
000082  6420              STR      r0,[r4,#0x40]         ;923
000084  6820              LDR      r0,[r4,#0]            ;931
000086  6880              LDR      r0,[r0,#8]            ;931
000088  f0005040          AND      r0,r0,#0x30000000     ;931
00008c  b9b8              CBNZ     r0,|L19.190|
00008e  7e20              LDRB     r0,[r4,#0x18]         ;932
000090  b9a8              CBNZ     r0,|L19.190|
000092  6820              LDR      r0,[r4,#0]            ;933
000094  6ac0              LDR      r0,[r0,#0x2c]         ;933
000096  f4000070          AND      r0,r0,#0xf00000       ;933
00009a  b120              CBZ      r0,|L19.166|
00009c  6820              LDR      r0,[r4,#0]            ;934
00009e  6880              LDR      r0,[r0,#8]            ;934
0000a0  f4006080          AND      r0,r0,#0x400          ;934
0000a4  b958              CBNZ     r0,|L19.190|
                  |L19.166|
0000a6  6c20              LDR      r0,[r4,#0x40]         ;937
0000a8  f4207080          BIC      r0,r0,#0x100          ;937
0000ac  6420              STR      r0,[r4,#0x40]         ;937
0000ae  6c20              LDR      r0,[r4,#0x40]         ;939
0000b0  f4005080          AND      r0,r0,#0x1000         ;939
0000b4  b918              CBNZ     r0,|L19.190|
0000b6  6c20              LDR      r0,[r4,#0x40]         ;941
0000b8  f0400001          ORR      r0,r0,#1              ;941
0000bc  6420              STR      r0,[r4,#0x40]         ;941
                  |L19.190|
0000be  2000              MOVS     r0,#0                 ;946
0000c0  e7ba              B        |L19.56|
;;;948    
                          ENDP


                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;959      */
;;;960    HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;961    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;962      uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;963      
;;;964      /* Check the parameters */
;;;965      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;966      assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;967    
;;;968      /* Get tick */
;;;969      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4607              MOV      r7,r0
;;;970    
;;;971      /* Check selected event flag */
;;;972      while(!(__HAL_ADC_GET_FLAG(hadc,EventType)))
000012  e013              B        |L20.60|
                  |L20.20|
;;;973      {
;;;974        /* Check for the Timeout */
;;;975        if(Timeout != HAL_MAX_DELAY)
000014  1c70              ADDS     r0,r6,#1
000016  b188              CBZ      r0,|L20.60|
;;;976        {
;;;977          if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
000018  b126              CBZ      r6,|L20.36|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1bc0              SUBS     r0,r0,r7
000020  42b0              CMP      r0,r6
000022  d90b              BLS      |L20.60|
                  |L20.36|
;;;978          {
;;;979            /* Update ADC state machine to timeout */
;;;980            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
000024  6c20              LDR      r0,[r4,#0x40]
000026  f0400004          ORR      r0,r0,#4
00002a  6420              STR      r0,[r4,#0x40]
;;;981            
;;;982            /* Process unlocked */
;;;983            __HAL_UNLOCK(hadc);
00002c  bf00              NOP      
00002e  2000              MOVS     r0,#0
000030  f884003c          STRB     r0,[r4,#0x3c]
000034  bf00              NOP      
;;;984            
;;;985            return HAL_TIMEOUT;
000036  2003              MOVS     r0,#3
                  |L20.56|
;;;986          }
;;;987        }
;;;988      }
;;;989      
;;;990      /* Analog watchdog (level out of window) event */
;;;991      if(EventType == ADC_AWD_EVENT)
;;;992      {
;;;993        /* Set ADC state */
;;;994        SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;995          
;;;996        /* Clear ADC analog watchdog flag */
;;;997        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;998      }
;;;999      /* Overrun event */
;;;1000     else
;;;1001     {
;;;1002       /* Set ADC state */
;;;1003       SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
;;;1004       /* Set ADC error code to overrun */
;;;1005       SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
;;;1006       
;;;1007       /* Clear ADC overrun flag */
;;;1008       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
;;;1009     }
;;;1010     
;;;1011     /* Return ADC state */
;;;1012     return HAL_OK;
;;;1013   }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L20.60|
00003c  6820              LDR      r0,[r4,#0]            ;972
00003e  6800              LDR      r0,[r0,#0]            ;972
000040  4028              ANDS     r0,r0,r5              ;972
000042  42a8              CMP      r0,r5                 ;972
000044  d1e6              BNE      |L20.20|
000046  2d01              CMP      r5,#1                 ;991
000048  d107              BNE      |L20.90|
00004a  6c20              LDR      r0,[r4,#0x40]         ;994
00004c  f4403080          ORR      r0,r0,#0x10000        ;994
000050  6420              STR      r0,[r4,#0x40]         ;994
000052  1ee8              SUBS     r0,r5,#3              ;997
000054  6821              LDR      r1,[r4,#0]            ;997
000056  6008              STR      r0,[r1,#0]            ;997
000058  e00b              B        |L20.114|
                  |L20.90|
00005a  6c20              LDR      r0,[r4,#0x40]         ;1003
00005c  f4406080          ORR      r0,r0,#0x400          ;1003
000060  6420              STR      r0,[r4,#0x40]         ;1003
000062  6c60              LDR      r0,[r4,#0x44]         ;1005
000064  f0400002          ORR      r0,r0,#2              ;1005
000068  6460              STR      r0,[r4,#0x44]         ;1005
00006a  f06f0020          MVN      r0,#0x20              ;1008
00006e  6821              LDR      r1,[r4,#0]            ;1008
000070  6008              STR      r0,[r1,#0]            ;1008
                  |L20.114|
000072  2000              MOVS     r0,#0                 ;1012
000074  e7e0              B        |L20.56|
;;;1014   
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;716      */
;;;717    HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
000000  b508              PUSH     {r3,lr}
;;;718    {
000002  4601              MOV      r1,r0
;;;719      __IO uint32_t counter = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;720      ADC_Common_TypeDef *tmpADC_Common;
;;;721      
;;;722      /* Check the parameters */
;;;723      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;724      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;725      
;;;726      /* Process locked */
;;;727      __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f891003c          LDRB     r0,[r1,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L21.22|
000012  2002              MOVS     r0,#2
                  |L21.20|
;;;728      
;;;729      /* Enable the ADC peripheral */
;;;730      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;731      Tstab time the ADC's stabilization */
;;;732      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;733      {  
;;;734        /* Enable the Peripheral */
;;;735        __HAL_ADC_ENABLE(hadc);
;;;736        
;;;737        /* Delay for ADC stabilization time */
;;;738        /* Compute number of CPU cycles to wait for */
;;;739        counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
;;;740        while(counter != 0U)
;;;741        {
;;;742          counter--;
;;;743        }
;;;744      }
;;;745      
;;;746      /* Start conversion if ADC is effectively enabled */
;;;747      if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
;;;748      {
;;;749        /* Set ADC state                                                          */
;;;750        /* - Clear state bitfield related to regular group conversion results     */
;;;751        /* - Set state bitfield related to regular group operation                */
;;;752        ADC_STATE_CLR_SET(hadc->State,
;;;753                          HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
;;;754                          HAL_ADC_STATE_REG_BUSY);
;;;755        
;;;756        /* If conversions on group regular are also triggering group injected,    */
;;;757        /* update ADC state.                                                      */
;;;758        if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;759        {
;;;760          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;761        }
;;;762        
;;;763        /* State machine update: Check if an injected conversion is ongoing */
;;;764        if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;765        {
;;;766          /* Reset ADC error code fields related to conversions on group regular */
;;;767          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;768        }
;;;769        else
;;;770        {
;;;771          /* Reset ADC all error code fields */
;;;772          ADC_CLEAR_ERRORCODE(hadc);
;;;773        } 
;;;774    
;;;775        /* Process unlocked */
;;;776        /* Unlock before starting ADC conversions: in case of potential           */
;;;777        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;778        __HAL_UNLOCK(hadc);
;;;779    
;;;780        /* Pointer to the common control register to which is belonging hadc    */
;;;781        /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;782        /* control register)                                                    */
;;;783        tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;784    
;;;785        /* Clear regular group conversion flag and overrun flag */
;;;786        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;787        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
;;;788        
;;;789        /* Check if Multimode enabled */
;;;790        if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
;;;791        {
;;;792    #if defined(ADC2) && defined(ADC3)
;;;793          if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
;;;794                                      || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
;;;795          {
;;;796    #endif /* ADC2 || ADC3 */
;;;797            /* if no external trigger present enable software conversion of regular channels */
;;;798            if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;799            {
;;;800              /* Enable the selected ADC software conversion for regular group */
;;;801              hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;802            }
;;;803    #if defined(ADC2) && defined(ADC3)
;;;804          }
;;;805    #endif /* ADC2 || ADC3 */
;;;806        }
;;;807        else
;;;808        {
;;;809          /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;810          if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;811          {
;;;812            /* Enable the selected ADC software conversion for regular group */
;;;813              hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;814          }
;;;815        }
;;;816      }
;;;817      
;;;818      /* Return function status */
;;;819      return HAL_OK;
;;;820    }
000014  bd08              POP      {r3,pc}
                  |L21.22|
000016  2001              MOVS     r0,#1                 ;727
000018  f881003c          STRB     r0,[r1,#0x3c]         ;727
00001c  bf00              NOP                            ;727
00001e  6808              LDR      r0,[r1,#0]            ;732
000020  6880              LDR      r0,[r0,#8]            ;732
000022  f0000001          AND      r0,r0,#1              ;732
000026  b9a0              CBNZ     r0,|L21.82|
000028  6808              LDR      r0,[r1,#0]            ;735
00002a  6880              LDR      r0,[r0,#8]            ;735
00002c  f0400001          ORR      r0,r0,#1              ;735
000030  680b              LDR      r3,[r1,#0]            ;735
000032  6098              STR      r0,[r3,#8]            ;735
000034  482f              LDR      r0,|L21.244|
000036  6800              LDR      r0,[r0,#0]            ;739  ; SystemCoreClock
000038  4b2f              LDR      r3,|L21.248|
00003a  fbb0f0f3          UDIV     r0,r0,r3              ;739
00003e  eb000040          ADD      r0,r0,r0,LSL #1       ;739
000042  9000              STR      r0,[sp,#0]            ;739
000044  e002              B        |L21.76|
                  |L21.70|
000046  9800              LDR      r0,[sp,#0]            ;742
000048  1e40              SUBS     r0,r0,#1              ;742
00004a  9000              STR      r0,[sp,#0]            ;742
                  |L21.76|
00004c  9800              LDR      r0,[sp,#0]            ;740
00004e  2800              CMP      r0,#0                 ;740
000050  d1f9              BNE      |L21.70|
                  |L21.82|
000052  6808              LDR      r0,[r1,#0]            ;747
000054  6880              LDR      r0,[r0,#8]            ;747
000056  f0000001          AND      r0,r0,#1              ;747
00005a  2800              CMP      r0,#0                 ;747
00005c  d047              BEQ      |L21.238|
00005e  6c08              LDR      r0,[r1,#0x40]         ;752
000060  f2406301          MOV      r3,#0x601             ;752
000064  4398              BICS     r0,r0,r3              ;752
000066  f4407080          ORR      r0,r0,#0x100          ;752
00006a  6408              STR      r0,[r1,#0x40]         ;752
00006c  6808              LDR      r0,[r1,#0]            ;758
00006e  6840              LDR      r0,[r0,#4]            ;758
000070  f4006080          AND      r0,r0,#0x400          ;758
000074  b128              CBZ      r0,|L21.130|
000076  6c08              LDR      r0,[r1,#0x40]         ;760
000078  f4205000          BIC      r0,r0,#0x2000         ;760
00007c  f4405080          ORR      r0,r0,#0x1000         ;760
000080  6408              STR      r0,[r1,#0x40]         ;760
                  |L21.130|
000082  6c08              LDR      r0,[r1,#0x40]         ;764
000084  f4005080          AND      r0,r0,#0x1000         ;764
000088  f5b05f80          CMP      r0,#0x1000            ;764
00008c  d104              BNE      |L21.152|
00008e  6c48              LDR      r0,[r1,#0x44]         ;767
000090  f0200006          BIC      r0,r0,#6              ;767
000094  6448              STR      r0,[r1,#0x44]         ;767
000096  e001              B        |L21.156|
                  |L21.152|
000098  2000              MOVS     r0,#0                 ;772
00009a  6448              STR      r0,[r1,#0x44]         ;772
                  |L21.156|
00009c  bf00              NOP                            ;778
00009e  2000              MOVS     r0,#0                 ;778
0000a0  f881003c          STRB     r0,[r1,#0x3c]         ;778
0000a4  bf00              NOP                            ;778
0000a6  4a15              LDR      r2,|L21.252|
0000a8  f06f0022          MVN      r0,#0x22              ;787
0000ac  680b              LDR      r3,[r1,#0]            ;787
0000ae  6018              STR      r0,[r3,#0]            ;787
0000b0  6850              LDR      r0,[r2,#4]            ;790
0000b2  f000001f          AND      r0,r0,#0x1f           ;790
0000b6  b958              CBNZ     r0,|L21.208|
0000b8  6808              LDR      r0,[r1,#0]            ;798
0000ba  6880              LDR      r0,[r0,#8]            ;798
0000bc  f0005040          AND      r0,r0,#0x30000000     ;798
0000c0  b9a8              CBNZ     r0,|L21.238|
0000c2  6808              LDR      r0,[r1,#0]            ;801
0000c4  6880              LDR      r0,[r0,#8]            ;801
0000c6  f0404080          ORR      r0,r0,#0x40000000     ;801
0000ca  680b              LDR      r3,[r1,#0]            ;801
0000cc  6098              STR      r0,[r3,#8]            ;801
0000ce  e00e              B        |L21.238|
                  |L21.208|
0000d0  4b0b              LDR      r3,|L21.256|
0000d2  6808              LDR      r0,[r1,#0]            ;810
0000d4  4298              CMP      r0,r3                 ;810
0000d6  d10a              BNE      |L21.238|
0000d8  6808              LDR      r0,[r1,#0]            ;810
0000da  6880              LDR      r0,[r0,#8]            ;810
0000dc  f0005040          AND      r0,r0,#0x30000000     ;810
0000e0  b928              CBNZ     r0,|L21.238|
0000e2  6808              LDR      r0,[r1,#0]            ;813
0000e4  6880              LDR      r0,[r0,#8]            ;813
0000e6  f0404080          ORR      r0,r0,#0x40000000     ;813
0000ea  680b              LDR      r3,[r1,#0]            ;813
0000ec  6098              STR      r0,[r3,#8]            ;813
                  |L21.238|
0000ee  2000              MOVS     r0,#0                 ;819
0000f0  e790              B        |L21.20|
;;;821    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L21.244|
                          DCD      SystemCoreClock
                  |L21.248|
                          DCD      0x000f4240
                  |L21.252|
                          DCD      0x40012300
                  |L21.256|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;1337     */
;;;1338   HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1339   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1340     __IO uint32_t counter = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1341     ADC_Common_TypeDef *tmpADC_Common;
;;;1342     
;;;1343     /* Check the parameters */
;;;1344     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1345     assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;1346     
;;;1347     /* Process locked */
;;;1348     __HAL_LOCK(hadc);
00000c  bf00              NOP      
00000e  f894003c          LDRB     r0,[r4,#0x3c]
000012  2801              CMP      r0,#1
000014  d101              BNE      |L22.26|
000016  2002              MOVS     r0,#2
                  |L22.24|
;;;1349     
;;;1350     /* Enable the ADC peripheral */
;;;1351     /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;1352     Tstab time the ADC's stabilization */
;;;1353     if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;1354     {  
;;;1355       /* Enable the Peripheral */
;;;1356       __HAL_ADC_ENABLE(hadc);
;;;1357       
;;;1358       /* Delay for ADC stabilization time */
;;;1359       /* Compute number of CPU cycles to wait for */
;;;1360       counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
;;;1361       while(counter != 0U)
;;;1362       {
;;;1363         counter--;
;;;1364       }
;;;1365     }
;;;1366     
;;;1367     /* Start conversion if ADC is effectively enabled */
;;;1368     if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1369     {
;;;1370       /* Set ADC state                                                          */
;;;1371       /* - Clear state bitfield related to regular group conversion results     */
;;;1372       /* - Set state bitfield related to regular group operation                */
;;;1373       ADC_STATE_CLR_SET(hadc->State,
;;;1374                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
;;;1375                         HAL_ADC_STATE_REG_BUSY);
;;;1376       
;;;1377       /* If conversions on group regular are also triggering group injected,    */
;;;1378       /* update ADC state.                                                      */
;;;1379       if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1380       {
;;;1381         ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1382       }
;;;1383       
;;;1384       /* State machine update: Check if an injected conversion is ongoing */
;;;1385       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1386       {
;;;1387         /* Reset ADC error code fields related to conversions on group regular */
;;;1388         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1389       }
;;;1390       else
;;;1391       {
;;;1392         /* Reset ADC all error code fields */
;;;1393         ADC_CLEAR_ERRORCODE(hadc);
;;;1394       }
;;;1395   
;;;1396       /* Process unlocked */
;;;1397       /* Unlock before starting ADC conversions: in case of potential           */
;;;1398       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1399       __HAL_UNLOCK(hadc);   
;;;1400   
;;;1401       /* Pointer to the common control register to which is belonging hadc    */
;;;1402       /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1403       /* control register)                                                    */
;;;1404       tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1405   
;;;1406       /* Set the DMA transfer complete callback */
;;;1407       hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;1408   
;;;1409       /* Set the DMA half transfer complete callback */
;;;1410       hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;1411       
;;;1412       /* Set the DMA error callback */
;;;1413       hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;1414   
;;;1415       
;;;1416       /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
;;;1417       /* start (in case of SW start):                                           */
;;;1418       
;;;1419       /* Clear regular group conversion flag and overrun flag */
;;;1420       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1421       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
;;;1422   
;;;1423       /* Enable ADC overrun interrupt */
;;;1424       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;1425       
;;;1426       /* Enable ADC DMA mode */
;;;1427       hadc->Instance->CR2 |= ADC_CR2_DMA;
;;;1428       
;;;1429       /* Start the DMA channel */
;;;1430       HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;1431       
;;;1432       /* Check if Multimode enabled */
;;;1433       if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
;;;1434       {
;;;1435   #if defined(ADC2) && defined(ADC3)
;;;1436         if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
;;;1437                                     || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
;;;1438         {
;;;1439   #endif /* ADC2 || ADC3 */
;;;1440           /* if no external trigger present enable software conversion of regular channels */
;;;1441           if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;1442           {
;;;1443             /* Enable the selected ADC software conversion for regular group */
;;;1444             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1445           }
;;;1446   #if defined(ADC2) && defined(ADC3)
;;;1447         }
;;;1448   #endif /* ADC2 || ADC3 */
;;;1449       }
;;;1450       else
;;;1451       {
;;;1452         /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;1453         if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;1454         {
;;;1455           /* Enable the selected ADC software conversion for regular group */
;;;1456             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1457         }
;;;1458       }
;;;1459     }
;;;1460     
;;;1461     /* Return function status */
;;;1462     return HAL_OK;
;;;1463   }
000018  bdf8              POP      {r3-r7,pc}
                  |L22.26|
00001a  2001              MOVS     r0,#1                 ;1348
00001c  f884003c          STRB     r0,[r4,#0x3c]         ;1348
000020  bf00              NOP                            ;1348
000022  6820              LDR      r0,[r4,#0]            ;1353
000024  6880              LDR      r0,[r0,#8]            ;1353
000026  f0000001          AND      r0,r0,#1              ;1353
00002a  b9a0              CBNZ     r0,|L22.86|
00002c  6820              LDR      r0,[r4,#0]            ;1356
00002e  6880              LDR      r0,[r0,#8]            ;1356
000030  f0400001          ORR      r0,r0,#1              ;1356
000034  6821              LDR      r1,[r4,#0]            ;1356
000036  6088              STR      r0,[r1,#8]            ;1356
000038  483d              LDR      r0,|L22.304|
00003a  6800              LDR      r0,[r0,#0]            ;1360  ; SystemCoreClock
00003c  493d              LDR      r1,|L22.308|
00003e  fbb0f0f1          UDIV     r0,r0,r1              ;1360
000042  eb000040          ADD      r0,r0,r0,LSL #1       ;1360
000046  9000              STR      r0,[sp,#0]            ;1360
000048  e002              B        |L22.80|
                  |L22.74|
00004a  9800              LDR      r0,[sp,#0]            ;1363
00004c  1e40              SUBS     r0,r0,#1              ;1363
00004e  9000              STR      r0,[sp,#0]            ;1363
                  |L22.80|
000050  9800              LDR      r0,[sp,#0]            ;1361
000052  2800              CMP      r0,#0                 ;1361
000054  d1f9              BNE      |L22.74|
                  |L22.86|
000056  6820              LDR      r0,[r4,#0]            ;1368
000058  6880              LDR      r0,[r0,#8]            ;1368
00005a  f0000001          AND      r0,r0,#1              ;1368
00005e  2800              CMP      r0,#0                 ;1368
000060  d064              BEQ      |L22.300|
000062  6c20              LDR      r0,[r4,#0x40]         ;1373
000064  f2406101          MOV      r1,#0x601             ;1373
000068  4388              BICS     r0,r0,r1              ;1373
00006a  f4407080          ORR      r0,r0,#0x100          ;1373
00006e  6420              STR      r0,[r4,#0x40]         ;1373
000070  6820              LDR      r0,[r4,#0]            ;1379
000072  6840              LDR      r0,[r0,#4]            ;1379
000074  f4006080          AND      r0,r0,#0x400          ;1379
000078  b128              CBZ      r0,|L22.134|
00007a  6c20              LDR      r0,[r4,#0x40]         ;1381
00007c  f4205000          BIC      r0,r0,#0x2000         ;1381
000080  f4405080          ORR      r0,r0,#0x1000         ;1381
000084  6420              STR      r0,[r4,#0x40]         ;1381
                  |L22.134|
000086  6c20              LDR      r0,[r4,#0x40]         ;1385
000088  f4005080          AND      r0,r0,#0x1000         ;1385
00008c  f5b05f80          CMP      r0,#0x1000            ;1385
000090  d104              BNE      |L22.156|
000092  6c60              LDR      r0,[r4,#0x44]         ;1388
000094  f0200006          BIC      r0,r0,#6              ;1388
000098  6460              STR      r0,[r4,#0x44]         ;1388
00009a  e001              B        |L22.160|
                  |L22.156|
00009c  2000              MOVS     r0,#0                 ;1393
00009e  6460              STR      r0,[r4,#0x44]         ;1393
                  |L22.160|
0000a0  bf00              NOP                            ;1399
0000a2  2000              MOVS     r0,#0                 ;1399
0000a4  f884003c          STRB     r0,[r4,#0x3c]         ;1399
0000a8  bf00              NOP                            ;1399
0000aa  4f23              LDR      r7,|L22.312|
0000ac  4823              LDR      r0,|L22.316|
0000ae  6ba1              LDR      r1,[r4,#0x38]         ;1407
0000b0  63c8              STR      r0,[r1,#0x3c]         ;1407
0000b2  4823              LDR      r0,|L22.320|
0000b4  6ba1              LDR      r1,[r4,#0x38]         ;1410
0000b6  6408              STR      r0,[r1,#0x40]         ;1410
0000b8  4822              LDR      r0,|L22.324|
0000ba  6ba1              LDR      r1,[r4,#0x38]         ;1413
0000bc  64c8              STR      r0,[r1,#0x4c]         ;1413
0000be  f06f0022          MVN      r0,#0x22              ;1421
0000c2  6821              LDR      r1,[r4,#0]            ;1421
0000c4  6008              STR      r0,[r1,#0]            ;1421
0000c6  6820              LDR      r0,[r4,#0]            ;1424
0000c8  6840              LDR      r0,[r0,#4]            ;1424
0000ca  f0406080          ORR      r0,r0,#0x4000000      ;1424
0000ce  6821              LDR      r1,[r4,#0]            ;1424
0000d0  6048              STR      r0,[r1,#4]            ;1424
0000d2  6820              LDR      r0,[r4,#0]            ;1427
0000d4  6880              LDR      r0,[r0,#8]            ;1427
0000d6  f4407080          ORR      r0,r0,#0x100          ;1427
0000da  6821              LDR      r1,[r4,#0]            ;1427
0000dc  6088              STR      r0,[r1,#8]            ;1427
0000de  6822              LDR      r2,[r4,#0]            ;1430
0000e0  f102014c          ADD      r1,r2,#0x4c           ;1430
0000e4  4633              MOV      r3,r6                 ;1430
0000e6  462a              MOV      r2,r5                 ;1430
0000e8  6ba0              LDR      r0,[r4,#0x38]         ;1430
0000ea  f7fffffe          BL       HAL_DMA_Start_IT
0000ee  6878              LDR      r0,[r7,#4]            ;1433
0000f0  f000001f          AND      r0,r0,#0x1f           ;1433
0000f4  b958              CBNZ     r0,|L22.270|
0000f6  6820              LDR      r0,[r4,#0]            ;1441
0000f8  6880              LDR      r0,[r0,#8]            ;1441
0000fa  f0005040          AND      r0,r0,#0x30000000     ;1441
0000fe  b928              CBNZ     r0,|L22.268|
000100  6820              LDR      r0,[r4,#0]            ;1444
000102  6880              LDR      r0,[r0,#8]            ;1444
000104  f0404080          ORR      r0,r0,#0x40000000     ;1444
000108  6821              LDR      r1,[r4,#0]            ;1444
00010a  6088              STR      r0,[r1,#8]            ;1444
                  |L22.268|
00010c  e00e              B        |L22.300|
                  |L22.270|
00010e  490e              LDR      r1,|L22.328|
000110  6820              LDR      r0,[r4,#0]            ;1453
000112  4288              CMP      r0,r1                 ;1453
000114  d10a              BNE      |L22.300|
000116  6820              LDR      r0,[r4,#0]            ;1453
000118  6880              LDR      r0,[r0,#8]            ;1453
00011a  f0005040          AND      r0,r0,#0x30000000     ;1453
00011e  b928              CBNZ     r0,|L22.300|
000120  6820              LDR      r0,[r4,#0]            ;1456
000122  6880              LDR      r0,[r0,#8]            ;1456
000124  f0404080          ORR      r0,r0,#0x40000000     ;1456
000128  6821              LDR      r1,[r4,#0]            ;1456
00012a  6088              STR      r0,[r1,#8]            ;1456
                  |L22.300|
00012c  2000              MOVS     r0,#0                 ;1462
00012e  e773              B        |L22.24|
;;;1464   
                          ENDP

                  |L22.304|
                          DCD      SystemCoreClock
                  |L22.308|
                          DCD      0x000f4240
                  |L22.312|
                          DCD      0x40012300
                  |L22.316|
                          DCD      ADC_DMAConvCplt
                  |L22.320|
                          DCD      ADC_DMAHalfConvCplt
                  |L22.324|
                          DCD      ADC_DMAError
                  |L22.328|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;1021     */
;;;1022   HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000000  b508              PUSH     {r3,lr}
;;;1023   {
000002  4601              MOV      r1,r0
;;;1024     __IO uint32_t counter = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1025     ADC_Common_TypeDef *tmpADC_Common;
;;;1026     
;;;1027     /* Check the parameters */
;;;1028     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1029     assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;1030     
;;;1031     /* Process locked */
;;;1032     __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f891003c          LDRB     r0,[r1,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L23.22|
000012  2002              MOVS     r0,#2
                  |L23.20|
;;;1033     
;;;1034     /* Enable the ADC peripheral */
;;;1035     /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;1036     Tstab time the ADC's stabilization */
;;;1037     if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;1038     {  
;;;1039       /* Enable the Peripheral */
;;;1040       __HAL_ADC_ENABLE(hadc);
;;;1041       
;;;1042       /* Delay for ADC stabilization time */
;;;1043       /* Compute number of CPU cycles to wait for */
;;;1044       counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
;;;1045       while(counter != 0U)
;;;1046       {
;;;1047         counter--;
;;;1048       }
;;;1049     }
;;;1050     
;;;1051     /* Start conversion if ADC is effectively enabled */
;;;1052     if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1053     {
;;;1054       /* Set ADC state                                                          */
;;;1055       /* - Clear state bitfield related to regular group conversion results     */
;;;1056       /* - Set state bitfield related to regular group operation                */
;;;1057       ADC_STATE_CLR_SET(hadc->State,
;;;1058                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
;;;1059                         HAL_ADC_STATE_REG_BUSY);
;;;1060       
;;;1061       /* If conversions on group regular are also triggering group injected,    */
;;;1062       /* update ADC state.                                                      */
;;;1063       if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1064       {
;;;1065         ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1066       }
;;;1067       
;;;1068       /* State machine update: Check if an injected conversion is ongoing */
;;;1069       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1070       {
;;;1071         /* Reset ADC error code fields related to conversions on group regular */
;;;1072         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1073       }
;;;1074       else
;;;1075       {
;;;1076         /* Reset ADC all error code fields */
;;;1077         ADC_CLEAR_ERRORCODE(hadc);
;;;1078       }
;;;1079   
;;;1080       /* Process unlocked */
;;;1081       /* Unlock before starting ADC conversions: in case of potential           */
;;;1082       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1083       __HAL_UNLOCK(hadc);
;;;1084   
;;;1085       /* Pointer to the common control register to which is belonging hadc    */
;;;1086       /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1087       /* control register)                                                    */
;;;1088       tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1089   
;;;1090       /* Clear regular group conversion flag and overrun flag */
;;;1091       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1092       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
;;;1093       
;;;1094       /* Enable end of conversion interrupt for regular group */
;;;1095       __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
;;;1096       
;;;1097       /* Check if Multimode enabled */
;;;1098       if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
;;;1099       {
;;;1100   #if defined(ADC2) && defined(ADC3)
;;;1101         if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
;;;1102                                     || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
;;;1103         {
;;;1104   #endif /* ADC2 || ADC3 */
;;;1105           /* if no external trigger present enable software conversion of regular channels */
;;;1106           if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;1107           {
;;;1108             /* Enable the selected ADC software conversion for regular group */
;;;1109             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1110           }
;;;1111   #if defined(ADC2) && defined(ADC3)
;;;1112         }
;;;1113   #endif /* ADC2 || ADC3 */
;;;1114       }
;;;1115       else
;;;1116       {
;;;1117         /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;1118         if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;1119         {
;;;1120           /* Enable the selected ADC software conversion for regular group */
;;;1121             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1122         }
;;;1123       }
;;;1124     }
;;;1125     
;;;1126     /* Return function status */
;;;1127     return HAL_OK;
;;;1128   }
000014  bd08              POP      {r3,pc}
                  |L23.22|
000016  2001              MOVS     r0,#1                 ;1032
000018  f881003c          STRB     r0,[r1,#0x3c]         ;1032
00001c  bf00              NOP                            ;1032
00001e  6808              LDR      r0,[r1,#0]            ;1037
000020  6880              LDR      r0,[r0,#8]            ;1037
000022  f0000001          AND      r0,r0,#1              ;1037
000026  b9a0              CBNZ     r0,|L23.82|
000028  6808              LDR      r0,[r1,#0]            ;1040
00002a  6880              LDR      r0,[r0,#8]            ;1040
00002c  f0400001          ORR      r0,r0,#1              ;1040
000030  680b              LDR      r3,[r1,#0]            ;1040
000032  6098              STR      r0,[r3,#8]            ;1040
000034  4832              LDR      r0,|L23.256|
000036  6800              LDR      r0,[r0,#0]            ;1044  ; SystemCoreClock
000038  4b32              LDR      r3,|L23.260|
00003a  fbb0f0f3          UDIV     r0,r0,r3              ;1044
00003e  eb000040          ADD      r0,r0,r0,LSL #1       ;1044
000042  9000              STR      r0,[sp,#0]            ;1044
000044  e002              B        |L23.76|
                  |L23.70|
000046  9800              LDR      r0,[sp,#0]            ;1047
000048  1e40              SUBS     r0,r0,#1              ;1047
00004a  9000              STR      r0,[sp,#0]            ;1047
                  |L23.76|
00004c  9800              LDR      r0,[sp,#0]            ;1045
00004e  2800              CMP      r0,#0                 ;1045
000050  d1f9              BNE      |L23.70|
                  |L23.82|
000052  6808              LDR      r0,[r1,#0]            ;1052
000054  6880              LDR      r0,[r0,#8]            ;1052
000056  f0000001          AND      r0,r0,#1              ;1052
00005a  2800              CMP      r0,#0                 ;1052
00005c  d04d              BEQ      |L23.250|
00005e  6c08              LDR      r0,[r1,#0x40]         ;1057
000060  f2406301          MOV      r3,#0x601             ;1057
000064  4398              BICS     r0,r0,r3              ;1057
000066  f4407080          ORR      r0,r0,#0x100          ;1057
00006a  6408              STR      r0,[r1,#0x40]         ;1057
00006c  6808              LDR      r0,[r1,#0]            ;1063
00006e  6840              LDR      r0,[r0,#4]            ;1063
000070  f4006080          AND      r0,r0,#0x400          ;1063
000074  b128              CBZ      r0,|L23.130|
000076  6c08              LDR      r0,[r1,#0x40]         ;1065
000078  f4205000          BIC      r0,r0,#0x2000         ;1065
00007c  f4405080          ORR      r0,r0,#0x1000         ;1065
000080  6408              STR      r0,[r1,#0x40]         ;1065
                  |L23.130|
000082  6c08              LDR      r0,[r1,#0x40]         ;1069
000084  f4005080          AND      r0,r0,#0x1000         ;1069
000088  f5b05f80          CMP      r0,#0x1000            ;1069
00008c  d104              BNE      |L23.152|
00008e  6c48              LDR      r0,[r1,#0x44]         ;1072
000090  f0200006          BIC      r0,r0,#6              ;1072
000094  6448              STR      r0,[r1,#0x44]         ;1072
000096  e001              B        |L23.156|
                  |L23.152|
000098  2000              MOVS     r0,#0                 ;1077
00009a  6448              STR      r0,[r1,#0x44]         ;1077
                  |L23.156|
00009c  bf00              NOP                            ;1083
00009e  2000              MOVS     r0,#0                 ;1083
0000a0  f881003c          STRB     r0,[r1,#0x3c]         ;1083
0000a4  bf00              NOP                            ;1083
0000a6  4a18              LDR      r2,|L23.264|
0000a8  f06f0022          MVN      r0,#0x22              ;1092
0000ac  680b              LDR      r3,[r1,#0]            ;1092
0000ae  6018              STR      r0,[r3,#0]            ;1092
0000b0  6808              LDR      r0,[r1,#0]            ;1095
0000b2  6840              LDR      r0,[r0,#4]            ;1095
0000b4  4b15              LDR      r3,|L23.268|
0000b6  4318              ORRS     r0,r0,r3              ;1095
0000b8  680b              LDR      r3,[r1,#0]            ;1095
0000ba  6058              STR      r0,[r3,#4]            ;1095
0000bc  6850              LDR      r0,[r2,#4]            ;1098
0000be  f000001f          AND      r0,r0,#0x1f           ;1098
0000c2  b958              CBNZ     r0,|L23.220|
0000c4  6808              LDR      r0,[r1,#0]            ;1106
0000c6  6880              LDR      r0,[r0,#8]            ;1106
0000c8  f0005040          AND      r0,r0,#0x30000000     ;1106
0000cc  b9a8              CBNZ     r0,|L23.250|
0000ce  6808              LDR      r0,[r1,#0]            ;1109
0000d0  6880              LDR      r0,[r0,#8]            ;1109
0000d2  f0404080          ORR      r0,r0,#0x40000000     ;1109
0000d6  680b              LDR      r3,[r1,#0]            ;1109
0000d8  6098              STR      r0,[r3,#8]            ;1109
0000da  e00e              B        |L23.250|
                  |L23.220|
0000dc  4b0c              LDR      r3,|L23.272|
0000de  6808              LDR      r0,[r1,#0]            ;1118
0000e0  4298              CMP      r0,r3                 ;1118
0000e2  d10a              BNE      |L23.250|
0000e4  6808              LDR      r0,[r1,#0]            ;1118
0000e6  6880              LDR      r0,[r0,#8]            ;1118
0000e8  f0005040          AND      r0,r0,#0x30000000     ;1118
0000ec  b928              CBNZ     r0,|L23.250|
0000ee  6808              LDR      r0,[r1,#0]            ;1121
0000f0  6880              LDR      r0,[r0,#8]            ;1121
0000f2  f0404080          ORR      r0,r0,#0x40000000     ;1121
0000f6  680b              LDR      r3,[r1,#0]            ;1121
0000f8  6098              STR      r0,[r3,#8]            ;1121
                  |L23.250|
0000fa  2000              MOVS     r0,#0                 ;1127
0000fc  e78a              B        |L23.20|
;;;1129   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L23.256|
                          DCD      SystemCoreClock
                  |L23.260|
                          DCD      0x000f4240
                  |L23.264|
                          DCD      0x40012300
                  |L23.268|
                          DCD      0x04000020
                  |L23.272|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;831      */
;;;832    HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;833    {
;;;834      /* Check the parameters */
;;;835      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;836      
;;;837      /* Process locked */
;;;838      __HAL_LOCK(hadc);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L24.16|
00000c  2002              MOVS     r0,#2
                  |L24.14|
;;;839      
;;;840      /* Stop potential conversion on going, on regular and injected groups */
;;;841      /* Disable ADC peripheral */
;;;842      __HAL_ADC_DISABLE(hadc);
;;;843      
;;;844      /* Check if ADC is effectively disabled */
;;;845      if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;846      {
;;;847        /* Set ADC state */
;;;848        ADC_STATE_CLR_SET(hadc->State,
;;;849                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;850                          HAL_ADC_STATE_READY);
;;;851      }
;;;852      
;;;853      /* Process unlocked */
;;;854      __HAL_UNLOCK(hadc);
;;;855      
;;;856      /* Return function status */
;;;857      return HAL_OK;
;;;858    }
00000e  4770              BX       lr
                  |L24.16|
000010  2001              MOVS     r0,#1                 ;838
000012  f881003c          STRB     r0,[r1,#0x3c]         ;838
000016  bf00              NOP                            ;838
000018  6808              LDR      r0,[r1,#0]            ;842
00001a  6880              LDR      r0,[r0,#8]            ;842
00001c  f0200001          BIC      r0,r0,#1              ;842
000020  680a              LDR      r2,[r1,#0]            ;842
000022  6090              STR      r0,[r2,#8]            ;842
000024  6808              LDR      r0,[r1,#0]            ;845
000026  6880              LDR      r0,[r0,#8]            ;845
000028  f0000001          AND      r0,r0,#1              ;845
00002c  b928              CBNZ     r0,|L24.58|
00002e  6c08              LDR      r0,[r1,#0x40]         ;848
000030  f4205088          BIC      r0,r0,#0x1100         ;848
000034  f0400001          ORR      r0,r0,#1              ;848
000038  6408              STR      r0,[r1,#0x40]         ;848
                  |L24.58|
00003a  bf00              NOP                            ;854
00003c  2000              MOVS     r0,#0                 ;854
00003e  f881003c          STRB     r0,[r1,#0x3c]         ;854
000042  bf00              NOP                            ;854
000044  bf00              NOP                            ;857
000046  e7e2              B        |L24.14|
;;;859    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;1470     */
;;;1471   HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1472   {
000002  4604              MOV      r4,r0
;;;1473     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1474     
;;;1475     /* Check the parameters */
;;;1476     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1477     
;;;1478     /* Process locked */
;;;1479     __HAL_LOCK(hadc);
000006  bf00              NOP      
000008  f894003c          LDRB     r0,[r4,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L25.20|
000010  2002              MOVS     r0,#2
                  |L25.18|
;;;1480     
;;;1481     /* Stop potential conversion on going, on regular and injected groups */
;;;1482     /* Disable ADC peripheral */
;;;1483     __HAL_ADC_DISABLE(hadc);
;;;1484     
;;;1485     /* Check if ADC is effectively disabled */
;;;1486     if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1487     {
;;;1488       /* Disable the selected ADC DMA mode */
;;;1489       hadc->Instance->CR2 &= ~ADC_CR2_DMA;
;;;1490       
;;;1491       /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;1492       /* DMA transfer is on going)                                              */
;;;1493       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1494       
;;;1495       /* Disable ADC overrun interrupt */
;;;1496       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;1497       
;;;1498       /* Set ADC state */
;;;1499       ADC_STATE_CLR_SET(hadc->State,
;;;1500                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1501                         HAL_ADC_STATE_READY);
;;;1502     }
;;;1503     
;;;1504     /* Process unlocked */
;;;1505     __HAL_UNLOCK(hadc);
;;;1506     
;;;1507     /* Return function status */
;;;1508     return tmp_hal_status;
;;;1509   }
000012  bd70              POP      {r4-r6,pc}
                  |L25.20|
000014  2001              MOVS     r0,#1                 ;1479
000016  f884003c          STRB     r0,[r4,#0x3c]         ;1479
00001a  bf00              NOP                            ;1479
00001c  6820              LDR      r0,[r4,#0]            ;1483
00001e  6880              LDR      r0,[r0,#8]            ;1483
000020  f0200001          BIC      r0,r0,#1              ;1483
000024  6821              LDR      r1,[r4,#0]            ;1483
000026  6088              STR      r0,[r1,#8]            ;1483
000028  6820              LDR      r0,[r4,#0]            ;1486
00002a  6880              LDR      r0,[r0,#8]            ;1486
00002c  f0000001          AND      r0,r0,#1              ;1486
000030  b9a8              CBNZ     r0,|L25.94|
000032  6820              LDR      r0,[r4,#0]            ;1489
000034  6880              LDR      r0,[r0,#8]            ;1489
000036  f4207080          BIC      r0,r0,#0x100          ;1489
00003a  6821              LDR      r1,[r4,#0]            ;1489
00003c  6088              STR      r0,[r1,#8]            ;1489
00003e  6ba0              LDR      r0,[r4,#0x38]         ;1493
000040  f7fffffe          BL       HAL_DMA_Abort
000044  4605              MOV      r5,r0                 ;1493
000046  6820              LDR      r0,[r4,#0]            ;1496
000048  6840              LDR      r0,[r0,#4]            ;1496
00004a  f0206080          BIC      r0,r0,#0x4000000      ;1496
00004e  6821              LDR      r1,[r4,#0]            ;1496
000050  6048              STR      r0,[r1,#4]            ;1496
000052  6c20              LDR      r0,[r4,#0x40]         ;1499
000054  f4205088          BIC      r0,r0,#0x1100         ;1499
000058  f0400001          ORR      r0,r0,#1              ;1499
00005c  6420              STR      r0,[r4,#0x40]         ;1499
                  |L25.94|
00005e  bf00              NOP                            ;1505
000060  2000              MOVS     r0,#0                 ;1505
000062  f884003c          STRB     r0,[r4,#0x3c]         ;1505
000066  bf00              NOP                            ;1505
000068  4628              MOV      r0,r5                 ;1508
00006a  e7d2              B        |L25.18|
;;;1510   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Stop_IT PROC
;;;1138     */
;;;1139   HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1140   {
;;;1141     /* Check the parameters */
;;;1142     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1143     
;;;1144     /* Process locked */
;;;1145     __HAL_LOCK(hadc);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L26.16|
00000c  2002              MOVS     r0,#2
                  |L26.14|
;;;1146     
;;;1147     /* Stop potential conversion on going, on regular and injected groups */
;;;1148     /* Disable ADC peripheral */
;;;1149     __HAL_ADC_DISABLE(hadc);
;;;1150     
;;;1151     /* Check if ADC is effectively disabled */
;;;1152     if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1153     {
;;;1154     	/* Disable ADC end of conversion interrupt for regular group */
;;;1155       __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
;;;1156   
;;;1157       /* Set ADC state */
;;;1158       ADC_STATE_CLR_SET(hadc->State,
;;;1159                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1160                         HAL_ADC_STATE_READY);
;;;1161     }
;;;1162     
;;;1163     /* Process unlocked */
;;;1164     __HAL_UNLOCK(hadc);
;;;1165     
;;;1166     /* Return function status */
;;;1167     return HAL_OK;
;;;1168   }
00000e  4770              BX       lr
                  |L26.16|
000010  2001              MOVS     r0,#1                 ;1145
000012  f881003c          STRB     r0,[r1,#0x3c]         ;1145
000016  bf00              NOP                            ;1145
000018  6808              LDR      r0,[r1,#0]            ;1149
00001a  6880              LDR      r0,[r0,#8]            ;1149
00001c  f0200001          BIC      r0,r0,#1              ;1149
000020  680a              LDR      r2,[r1,#0]            ;1149
000022  6090              STR      r0,[r2,#8]            ;1149
000024  6808              LDR      r0,[r1,#0]            ;1152
000026  6880              LDR      r0,[r0,#8]            ;1152
000028  f0000001          AND      r0,r0,#1              ;1152
00002c  b958              CBNZ     r0,|L26.70|
00002e  6808              LDR      r0,[r1,#0]            ;1155
000030  6840              LDR      r0,[r0,#4]            ;1155
000032  4a08              LDR      r2,|L26.84|
000034  4010              ANDS     r0,r0,r2              ;1155
000036  680a              LDR      r2,[r1,#0]            ;1155
000038  6050              STR      r0,[r2,#4]            ;1155
00003a  6c08              LDR      r0,[r1,#0x40]         ;1158
00003c  f4205088          BIC      r0,r0,#0x1100         ;1158
000040  f0400001          ORR      r0,r0,#1              ;1158
000044  6408              STR      r0,[r1,#0x40]         ;1158
                  |L26.70|
000046  bf00              NOP                            ;1164
000048  2000              MOVS     r0,#0                 ;1164
00004a  f881003c          STRB     r0,[r1,#0x3c]         ;1164
00004e  bf00              NOP                            ;1164
000050  bf00              NOP                            ;1167
000052  e7dc              B        |L26.14|
;;;1169   
                          ENDP

                  |L26.84|
                          DCD      0xfbffffdf

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REVSH|
#line 478
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____RRX|
#line 665
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
