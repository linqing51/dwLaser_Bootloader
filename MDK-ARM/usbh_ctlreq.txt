; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\usbh_ctlreq.o --asm_dir=./ --list_dir=--list --depend=mcu_application\usbh_ctlreq.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\usbh_ctlreq.crf ../Middlewares/ST/STM32_USB_Host_Library/Core/Src/usbh_ctlreq.c]
                          THUMB

                          AREA ||i.USBH_ClrFeature||, CODE, READONLY, ALIGN=1

                  USBH_ClrFeature PROC
;;;321      */
;;;322    USBH_StatusTypeDef USBH_ClrFeature(USBH_HandleTypeDef *phost, uint8_t ep_num)
000000  b570              PUSH     {r4-r6,lr}
;;;323    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;324      if (phost->RequestState == CMD_SEND)
000006  78a0              LDRB     r0,[r4,#2]
000008  2801              CMP      r0,#1
00000a  d107              BNE      |L1.28|
;;;325      {
;;;326        phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
00000c  2102              MOVS     r1,#2
00000e  7421              STRB     r1,[r4,#0x10]
;;;327                                               | USB_REQ_TYPE_STANDARD;
;;;328    
;;;329        phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
000010  2101              MOVS     r1,#1
000012  7461              STRB     r1,[r4,#0x11]
;;;330        phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
000014  2100              MOVS     r1,#0
000016  8261              STRH     r1,[r4,#0x12]
;;;331        phost->Control.setup.b.wIndex.w = ep_num;
000018  82a5              STRH     r5,[r4,#0x14]
;;;332        phost->Control.setup.b.wLength.w = 0U;
00001a  82e1              STRH     r1,[r4,#0x16]
                  |L1.28|
;;;333      }
;;;334      return USBH_CtlReq(phost, 0U, 0U);
00001c  2200              MOVS     r2,#0
00001e  4611              MOV      r1,r2
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USBH_CtlReq
;;;335    }
000026  bd70              POP      {r4-r6,pc}
;;;336    
                          ENDP


                          AREA ||i.USBH_CtlReq||, CODE, READONLY, ALIGN=1

                  USBH_CtlReq PROC
;;;544      */
;;;545    USBH_StatusTypeDef USBH_CtlReq(USBH_HandleTypeDef *phost, uint8_t *buff,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;546                                   uint16_t length)
;;;547    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;548      USBH_StatusTypeDef status;
;;;549      status = USBH_BUSY;
00000a  2501              MOVS     r5,#1
;;;550    
;;;551      switch (phost->RequestState)
00000c  78a0              LDRB     r0,[r4,#2]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L2.24|
000012  2802              CMP      r0,#2
000014  d119              BNE      |L2.74|
000016  e007              B        |L2.40|
                  |L2.24|
;;;552      {
;;;553        case CMD_SEND:
;;;554          /* Start a SETUP transfer */
;;;555          phost->Control.buff = buff;
000018  60a6              STR      r6,[r4,#8]
;;;556          phost->Control.length = length;
00001a  81a7              STRH     r7,[r4,#0xc]
;;;557          phost->Control.state = CTRL_SETUP;
00001c  2101              MOVS     r1,#1
00001e  7621              STRB     r1,[r4,#0x18]
;;;558          phost->RequestState = CMD_WAIT;
000020  2002              MOVS     r0,#2
000022  70a0              STRB     r0,[r4,#2]
;;;559          status = USBH_BUSY;
000024  2501              MOVS     r5,#1
;;;560    
;;;561    #if (USBH_USE_OS == 1U)
;;;562          phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;563    #if (osCMSIS < 0x20000U)
;;;564          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;565    #else
;;;566          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;567    #endif
;;;568    #endif
;;;569          break;
000026  e011              B        |L2.76|
                  |L2.40|
;;;570    
;;;571        case CMD_WAIT:
;;;572          status = USBH_HandleControl(phost);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       USBH_HandleControl
00002e  4605              MOV      r5,r0
;;;573          if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
000030  b10d              CBZ      r5,|L2.54|
000032  2d03              CMP      r5,#3
000034  d104              BNE      |L2.64|
                  |L2.54|
;;;574          {
;;;575            /* Transaction completed, move control state to idle */
;;;576            phost->RequestState = CMD_SEND;
000036  2001              MOVS     r0,#1
000038  70a0              STRB     r0,[r4,#2]
;;;577            phost->Control.state = CTRL_IDLE;
00003a  2100              MOVS     r1,#0
00003c  7621              STRB     r1,[r4,#0x18]
00003e  e003              B        |L2.72|
                  |L2.64|
;;;578          }
;;;579          else if (status == USBH_FAIL)
000040  2d02              CMP      r5,#2
000042  d101              BNE      |L2.72|
;;;580          {
;;;581            /* Failure Mode */
;;;582            phost->RequestState = CMD_SEND;
000044  2001              MOVS     r0,#1
000046  70a0              STRB     r0,[r4,#2]
                  |L2.72|
;;;583          }
;;;584          else
;;;585          {
;;;586            /* .. */
;;;587          }
;;;588    #if (USBH_USE_OS == 1U)
;;;589          phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;590    #if (osCMSIS < 0x20000U)
;;;591          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;592    #else
;;;593          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;594    #endif
;;;595    #endif
;;;596          break;
000048  e000              B        |L2.76|
                  |L2.74|
;;;597    
;;;598        default:
;;;599          break;
00004a  bf00              NOP      
                  |L2.76|
00004c  bf00              NOP                            ;569
;;;600      }
;;;601      return status;
00004e  4628              MOV      r0,r5
;;;602    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;603    
                          ENDP


                          AREA ||i.USBH_GetDescriptor||, CODE, READONLY, ALIGN=1

                  USBH_GetDescriptor PROC
;;;187      */
;;;188    USBH_StatusTypeDef USBH_GetDescriptor(USBH_HandleTypeDef *phost,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;189                                          uint8_t  req_type,
;;;190                                          uint16_t value_idx,
;;;191                                          uint8_t *buff,
;;;192                                          uint16_t length)
;;;193    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;194      if (phost->RequestState == CMD_SEND)
000010  78a0              LDRB     r0,[r4,#2]
000012  2801              CMP      r0,#1
000014  d112              BNE      |L3.60|
;;;195      {
;;;196        phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
000016  f0460180          ORR      r1,r6,#0x80
00001a  7421              STRB     r1,[r4,#0x10]
;;;197        phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
00001c  2106              MOVS     r1,#6
00001e  7461              STRB     r1,[r4,#0x11]
;;;198        phost->Control.setup.b.wValue.w = value_idx;
000020  8265              STRH     r5,[r4,#0x12]
;;;199    
;;;200        if ((value_idx & 0xff00U) == USB_DESC_STRING)
000022  f405407f          AND      r0,r5,#0xff00
000026  f5b07f40          CMP      r0,#0x300
00002a  d103              BNE      |L3.52|
;;;201        {
;;;202          phost->Control.setup.b.wIndex.w = 0x0409U;
00002c  f2404109          MOV      r1,#0x409
000030  82a1              STRH     r1,[r4,#0x14]
000032  e001              B        |L3.56|
                  |L3.52|
;;;203        }
;;;204        else
;;;205        {
;;;206          phost->Control.setup.b.wIndex.w = 0U;
000034  2100              MOVS     r1,#0
000036  82a1              STRH     r1,[r4,#0x14]
                  |L3.56|
;;;207        }
;;;208        phost->Control.setup.b.wLength.w = length;
000038  f8a48016          STRH     r8,[r4,#0x16]
                  |L3.60|
;;;209      }
;;;210    
;;;211      return USBH_CtlReq(phost, buff, length);
00003c  4642              MOV      r2,r8
00003e  4639              MOV      r1,r7
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       USBH_CtlReq
;;;212    }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;213    
                          ENDP


                          AREA ||i.USBH_GetNextDesc||, CODE, READONLY, ALIGN=1

                  USBH_GetNextDesc PROC
;;;522      */
;;;523    USBH_DescHeader_t  *USBH_GetNextDesc(uint8_t   *pbuf, uint16_t  *ptr)
000000  b510              PUSH     {r4,lr}
;;;524    {
000002  4602              MOV      r2,r0
;;;525      USBH_DescHeader_t  *pnext;
;;;526    
;;;527      *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
000004  880b              LDRH     r3,[r1,#0]
000006  7814              LDRB     r4,[r2,#0]
000008  4423              ADD      r3,r3,r4
00000a  800b              STRH     r3,[r1,#0]
;;;528      pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
00000c  7813              LDRB     r3,[r2,#0]
00000e  1898              ADDS     r0,r3,r2
;;;529                                            ((USBH_DescHeader_t *)(void *)pbuf)->bLength);
;;;530    
;;;531      return (pnext);
;;;532    }
000010  bd10              POP      {r4,pc}
;;;533    
                          ENDP


                          AREA ||i.USBH_Get_CfgDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_CfgDesc PROC
;;;129      */
;;;130    USBH_StatusTypeDef USBH_Get_CfgDesc(USBH_HandleTypeDef *phost,
000000  b5f8              PUSH     {r3-r7,lr}
;;;131                                        uint16_t length)
;;;132    
;;;133    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;134      USBH_StatusTypeDef status;
;;;135      uint8_t *pData = phost->device.CfgDesc_Raw;;
000006  f104061c          ADD      r6,r4,#0x1c
;;;136    
;;;137      if ((status = USBH_GetDescriptor(phost, (USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD),
00000a  4633              MOV      r3,r6
00000c  f44f7200          MOV      r2,#0x200
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  9500              STR      r5,[sp,#0]
000016  f7fffffe          BL       USBH_GetDescriptor
00001a  1e07              SUBS     r7,r0,#0
00001c  d105              BNE      |L5.42|
;;;138                                       USB_DESC_CONFIGURATION, pData, length)) == USBH_OK)
;;;139      {
;;;140        /* Commands successfully sent and Response Received  */
;;;141        USBH_ParseCfgDesc(&phost->device.CfgDesc, pData, length);
00001e  462a              MOV      r2,r5
000020  4631              MOV      r1,r6
000022  f504704e          ADD      r0,r4,#0x338
000026  f7fffffe          BL       USBH_ParseCfgDesc
                  |L5.42|
;;;142      }
;;;143    
;;;144      return status;
00002a  4638              MOV      r0,r7
;;;145    }
00002c  bdf8              POP      {r3-r7,pc}
;;;146    
                          ENDP


                          AREA ||i.USBH_Get_DevDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_DevDesc PROC
;;;102      */
;;;103    USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint8_t length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;104    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;105      USBH_StatusTypeDef status;
;;;106    
;;;107      if ((status = USBH_GetDescriptor(phost,
000006  f504738e          ADD      r3,r4,#0x11c
00000a  f44f7280          MOV      r2,#0x100
00000e  2100              MOVS     r1,#0
000010  4620              MOV      r0,r4
000012  9500              STR      r5,[sp,#0]
000014  f7fffffe          BL       USBH_GetDescriptor
000018  1e06              SUBS     r6,r0,#0
00001a  d106              BNE      |L6.42|
;;;108                                       USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
;;;109                                       USB_DESC_DEVICE, phost->device.Data,
;;;110                                       (uint16_t)length)) == USBH_OK)
;;;111      {
;;;112        /* Commands successfully sent and Response Received */
;;;113        USBH_ParseDevDesc(&phost->device.DevDesc, phost->device.Data,
00001c  462a              MOV      r2,r5
00001e  f504718e          ADD      r1,r4,#0x11c
000022  f2043026          ADD      r0,r4,#0x326
000026  f7fffffe          BL       USBH_ParseDevDesc
                  |L6.42|
;;;114                          (uint16_t)length);
;;;115      }
;;;116    
;;;117      return status;
00002a  4630              MOV      r0,r6
;;;118    }
00002c  bdf8              POP      {r3-r7,pc}
;;;119    
                          ENDP


                          AREA ||i.USBH_Get_StringDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_StringDesc PROC
;;;157      */
;;;158    USBH_StatusTypeDef USBH_Get_StringDesc(USBH_HandleTypeDef *phost,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;159                                           uint8_t string_index, uint8_t *buff,
;;;160                                           uint16_t length)
;;;161    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;162      USBH_StatusTypeDef status;
;;;163    
;;;164      if ((status = USBH_GetDescriptor(phost,
00000c  f4467240          ORR      r2,r6,#0x300
000010  f504738e          ADD      r3,r4,#0x11c
000014  2100              MOVS     r1,#0
000016  4620              MOV      r0,r4
000018  9500              STR      r5,[sp,#0]
00001a  f7fffffe          BL       USBH_GetDescriptor
00001e  f1b00800          SUBS     r8,r0,#0
000022  d105              BNE      |L7.48|
;;;165                                       USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
;;;166                                       USB_DESC_STRING | string_index,
;;;167                                       phost->device.Data, length)) == USBH_OK)
;;;168      {
;;;169        /* Commands successfully sent and Response Received  */
;;;170        USBH_ParseStringDesc(phost->device.Data, buff, length);
000024  462a              MOV      r2,r5
000026  4639              MOV      r1,r7
000028  f504708e          ADD      r0,r4,#0x11c
00002c  f7fffffe          BL       USBH_ParseStringDesc
                  |L7.48|
;;;171      }
;;;172    
;;;173      return status;
000030  4640              MOV      r0,r8
;;;174    }
000032  e8bd83f8          POP      {r3-r9,pc}
;;;175    
                          ENDP


                          AREA ||i.USBH_HandleControl||, CODE, READONLY, ALIGN=2

                  USBH_HandleControl PROC
;;;610      */
;;;611    static USBH_StatusTypeDef USBH_HandleControl(USBH_HandleTypeDef *phost)
000000  b5f8              PUSH     {r3-r7,lr}
;;;612    {
000002  4604              MOV      r4,r0
;;;613      uint8_t direction;
;;;614      USBH_StatusTypeDef status = USBH_BUSY;
000004  2701              MOVS     r7,#1
;;;615      USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
000006  2500              MOVS     r5,#0
;;;616    
;;;617      switch (phost->Control.state)
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  280c              CMP      r0,#0xc
00000c  d26f              BCS      |L8.238|
00000e  e8dff000          TBB      [pc,r0]
000012  e606              DCB      0xe6,0x06
000014  0f323e50          DCB      0x0f,0x32,0x3e,0x50
000018  5e7a869a          DCB      0x5e,0x7a,0x86,0x9a
00001c  a8bd              DCB      0xa8,0xbd
;;;618      {
;;;619        case CTRL_SETUP:
;;;620          /* send a SETUP packet */
;;;621          USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
00001e  7962              LDRB     r2,[r4,#5]
000020  f1040110          ADD      r1,r4,#0x10
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       USBH_CtlSendSetup
;;;622                            phost->Control.pipe_out);
;;;623    
;;;624          phost->Control.state = CTRL_SETUP_WAIT;
00002a  2102              MOVS     r1,#2
00002c  7621              STRB     r1,[r4,#0x18]
;;;625          break;
00002e  e0d7              B        |L8.480|
;;;626    
;;;627        case CTRL_SETUP_WAIT:
;;;628    
;;;629          URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
000030  7961              LDRB     r1,[r4,#5]
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       USBH_LL_GetURBState
000038  4605              MOV      r5,r0
;;;630          /* case SETUP packet sent successfully */
;;;631          if (URB_Status == USBH_URB_DONE)
00003a  2d01              CMP      r5,#1
00003c  d114              BNE      |L8.104|
;;;632          {
;;;633            direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
00003e  7c20              LDRB     r0,[r4,#0x10]
000040  f0000680          AND      r6,r0,#0x80
;;;634    
;;;635            /* check if there is a data stage */
;;;636            if (phost->Control.setup.b.wLength.w != 0U)
000044  8ae0              LDRH     r0,[r4,#0x16]
000046  b138              CBZ      r0,|L8.88|
;;;637            {
;;;638              if (direction == USB_D2H)
000048  2e80              CMP      r6,#0x80
00004a  d102              BNE      |L8.82|
;;;639              {
;;;640                /* Data Direction is IN */
;;;641                phost->Control.state = CTRL_DATA_IN;
00004c  2103              MOVS     r1,#3
00004e  7621              STRB     r1,[r4,#0x18]
000050  e010              B        |L8.116|
                  |L8.82|
;;;642              }
;;;643              else
;;;644              {
;;;645                /* Data Direction is OUT */
;;;646                phost->Control.state = CTRL_DATA_OUT;
000052  2105              MOVS     r1,#5
000054  7621              STRB     r1,[r4,#0x18]
000056  e00d              B        |L8.116|
                  |L8.88|
;;;647              }
;;;648            }
;;;649            /* No DATA stage */
;;;650            else
;;;651            {
;;;652              /* If there is No Data Transfer Stage */
;;;653              if (direction == USB_D2H)
000058  2e80              CMP      r6,#0x80
00005a  d102              BNE      |L8.98|
;;;654              {
;;;655                /* Data Direction is IN */
;;;656                phost->Control.state = CTRL_STATUS_OUT;
00005c  2109              MOVS     r1,#9
00005e  7621              STRB     r1,[r4,#0x18]
000060  e008              B        |L8.116|
                  |L8.98|
;;;657              }
;;;658              else
;;;659              {
;;;660                /* Data Direction is OUT */
;;;661                phost->Control.state = CTRL_STATUS_IN;
000062  2107              MOVS     r1,#7
000064  7621              STRB     r1,[r4,#0x18]
000066  e005              B        |L8.116|
                  |L8.104|
;;;662              }
;;;663            }
;;;664    
;;;665    #if (USBH_USE_OS == 1U)
;;;666            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;667    #if (osCMSIS < 0x20000U)
;;;668            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;669    #else
;;;670            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;671    #endif
;;;672    #endif
;;;673          }
;;;674          else
;;;675          {
;;;676            if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
000068  2d04              CMP      r5,#4
00006a  d001              BEQ      |L8.112|
00006c  2d02              CMP      r5,#2
00006e  d101              BNE      |L8.116|
                  |L8.112|
;;;677            {
;;;678              phost->Control.state = CTRL_ERROR;
000070  210b              MOVS     r1,#0xb
000072  7621              STRB     r1,[r4,#0x18]
                  |L8.116|
;;;679    
;;;680    #if (USBH_USE_OS == 1U)
;;;681              phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;682    #if (osCMSIS < 0x20000U)
;;;683              (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;684    #else
;;;685              (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;686    #endif
;;;687    #endif
;;;688            }
;;;689          }
;;;690          break;
000074  e0b4              B        |L8.480|
;;;691    
;;;692        case CTRL_DATA_IN:
;;;693          /* Issue an IN token */
;;;694          phost->Control.timer = (uint16_t)phost->Timer;
000076  f8d403c4          LDR      r0,[r4,#0x3c4]
00007a  81e0              STRH     r0,[r4,#0xe]
;;;695          USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
00007c  7923              LDRB     r3,[r4,#4]
00007e  89a2              LDRH     r2,[r4,#0xc]
000080  4620              MOV      r0,r4
000082  68a1              LDR      r1,[r4,#8]
000084  f7fffffe          BL       USBH_CtlReceiveData
;;;696                              phost->Control.pipe_in);
;;;697    
;;;698          phost->Control.state = CTRL_DATA_IN_WAIT;
000088  2104              MOVS     r1,#4
00008a  7621              STRB     r1,[r4,#0x18]
;;;699          break;
00008c  e0a8              B        |L8.480|
;;;700    
;;;701        case CTRL_DATA_IN_WAIT:
;;;702    
;;;703          URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
00008e  7921              LDRB     r1,[r4,#4]
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       USBH_LL_GetURBState
000096  4605              MOV      r5,r0
;;;704    
;;;705          /* check is DATA packet transferred successfully */
;;;706          if (URB_Status == USBH_URB_DONE)
000098  2d01              CMP      r5,#1
00009a  d101              BNE      |L8.160|
;;;707          {
;;;708            phost->Control.state = CTRL_STATUS_OUT;
00009c  2109              MOVS     r1,#9
00009e  7621              STRB     r1,[r4,#0x18]
                  |L8.160|
;;;709    
;;;710    #if (USBH_USE_OS == 1U)
;;;711            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;712    #if (osCMSIS < 0x20000U)
;;;713            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;714    #else
;;;715            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;716    #endif
;;;717    #endif
;;;718          }
;;;719    
;;;720          /* manage error cases*/
;;;721          if (URB_Status == USBH_URB_STALL)
0000a0  2d05              CMP      r5,#5
0000a2  d101              BNE      |L8.168|
;;;722          {
;;;723            /* In stall case, return to previous machine state*/
;;;724            status = USBH_NOT_SUPPORTED;
0000a4  2703              MOVS     r7,#3
0000a6  e003              B        |L8.176|
                  |L8.168|
;;;725    
;;;726    #if (USBH_USE_OS == 1U)
;;;727            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;728    #if (osCMSIS < 0x20000U)
;;;729            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;730    #else
;;;731            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;732    #endif
;;;733    #endif
;;;734          }
;;;735          else
;;;736          {
;;;737            if (URB_Status == USBH_URB_ERROR)
0000a8  2d04              CMP      r5,#4
0000aa  d101              BNE      |L8.176|
;;;738            {
;;;739              /* Device error */
;;;740              phost->Control.state = CTRL_ERROR;
0000ac  210b              MOVS     r1,#0xb
0000ae  7621              STRB     r1,[r4,#0x18]
                  |L8.176|
;;;741    
;;;742    #if (USBH_USE_OS == 1U)
;;;743              phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;744    #if (osCMSIS < 0x20000U)
;;;745              (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;746    #else
;;;747              (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;748    #endif
;;;749    #endif
;;;750            }
;;;751          }
;;;752          break;
0000b0  e096              B        |L8.480|
;;;753    
;;;754        case CTRL_DATA_OUT:
;;;755    
;;;756          USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
0000b2  2001              MOVS     r0,#1
0000b4  9000              STR      r0,[sp,#0]
0000b6  7963              LDRB     r3,[r4,#5]
0000b8  89a2              LDRH     r2,[r4,#0xc]
0000ba  4620              MOV      r0,r4
0000bc  68a1              LDR      r1,[r4,#8]
0000be  f7fffffe          BL       USBH_CtlSendData
;;;757                           phost->Control.pipe_out, 1U);
;;;758    
;;;759          phost->Control.timer = (uint16_t)phost->Timer;
0000c2  f8d403c4          LDR      r0,[r4,#0x3c4]
0000c6  81e0              STRH     r0,[r4,#0xe]
;;;760          phost->Control.state = CTRL_DATA_OUT_WAIT;
0000c8  2106              MOVS     r1,#6
0000ca  7621              STRB     r1,[r4,#0x18]
;;;761          break;
0000cc  e088              B        |L8.480|
;;;762    
;;;763        case CTRL_DATA_OUT_WAIT:
;;;764    
;;;765          URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
0000ce  7961              LDRB     r1,[r4,#5]
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       USBH_LL_GetURBState
0000d6  4605              MOV      r5,r0
;;;766    
;;;767          if (URB_Status == USBH_URB_DONE)
0000d8  2d01              CMP      r5,#1
0000da  d102              BNE      |L8.226|
;;;768          {
;;;769            /* If the Setup Pkt is sent successful, then change the state */
;;;770            phost->Control.state = CTRL_STATUS_IN;
0000dc  2107              MOVS     r1,#7
0000de  7621              STRB     r1,[r4,#0x18]
0000e0  e010              B        |L8.260|
                  |L8.226|
;;;771    
;;;772    #if (USBH_USE_OS == 1U)
;;;773            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;774    #if (osCMSIS < 0x20000U)
;;;775            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;776    #else
;;;777            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;778    #endif
;;;779    #endif
;;;780          }
;;;781    
;;;782          /* handle error cases */
;;;783          else if (URB_Status == USBH_URB_STALL)
0000e2  2d05              CMP      r5,#5
0000e4  d104              BNE      |L8.240|
;;;784          {
;;;785            /* In stall case, return to previous machine state*/
;;;786            phost->Control.state = CTRL_STALLED;
0000e6  210c              MOVS     r1,#0xc
0000e8  7621              STRB     r1,[r4,#0x18]
;;;787            status = USBH_NOT_SUPPORTED;
0000ea  2703              MOVS     r7,#3
0000ec  e00a              B        |L8.260|
                  |L8.238|
0000ee  e076              B        |L8.478|
                  |L8.240|
;;;788    
;;;789    #if (USBH_USE_OS == 1U)
;;;790            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;791    #if (osCMSIS < 0x20000U)
;;;792            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;793    #else
;;;794            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;795    #endif
;;;796    #endif
;;;797          }
;;;798          else if (URB_Status == USBH_URB_NOTREADY)
0000f0  2d02              CMP      r5,#2
0000f2  d102              BNE      |L8.250|
;;;799          {
;;;800            /* Nack received from device */
;;;801            phost->Control.state = CTRL_DATA_OUT;
0000f4  2105              MOVS     r1,#5
0000f6  7621              STRB     r1,[r4,#0x18]
0000f8  e004              B        |L8.260|
                  |L8.250|
;;;802    
;;;803    #if (USBH_USE_OS == 1U)
;;;804            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;805    #if (osCMSIS < 0x20000U)
;;;806            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;807    #else
;;;808            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;809    #endif
;;;810    #endif
;;;811          }
;;;812          else
;;;813          {
;;;814            if (URB_Status == USBH_URB_ERROR)
0000fa  2d04              CMP      r5,#4
0000fc  d102              BNE      |L8.260|
;;;815            {
;;;816              /* device error */
;;;817              phost->Control.state = CTRL_ERROR;
0000fe  210b              MOVS     r1,#0xb
000100  7621              STRB     r1,[r4,#0x18]
;;;818              status = USBH_FAIL;
000102  2702              MOVS     r7,#2
                  |L8.260|
;;;819    
;;;820    #if (USBH_USE_OS == 1U)
;;;821              phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;822    #if (osCMSIS < 0x20000U)
;;;823              (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;824    #else
;;;825              (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;826    #endif
;;;827    #endif
;;;828            }
;;;829          }
;;;830          break;
000104  e06c              B        |L8.480|
;;;831    
;;;832        case CTRL_STATUS_IN:
;;;833          /* Send 0 bytes out packet */
;;;834          USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
000106  7923              LDRB     r3,[r4,#4]
000108  2200              MOVS     r2,#0
00010a  4611              MOV      r1,r2
00010c  4620              MOV      r0,r4
00010e  f7fffffe          BL       USBH_CtlReceiveData
;;;835    
;;;836          phost->Control.timer = (uint16_t)phost->Timer;
000112  f8d403c4          LDR      r0,[r4,#0x3c4]
000116  81e0              STRH     r0,[r4,#0xe]
;;;837          phost->Control.state = CTRL_STATUS_IN_WAIT;
000118  2108              MOVS     r1,#8
00011a  7621              STRB     r1,[r4,#0x18]
;;;838    
;;;839          break;
00011c  e060              B        |L8.480|
;;;840    
;;;841        case CTRL_STATUS_IN_WAIT:
;;;842    
;;;843          URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
00011e  7921              LDRB     r1,[r4,#4]
000120  4620              MOV      r0,r4
000122  f7fffffe          BL       USBH_LL_GetURBState
000126  4605              MOV      r5,r0
;;;844    
;;;845          if (URB_Status == USBH_URB_DONE)
000128  2d01              CMP      r5,#1
00012a  d103              BNE      |L8.308|
;;;846          {
;;;847            /* Control transfers completed, Exit the State Machine */
;;;848            phost->Control.state = CTRL_COMPLETE;
00012c  210d              MOVS     r1,#0xd
00012e  7621              STRB     r1,[r4,#0x18]
;;;849            status = USBH_OK;
000130  2700              MOVS     r7,#0
000132  e007              B        |L8.324|
                  |L8.308|
;;;850    
;;;851    #if (USBH_USE_OS == 1U)
;;;852            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;853    #if (osCMSIS < 0x20000U)
;;;854            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;855    #else
;;;856            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;857    #endif
;;;858    #endif
;;;859          }
;;;860          else if (URB_Status == USBH_URB_ERROR)
000134  2d04              CMP      r5,#4
000136  d102              BNE      |L8.318|
;;;861          {
;;;862            phost->Control.state = CTRL_ERROR;
000138  210b              MOVS     r1,#0xb
00013a  7621              STRB     r1,[r4,#0x18]
00013c  e002              B        |L8.324|
                  |L8.318|
;;;863    
;;;864    #if (USBH_USE_OS == 1U)
;;;865            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;866    #if (osCMSIS < 0x20000U)
;;;867            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;868    #else
;;;869            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;870    #endif
;;;871    #endif
;;;872          }
;;;873          else
;;;874          {
;;;875            if (URB_Status == USBH_URB_STALL)
00013e  2d05              CMP      r5,#5
000140  d100              BNE      |L8.324|
;;;876            {
;;;877              /* Control transfers completed, Exit the State Machine */
;;;878              status = USBH_NOT_SUPPORTED;
000142  2703              MOVS     r7,#3
                  |L8.324|
;;;879    
;;;880    #if (USBH_USE_OS == 1U)
;;;881              phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;882    #if (osCMSIS < 0x20000U)
;;;883              (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;884    #else
;;;885              (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;886    #endif
;;;887    #endif
;;;888            }
;;;889          }
;;;890          break;
000144  e04c              B        |L8.480|
;;;891    
;;;892        case CTRL_STATUS_OUT:
;;;893          USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
000146  2001              MOVS     r0,#1
000148  9000              STR      r0,[sp,#0]
00014a  7963              LDRB     r3,[r4,#5]
00014c  2200              MOVS     r2,#0
00014e  4611              MOV      r1,r2
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       USBH_CtlSendData
;;;894    
;;;895          phost->Control.timer = (uint16_t)phost->Timer;
000156  f8d403c4          LDR      r0,[r4,#0x3c4]
00015a  81e0              STRH     r0,[r4,#0xe]
;;;896          phost->Control.state = CTRL_STATUS_OUT_WAIT;
00015c  210a              MOVS     r1,#0xa
00015e  7621              STRB     r1,[r4,#0x18]
;;;897          break;
000160  e03e              B        |L8.480|
;;;898    
;;;899        case CTRL_STATUS_OUT_WAIT:
;;;900          URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
000162  7961              LDRB     r1,[r4,#5]
000164  4620              MOV      r0,r4
000166  f7fffffe          BL       USBH_LL_GetURBState
00016a  4605              MOV      r5,r0
;;;901          if (URB_Status == USBH_URB_DONE)
00016c  2d01              CMP      r5,#1
00016e  d103              BNE      |L8.376|
;;;902          {
;;;903            status = USBH_OK;
000170  2700              MOVS     r7,#0
;;;904            phost->Control.state = CTRL_COMPLETE;
000172  210d              MOVS     r1,#0xd
000174  7621              STRB     r1,[r4,#0x18]
000176  e008              B        |L8.394|
                  |L8.376|
;;;905    
;;;906    #if (USBH_USE_OS == 1U)
;;;907            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;908    #if (osCMSIS < 0x20000U)
;;;909            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;910    #else
;;;911            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;912    #endif
;;;913    #endif
;;;914          }
;;;915          else if (URB_Status == USBH_URB_NOTREADY)
000178  2d02              CMP      r5,#2
00017a  d102              BNE      |L8.386|
;;;916          {
;;;917            phost->Control.state = CTRL_STATUS_OUT;
00017c  2109              MOVS     r1,#9
00017e  7621              STRB     r1,[r4,#0x18]
000180  e003              B        |L8.394|
                  |L8.386|
;;;918    
;;;919    #if (USBH_USE_OS == 1U)
;;;920            phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;921    #if (osCMSIS < 0x20000U)
;;;922            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;923    #else
;;;924            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;925    #endif
;;;926    #endif
;;;927          }
;;;928          else
;;;929          {
;;;930            if (URB_Status == USBH_URB_ERROR)
000182  2d04              CMP      r5,#4
000184  d101              BNE      |L8.394|
;;;931            {
;;;932              phost->Control.state = CTRL_ERROR;
000186  210b              MOVS     r1,#0xb
000188  7621              STRB     r1,[r4,#0x18]
                  |L8.394|
;;;933    
;;;934    #if (USBH_USE_OS == 1U)
;;;935              phost->os_msg = (uint32_t)USBH_CONTROL_EVENT;
;;;936    #if (osCMSIS < 0x20000U)
;;;937              (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;938    #else
;;;939              (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;940    #endif
;;;941    #endif
;;;942            }
;;;943          }
;;;944          break;
00018a  e029              B        |L8.480|
;;;945    
;;;946        case CTRL_ERROR:
;;;947          /*
;;;948          After a halt condition is encountered or an error is detected by the
;;;949          host, a control endpoint is allowed to recover by accepting the next Setup
;;;950          PID; i.e., recovery actions via some other pipe are not required for control
;;;951          endpoints. For the Default Control Pipe, a device reset will ultimately be
;;;952          required to clear the halt or error condition if the next Setup PID is not
;;;953          accepted.
;;;954          */
;;;955          if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
00018c  7e60              LDRB     r0,[r4,#0x19]
00018e  1c40              ADDS     r0,r0,#1
000190  b2c1              UXTB     r1,r0
000192  7661              STRB     r1,[r4,#0x19]
000194  2902              CMP      r1,#2
000196  d804              BHI      |L8.418|
;;;956          {
;;;957            /* Do the transmission again, starting from SETUP Packet */
;;;958            phost->Control.state = CTRL_SETUP;
000198  2101              MOVS     r1,#1
00019a  7621              STRB     r1,[r4,#0x18]
;;;959            phost->RequestState = CMD_SEND;
00019c  2001              MOVS     r0,#1
00019e  70a0              STRB     r0,[r4,#2]
0001a0  e01c              B        |L8.476|
                  |L8.418|
;;;960          }
;;;961          else
;;;962          {
;;;963            phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
0001a2  2106              MOVS     r1,#6
0001a4  4620              MOV      r0,r4
0001a6  f8d423d4          LDR      r2,[r4,#0x3d4]
0001aa  4790              BLX      r2
;;;964            phost->Control.errorcount = 0U;
0001ac  2100              MOVS     r1,#0
0001ae  7661              STRB     r1,[r4,#0x19]
;;;965            USBH_ErrLog("Control error: Device not responding");
0001b0  bf00              NOP      
0001b2  a00d              ADR      r0,|L8.488|
0001b4  f7fffffe          BL       __2printf
0001b8  a00d              ADR      r0,|L8.496|
0001ba  f7fffffe          BL       __2printf
0001be  a016              ADR      r0,|L8.536|
0001c0  f7fffffe          BL       __2printf
0001c4  bf00              NOP      
;;;966    
;;;967            /* Free control pipes */
;;;968            USBH_FreePipe(phost, phost->Control.pipe_out);
0001c6  7961              LDRB     r1,[r4,#5]
0001c8  4620              MOV      r0,r4
0001ca  f7fffffe          BL       USBH_FreePipe
;;;969            USBH_FreePipe(phost, phost->Control.pipe_in);
0001ce  7921              LDRB     r1,[r4,#4]
0001d0  4620              MOV      r0,r4
0001d2  f7fffffe          BL       USBH_FreePipe
;;;970    
;;;971            phost->gState = HOST_IDLE;
0001d6  2000              MOVS     r0,#0
0001d8  7020              STRB     r0,[r4,#0]
;;;972            status = USBH_FAIL;
0001da  2702              MOVS     r7,#2
                  |L8.476|
;;;973          }
;;;974          break;
0001dc  e000              B        |L8.480|
                  |L8.478|
;;;975    
;;;976        default:
;;;977          break;
0001de  bf00              NOP      
                  |L8.480|
0001e0  bf00              NOP                            ;625
;;;978      }
;;;979    
;;;980      return status;
0001e2  4638              MOV      r0,r7
;;;981    }
0001e4  bdf8              POP      {r3-r7,pc}
;;;982    
                          ENDP

0001e6  0000              DCW      0x0000
                  |L8.488|
0001e8  4552524f          DCB      "ERROR: ",0
0001ec  523a2000
                  |L8.496|
0001f0  436f6e74          DCB      "Control error: Device not responding",0
0001f4  726f6c20
0001f8  6572726f
0001fc  723a2044
000200  65766963
000204  65206e6f
000208  74207265
00020c  73706f6e
000210  64696e67
000214  00      
000215  00                DCB      0
000216  00                DCB      0
000217  00                DCB      0
                  |L8.536|
000218  0a00              DCB      "\n",0
00021a  00                DCB      0
00021b  00                DCB      0

                          AREA ||i.USBH_ParseCfgDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseCfgDesc PROC
;;;379      */
;;;380    static void USBH_ParseCfgDesc(USBH_CfgDescTypeDef *cfg_desc, uint8_t *buf,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;381                                  uint16_t length)
;;;382    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4693              MOV      r11,r2
;;;383      USBH_InterfaceDescTypeDef    *pif ;
;;;384      USBH_EpDescTypeDef           *pep;
;;;385      USBH_DescHeader_t            *pdesc = (USBH_DescHeader_t *)(void *)buf;
00000a  4635              MOV      r5,r6
;;;386      uint16_t                     ptr;
;;;387      uint8_t                      if_ix = 0U;
00000c  f04f0800          MOV      r8,#0
;;;388      uint8_t                      ep_ix = 0U;
000010  46c1              MOV      r9,r8
;;;389    
;;;390      pdesc   = (USBH_DescHeader_t *)(void *)buf;
000012  bf00              NOP      
;;;391    
;;;392      /* Parse configuration descriptor */
;;;393      cfg_desc->bLength             = *(uint8_t *)(buf + 0);
000014  7830              LDRB     r0,[r6,#0]
000016  7020              STRB     r0,[r4,#0]
;;;394      cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
000018  7870              LDRB     r0,[r6,#1]
00001a  7060              STRB     r0,[r4,#1]
;;;395      cfg_desc->wTotalLength        = LE16(buf + 2);
00001c  78b1              LDRB     r1,[r6,#2]
00001e  78f0              LDRB     r0,[r6,#3]
000020  ea412000          ORR      r0,r1,r0,LSL #8
000024  8060              STRH     r0,[r4,#2]
;;;396      cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
000026  7930              LDRB     r0,[r6,#4]
000028  7120              STRB     r0,[r4,#4]
;;;397      cfg_desc->bConfigurationValue = *(uint8_t *)(buf + 5);
00002a  7970              LDRB     r0,[r6,#5]
00002c  7160              STRB     r0,[r4,#5]
;;;398      cfg_desc->iConfiguration      = *(uint8_t *)(buf + 6);
00002e  79b0              LDRB     r0,[r6,#6]
000030  71a0              STRB     r0,[r4,#6]
;;;399      cfg_desc->bmAttributes        = *(uint8_t *)(buf + 7);
000032  79f0              LDRB     r0,[r6,#7]
000034  71e0              STRB     r0,[r4,#7]
;;;400      cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
000036  7a30              LDRB     r0,[r6,#8]
000038  7220              STRB     r0,[r4,#8]
;;;401    
;;;402      if (length > USB_CONFIGURATION_DESC_SIZE)
00003a  f1bb0f09          CMP      r11,#9
00003e  d94a              BLS      |L9.214|
;;;403      {
;;;404        ptr = USB_LEN_CFG_DESC;
000040  2009              MOVS     r0,#9
000042  9000              STR      r0,[sp,#0]
;;;405        pif = (USBH_InterfaceDescTypeDef *)0;
000044  2700              MOVS     r7,#0
;;;406    
;;;407        while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
000046  e03e              B        |L9.198|
                  |L9.72|
;;;408        {
;;;409          pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
000048  4669              MOV      r1,sp
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USBH_GetNextDesc
000050  4605              MOV      r5,r0
;;;410          if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
000052  7868              LDRB     r0,[r5,#1]
000054  2804              CMP      r0,#4
000056  d136              BNE      |L9.198|
;;;411          {
;;;412            pif = &cfg_desc->Itf_Desc[if_ix];
000058  eb080088          ADD      r0,r8,r8,LSL #2
00005c  eb0001c8          ADD      r1,r0,r8,LSL #3
000060  f104000a          ADD      r0,r4,#0xa
000064  eb000741          ADD      r7,r0,r1,LSL #1
;;;413            USBH_ParseInterfaceDesc(pif, (uint8_t *)(void *)pdesc);
000068  4629              MOV      r1,r5
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       USBH_ParseInterfaceDesc
;;;414    
;;;415            ep_ix = 0U;
000070  f04f0900          MOV      r9,#0
;;;416            pep = (USBH_EpDescTypeDef *)0;
000074  46ca              MOV      r10,r9
;;;417            while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
000076  e01a              B        |L9.174|
                  |L9.120|
;;;418            {
;;;419              pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
000078  4669              MOV      r1,sp
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       USBH_GetNextDesc
000080  4605              MOV      r5,r0
;;;420              if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
000082  7868              LDRB     r0,[r5,#1]
000084  2805              CMP      r0,#5
000086  d112              BNE      |L9.174|
;;;421              {
;;;422                pep = &cfg_desc->Itf_Desc[if_ix].Ep_Desc[ep_ix];
000088  eb080088          ADD      r0,r8,r8,LSL #2
00008c  eb0001c8          ADD      r1,r0,r8,LSL #3
000090  f104000a          ADD      r0,r4,#0xa
000094  eb000041          ADD      r0,r0,r1,LSL #1
000098  300a              ADDS     r0,r0,#0xa
00009a  eb000ac9          ADD      r10,r0,r9,LSL #3
;;;423                USBH_ParseEPDesc(pep, (uint8_t *)(void *)pdesc);
00009e  4629              MOV      r1,r5
0000a0  4650              MOV      r0,r10
0000a2  f7fffffe          BL       USBH_ParseEPDesc
;;;424                ep_ix++;
0000a6  f1090001          ADD      r0,r9,#1
0000aa  f00009ff          AND      r9,r0,#0xff
                  |L9.174|
0000ae  7938              LDRB     r0,[r7,#4]            ;417
0000b0  4548              CMP      r0,r9                 ;417
0000b2  dd04              BLE      |L9.190|
0000b4  8860              LDRH     r0,[r4,#2]            ;417
0000b6  f8bd1000          LDRH     r1,[sp,#0]            ;417
0000ba  4288              CMP      r0,r1                 ;417
0000bc  dcdc              BGT      |L9.120|
                  |L9.190|
;;;425              }
;;;426            }
;;;427            if_ix++;
0000be  f1080001          ADD      r0,r8,#1
0000c2  f00008ff          AND      r8,r0,#0xff
                  |L9.198|
0000c6  f1b80f02          CMP      r8,#2                 ;407
0000ca  d204              BCS      |L9.214|
0000cc  8860              LDRH     r0,[r4,#2]            ;407
0000ce  f8bd1000          LDRH     r1,[sp,#0]            ;407
0000d2  4288              CMP      r0,r1                 ;407
0000d4  dcb8              BGT      |L9.72|
                  |L9.214|
;;;428          }
;;;429        }
;;;430      }
;;;431    }
0000d6  e8bd8ff8          POP      {r3-r11,pc}
;;;432    
                          ENDP


                          AREA ||i.USBH_ParseDevDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseDevDesc PROC
;;;345      */
;;;346    static void  USBH_ParseDevDesc(USBH_DevDescTypeDef *dev_desc, uint8_t *buf,
000000  b510              PUSH     {r4,lr}
;;;347                                   uint16_t length)
;;;348    {
;;;349      dev_desc->bLength            = *(uint8_t *)(buf +  0);
000002  780b              LDRB     r3,[r1,#0]
000004  7003              STRB     r3,[r0,#0]
;;;350      dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
000006  784b              LDRB     r3,[r1,#1]
000008  7043              STRB     r3,[r0,#1]
;;;351      dev_desc->bcdUSB             = LE16(buf +  2);
00000a  788c              LDRB     r4,[r1,#2]
00000c  78cb              LDRB     r3,[r1,#3]
00000e  ea442303          ORR      r3,r4,r3,LSL #8
000012  8043              STRH     r3,[r0,#2]
;;;352      dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
000014  790b              LDRB     r3,[r1,#4]
000016  7103              STRB     r3,[r0,#4]
;;;353      dev_desc->bDeviceSubClass    = *(uint8_t *)(buf +  5);
000018  794b              LDRB     r3,[r1,#5]
00001a  7143              STRB     r3,[r0,#5]
;;;354      dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6);
00001c  798b              LDRB     r3,[r1,#6]
00001e  7183              STRB     r3,[r0,#6]
;;;355      dev_desc->bMaxPacketSize     = *(uint8_t *)(buf +  7);
000020  79cb              LDRB     r3,[r1,#7]
000022  71c3              STRB     r3,[r0,#7]
;;;356    
;;;357      if (length > 8U)
000024  2a08              CMP      r2,#8
000026  d916              BLS      |L10.86|
;;;358      {
;;;359        /* For 1st time after device connection, Host may issue only 8 bytes for
;;;360        Device Descriptor Length  */
;;;361        dev_desc->idVendor           = LE16(buf +  8);
000028  7a0c              LDRB     r4,[r1,#8]
00002a  7a4b              LDRB     r3,[r1,#9]
00002c  ea442303          ORR      r3,r4,r3,LSL #8
000030  8103              STRH     r3,[r0,#8]
;;;362        dev_desc->idProduct          = LE16(buf + 10);
000032  7a8c              LDRB     r4,[r1,#0xa]
000034  7acb              LDRB     r3,[r1,#0xb]
000036  ea442303          ORR      r3,r4,r3,LSL #8
00003a  8143              STRH     r3,[r0,#0xa]
;;;363        dev_desc->bcdDevice          = LE16(buf + 12);
00003c  7b0c              LDRB     r4,[r1,#0xc]
00003e  7b4b              LDRB     r3,[r1,#0xd]
000040  ea442303          ORR      r3,r4,r3,LSL #8
000044  8183              STRH     r3,[r0,#0xc]
;;;364        dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
000046  7b8b              LDRB     r3,[r1,#0xe]
000048  7383              STRB     r3,[r0,#0xe]
;;;365        dev_desc->iProduct           = *(uint8_t *)(buf + 15);
00004a  7bcb              LDRB     r3,[r1,#0xf]
00004c  73c3              STRB     r3,[r0,#0xf]
;;;366        dev_desc->iSerialNumber      = *(uint8_t *)(buf + 16);
00004e  7c0b              LDRB     r3,[r1,#0x10]
000050  7403              STRB     r3,[r0,#0x10]
;;;367        dev_desc->bNumConfigurations = *(uint8_t *)(buf + 17);
000052  7c4b              LDRB     r3,[r1,#0x11]
000054  7443              STRB     r3,[r0,#0x11]
                  |L10.86|
;;;368      }
;;;369    }
000056  bd10              POP      {r4,pc}
;;;370    
                          ENDP


                          AREA ||i.USBH_ParseEPDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseEPDesc PROC
;;;462      */
;;;463    static void  USBH_ParseEPDesc(USBH_EpDescTypeDef  *ep_descriptor,
000000  780a              LDRB     r2,[r1,#0]
;;;464                                  uint8_t *buf)
;;;465    {
;;;466      ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;467      ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;468      ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;469      ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;470      ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
000010  790b              LDRB     r3,[r1,#4]
000012  794a              LDRB     r2,[r1,#5]
000014  ea432202          ORR      r2,r3,r2,LSL #8
000018  8082              STRH     r2,[r0,#4]
;;;471      ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
00001a  798a              LDRB     r2,[r1,#6]
00001c  7182              STRB     r2,[r0,#6]
;;;472    }
00001e  4770              BX       lr
;;;473    
                          ENDP


                          AREA ||i.USBH_ParseInterfaceDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseInterfaceDesc PROC
;;;440      */
;;;441    static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor,
000000  780a              LDRB     r2,[r1,#0]
;;;442                                         uint8_t *buf)
;;;443    {
;;;444      if_descriptor->bLength            = *(uint8_t *)(buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;445      if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;446      if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;447      if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;448      if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
000010  790a              LDRB     r2,[r1,#4]
000012  7102              STRB     r2,[r0,#4]
;;;449      if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
000014  794a              LDRB     r2,[r1,#5]
000016  7142              STRB     r2,[r0,#5]
;;;450      if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
000018  798a              LDRB     r2,[r1,#6]
00001a  7182              STRB     r2,[r0,#6]
;;;451      if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
00001c  79ca              LDRB     r2,[r1,#7]
00001e  71c2              STRB     r2,[r0,#7]
;;;452      if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
000020  7a0a              LDRB     r2,[r1,#8]
000022  7202              STRB     r2,[r0,#8]
;;;453    }
000024  4770              BX       lr
;;;454    
                          ENDP


                          AREA ||i.USBH_ParseStringDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseStringDesc PROC
;;;482      */
;;;483    static void USBH_ParseStringDesc(uint8_t *psrc, uint8_t *pdest, uint16_t length)
000000  b530              PUSH     {r4,r5,lr}
;;;484    {
000002  4613              MOV      r3,r2
;;;485      uint16_t strlength;
;;;486      uint16_t idx;
;;;487    
;;;488      /* The UNICODE string descriptor is not NULL-terminated. The string length is
;;;489      computed by substracting two from the value of the first byte of the descriptor.
;;;490      */
;;;491    
;;;492      /* Check which is lower size, the Size of string or the length of bytes read
;;;493      from the device */
;;;494    
;;;495      if (psrc[1] == USB_DESC_TYPE_STRING)
000004  7845              LDRB     r5,[r0,#1]
000006  2d03              CMP      r5,#3
000008  d114              BNE      |L13.52|
;;;496      {
;;;497        /* Make sure the Descriptor is String Type */
;;;498    
;;;499        /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */
;;;500        strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
00000a  7805              LDRB     r5,[r0,#0]
00000c  1ead              SUBS     r5,r5,#2
00000e  429d              CMP      r5,r3
000010  d802              BHI      |L13.24|
000012  7805              LDRB     r5,[r0,#0]
000014  1ead              SUBS     r5,r5,#2
000016  e000              B        |L13.26|
                  |L13.24|
000018  461d              MOV      r5,r3
                  |L13.26|
00001a  b2ac              UXTH     r4,r5
;;;501    
;;;502        /* Adjust the offset ignoring the String Len and Descriptor type */
;;;503        psrc += 2U;
00001c  1c80              ADDS     r0,r0,#2
;;;504    
;;;505        for (idx = 0U; idx < strlength; idx += 2U)
00001e  2200              MOVS     r2,#0
000020  e004              B        |L13.44|
                  |L13.34|
;;;506        {
;;;507          /* Copy Only the string and ignore the UNICODE ID, hence add the src */
;;;508          *pdest =  psrc[idx];
000022  5c85              LDRB     r5,[r0,r2]
000024  700d              STRB     r5,[r1,#0]
;;;509          pdest++;
000026  1c49              ADDS     r1,r1,#1
000028  1c95              ADDS     r5,r2,#2              ;505
00002a  b2aa              UXTH     r2,r5                 ;505
                  |L13.44|
00002c  42a2              CMP      r2,r4                 ;505
00002e  dbf8              BLT      |L13.34|
;;;510        }
;;;511        *pdest = 0U; /* mark end of string */
000030  2500              MOVS     r5,#0
000032  700d              STRB     r5,[r1,#0]
                  |L13.52|
;;;512      }
;;;513    }
000034  bd30              POP      {r4,r5,pc}
;;;514    
                          ENDP


                          AREA ||i.USBH_SetAddress||, CODE, READONLY, ALIGN=1

                  USBH_SetAddress PROC
;;;221      */
;;;222    USBH_StatusTypeDef USBH_SetAddress(USBH_HandleTypeDef *phost,
000000  b570              PUSH     {r4-r6,lr}
;;;223                                       uint8_t DeviceAddress)
;;;224    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;225      if (phost->RequestState == CMD_SEND)
000006  78a0              LDRB     r0,[r4,#2]
000008  2801              CMP      r0,#1
00000a  d107              BNE      |L14.28|
;;;226      {
;;;227        phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
00000c  2100              MOVS     r1,#0
00000e  7421              STRB     r1,[r4,#0x10]
;;;228                                               USB_REQ_TYPE_STANDARD;
;;;229    
;;;230        phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
000010  2105              MOVS     r1,#5
000012  7461              STRB     r1,[r4,#0x11]
;;;231    
;;;232        phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
000014  8265              STRH     r5,[r4,#0x12]
;;;233        phost->Control.setup.b.wIndex.w = 0U;
000016  2100              MOVS     r1,#0
000018  82a1              STRH     r1,[r4,#0x14]
;;;234        phost->Control.setup.b.wLength.w = 0U;
00001a  82e1              STRH     r1,[r4,#0x16]
                  |L14.28|
;;;235      }
;;;236    
;;;237      return USBH_CtlReq(phost, 0U, 0U);
00001c  2200              MOVS     r2,#0
00001e  4611              MOV      r1,r2
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USBH_CtlReq
;;;238    }
000026  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP


                          AREA ||i.USBH_SetCfg||, CODE, READONLY, ALIGN=1

                  USBH_SetCfg PROC
;;;247      */
;;;248    USBH_StatusTypeDef USBH_SetCfg(USBH_HandleTypeDef *phost, uint16_t cfg_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;249    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;250      if (phost->RequestState == CMD_SEND)
000006  78a0              LDRB     r0,[r4,#2]
000008  2801              CMP      r0,#1
00000a  d107              BNE      |L15.28|
;;;251      {
;;;252        phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
00000c  2100              MOVS     r1,#0
00000e  7421              STRB     r1,[r4,#0x10]
;;;253                                               | USB_REQ_TYPE_STANDARD;
;;;254    
;;;255        phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
000010  2109              MOVS     r1,#9
000012  7461              STRB     r1,[r4,#0x11]
;;;256        phost->Control.setup.b.wValue.w = cfg_idx;
000014  8265              STRH     r5,[r4,#0x12]
;;;257        phost->Control.setup.b.wIndex.w = 0U;
000016  2100              MOVS     r1,#0
000018  82a1              STRH     r1,[r4,#0x14]
;;;258        phost->Control.setup.b.wLength.w = 0U;
00001a  82e1              STRH     r1,[r4,#0x16]
                  |L15.28|
;;;259      }
;;;260    
;;;261      return USBH_CtlReq(phost, 0U, 0U);
00001c  2200              MOVS     r2,#0
00001e  4611              MOV      r1,r2
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USBH_CtlReq
;;;262    }
000026  bd70              POP      {r4-r6,pc}
;;;263    
                          ENDP


                          AREA ||i.USBH_SetFeature||, CODE, READONLY, ALIGN=1

                  USBH_SetFeature PROC
;;;296    */
;;;297    USBH_StatusTypeDef USBH_SetFeature(USBH_HandleTypeDef *phost, uint8_t wValue)
000000  b570              PUSH     {r4-r6,lr}
;;;298    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;299      if (phost->RequestState == CMD_SEND)
000006  78a0              LDRB     r0,[r4,#2]
000008  2801              CMP      r0,#1
00000a  d107              BNE      |L16.28|
;;;300      {
;;;301        phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
00000c  2100              MOVS     r1,#0
00000e  7421              STRB     r1,[r4,#0x10]
;;;302                                               | USB_REQ_TYPE_STANDARD;
;;;303    
;;;304        phost->Control.setup.b.bRequest = USB_REQ_SET_FEATURE;
000010  2103              MOVS     r1,#3
000012  7461              STRB     r1,[r4,#0x11]
;;;305        phost->Control.setup.b.wValue.w = wValue;
000014  8265              STRH     r5,[r4,#0x12]
;;;306        phost->Control.setup.b.wIndex.w = 0U;
000016  2100              MOVS     r1,#0
000018  82a1              STRH     r1,[r4,#0x14]
;;;307        phost->Control.setup.b.wLength.w = 0U;
00001a  82e1              STRH     r1,[r4,#0x16]
                  |L16.28|
;;;308      }
;;;309    
;;;310      return USBH_CtlReq(phost, 0U, 0U);
00001c  2200              MOVS     r2,#0
00001e  4611              MOV      r1,r2
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USBH_CtlReq
;;;311    }
000026  bd70              POP      {r4-r6,pc}
;;;312    
                          ENDP


                          AREA ||i.USBH_SetInterface||, CODE, READONLY, ALIGN=1

                  USBH_SetInterface PROC
;;;271      */
;;;272    USBH_StatusTypeDef USBH_SetInterface(USBH_HandleTypeDef *phost, uint8_t ep_num,
000000  b570              PUSH     {r4-r6,lr}
;;;273                                         uint8_t altSetting)
;;;274    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;275      if (phost->RequestState == CMD_SEND)
000008  78a0              LDRB     r0,[r4,#2]
00000a  2801              CMP      r0,#1
00000c  d107              BNE      |L17.30|
;;;276      {
;;;277        phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_INTERFACE
00000e  2101              MOVS     r1,#1
000010  7421              STRB     r1,[r4,#0x10]
;;;278                                               | USB_REQ_TYPE_STANDARD;
;;;279    
;;;280        phost->Control.setup.b.bRequest = USB_REQ_SET_INTERFACE;
000012  210b              MOVS     r1,#0xb
000014  7461              STRB     r1,[r4,#0x11]
;;;281        phost->Control.setup.b.wValue.w = altSetting;
000016  8266              STRH     r6,[r4,#0x12]
;;;282        phost->Control.setup.b.wIndex.w = ep_num;
000018  82a5              STRH     r5,[r4,#0x14]
;;;283        phost->Control.setup.b.wLength.w = 0U;
00001a  2100              MOVS     r1,#0
00001c  82e1              STRH     r1,[r4,#0x16]
                  |L17.30|
;;;284      }
;;;285    
;;;286      return USBH_CtlReq(phost, 0U, 0U);
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       USBH_CtlReq
;;;287    }
000028  bd70              POP      {r4-r6,pc}
;;;288    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Middlewares/ST/STM32_USB_Host_Library/Core/Src/usbh_ctlreq.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_usbh_ctlreq_c_3531d2fa____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___13_usbh_ctlreq_c_3531d2fa____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_usbh_ctlreq_c_3531d2fa____REVSH|
#line 478
|__asm___13_usbh_ctlreq_c_3531d2fa____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_usbh_ctlreq_c_3531d2fa____RRX|
#line 665
|__asm___13_usbh_ctlreq_c_3531d2fa____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
