; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\usbh_conf.o --asm_dir=./ --list_dir=--list --depend=mcu_application\usbh_conf.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\usbh_conf.crf ../USB_HOST/Target/usbh_conf.c]
                          THUMB

                          AREA ||i.HAL_HCD_Connect_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_Connect_Callback PROC
;;;135      */
;;;136    void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;137    {
000002  4604              MOV      r4,r0
;;;138      USBH_LL_Connect(hhcd->pData);
000004  f8d402c0          LDR      r0,[r4,#0x2c0]
000008  f7fffffe          BL       USBH_LL_Connect
;;;139    }
00000c  bd10              POP      {r4,pc}
;;;140    
                          ENDP


                          AREA ||i.HAL_HCD_Disconnect_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_Disconnect_Callback PROC
;;;145      */
;;;146    void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;147    {
000002  4604              MOV      r4,r0
;;;148      USBH_LL_Disconnect(hhcd->pData);
000004  f8d402c0          LDR      r0,[r4,#0x2c0]
000008  f7fffffe          BL       USBH_LL_Disconnect
;;;149    }
00000c  bd10              POP      {r4,pc}
;;;150    
                          ENDP


                          AREA ||i.HAL_HCD_HC_NotifyURBChange_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_NotifyURBChange_Callback PROC
;;;157      */
;;;158    void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
000000  4770              BX       lr
;;;159    {
;;;160      /* To be used with OS to sync URB state with the global state machine */
;;;161    #if (USBH_USE_OS == 1)
;;;162      USBH_LL_NotifyURBChange(hhcd->pData);
;;;163    #endif
;;;164    }
;;;165    /**
                          ENDP


                          AREA ||i.HAL_HCD_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_HCD_MspDeInit PROC
;;;95     
;;;96     void HAL_HCD_MspDeInit(HCD_HandleTypeDef* hcdHandle)
000000  b510              PUSH     {r4,lr}
;;;97     {
000002  4604              MOV      r4,r0
;;;98       if(hcdHandle->Instance==USB_OTG_FS)
000004  6820              LDR      r0,[r4,#0]
000006  f1b04fa0          CMP      r0,#0x50000000
00000a  d10d              BNE      |L4.40|
;;;99       {
;;;100      /* USER CODE BEGIN USB_OTG_FS_MspDeInit 0 */
;;;101    
;;;102      /* USER CODE END USB_OTG_FS_MspDeInit 0 */
;;;103        /* Peripheral clock disable */
;;;104        __HAL_RCC_USB_OTG_FS_CLK_DISABLE();
00000c  4807              LDR      r0,|L4.44|
00000e  6800              LDR      r0,[r0,#0]
000010  f0200080          BIC      r0,r0,#0x80
000014  4905              LDR      r1,|L4.44|
000016  6008              STR      r0,[r1,#0]
;;;105    
;;;106        /**USB_OTG_FS GPIO Configuration
;;;107        PA11     ------> USB_OTG_FS_DM
;;;108        PA12     ------> USB_OTG_FS_DP
;;;109        */
;;;110        HAL_GPIO_DeInit(GPIOA, USB_OTG_FS_DM_Pin|USB_OTG_FS_DP_Pin);
000018  f44f51c0          MOV      r1,#0x1800
00001c  4804              LDR      r0,|L4.48|
00001e  f7fffffe          BL       HAL_GPIO_DeInit
;;;111    
;;;112        /* Peripheral interrupt Deinit*/
;;;113        HAL_NVIC_DisableIRQ(OTG_FS_IRQn);
000022  2043              MOVS     r0,#0x43
000024  f7fffffe          BL       HAL_NVIC_DisableIRQ
                  |L4.40|
;;;114    
;;;115      /* USER CODE BEGIN USB_OTG_FS_MspDeInit 1 */
;;;116    
;;;117      /* USER CODE END USB_OTG_FS_MspDeInit 1 */
;;;118      }
;;;119    }
000028  bd10              POP      {r4,pc}
;;;120    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40023834
                  |L4.48|
                          DCD      0x40020000

                          AREA ||i.HAL_HCD_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_HCD_MspInit PROC
;;;62     
;;;63     void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
000000  b510              PUSH     {r4,lr}
;;;64     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;65       GPIO_InitTypeDef GPIO_InitStruct = {0};
000006  2114              MOVS     r1,#0x14
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;66       if(hcdHandle->Instance==USB_OTG_FS)
00000e  6820              LDR      r0,[r4,#0]
000010  f1b04fa0          CMP      r0,#0x50000000
000014  d142              BNE      |L5.156|
;;;67       {
;;;68       /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */
;;;69     
;;;70       /* USER CODE END USB_OTG_FS_MspInit 0 */
;;;71     
;;;72         __HAL_RCC_GPIOA_CLK_ENABLE();
000016  bf00              NOP      
000018  2000              MOVS     r0,#0
00001a  9000              STR      r0,[sp,#0]
00001c  4820              LDR      r0,|L5.160|
00001e  6800              LDR      r0,[r0,#0]
000020  f0400001          ORR      r0,r0,#1
000024  491e              LDR      r1,|L5.160|
000026  6008              STR      r0,[r1,#0]
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f0000001          AND      r0,r0,#1
000030  9000              STR      r0,[sp,#0]
000032  bf00              NOP      
000034  bf00              NOP      
;;;73         /**USB_OTG_FS GPIO Configuration
;;;74         PA11     ------> USB_OTG_FS_DM
;;;75         PA12     ------> USB_OTG_FS_DP
;;;76         */
;;;77         GPIO_InitStruct.Pin = USB_OTG_FS_DM_Pin|USB_OTG_FS_DP_Pin;
000036  f44f50c0          MOV      r0,#0x1800
00003a  9001              STR      r0,[sp,#4]
;;;78         GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00003c  2002              MOVS     r0,#2
00003e  9002              STR      r0,[sp,#8]
;;;79         GPIO_InitStruct.Pull = GPIO_NOPULL;
000040  2000              MOVS     r0,#0
000042  9003              STR      r0,[sp,#0xc]
;;;80         GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
000044  2003              MOVS     r0,#3
000046  9004              STR      r0,[sp,#0x10]
;;;81         GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
000048  200a              MOVS     r0,#0xa
00004a  9005              STR      r0,[sp,#0x14]
;;;82         HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
00004c  a901              ADD      r1,sp,#4
00004e  4815              LDR      r0,|L5.164|
000050  f7fffffe          BL       HAL_GPIO_Init
;;;83     
;;;84         /* Peripheral clock enable */
;;;85         __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
000054  bf00              NOP      
000056  4812              LDR      r0,|L5.160|
000058  1d00              ADDS     r0,r0,#4
00005a  6800              LDR      r0,[r0,#0]
00005c  f0400080          ORR      r0,r0,#0x80
000060  490f              LDR      r1,|L5.160|
000062  1d09              ADDS     r1,r1,#4
000064  6008              STR      r0,[r1,#0]
000066  bf00              NOP      
000068  2000              MOVS     r0,#0
00006a  9000              STR      r0,[sp,#0]
00006c  480c              LDR      r0,|L5.160|
00006e  3014              ADDS     r0,r0,#0x14
000070  6800              LDR      r0,[r0,#0]
000072  f4404080          ORR      r0,r0,#0x4000
000076  490a              LDR      r1,|L5.160|
000078  3114              ADDS     r1,r1,#0x14
00007a  6008              STR      r0,[r1,#0]
00007c  4608              MOV      r0,r1
00007e  6800              LDR      r0,[r0,#0]
000080  f4004080          AND      r0,r0,#0x4000
000084  9000              STR      r0,[sp,#0]
000086  bf00              NOP      
000088  bf00              NOP      
00008a  bf00              NOP      
;;;86     
;;;87         /* Peripheral interrupt init */
;;;88         HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
00008c  2200              MOVS     r2,#0
00008e  2101              MOVS     r1,#1
000090  2043              MOVS     r0,#0x43
000092  f7fffffe          BL       HAL_NVIC_SetPriority
;;;89         HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
000096  2043              MOVS     r0,#0x43
000098  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L5.156|
;;;90       /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */
;;;91     
;;;92       /* USER CODE END USB_OTG_FS_MspInit 1 */
;;;93       }
;;;94     }
00009c  b006              ADD      sp,sp,#0x18
00009e  bd10              POP      {r4,pc}
;;;95     
                          ENDP

                  |L5.160|
                          DCD      0x40023830
                  |L5.164|
                          DCD      0x40020000

                          AREA ||i.HAL_HCD_PortDisabled_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_PortDisabled_Callback PROC
;;;179      */
;;;180    void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182      USBH_LL_PortDisabled(hhcd->pData);
000004  f8d402c0          LDR      r0,[r4,#0x2c0]
000008  f7fffffe          BL       USBH_LL_PortDisabled
;;;183    }
00000c  bd10              POP      {r4,pc}
;;;184    
                          ENDP


                          AREA ||i.HAL_HCD_PortEnabled_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_PortEnabled_Callback PROC
;;;169      */
;;;170    void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;171    {
000002  4604              MOV      r4,r0
;;;172      USBH_LL_PortEnabled(hhcd->pData);
000004  f8d402c0          LDR      r0,[r4,#0x2c0]
000008  f7fffffe          BL       USBH_LL_PortEnabled
;;;173    }
00000c  bd10              POP      {r4,pc}
;;;174    
                          ENDP


                          AREA ||i.HAL_HCD_SOF_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_SOF_Callback PROC
;;;125      */
;;;126    void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;127    {
000002  4604              MOV      r4,r0
;;;128      USBH_LL_IncTimer(hhcd->pData);
000004  f8d402c0          LDR      r0,[r4,#0x2c0]
000008  f7fffffe          BL       USBH_LL_IncTimer
;;;129    }
00000c  bd10              POP      {r4,pc}
;;;130    
                          ENDP


                          AREA ||i.USBH_Delay||, CODE, READONLY, ALIGN=1

                  USBH_Delay PROC
;;;505      */
;;;506    void USBH_Delay(uint32_t Delay)
000000  b510              PUSH     {r4,lr}
;;;507    {
000002  4604              MOV      r4,r0
;;;508      HAL_Delay(Delay);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HAL_Delay
;;;509    }
00000a  bd10              POP      {r4,pc}
;;;510    
                          ENDP


                          AREA ||i.USBH_Get_USB_Status||, CODE, READONLY, ALIGN=1

                  USBH_Get_USB_Status PROC
;;;515      */
;;;516    USBH_StatusTypeDef USBH_Get_USB_Status(HAL_StatusTypeDef hal_status)
000000  4601              MOV      r1,r0
;;;517    {
;;;518      USBH_StatusTypeDef usb_status = USBH_OK;
000002  2000              MOVS     r0,#0
;;;519    
;;;520      switch (hal_status)
000004  b131              CBZ      r1,|L10.20|
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L10.24|
00000a  2902              CMP      r1,#2
00000c  d006              BEQ      |L10.28|
00000e  2903              CMP      r1,#3
000010  d108              BNE      |L10.36|
000012  e005              B        |L10.32|
                  |L10.20|
;;;521      {
;;;522        case HAL_OK :
;;;523          usb_status = USBH_OK;
000014  2000              MOVS     r0,#0
;;;524        break;
000016  e007              B        |L10.40|
                  |L10.24|
;;;525        case HAL_ERROR :
;;;526          usb_status = USBH_FAIL;
000018  2002              MOVS     r0,#2
;;;527        break;
00001a  e005              B        |L10.40|
                  |L10.28|
;;;528        case HAL_BUSY :
;;;529          usb_status = USBH_BUSY;
00001c  2001              MOVS     r0,#1
;;;530        break;
00001e  e003              B        |L10.40|
                  |L10.32|
;;;531        case HAL_TIMEOUT :
;;;532          usb_status = USBH_FAIL;
000020  2002              MOVS     r0,#2
;;;533        break;
000022  e001              B        |L10.40|
                  |L10.36|
;;;534        default :
;;;535          usb_status = USBH_FAIL;
000024  2002              MOVS     r0,#2
;;;536        break;
000026  bf00              NOP      
                  |L10.40|
000028  bf00              NOP                            ;524
;;;537      }
;;;538      return usb_status;
;;;539    }
00002a  4770              BX       lr
;;;540    
                          ENDP


                          AREA ||i.USBH_LL_ClosePipe||, CODE, READONLY, ALIGN=1

                  USBH_LL_ClosePipe PROC
;;;357      */
;;;358    USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;359    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;360      HAL_StatusTypeDef hal_status = HAL_OK;
000008  2600              MOVS     r6,#0
;;;361      USBH_StatusTypeDef usb_status = USBH_OK;
00000a  2700              MOVS     r7,#0
;;;362    
;;;363      hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
00000c  4629              MOV      r1,r5
00000e  f8d403d0          LDR      r0,[r4,#0x3d0]
000012  f7fffffe          BL       HAL_HCD_HC_Halt
000016  4606              MOV      r6,r0
;;;364    
;;;365      usb_status = USBH_Get_USB_Status(hal_status);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       USBH_Get_USB_Status
00001e  4607              MOV      r7,r0
;;;366    
;;;367      return usb_status;
000020  4638              MOV      r0,r7
;;;368    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;369    
                          ENDP


                          AREA ||i.USBH_LL_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_LL_DeInit PROC
;;;222      */
;;;223    USBH_StatusTypeDef USBH_LL_DeInit(USBH_HandleTypeDef *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;224    {
000002  4604              MOV      r4,r0
;;;225      HAL_StatusTypeDef hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;226      USBH_StatusTypeDef usb_status = USBH_OK;
000006  2600              MOVS     r6,#0
;;;227    
;;;228      hal_status = HAL_HCD_DeInit(phost->pData);
000008  f8d403d0          LDR      r0,[r4,#0x3d0]
00000c  f7fffffe          BL       HAL_HCD_DeInit
000010  4605              MOV      r5,r0
;;;229    
;;;230      usb_status = USBH_Get_USB_Status(hal_status);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USBH_Get_USB_Status
000018  4606              MOV      r6,r0
;;;231    
;;;232      return usb_status;
00001a  4630              MOV      r0,r6
;;;233    }
00001c  bd70              POP      {r4-r6,pc}
;;;234    
                          ENDP


                          AREA ||i.USBH_LL_DriverVBUS||, CODE, READONLY, ALIGN=1

                  USBH_LL_DriverVBUS PROC
;;;439      */
;;;440    USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
000000  b570              PUSH     {r4-r6,lr}
;;;441    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;442      if (phost->id == HOST_FS) {
000006  f89503cc          LDRB     r0,[r5,#0x3cc]
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L13.20|
;;;443        MX_DriverVbusFS(state);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       MX_DriverVbusFS
                  |L13.20|
;;;444      }
;;;445    
;;;446      /* USER CODE BEGIN 0 */
;;;447    
;;;448      /* USER CODE END 0*/
;;;449    
;;;450      HAL_Delay(200);
000014  20c8              MOVS     r0,#0xc8
000016  f7fffffe          BL       HAL_Delay
;;;451      return USBH_OK;
00001a  2000              MOVS     r0,#0
;;;452    }
00001c  bd70              POP      {r4-r6,pc}
;;;453    
                          ENDP


                          AREA ||i.USBH_LL_GetLastXferSize||, CODE, READONLY, ALIGN=1

                  USBH_LL_GetLastXferSize PROC
;;;321      */
;;;322    uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
000000  b570              PUSH     {r4-r6,lr}
;;;323    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;324      return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
000006  4629              MOV      r1,r5
000008  f8d403d0          LDR      r0,[r4,#0x3d0]
00000c  f7fffffe          BL       HAL_HCD_HC_GetXferCount
;;;325    }
000010  bd70              POP      {r4-r6,pc}
;;;326    
                          ENDP


                          AREA ||i.USBH_LL_GetSpeed||, CODE, READONLY, ALIGN=1

                  USBH_LL_GetSpeed PROC
;;;273      */
;;;274    USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;275    {
000002  4604              MOV      r4,r0
;;;276      USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
000004  2501              MOVS     r5,#1
;;;277    
;;;278      switch (HAL_HCD_GetCurrentSpeed(phost->pData))
000006  f8d403d0          LDR      r0,[r4,#0x3d0]
00000a  f7fffffe          BL       HAL_HCD_GetCurrentSpeed
00000e  b120              CBZ      r0,|L15.26|
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L15.30|
000014  2802              CMP      r0,#2
000016  d106              BNE      |L15.38|
000018  e003              B        |L15.34|
                  |L15.26|
;;;279      {
;;;280      case 0 :
;;;281        speed = USBH_SPEED_HIGH;
00001a  2500              MOVS     r5,#0
;;;282        break;
00001c  e005              B        |L15.42|
                  |L15.30|
;;;283    
;;;284      case 1 :
;;;285        speed = USBH_SPEED_FULL;
00001e  2501              MOVS     r5,#1
;;;286        break;
000020  e003              B        |L15.42|
                  |L15.34|
;;;287    
;;;288      case 2 :
;;;289        speed = USBH_SPEED_LOW;
000022  2502              MOVS     r5,#2
;;;290        break;
000024  e001              B        |L15.42|
                  |L15.38|
;;;291    
;;;292      default:
;;;293       speed = USBH_SPEED_FULL;
000026  2501              MOVS     r5,#1
;;;294        break;
000028  bf00              NOP      
                  |L15.42|
00002a  bf00              NOP                            ;282
;;;295      }
;;;296      return  speed;
00002c  4628              MOV      r0,r5
;;;297    }
00002e  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP


                          AREA ||i.USBH_LL_GetToggle||, CODE, READONLY, ALIGN=1

                  USBH_LL_GetToggle PROC
;;;483      */
;;;484    uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef *phost, uint8_t pipe)
000000  b530              PUSH     {r4,r5,lr}
;;;485    {
000002  4603              MOV      r3,r0
;;;486      uint8_t toggle = 0;
000004  2000              MOVS     r0,#0
;;;487      HCD_HandleTypeDef *pHandle;
;;;488      pHandle = phost->pData;
000006  f8d323d0          LDR      r2,[r3,#0x3d0]
;;;489    
;;;490      if(pHandle->hc[pipe].ep_is_in)
00000a  eb010581          ADD      r5,r1,r1,LSL #2
00000e  f1020438          ADD      r4,r2,#0x38
000012  eb0404c5          ADD      r4,r4,r5,LSL #3
000016  78e4              LDRB     r4,[r4,#3]
000018  b13c              CBZ      r4,|L16.42|
;;;491      {
;;;492        toggle = pHandle->hc[pipe].toggle_in;
00001a  eb010581          ADD      r5,r1,r1,LSL #2
00001e  f1020438          ADD      r4,r2,#0x38
000022  eb0404c5          ADD      r4,r4,r5,LSL #3
000026  7e20              LDRB     r0,[r4,#0x18]
000028  e006              B        |L16.56|
                  |L16.42|
;;;493      }
;;;494      else
;;;495      {
;;;496        toggle = pHandle->hc[pipe].toggle_out;
00002a  eb010581          ADD      r5,r1,r1,LSL #2
00002e  f1020438          ADD      r4,r2,#0x38
000032  eb0404c5          ADD      r4,r4,r5,LSL #3
000036  7e60              LDRB     r0,[r4,#0x19]
                  |L16.56|
;;;497      }
;;;498      return toggle;
;;;499    }
000038  bd30              POP      {r4,r5,pc}
;;;500    
                          ENDP


                          AREA ||i.USBH_LL_GetURBState||, CODE, READONLY, ALIGN=1

                  USBH_LL_GetURBState PROC
;;;425      */
;;;426    USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
000000  b570              PUSH     {r4-r6,lr}
;;;427    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;428      return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
000006  4629              MOV      r1,r5
000008  f8d403d0          LDR      r0,[r4,#0x3d0]
00000c  f7fffffe          BL       HAL_HCD_HC_GetURBState
;;;429    }
000010  bd70              POP      {r4-r6,pc}
;;;430    
                          ENDP


                          AREA ||i.USBH_LL_Init||, CODE, READONLY, ALIGN=2

                  USBH_LL_Init PROC
;;;193      */
;;;194    USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;195    {
000002  4604              MOV      r4,r0
;;;196      /* Init USB_IP */
;;;197      if (phost->id == HOST_FS) {
000004  f89403cc          LDRB     r0,[r4,#0x3cc]
000008  2801              CMP      r0,#1
00000a  d120              BNE      |L18.78|
;;;198      /* Link the driver to the stack. */
;;;199      hhcd_USB_OTG_FS.pData = phost;
00000c  4811              LDR      r0,|L18.84|
00000e  f8c042c0          STR      r4,[r0,#0x2c0]  ; hhcd_USB_OTG_FS
;;;200      phost->pData = &hhcd_USB_OTG_FS;
000012  f8c403d0          STR      r0,[r4,#0x3d0]
;;;201    
;;;202      hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
000016  f04f40a0          MOV      r0,#0x50000000
00001a  490e              LDR      r1,|L18.84|
00001c  6008              STR      r0,[r1,#0]  ; hhcd_USB_OTG_FS
;;;203      hhcd_USB_OTG_FS.Init.Host_channels = 12;
00001e  210c              MOVS     r1,#0xc
000020  480c              LDR      r0,|L18.84|
000022  6081              STR      r1,[r0,#8]
;;;204      hhcd_USB_OTG_FS.Init.speed = HCD_SPEED_FULL;
000024  2101              MOVS     r1,#1
000026  60c1              STR      r1,[r0,#0xc]
;;;205      hhcd_USB_OTG_FS.Init.dma_enable = DISABLE;
000028  2100              MOVS     r1,#0
00002a  6101              STR      r1,[r0,#0x10]
;;;206      hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
00002c  2102              MOVS     r1,#2
00002e  6181              STR      r1,[r0,#0x18]
;;;207      hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
000030  2100              MOVS     r1,#0
000032  61c1              STR      r1,[r0,#0x1c]
;;;208      if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
000034  f7fffffe          BL       HAL_HCD_Init
000038  b108              CBZ      r0,|L18.62|
;;;209      {
;;;210        Error_Handler( );
00003a  f7fffffe          BL       Error_Handler
                  |L18.62|
;;;211      }
;;;212    
;;;213      USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
00003e  4805              LDR      r0,|L18.84|
000040  f7fffffe          BL       HAL_HCD_GetCurrentFrame
000044  4605              MOV      r5,r0
000046  4629              MOV      r1,r5
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       USBH_LL_SetTimer
                  |L18.78|
;;;214      }
;;;215      return USBH_OK;
00004e  2000              MOVS     r0,#0
;;;216    }
000050  bd70              POP      {r4-r6,pc}
;;;217    
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      hhcd_USB_OTG_FS

                          AREA ||i.USBH_LL_OpenPipe||, CODE, READONLY, ALIGN=1

                  USBH_LL_OpenPipe PROC
;;;337      */
;;;338    USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;339                                        uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
;;;340    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9a0f          LDRD     r9,r10,[sp,#0x3c]
000010  f8dd8038          LDR      r8,[sp,#0x38]
;;;341      HAL_StatusTypeDef hal_status = HAL_OK;
000014  f04f0b00          MOV      r11,#0
;;;342      USBH_StatusTypeDef usb_status = USBH_OK;
000018  2000              MOVS     r0,#0
00001a  9003              STR      r0,[sp,#0xc]
;;;343    
;;;344      hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
00001c  e88d0700          STM      sp,{r8-r10}
000020  463b              MOV      r3,r7
000022  4632              MOV      r2,r6
000024  4629              MOV      r1,r5
000026  f8d403d0          LDR      r0,[r4,#0x3d0]
00002a  f7fffffe          BL       HAL_HCD_HC_Init
00002e  4683              MOV      r11,r0
;;;345                                   dev_address, speed, ep_type, mps);
;;;346    
;;;347      usb_status = USBH_Get_USB_Status(hal_status);
000030  4658              MOV      r0,r11
000032  f7fffffe          BL       USBH_Get_USB_Status
000036  9003              STR      r0,[sp,#0xc]
;;;348    
;;;349      return usb_status;
000038  9803              LDR      r0,[sp,#0xc]
;;;350    }
00003a  b004              ADD      sp,sp,#0x10
00003c  e8bd9ff0          POP      {r4-r12,pc}
;;;351    
                          ENDP


                          AREA ||i.USBH_LL_ResetPort||, CODE, READONLY, ALIGN=1

                  USBH_LL_ResetPort PROC
;;;303      */
;;;304    USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;305    {
000002  4604              MOV      r4,r0
;;;306      HAL_StatusTypeDef hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;307      USBH_StatusTypeDef usb_status = USBH_OK;
000006  2600              MOVS     r6,#0
;;;308    
;;;309      hal_status = HAL_HCD_ResetPort(phost->pData);
000008  f8d403d0          LDR      r0,[r4,#0x3d0]
00000c  f7fffffe          BL       HAL_HCD_ResetPort
000010  4605              MOV      r5,r0
;;;310    
;;;311      usb_status = USBH_Get_USB_Status(hal_status);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USBH_Get_USB_Status
000018  4606              MOV      r6,r0
;;;312    
;;;313      return usb_status;
00001a  4630              MOV      r0,r6
;;;314    }
00001c  bd70              POP      {r4-r6,pc}
;;;315    
                          ENDP


                          AREA ||i.USBH_LL_SetToggle||, CODE, READONLY, ALIGN=1

                  USBH_LL_SetToggle PROC
;;;460      */
;;;461    USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
000000  b530              PUSH     {r4,r5,lr}
;;;462    {
000002  4604              MOV      r4,r0
;;;463      HCD_HandleTypeDef *pHandle;
;;;464      pHandle = phost->pData;
000004  f8d433d0          LDR      r3,[r4,#0x3d0]
;;;465    
;;;466      if(pHandle->hc[pipe].ep_is_in)
000008  eb010581          ADD      r5,r1,r1,LSL #2
00000c  f1030038          ADD      r0,r3,#0x38
000010  eb0000c5          ADD      r0,r0,r5,LSL #3
000014  78c0              LDRB     r0,[r0,#3]
000016  b138              CBZ      r0,|L21.40|
;;;467      {
;;;468        pHandle->hc[pipe].toggle_in = toggle;
000018  eb010581          ADD      r5,r1,r1,LSL #2
00001c  f1030038          ADD      r0,r3,#0x38
000020  eb0000c5          ADD      r0,r0,r5,LSL #3
000024  7602              STRB     r2,[r0,#0x18]
000026  e006              B        |L21.54|
                  |L21.40|
;;;469      }
;;;470      else
;;;471      {
;;;472        pHandle->hc[pipe].toggle_out = toggle;
000028  eb010581          ADD      r5,r1,r1,LSL #2
00002c  f1030038          ADD      r0,r3,#0x38
000030  eb0000c5          ADD      r0,r0,r5,LSL #3
000034  7642              STRB     r2,[r0,#0x19]
                  |L21.54|
;;;473      }
;;;474    
;;;475      return USBH_OK;
000036  2000              MOVS     r0,#0
;;;476    }
000038  bd30              POP      {r4,r5,pc}
;;;477    
                          ENDP


                          AREA ||i.USBH_LL_Start||, CODE, READONLY, ALIGN=1

                  USBH_LL_Start PROC
;;;239      */
;;;240    USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;241    {
000002  4604              MOV      r4,r0
;;;242      HAL_StatusTypeDef hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;243      USBH_StatusTypeDef usb_status = USBH_OK;
000006  2600              MOVS     r6,#0
;;;244    
;;;245      hal_status = HAL_HCD_Start(phost->pData);
000008  f8d403d0          LDR      r0,[r4,#0x3d0]
00000c  f7fffffe          BL       HAL_HCD_Start
000010  4605              MOV      r5,r0
;;;246    
;;;247      usb_status = USBH_Get_USB_Status(hal_status);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USBH_Get_USB_Status
000018  4606              MOV      r6,r0
;;;248    
;;;249      return usb_status;
00001a  4630              MOV      r0,r6
;;;250    }
00001c  bd70              POP      {r4-r6,pc}
;;;251    
                          ENDP


                          AREA ||i.USBH_LL_Stop||, CODE, READONLY, ALIGN=1

                  USBH_LL_Stop PROC
;;;256      */
;;;257    USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;258    {
000002  4604              MOV      r4,r0
;;;259      HAL_StatusTypeDef hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;260      USBH_StatusTypeDef usb_status = USBH_OK;
000006  2600              MOVS     r6,#0
;;;261    
;;;262      hal_status = HAL_HCD_Stop(phost->pData);
000008  f8d403d0          LDR      r0,[r4,#0x3d0]
00000c  f7fffffe          BL       HAL_HCD_Stop
000010  4605              MOV      r5,r0
;;;263    
;;;264      usb_status = USBH_Get_USB_Status(hal_status);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USBH_Get_USB_Status
000018  4606              MOV      r6,r0
;;;265    
;;;266      return usb_status;
00001a  4630              MOV      r0,r6
;;;267    }
00001c  bd70              POP      {r4-r6,pc}
;;;268    
                          ENDP


                          AREA ||i.USBH_LL_SubmitURB||, CODE, READONLY, ALIGN=1

                  USBH_LL_SubmitURB PROC
;;;396      */
;;;397    USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;398                                         uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
;;;399                                         uint8_t do_ping)
;;;400    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  e9ddab12          LDRD     r10,r11,[sp,#0x48]
000012  e9dd8910          LDRD     r8,r9,[sp,#0x40]
;;;401      HAL_StatusTypeDef hal_status = HAL_OK;
000016  2000              MOVS     r0,#0
000018  9006              STR      r0,[sp,#0x18]
;;;402      USBH_StatusTypeDef usb_status = USBH_OK;
00001a  9005              STR      r0,[sp,#0x14]
;;;403    
;;;404      hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
00001c  e88d0f00          STM      sp,{r8-r11}
000020  463b              MOV      r3,r7
000022  4632              MOV      r2,r6
000024  4629              MOV      r1,r5
000026  f8d403d0          LDR      r0,[r4,#0x3d0]
00002a  f7fffffe          BL       HAL_HCD_HC_SubmitRequest
00002e  9006              STR      r0,[sp,#0x18]
;;;405                                            ep_type, token, pbuff, length,
;;;406                                            do_ping);
;;;407      usb_status =  USBH_Get_USB_Status(hal_status);
000030  9806              LDR      r0,[sp,#0x18]
000032  f7fffffe          BL       USBH_Get_USB_Status
000036  9005              STR      r0,[sp,#0x14]
;;;408    
;;;409      return usb_status;
000038  9805              LDR      r0,[sp,#0x14]
;;;410    }
00003a  b007              ADD      sp,sp,#0x1c
00003c  e8bd8ff0          POP      {r4-r11,pc}
;;;411    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hhcd_USB_OTG_FS
                          %        708

;*** Start embedded assembler ***

#line 1 "../USB_HOST/Target/usbh_conf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_conf_c_670ba790____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___11_usbh_conf_c_670ba790____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_conf_c_670ba790____REVSH|
#line 478
|__asm___11_usbh_conf_c_670ba790____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_conf_c_670ba790____RRX|
#line 665
|__asm___11_usbh_conf_c_670ba790____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
