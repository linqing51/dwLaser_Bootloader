; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_dma.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_dma.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_dma.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;1183     */
;;;1184   static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1185   {
;;;1186     uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
000002  7808              LDRB     r0,[r1,#0]
000004  3810              SUBS     r0,r0,#0x10
000006  2318              MOVS     r3,#0x18
000008  fbb0f2f3          UDIV     r2,r0,r3
;;;1187     
;;;1188     /* lookup table for necessary bitshift of flags within status registers */
;;;1189     static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
;;;1190     hdma->StreamIndex = flagBitshiftOffset[stream_number];
00000c  4808              LDR      r0,|L1.48|
00000e  5c80              LDRB     r0,[r0,r2]
000010  65c8              STR      r0,[r1,#0x5c]
;;;1191     
;;;1192     if (stream_number > 3U)
000012  2a03              CMP      r2,#3
000014  d905              BLS      |L1.34|
;;;1193     {
;;;1194       /* return pointer to HISR and HIFCR */
;;;1195       hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
000016  6808              LDR      r0,[r1,#0]
000018  f36f0009          BFC      r0,#0,#10
00001c  1d00              ADDS     r0,r0,#4
00001e  6588              STR      r0,[r1,#0x58]
000020  e003              B        |L1.42|
                  |L1.34|
;;;1196     }
;;;1197     else
;;;1198     {
;;;1199       /* return pointer to LISR and LIFCR */
;;;1200       hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
000022  6808              LDR      r0,[r1,#0]
000024  f36f0009          BFC      r0,#0,#10
000028  6588              STR      r0,[r1,#0x58]
                  |L1.42|
;;;1201     }
;;;1202     
;;;1203     return hdma->StreamBaseAddress;
00002a  6d88              LDR      r0,[r1,#0x58]
;;;1204   }
00002c  4770              BX       lr
;;;1205   
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      flagBitshiftOffset

                          AREA ||i.DMA_CheckFifoParam||, CODE, READONLY, ALIGN=1

                  DMA_CheckFifoParam PROC
;;;1211     */
;;;1212   static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1213   {
;;;1214     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;1215     uint32_t tmp = hdma->Init.FIFOThreshold;
000004  6a8a              LDR      r2,[r1,#0x28]
;;;1216     
;;;1217     /* Memory Data size equal to Byte */
;;;1218     if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
000006  698b              LDR      r3,[r1,#0x18]
000008  b9cb              CBNZ     r3,|L2.62|
;;;1219     {
;;;1220       switch (tmp)
00000a  b132              CBZ      r2,|L2.26|
00000c  2a01              CMP      r2,#1
00000e  d00d              BEQ      |L2.44|
000010  2a02              CMP      r2,#2
000012  d003              BEQ      |L2.28|
000014  2a03              CMP      r2,#3
000016  d110              BNE      |L2.58|
000018  e00e              B        |L2.56|
                  |L2.26|
;;;1221       {
;;;1222       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1223       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00001a  bf00              NOP      
                  |L2.28|
;;;1224         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00001c  6acb              LDR      r3,[r1,#0x2c]
00001e  f0037380          AND      r3,r3,#0x1000000
000022  f1b37f80          CMP      r3,#0x1000000
000026  d100              BNE      |L2.42|
;;;1225         {
;;;1226           status = HAL_ERROR;
000028  2001              MOVS     r0,#1
                  |L2.42|
;;;1227         }
;;;1228         break;
00002a  e007              B        |L2.60|
                  |L2.44|
;;;1229       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1230         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00002c  6acb              LDR      r3,[r1,#0x2c]
00002e  f1b37fc0          CMP      r3,#0x1800000
000032  d100              BNE      |L2.54|
;;;1231         {
;;;1232           status = HAL_ERROR;
000034  2001              MOVS     r0,#1
                  |L2.54|
;;;1233         }
;;;1234         break;
000036  e001              B        |L2.60|
                  |L2.56|
;;;1235       case DMA_FIFO_THRESHOLD_FULL:
;;;1236         break;
000038  e000              B        |L2.60|
                  |L2.58|
;;;1237       default:
;;;1238         break;
00003a  bf00              NOP      
                  |L2.60|
00003c  e034              B        |L2.168|
                  |L2.62|
;;;1239       }
;;;1240     }
;;;1241     
;;;1242     /* Memory Data size equal to Half-Word */
;;;1243     else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
00003e  698b              LDR      r3,[r1,#0x18]
000040  f5b35f00          CMP      r3,#0x2000
000044  d11a              BNE      |L2.124|
;;;1244     {
;;;1245       switch (tmp)
000046  b132              CBZ      r2,|L2.86|
000048  2a01              CMP      r2,#1
00004a  d007              BEQ      |L2.92|
00004c  2a02              CMP      r2,#2
00004e  d003              BEQ      |L2.88|
000050  2a03              CMP      r2,#3
000052  d111              BNE      |L2.120|
000054  e00a              B        |L2.108|
                  |L2.86|
;;;1246       {
;;;1247       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1248       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
000056  bf00              NOP      
                  |L2.88|
;;;1249         status = HAL_ERROR;
000058  2001              MOVS     r0,#1
;;;1250         break;
00005a  e00e              B        |L2.122|
                  |L2.92|
;;;1251       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1252         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00005c  6acb              LDR      r3,[r1,#0x2c]
00005e  f0037380          AND      r3,r3,#0x1000000
000062  f1b37f80          CMP      r3,#0x1000000
000066  d100              BNE      |L2.106|
;;;1253         {
;;;1254           status = HAL_ERROR;
000068  2001              MOVS     r0,#1
                  |L2.106|
;;;1255         }
;;;1256         break;
00006a  e006              B        |L2.122|
                  |L2.108|
;;;1257       case DMA_FIFO_THRESHOLD_FULL:
;;;1258         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00006c  6acb              LDR      r3,[r1,#0x2c]
00006e  f1b37fc0          CMP      r3,#0x1800000
000072  d100              BNE      |L2.118|
;;;1259         {
;;;1260           status = HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L2.118|
;;;1261         }
;;;1262         break;   
000076  e000              B        |L2.122|
                  |L2.120|
;;;1263       default:
;;;1264         break;
000078  bf00              NOP      
                  |L2.122|
00007a  e015              B        |L2.168|
                  |L2.124|
;;;1265       }
;;;1266     }
;;;1267     
;;;1268     /* Memory Data size equal to Word */
;;;1269     else
;;;1270     {
;;;1271       switch (tmp)
00007c  b132              CBZ      r2,|L2.140|
00007e  2a01              CMP      r2,#1
000080  d005              BEQ      |L2.142|
000082  2a02              CMP      r2,#2
000084  d004              BEQ      |L2.144|
000086  2a03              CMP      r2,#3
000088  d10c              BNE      |L2.164|
00008a  e003              B        |L2.148|
                  |L2.140|
;;;1272       {
;;;1273       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1274       case DMA_FIFO_THRESHOLD_HALFFULL:
00008c  bf00              NOP      
                  |L2.142|
;;;1275       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00008e  bf00              NOP      
                  |L2.144|
;;;1276         status = HAL_ERROR;
000090  2001              MOVS     r0,#1
;;;1277         break;
000092  e008              B        |L2.166|
                  |L2.148|
;;;1278       case DMA_FIFO_THRESHOLD_FULL:
;;;1279         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000094  6acb              LDR      r3,[r1,#0x2c]
000096  f0037380          AND      r3,r3,#0x1000000
00009a  f1b37f80          CMP      r3,#0x1000000
00009e  d100              BNE      |L2.162|
;;;1280         {
;;;1281           status = HAL_ERROR;
0000a0  2001              MOVS     r0,#1
                  |L2.162|
;;;1282         }
;;;1283         break;
0000a2  e000              B        |L2.166|
                  |L2.164|
;;;1284       default:
;;;1285         break;
0000a4  bf00              NOP      
                  |L2.166|
0000a6  bf00              NOP                            ;1277
                  |L2.168|
;;;1286       }
;;;1287     } 
;;;1288     
;;;1289     return status; 
;;;1290   }
0000a8  4770              BX       lr
;;;1291   
                          ENDP


                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1149     */
;;;1150   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1151   {
;;;1152     /* Clear DBM bit */
;;;1153     hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6824              LDR      r4,[r4,#0]
000006  f4242480          BIC      r4,r4,#0x40000
00000a  6805              LDR      r5,[r0,#0]
00000c  602c              STR      r4,[r5,#0]
;;;1154   
;;;1155     /* Configure DMA Stream data length */
;;;1156     hdma->Instance->NDTR = DataLength;
00000e  6804              LDR      r4,[r0,#0]
000010  6063              STR      r3,[r4,#4]
;;;1157   
;;;1158     /* Memory to Peripheral */
;;;1159     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000012  6884              LDR      r4,[r0,#8]
000014  2c40              CMP      r4,#0x40
000016  d104              BNE      |L3.34|
;;;1160     {
;;;1161       /* Configure DMA Stream destination address */
;;;1162       hdma->Instance->PAR = DstAddress;
000018  6804              LDR      r4,[r0,#0]
00001a  60a2              STR      r2,[r4,#8]
;;;1163   
;;;1164       /* Configure DMA Stream source address */
;;;1165       hdma->Instance->M0AR = SrcAddress;
00001c  6804              LDR      r4,[r0,#0]
00001e  60e1              STR      r1,[r4,#0xc]
000020  e003              B        |L3.42|
                  |L3.34|
;;;1166     }
;;;1167     /* Peripheral to Memory */
;;;1168     else
;;;1169     {
;;;1170       /* Configure DMA Stream source address */
;;;1171       hdma->Instance->PAR = SrcAddress;
000022  6804              LDR      r4,[r0,#0]
000024  60a1              STR      r1,[r4,#8]
;;;1172   
;;;1173       /* Configure DMA Stream destination address */
;;;1174       hdma->Instance->M0AR = DstAddress;
000026  6804              LDR      r4,[r0,#0]
000028  60e2              STR      r2,[r4,#0xc]
                  |L3.42|
;;;1175     }
;;;1176   }
00002a  bd30              POP      {r4,r5,pc}
;;;1177   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;513      */
;;;514    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;515    {
000002  4604              MOV      r4,r0
;;;516      /* calculate DMA base and stream number */
;;;517      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000004  6da5              LDR      r5,[r4,#0x58]
;;;518      
;;;519      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;520      
;;;521      if(hdma->State != HAL_DMA_STATE_BUSY)
00000c  f8940035          LDRB     r0,[r4,#0x35]
000010  2802              CMP      r0,#2
000012  d008              BEQ      |L4.38|
;;;522      {
;;;523        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000014  2080              MOVS     r0,#0x80
000016  6560              STR      r0,[r4,#0x54]
;;;524        
;;;525        /* Process Unlocked */
;;;526        __HAL_UNLOCK(hdma);
000018  bf00              NOP      
00001a  2000              MOVS     r0,#0
00001c  f8840034          STRB     r0,[r4,#0x34]
000020  bf00              NOP      
;;;527        
;;;528        return HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L4.36|
;;;529      }
;;;530      else
;;;531      {
;;;532        /* Disable all the transfer interrupts */
;;;533        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;534        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;535        
;;;536        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;537        {
;;;538          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;539        }
;;;540        
;;;541        /* Disable the stream */
;;;542        __HAL_DMA_DISABLE(hdma);
;;;543        
;;;544        /* Check if the DMA Stream is effectively disabled */
;;;545        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;546        {
;;;547          /* Check for the Timeout */
;;;548          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;549          {
;;;550            /* Update error code */
;;;551            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;552            
;;;553            /* Process Unlocked */
;;;554            __HAL_UNLOCK(hdma);
;;;555            
;;;556            /* Change the DMA state */
;;;557            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;558            
;;;559            return HAL_TIMEOUT;
;;;560          }
;;;561        }
;;;562        
;;;563        /* Clear all interrupt flags at correct offset within the register */
;;;564        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;565        
;;;566        /* Process Unlocked */
;;;567        __HAL_UNLOCK(hdma);
;;;568        
;;;569        /* Change the DMA state*/
;;;570        hdma->State = HAL_DMA_STATE_READY;
;;;571      }
;;;572      return HAL_OK;
;;;573    }
000024  bd70              POP      {r4-r6,pc}
                  |L4.38|
000026  6820              LDR      r0,[r4,#0]            ;533
000028  6800              LDR      r0,[r0,#0]            ;533
00002a  f0200016          BIC      r0,r0,#0x16           ;533
00002e  6821              LDR      r1,[r4,#0]            ;533
000030  6008              STR      r0,[r1,#0]            ;533
000032  6820              LDR      r0,[r4,#0]            ;534
000034  6940              LDR      r0,[r0,#0x14]         ;534
000036  f0200080          BIC      r0,r0,#0x80           ;534
00003a  6821              LDR      r1,[r4,#0]            ;534
00003c  6148              STR      r0,[r1,#0x14]         ;534
00003e  6c20              LDR      r0,[r4,#0x40]         ;536
000040  b908              CBNZ     r0,|L4.70|
000042  6ca0              LDR      r0,[r4,#0x48]         ;536
000044  b128              CBZ      r0,|L4.82|
                  |L4.70|
000046  6820              LDR      r0,[r4,#0]            ;538
000048  6800              LDR      r0,[r0,#0]            ;538
00004a  f0200008          BIC      r0,r0,#8              ;538
00004e  6821              LDR      r1,[r4,#0]            ;538
000050  6008              STR      r0,[r1,#0]            ;538
                  |L4.82|
000052  6820              LDR      r0,[r4,#0]            ;542
000054  6800              LDR      r0,[r0,#0]            ;542
000056  f0200001          BIC      r0,r0,#1              ;542
00005a  6821              LDR      r1,[r4,#0]            ;542
00005c  6008              STR      r0,[r1,#0]            ;542
00005e  e00f              B        |L4.128|
                  |L4.96|
000060  f7fffffe          BL       HAL_GetTick
000064  1b80              SUBS     r0,r0,r6              ;548
000066  2805              CMP      r0,#5                 ;548
000068  d90a              BLS      |L4.128|
00006a  2020              MOVS     r0,#0x20              ;551
00006c  6560              STR      r0,[r4,#0x54]         ;551
00006e  bf00              NOP                            ;554
000070  2000              MOVS     r0,#0                 ;554
000072  f8840034          STRB     r0,[r4,#0x34]         ;554
000076  bf00              NOP                            ;554
000078  2003              MOVS     r0,#3                 ;557
00007a  f8840035          STRB     r0,[r4,#0x35]         ;557
00007e  e7d1              B        |L4.36|
                  |L4.128|
000080  6820              LDR      r0,[r4,#0]            ;545
000082  6800              LDR      r0,[r0,#0]            ;545
000084  f0000001          AND      r0,r0,#1              ;545
000088  2800              CMP      r0,#0                 ;545
00008a  d1e9              BNE      |L4.96|
00008c  f894105c          LDRB     r1,[r4,#0x5c]         ;564
000090  203f              MOVS     r0,#0x3f              ;564
000092  4088              LSLS     r0,r0,r1              ;564
000094  60a8              STR      r0,[r5,#8]            ;564
000096  bf00              NOP                            ;567
000098  2000              MOVS     r0,#0                 ;567
00009a  f8840034          STRB     r0,[r4,#0x34]         ;567
00009e  bf00              NOP                            ;567
0000a0  2001              MOVS     r0,#1                 ;570
0000a2  f8840035          STRB     r0,[r4,#0x35]         ;570
0000a6  2000              MOVS     r0,#0                 ;572
0000a8  e7bc              B        |L4.36|
;;;574    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;580      */
;;;581    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;582    {
;;;583      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  f8910035          LDRB     r0,[r1,#0x35]
000006  2802              CMP      r0,#2
000008  d003              BEQ      |L5.18|
;;;584      {
;;;585        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000a  2080              MOVS     r0,#0x80
00000c  6548              STR      r0,[r1,#0x54]
;;;586        return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L5.16|
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Set Abort State  */
;;;591        hdma->State = HAL_DMA_STATE_ABORT;
;;;592        
;;;593        /* Disable the stream */
;;;594        __HAL_DMA_DISABLE(hdma);
;;;595      }
;;;596    
;;;597      return HAL_OK;
;;;598    }
000010  4770              BX       lr
                  |L5.18|
000012  2005              MOVS     r0,#5                 ;591
000014  f8810035          STRB     r0,[r1,#0x35]         ;591
000018  6808              LDR      r0,[r1,#0]            ;594
00001a  6800              LDR      r0,[r0,#0]            ;594
00001c  f0200001          BIC      r0,r0,#1              ;594
000020  680a              LDR      r2,[r1,#0]            ;594
000022  6010              STR      r0,[r2,#0]            ;594
000024  2000              MOVS     r0,#0                 ;597
000026  e7f3              B        |L5.16|
;;;599    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;309      */
;;;310    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;311    {
000002  4604              MOV      r4,r0
;;;312      DMA_Base_Registers *regs;
;;;313    
;;;314      /* Check the DMA peripheral state */
;;;315      if(hdma == NULL)
000004  b90c              CBNZ     r4,|L6.10|
;;;316      {
;;;317        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;318      }
;;;319      
;;;320      /* Check the DMA peripheral state */
;;;321      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;322      {
;;;323        /* Return error status */
;;;324        return HAL_BUSY;
;;;325      }
;;;326    
;;;327      /* Check the parameters */
;;;328      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;329    
;;;330      /* Disable the selected DMA Streamx */
;;;331      __HAL_DMA_DISABLE(hdma);
;;;332    
;;;333      /* Reset DMA Streamx control register */
;;;334      hdma->Instance->CR   = 0U;
;;;335    
;;;336      /* Reset DMA Streamx number of data to transfer register */
;;;337      hdma->Instance->NDTR = 0U;
;;;338    
;;;339      /* Reset DMA Streamx peripheral address register */
;;;340      hdma->Instance->PAR  = 0U;
;;;341    
;;;342      /* Reset DMA Streamx memory 0 address register */
;;;343      hdma->Instance->M0AR = 0U;
;;;344      
;;;345      /* Reset DMA Streamx memory 1 address register */
;;;346      hdma->Instance->M1AR = 0U;
;;;347      
;;;348      /* Reset DMA Streamx FIFO control register */
;;;349      hdma->Instance->FCR  = 0x00000021U;
;;;350      
;;;351      /* Get DMA steam Base Address */  
;;;352      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;353      
;;;354      /* Clean all callbacks */
;;;355      hdma->XferCpltCallback = NULL;
;;;356      hdma->XferHalfCpltCallback = NULL;
;;;357      hdma->XferM1CpltCallback = NULL;
;;;358      hdma->XferM1HalfCpltCallback = NULL;
;;;359      hdma->XferErrorCallback = NULL;
;;;360      hdma->XferAbortCallback = NULL;
;;;361    
;;;362      /* Clear all interrupt flags at correct offset within the register */
;;;363      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;364    
;;;365      /* Reset the error code */
;;;366      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;367    
;;;368      /* Reset the DMA state */
;;;369      hdma->State = HAL_DMA_STATE_RESET;
;;;370    
;;;371      /* Release Lock */
;;;372      __HAL_UNLOCK(hdma);
;;;373    
;;;374      return HAL_OK;
;;;375    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  f8940035          LDRB     r0,[r4,#0x35]         ;321
00000e  2802              CMP      r0,#2                 ;321
000010  d100              BNE      |L6.20|
000012  e7f9              B        |L6.8|
                  |L6.20|
000014  6820              LDR      r0,[r4,#0]            ;331
000016  6800              LDR      r0,[r0,#0]            ;331
000018  f0200001          BIC      r0,r0,#1              ;331
00001c  6821              LDR      r1,[r4,#0]            ;331
00001e  6008              STR      r0,[r1,#0]            ;331
000020  2000              MOVS     r0,#0                 ;334
000022  6821              LDR      r1,[r4,#0]            ;334
000024  6008              STR      r0,[r1,#0]            ;334
000026  6821              LDR      r1,[r4,#0]            ;337
000028  6048              STR      r0,[r1,#4]            ;337
00002a  6821              LDR      r1,[r4,#0]            ;340
00002c  6088              STR      r0,[r1,#8]            ;340
00002e  6821              LDR      r1,[r4,#0]            ;343
000030  60c8              STR      r0,[r1,#0xc]          ;343
000032  6821              LDR      r1,[r4,#0]            ;346
000034  6108              STR      r0,[r1,#0x10]         ;346
000036  2021              MOVS     r0,#0x21              ;349
000038  6821              LDR      r1,[r4,#0]            ;349
00003a  6148              STR      r0,[r1,#0x14]         ;349
00003c  4620              MOV      r0,r4                 ;352
00003e  f7fffffe          BL       DMA_CalcBaseAndBitshift
000042  4605              MOV      r5,r0                 ;352
000044  2000              MOVS     r0,#0                 ;355
000046  63e0              STR      r0,[r4,#0x3c]         ;355
000048  6420              STR      r0,[r4,#0x40]         ;356
00004a  6460              STR      r0,[r4,#0x44]         ;357
00004c  64a0              STR      r0,[r4,#0x48]         ;358
00004e  64e0              STR      r0,[r4,#0x4c]         ;359
000050  6520              STR      r0,[r4,#0x50]         ;360
000052  f894105c          LDRB     r1,[r4,#0x5c]         ;363
000056  203f              MOVS     r0,#0x3f              ;363
000058  4088              LSLS     r0,r0,r1              ;363
00005a  60a8              STR      r0,[r5,#8]            ;363
00005c  2000              MOVS     r0,#0                 ;366
00005e  6560              STR      r0,[r4,#0x54]         ;366
000060  f8840035          STRB     r0,[r4,#0x35]         ;369
000064  bf00              NOP                            ;372
000066  f8840034          STRB     r0,[r4,#0x34]         ;372
00006a  bf00              NOP                            ;372
00006c  bf00              NOP                            ;374
00006e  e7cb              B        |L6.8|
;;;376    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1123     */
;;;1124   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1125   {
;;;1126     return hdma->ErrorCode;
000002  6d48              LDR      r0,[r1,#0x54]
;;;1127   }
000004  4770              BX       lr
;;;1128   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1112     */
;;;1113   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1114   {
;;;1115     return hdma->State;
000002  f8910035          LDRB     r0,[r1,#0x35]
;;;1116   }
000006  4770              BX       lr
;;;1117   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;746      */
;;;747    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;748    {
000002  4604              MOV      r4,r0
;;;749      uint32_t tmpisr;
;;;750      __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;751      uint32_t timeout = SystemCoreClock / 9600U;
000008  488c              LDR      r0,|L9.572|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f44f5116          MOV      r1,#0x2580
000010  fbb0f7f1          UDIV     r7,r0,r1
;;;752    
;;;753      /* calculate DMA base and stream number */
;;;754      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000014  6da5              LDR      r5,[r4,#0x58]
;;;755    
;;;756      tmpisr = regs->ISR;
000016  682e              LDR      r6,[r5,#0]
;;;757    
;;;758      /* Transfer Error Interrupt management ***************************************/
;;;759      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
000018  f894105c          LDRB     r1,[r4,#0x5c]
00001c  2008              MOVS     r0,#8
00001e  4088              LSLS     r0,r0,r1
000020  4030              ANDS     r0,r0,r6
000022  b198              CBZ      r0,|L9.76|
;;;760      {
;;;761        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f0000004          AND      r0,r0,#4
00002c  b170              CBZ      r0,|L9.76|
;;;762        {
;;;763          /* Disable the transfer error interrupt */
;;;764          hdma->Instance->CR  &= ~(DMA_IT_TE);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;765          
;;;766          /* Clear the transfer error flag */
;;;767          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003a  f894105c          LDRB     r1,[r4,#0x5c]
00003e  2008              MOVS     r0,#8
000040  4088              LSLS     r0,r0,r1
000042  60a8              STR      r0,[r5,#8]
;;;768          
;;;769          /* Update error code */
;;;770          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400001          ORR      r0,r0,#1
00004a  6560              STR      r0,[r4,#0x54]
                  |L9.76|
;;;771        }
;;;772      }
;;;773      /* FIFO Error Interrupt management ******************************************/
;;;774      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
00004c  f894105c          LDRB     r1,[r4,#0x5c]
000050  2001              MOVS     r0,#1
000052  4088              LSLS     r0,r0,r1
000054  4030              ANDS     r0,r0,r6
000056  b168              CBZ      r0,|L9.116|
;;;775      {
;;;776        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
000058  6820              LDR      r0,[r4,#0]
00005a  6940              LDR      r0,[r0,#0x14]
00005c  f0000080          AND      r0,r0,#0x80
000060  b140              CBZ      r0,|L9.116|
;;;777        {
;;;778          /* Clear the FIFO error flag */
;;;779          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000062  f894105c          LDRB     r1,[r4,#0x5c]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  60a8              STR      r0,[r5,#8]
;;;780    
;;;781          /* Update error code */
;;;782          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00006c  6d60              LDR      r0,[r4,#0x54]
00006e  f0400002          ORR      r0,r0,#2
000072  6560              STR      r0,[r4,#0x54]
                  |L9.116|
;;;783        }
;;;784      }
;;;785      /* Direct Mode Error Interrupt management ***********************************/
;;;786      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
000074  f894105c          LDRB     r1,[r4,#0x5c]
000078  2004              MOVS     r0,#4
00007a  4088              LSLS     r0,r0,r1
00007c  4030              ANDS     r0,r0,r6
00007e  b168              CBZ      r0,|L9.156|
;;;787      {
;;;788        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0000002          AND      r0,r0,#2
000088  b140              CBZ      r0,|L9.156|
;;;789        {
;;;790          /* Clear the direct mode error flag */
;;;791          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
00008a  f894105c          LDRB     r1,[r4,#0x5c]
00008e  2004              MOVS     r0,#4
000090  4088              LSLS     r0,r0,r1
000092  60a8              STR      r0,[r5,#8]
;;;792    
;;;793          /* Update error code */
;;;794          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
000094  6d60              LDR      r0,[r4,#0x54]
000096  f0400004          ORR      r0,r0,#4
00009a  6560              STR      r0,[r4,#0x54]
                  |L9.156|
;;;795        }
;;;796      }
;;;797      /* Half Transfer Complete Interrupt management ******************************/
;;;798      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
00009c  f894105c          LDRB     r1,[r4,#0x5c]
0000a0  2010              MOVS     r0,#0x10
0000a2  4088              LSLS     r0,r0,r1
0000a4  4030              ANDS     r0,r0,r6
0000a6  b378              CBZ      r0,|L9.264|
;;;799      {
;;;800        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0000008          AND      r0,r0,#8
0000b0  b350              CBZ      r0,|L9.264|
;;;801        {
;;;802          /* Clear the half transfer complete flag */
;;;803          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000b2  f894105c          LDRB     r1,[r4,#0x5c]
0000b6  2010              MOVS     r0,#0x10
0000b8  4088              LSLS     r0,r0,r1
0000ba  60a8              STR      r0,[r5,#8]
;;;804          
;;;805          /* Multi_Buffering mode enabled */
;;;806          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000bc  6820              LDR      r0,[r4,#0]
0000be  6800              LDR      r0,[r0,#0]
0000c0  f4002080          AND      r0,r0,#0x40000
0000c4  b180              CBZ      r0,|L9.232|
;;;807          {
;;;808            /* Current memory buffer used is Memory 0 */
;;;809            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f4002000          AND      r0,r0,#0x80000
0000ce  b928              CBNZ     r0,|L9.220|
;;;810            {
;;;811              if(hdma->XferHalfCpltCallback != NULL)
0000d0  6c20              LDR      r0,[r4,#0x40]
0000d2  b1c8              CBZ      r0,|L9.264|
;;;812              {
;;;813                /* Half transfer callback */
;;;814                hdma->XferHalfCpltCallback(hdma);
0000d4  4620              MOV      r0,r4
0000d6  6c21              LDR      r1,[r4,#0x40]
0000d8  4788              BLX      r1
0000da  e015              B        |L9.264|
                  |L9.220|
;;;815              }
;;;816            }
;;;817            /* Current memory buffer used is Memory 1 */
;;;818            else
;;;819            {
;;;820              if(hdma->XferM1HalfCpltCallback != NULL)
0000dc  6ca0              LDR      r0,[r4,#0x48]
0000de  b198              CBZ      r0,|L9.264|
;;;821              {
;;;822                /* Half transfer callback */
;;;823                hdma->XferM1HalfCpltCallback(hdma);
0000e0  4620              MOV      r0,r4
0000e2  6ca1              LDR      r1,[r4,#0x48]
0000e4  4788              BLX      r1
0000e6  e00f              B        |L9.264|
                  |L9.232|
;;;824              }
;;;825            }
;;;826          }
;;;827          else
;;;828          {
;;;829            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;830            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6800              LDR      r0,[r0,#0]
0000ec  f4007080          AND      r0,r0,#0x100
0000f0  b928              CBNZ     r0,|L9.254|
;;;831            {
;;;832              /* Disable the half transfer interrupt */
;;;833              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6800              LDR      r0,[r0,#0]
0000f6  f0200008          BIC      r0,r0,#8
0000fa  6821              LDR      r1,[r4,#0]
0000fc  6008              STR      r0,[r1,#0]
                  |L9.254|
;;;834            }
;;;835            
;;;836            if(hdma->XferHalfCpltCallback != NULL)
0000fe  6c20              LDR      r0,[r4,#0x40]
000100  b110              CBZ      r0,|L9.264|
;;;837            {
;;;838              /* Half transfer callback */
;;;839              hdma->XferHalfCpltCallback(hdma);
000102  4620              MOV      r0,r4
000104  6c21              LDR      r1,[r4,#0x40]
000106  4788              BLX      r1
                  |L9.264|
;;;840            }
;;;841          }
;;;842        }
;;;843      }
;;;844      /* Transfer Complete Interrupt management ***********************************/
;;;845      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
000108  f894105c          LDRB     r1,[r4,#0x5c]
00010c  2020              MOVS     r0,#0x20
00010e  4088              LSLS     r0,r0,r1
000110  4030              ANDS     r0,r0,r6
000112  2800              CMP      r0,#0
000114  d065              BEQ      |L9.482|
;;;846      {
;;;847        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
000116  6820              LDR      r0,[r4,#0]
000118  6800              LDR      r0,[r0,#0]
00011a  f0000010          AND      r0,r0,#0x10
00011e  2800              CMP      r0,#0
000120  d05f              BEQ      |L9.482|
;;;848        {
;;;849          /* Clear the transfer complete flag */
;;;850          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
000122  f894105c          LDRB     r1,[r4,#0x5c]
000126  2020              MOVS     r0,#0x20
000128  4088              LSLS     r0,r0,r1
00012a  60a8              STR      r0,[r5,#8]
;;;851          
;;;852          if(HAL_DMA_STATE_ABORT == hdma->State)
00012c  f8940035          LDRB     r0,[r4,#0x35]
000130  2805              CMP      r0,#5
000132  d128              BNE      |L9.390|
;;;853          {
;;;854            /* Disable all the transfer interrupts */
;;;855            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
000134  6820              LDR      r0,[r4,#0]
000136  6800              LDR      r0,[r0,#0]
000138  f0200016          BIC      r0,r0,#0x16
00013c  6821              LDR      r1,[r4,#0]
00013e  6008              STR      r0,[r1,#0]
;;;856            hdma->Instance->FCR &= ~(DMA_IT_FE);
000140  6820              LDR      r0,[r4,#0]
000142  6940              LDR      r0,[r0,#0x14]
000144  f0200080          BIC      r0,r0,#0x80
000148  6821              LDR      r1,[r4,#0]
00014a  6148              STR      r0,[r1,#0x14]
;;;857            
;;;858            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
00014c  6c20              LDR      r0,[r4,#0x40]
00014e  b908              CBNZ     r0,|L9.340|
000150  6ca0              LDR      r0,[r4,#0x48]
000152  b128              CBZ      r0,|L9.352|
                  |L9.340|
;;;859            {
;;;860              hdma->Instance->CR  &= ~(DMA_IT_HT);
000154  6820              LDR      r0,[r4,#0]
000156  6800              LDR      r0,[r0,#0]
000158  f0200008          BIC      r0,r0,#8
00015c  6821              LDR      r1,[r4,#0]
00015e  6008              STR      r0,[r1,#0]
                  |L9.352|
;;;861            }
;;;862    
;;;863            /* Clear all interrupt flags at correct offset within the register */
;;;864            regs->IFCR = 0x3FU << hdma->StreamIndex;
000160  f894105c          LDRB     r1,[r4,#0x5c]
000164  203f              MOVS     r0,#0x3f
000166  4088              LSLS     r0,r0,r1
000168  60a8              STR      r0,[r5,#8]
;;;865    
;;;866            /* Process Unlocked */
;;;867            __HAL_UNLOCK(hdma);
00016a  bf00              NOP      
00016c  2000              MOVS     r0,#0
00016e  f8840034          STRB     r0,[r4,#0x34]
000172  bf00              NOP      
;;;868    
;;;869            /* Change the DMA state */
;;;870            hdma->State = HAL_DMA_STATE_READY;
000174  2001              MOVS     r0,#1
000176  f8840035          STRB     r0,[r4,#0x35]
;;;871    
;;;872            if(hdma->XferAbortCallback != NULL)
00017a  6d20              LDR      r0,[r4,#0x50]
00017c  b110              CBZ      r0,|L9.388|
;;;873            {
;;;874              hdma->XferAbortCallback(hdma);
00017e  4620              MOV      r0,r4
000180  6d21              LDR      r1,[r4,#0x50]
000182  4788              BLX      r1
                  |L9.388|
;;;875            }
;;;876            return;
;;;877          }
;;;878    
;;;879          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
;;;880          {
;;;881            /* Current memory buffer used is Memory 0 */
;;;882            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
;;;883            {
;;;884              if(hdma->XferM1CpltCallback != NULL)
;;;885              {
;;;886                /* Transfer complete Callback for memory1 */
;;;887                hdma->XferM1CpltCallback(hdma);
;;;888              }
;;;889            }
;;;890            /* Current memory buffer used is Memory 1 */
;;;891            else
;;;892            {
;;;893              if(hdma->XferCpltCallback != NULL)
;;;894              {
;;;895                /* Transfer complete Callback for memory0 */
;;;896                hdma->XferCpltCallback(hdma);
;;;897              }
;;;898            }
;;;899          }
;;;900          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;901          else
;;;902          {
;;;903            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;904            {
;;;905              /* Disable the transfer complete interrupt */
;;;906              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;907    
;;;908              /* Process Unlocked */
;;;909              __HAL_UNLOCK(hdma);
;;;910    
;;;911              /* Change the DMA state */
;;;912              hdma->State = HAL_DMA_STATE_READY;
;;;913            }
;;;914    
;;;915            if(hdma->XferCpltCallback != NULL)
;;;916            {
;;;917              /* Transfer complete callback */
;;;918              hdma->XferCpltCallback(hdma);
;;;919            }
;;;920          }
;;;921        }
;;;922      }
;;;923      
;;;924      /* manage error case */
;;;925      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;926      {
;;;927        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;928        {
;;;929          hdma->State = HAL_DMA_STATE_ABORT;
;;;930    
;;;931          /* Disable the stream */
;;;932          __HAL_DMA_DISABLE(hdma);
;;;933    
;;;934          do
;;;935          {
;;;936            if (++count > timeout)
;;;937            {
;;;938              break;
;;;939            }
;;;940          }
;;;941          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
;;;942    
;;;943          /* Process Unlocked */
;;;944          __HAL_UNLOCK(hdma);
;;;945    
;;;946          /* Change the DMA state */
;;;947          hdma->State = HAL_DMA_STATE_READY;
;;;948        }
;;;949    
;;;950        if(hdma->XferErrorCallback != NULL)
;;;951        {
;;;952          /* Transfer error callback */
;;;953          hdma->XferErrorCallback(hdma);
;;;954        }
;;;955      }
;;;956    }
000184  bdf8              POP      {r3-r7,pc}
                  |L9.390|
000186  6820              LDR      r0,[r4,#0]            ;879
000188  6800              LDR      r0,[r0,#0]            ;879
00018a  f4002080          AND      r0,r0,#0x40000        ;879
00018e  b180              CBZ      r0,|L9.434|
000190  6820              LDR      r0,[r4,#0]            ;882
000192  6800              LDR      r0,[r0,#0]            ;882
000194  f4002000          AND      r0,r0,#0x80000        ;882
000198  b928              CBNZ     r0,|L9.422|
00019a  6c60              LDR      r0,[r4,#0x44]         ;884
00019c  b110              CBZ      r0,|L9.420|
00019e  4620              MOV      r0,r4                 ;887
0001a0  6c61              LDR      r1,[r4,#0x44]         ;887
0001a2  4788              BLX      r1                    ;887
                  |L9.420|
0001a4  e01d              B        |L9.482|
                  |L9.422|
0001a6  6be0              LDR      r0,[r4,#0x3c]         ;893
0001a8  b1d8              CBZ      r0,|L9.482|
0001aa  4620              MOV      r0,r4                 ;896
0001ac  6be1              LDR      r1,[r4,#0x3c]         ;896
0001ae  4788              BLX      r1                    ;896
0001b0  e017              B        |L9.482|
                  |L9.434|
0001b2  6820              LDR      r0,[r4,#0]            ;903
0001b4  6800              LDR      r0,[r0,#0]            ;903
0001b6  f4007080          AND      r0,r0,#0x100          ;903
0001ba  b968              CBNZ     r0,|L9.472|
0001bc  6820              LDR      r0,[r4,#0]            ;906
0001be  6800              LDR      r0,[r0,#0]            ;906
0001c0  f0200010          BIC      r0,r0,#0x10           ;906
0001c4  6821              LDR      r1,[r4,#0]            ;906
0001c6  6008              STR      r0,[r1,#0]            ;906
0001c8  bf00              NOP                            ;909
0001ca  2000              MOVS     r0,#0                 ;909
0001cc  f8840034          STRB     r0,[r4,#0x34]         ;909
0001d0  bf00              NOP                            ;909
0001d2  2001              MOVS     r0,#1                 ;912
0001d4  f8840035          STRB     r0,[r4,#0x35]         ;912
                  |L9.472|
0001d8  6be0              LDR      r0,[r4,#0x3c]         ;915
0001da  b110              CBZ      r0,|L9.482|
0001dc  4620              MOV      r0,r4                 ;918
0001de  6be1              LDR      r1,[r4,#0x3c]         ;918
0001e0  4788              BLX      r1                    ;918
                  |L9.482|
0001e2  6d60              LDR      r0,[r4,#0x54]         ;925
0001e4  b338              CBZ      r0,|L9.566|
0001e6  6d60              LDR      r0,[r4,#0x54]         ;927
0001e8  f0000001          AND      r0,r0,#1              ;927
0001ec  b1f0              CBZ      r0,|L9.556|
0001ee  2005              MOVS     r0,#5                 ;929
0001f0  f8840035          STRB     r0,[r4,#0x35]         ;929
0001f4  6820              LDR      r0,[r4,#0]            ;932
0001f6  6800              LDR      r0,[r0,#0]            ;932
0001f8  f0200001          BIC      r0,r0,#1              ;932
0001fc  6821              LDR      r1,[r4,#0]            ;932
0001fe  6008              STR      r0,[r1,#0]            ;932
000200  bf00              NOP                            ;934
                  |L9.514|
000202  9800              LDR      r0,[sp,#0]            ;936
000204  1c40              ADDS     r0,r0,#1              ;936
000206  9000              STR      r0,[sp,#0]            ;936
000208  42b8              CMP      r0,r7                 ;936
00020a  d900              BLS      |L9.526|
00020c  e005              B        |L9.538|
                  |L9.526|
00020e  6820              LDR      r0,[r4,#0]            ;941
000210  6800              LDR      r0,[r0,#0]            ;941
000212  f0000001          AND      r0,r0,#1              ;941
000216  2800              CMP      r0,#0                 ;941
000218  d1f3              BNE      |L9.514|
                  |L9.538|
00021a  bf00              NOP                            ;938
00021c  bf00              NOP                            ;944
00021e  2000              MOVS     r0,#0                 ;944
000220  f8840034          STRB     r0,[r4,#0x34]         ;944
000224  bf00              NOP                            ;944
000226  2001              MOVS     r0,#1                 ;947
000228  f8840035          STRB     r0,[r4,#0x35]         ;947
                  |L9.556|
00022c  6ce0              LDR      r0,[r4,#0x4c]         ;950
00022e  b110              CBZ      r0,|L9.566|
000230  4620              MOV      r0,r4                 ;953
000232  6ce1              LDR      r1,[r4,#0x4c]         ;953
000234  4788              BLX      r1                    ;953
                  |L9.566|
000236  bf00              NOP      
000238  e7a4              B        |L9.388|
;;;957    
                          ENDP

00023a  0000              DCW      0x0000
                  |L9.572|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;170      */
;;;171    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;172    {
000004  4604              MOV      r4,r0
;;;173      uint32_t tmp = 0U;
000006  2500              MOVS     r5,#0
;;;174      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;175      DMA_Base_Registers *regs;
;;;176    
;;;177      /* Check the DMA peripheral state */
;;;178      if(hdma == NULL)
00000e  b914              CBNZ     r4,|L10.22|
;;;179      {
;;;180        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L10.18|
;;;181      }
;;;182    
;;;183      /* Check the parameters */
;;;184      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;185      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;186      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;187      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;188      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;189      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;190      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;191      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;192      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;193      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;194      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;195         when FIFO mode is enabled */
;;;196      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;197      {
;;;198        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;199        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;200        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;201      }
;;;202      
;;;203      /* Allocate lock resource */
;;;204      __HAL_UNLOCK(hdma);
;;;205    
;;;206      /* Change DMA peripheral state */
;;;207      hdma->State = HAL_DMA_STATE_BUSY;
;;;208      
;;;209      /* Disable the peripheral */
;;;210      __HAL_DMA_DISABLE(hdma);
;;;211      
;;;212      /* Check if the DMA Stream is effectively disabled */
;;;213      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;214      {
;;;215        /* Check for the Timeout */
;;;216        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;217        {
;;;218          /* Update error code */
;;;219          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;220          
;;;221          /* Change the DMA state */
;;;222          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;223          
;;;224          return HAL_TIMEOUT;
;;;225        }
;;;226      }
;;;227      
;;;228      /* Get the CR register value */
;;;229      tmp = hdma->Instance->CR;
;;;230    
;;;231      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;232      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;233                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;234                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;235                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;236    
;;;237      /* Prepare the DMA Stream configuration */
;;;238      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;239              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;240              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;241              hdma->Init.Mode                | hdma->Init.Priority;
;;;242    
;;;243      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;244      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;245      {
;;;246        /* Get memory burst and peripheral burst */
;;;247        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;248      }
;;;249      
;;;250      /* Write to DMA Stream CR register */
;;;251      hdma->Instance->CR = tmp;  
;;;252    
;;;253      /* Get the FCR register value */
;;;254      tmp = hdma->Instance->FCR;
;;;255    
;;;256      /* Clear Direct mode and FIFO threshold bits */
;;;257      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;258    
;;;259      /* Prepare the DMA Stream FIFO configuration */
;;;260      tmp |= hdma->Init.FIFOMode;
;;;261    
;;;262      /* The FIFO threshold is not used when the FIFO mode is disabled */
;;;263      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;264      {
;;;265        /* Get the FIFO threshold */
;;;266        tmp |= hdma->Init.FIFOThreshold;
;;;267        
;;;268        /* Check compatibility between FIFO threshold level and size of the memory burst */
;;;269        /* for INCR4, INCR8, INCR16 bursts */
;;;270        if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
;;;271        {
;;;272          if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;273          {
;;;274            /* Update error code */
;;;275            hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;276            
;;;277            /* Change the DMA state */
;;;278            hdma->State = HAL_DMA_STATE_READY;
;;;279            
;;;280            return HAL_ERROR; 
;;;281          }
;;;282        }
;;;283      }
;;;284      
;;;285      /* Write to DMA Stream FCR */
;;;286      hdma->Instance->FCR = tmp;
;;;287    
;;;288      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;289         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;290      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;291      
;;;292      /* Clear all interrupt flags */
;;;293      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;294    
;;;295      /* Initialize the error code */
;;;296      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;297                                                                                         
;;;298      /* Initialize the DMA state */
;;;299      hdma->State = HAL_DMA_STATE_READY;
;;;300    
;;;301      return HAL_OK;
;;;302    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L10.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;196
000018  b100              CBZ      r0,|L10.28|
00001a  bf00              NOP                            ;200
                  |L10.28|
00001c  bf00              NOP                            ;204
00001e  2000              MOVS     r0,#0                 ;204
000020  f8840034          STRB     r0,[r4,#0x34]         ;204
000024  bf00              NOP                            ;204
000026  2002              MOVS     r0,#2                 ;207
000028  f8840035          STRB     r0,[r4,#0x35]         ;207
00002c  6820              LDR      r0,[r4,#0]            ;210
00002e  6800              LDR      r0,[r0,#0]            ;210
000030  f0200001          BIC      r0,r0,#1              ;210
000034  6821              LDR      r1,[r4,#0]            ;210
000036  6008              STR      r0,[r1,#0]            ;210
000038  e00a              B        |L10.80|
                  |L10.58|
00003a  f7fffffe          BL       HAL_GetTick
00003e  1bc0              SUBS     r0,r0,r7              ;216
000040  2805              CMP      r0,#5                 ;216
000042  d905              BLS      |L10.80|
000044  2020              MOVS     r0,#0x20              ;219
000046  6560              STR      r0,[r4,#0x54]         ;219
000048  2003              MOVS     r0,#3                 ;222
00004a  f8840035          STRB     r0,[r4,#0x35]         ;222
00004e  e7e0              B        |L10.18|
                  |L10.80|
000050  6820              LDR      r0,[r4,#0]            ;213
000052  6800              LDR      r0,[r0,#0]            ;213
000054  f0000001          AND      r0,r0,#1              ;213
000058  2800              CMP      r0,#0                 ;213
00005a  d1ee              BNE      |L10.58|
00005c  6820              LDR      r0,[r4,#0]            ;229
00005e  6805              LDR      r5,[r0,#0]            ;229
000060  4821              LDR      r0,|L10.232|
000062  4005              ANDS     r5,r5,r0              ;232
000064  e9d40101          LDRD     r0,r1,[r4,#4]         ;238
000068  4308              ORRS     r0,r0,r1              ;238
00006a  68e1              LDR      r1,[r4,#0xc]          ;238
00006c  4308              ORRS     r0,r0,r1              ;238
00006e  6921              LDR      r1,[r4,#0x10]         ;238
000070  4308              ORRS     r0,r0,r1              ;238
000072  6961              LDR      r1,[r4,#0x14]         ;238
000074  4308              ORRS     r0,r0,r1              ;238
000076  69a1              LDR      r1,[r4,#0x18]         ;238
000078  4308              ORRS     r0,r0,r1              ;238
00007a  69e1              LDR      r1,[r4,#0x1c]         ;238
00007c  4308              ORRS     r0,r0,r1              ;238
00007e  6a21              LDR      r1,[r4,#0x20]         ;238
000080  4308              ORRS     r0,r0,r1              ;238
000082  4305              ORRS     r5,r5,r0              ;238
000084  6a60              LDR      r0,[r4,#0x24]         ;244
000086  2804              CMP      r0,#4                 ;244
000088  d103              BNE      |L10.146|
00008a  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;247
00008e  4308              ORRS     r0,r0,r1              ;247
000090  4305              ORRS     r5,r5,r0              ;247
                  |L10.146|
000092  6820              LDR      r0,[r4,#0]            ;251
000094  6005              STR      r5,[r0,#0]            ;251
000096  6820              LDR      r0,[r4,#0]            ;254
000098  6945              LDR      r5,[r0,#0x14]         ;254
00009a  f0250507          BIC      r5,r5,#7              ;257
00009e  6a60              LDR      r0,[r4,#0x24]         ;260
0000a0  4305              ORRS     r5,r5,r0              ;260
0000a2  6a60              LDR      r0,[r4,#0x24]         ;263
0000a4  2804              CMP      r0,#4                 ;263
0000a6  d10d              BNE      |L10.196|
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;266
0000aa  4305              ORRS     r5,r5,r0              ;266
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;270
0000ae  b148              CBZ      r0,|L10.196|
0000b0  4620              MOV      r0,r4                 ;272
0000b2  f7fffffe          BL       DMA_CheckFifoParam
0000b6  b128              CBZ      r0,|L10.196|
0000b8  2040              MOVS     r0,#0x40              ;275
0000ba  6560              STR      r0,[r4,#0x54]         ;275
0000bc  2001              MOVS     r0,#1                 ;278
0000be  f8840035          STRB     r0,[r4,#0x35]         ;278
0000c2  e7a6              B        |L10.18|
                  |L10.196|
0000c4  6820              LDR      r0,[r4,#0]            ;286
0000c6  6145              STR      r5,[r0,#0x14]         ;286
0000c8  4620              MOV      r0,r4                 ;290
0000ca  f7fffffe          BL       DMA_CalcBaseAndBitshift
0000ce  4606              MOV      r6,r0                 ;290
0000d0  f894105c          LDRB     r1,[r4,#0x5c]         ;293
0000d4  203f              MOVS     r0,#0x3f              ;293
0000d6  4088              LSLS     r0,r0,r1              ;293
0000d8  60b0              STR      r0,[r6,#8]            ;293
0000da  2000              MOVS     r0,#0                 ;296
0000dc  6560              STR      r0,[r4,#0x54]         ;296
0000de  2001              MOVS     r0,#1                 ;299
0000e0  f8840035          STRB     r0,[r4,#0x35]         ;299
0000e4  2000              MOVS     r0,#0                 ;301
0000e6  e794              B        |L10.18|
;;;303    
                          ENDP

                  |L10.232|
                          DCD      0xe010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA_PollForTransfer PROC
;;;610      */
;;;611    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;612    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;613      HAL_StatusTypeDef status = HAL_OK; 
00000a  f04f0a00          MOV      r10,#0
;;;614      uint32_t mask_cpltlevel;
;;;615      uint32_t tickstart = HAL_GetTick(); 
00000e  f7fffffe          BL       HAL_GetTick
000012  4683              MOV      r11,r0
;;;616      uint32_t tmpisr;
;;;617      
;;;618      /* calculate DMA base and stream number */
;;;619      DMA_Base_Registers *regs;
;;;620    
;;;621      if(HAL_DMA_STATE_BUSY != hdma->State)
000014  f8940035          LDRB     r0,[r4,#0x35]
000018  2802              CMP      r0,#2
00001a  d009              BEQ      |L11.48|
;;;622      {
;;;623        /* No transfer ongoing */
;;;624        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001c  2080              MOVS     r0,#0x80
00001e  6560              STR      r0,[r4,#0x54]
;;;625        __HAL_UNLOCK(hdma);
000020  bf00              NOP      
000022  2000              MOVS     r0,#0
000024  f8840034          STRB     r0,[r4,#0x34]
000028  bf00              NOP      
;;;626        return HAL_ERROR;
00002a  2001              MOVS     r0,#1
                  |L11.44|
;;;627      }
;;;628    
;;;629      /* Polling mode not supported in circular mode and double buffering mode */
;;;630      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
;;;631      {
;;;632        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;633        return HAL_ERROR;
;;;634      }
;;;635      
;;;636      /* Get the level transfer complete flag */
;;;637      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;638      {
;;;639        /* Transfer Complete flag */
;;;640        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;641      }
;;;642      else
;;;643      {
;;;644        /* Half Transfer Complete flag */
;;;645        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;646      }
;;;647      
;;;648      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;649      tmpisr = regs->ISR;
;;;650      
;;;651      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
;;;652      {
;;;653        /* Check for the Timeout (Not applicable in circular mode)*/
;;;654        if(Timeout != HAL_MAX_DELAY)
;;;655        {
;;;656          if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
;;;657          {
;;;658            /* Update error code */
;;;659            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;660    
;;;661            /* Process Unlocked */
;;;662            __HAL_UNLOCK(hdma);
;;;663            
;;;664            /* Change the DMA state */
;;;665            hdma->State = HAL_DMA_STATE_READY;
;;;666            
;;;667            return HAL_TIMEOUT;
;;;668          }
;;;669        }
;;;670    
;;;671        /* Get the ISR register value */
;;;672        tmpisr = regs->ISR;
;;;673    
;;;674        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;675        {
;;;676          /* Update error code */
;;;677          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;678          
;;;679          /* Clear the transfer error flag */
;;;680          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;681        }
;;;682        
;;;683        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;684        {
;;;685          /* Update error code */
;;;686          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;687          
;;;688          /* Clear the FIFO error flag */
;;;689          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;690        }
;;;691        
;;;692        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;693        {
;;;694          /* Update error code */
;;;695          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;696          
;;;697          /* Clear the Direct Mode error flag */
;;;698          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;699        }
;;;700      }
;;;701      
;;;702      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;703      {
;;;704        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;705        {
;;;706          HAL_DMA_Abort(hdma);
;;;707        
;;;708          /* Clear the half transfer and transfer complete flags */
;;;709          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;710        
;;;711          /* Process Unlocked */
;;;712          __HAL_UNLOCK(hdma);
;;;713    
;;;714          /* Change the DMA state */
;;;715          hdma->State= HAL_DMA_STATE_READY;
;;;716    
;;;717          return HAL_ERROR;
;;;718       }
;;;719      }
;;;720      
;;;721      /* Get the level transfer complete flag */
;;;722      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;723      {
;;;724        /* Clear the half transfer and transfer complete flags */
;;;725        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;726        
;;;727        /* Process Unlocked */
;;;728        __HAL_UNLOCK(hdma);
;;;729    
;;;730        hdma->State = HAL_DMA_STATE_READY;
;;;731      }
;;;732      else
;;;733      {
;;;734        /* Clear the half transfer and transfer complete flags */
;;;735        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;736      }
;;;737      
;;;738      return status;
;;;739    }
00002c  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.48|
000030  6820              LDR      r0,[r4,#0]            ;630
000032  6800              LDR      r0,[r0,#0]            ;630
000034  f4007080          AND      r0,r0,#0x100          ;630
000038  b120              CBZ      r0,|L11.68|
00003a  f44f7080          MOV      r0,#0x100             ;632
00003e  6560              STR      r0,[r4,#0x54]         ;632
000040  2001              MOVS     r0,#1                 ;633
000042  e7f3              B        |L11.44|
                  |L11.68|
000044  f1b80f00          CMP      r8,#0                 ;637
000048  d105              BNE      |L11.86|
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;640
00004e  2020              MOVS     r0,#0x20              ;640
000050  fa00f901          LSL      r9,r0,r1              ;640
000054  e004              B        |L11.96|
                  |L11.86|
000056  f894105c          LDRB     r1,[r4,#0x5c]         ;645
00005a  2010              MOVS     r0,#0x10              ;645
00005c  fa00f901          LSL      r9,r0,r1              ;645
                  |L11.96|
000060  6da5              LDR      r5,[r4,#0x58]         ;648
000062  682e              LDR      r6,[r5,#0]            ;649
000064  e042              B        |L11.236|
                  |L11.102|
000066  1c78              ADDS     r0,r7,#1              ;654
000068  b190              CBZ      r0,|L11.144|
00006a  b12f              CBZ      r7,|L11.120|
00006c  f7fffffe          BL       HAL_GetTick
000070  eba0000b          SUB      r0,r0,r11             ;656
000074  42b8              CMP      r0,r7                 ;656
000076  d90b              BLS      |L11.144|
                  |L11.120|
000078  2020              MOVS     r0,#0x20              ;659
00007a  6560              STR      r0,[r4,#0x54]         ;659
00007c  bf00              NOP                            ;662
00007e  2000              MOVS     r0,#0                 ;662
000080  f8840034          STRB     r0,[r4,#0x34]         ;662
000084  bf00              NOP                            ;662
000086  2001              MOVS     r0,#1                 ;665
000088  f8840035          STRB     r0,[r4,#0x35]         ;665
00008c  2003              MOVS     r0,#3                 ;667
00008e  e7cd              B        |L11.44|
                  |L11.144|
000090  682e              LDR      r6,[r5,#0]            ;672
000092  f894105c          LDRB     r1,[r4,#0x5c]         ;674
000096  2008              MOVS     r0,#8                 ;674
000098  4088              LSLS     r0,r0,r1              ;674
00009a  4030              ANDS     r0,r0,r6              ;674
00009c  b140              CBZ      r0,|L11.176|
00009e  6d60              LDR      r0,[r4,#0x54]         ;677
0000a0  f0400001          ORR      r0,r0,#1              ;677
0000a4  6560              STR      r0,[r4,#0x54]         ;677
0000a6  f894105c          LDRB     r1,[r4,#0x5c]         ;680
0000aa  2008              MOVS     r0,#8                 ;680
0000ac  4088              LSLS     r0,r0,r1              ;680
0000ae  60a8              STR      r0,[r5,#8]            ;680
                  |L11.176|
0000b0  f894105c          LDRB     r1,[r4,#0x5c]         ;683
0000b4  2001              MOVS     r0,#1                 ;683
0000b6  4088              LSLS     r0,r0,r1              ;683
0000b8  4030              ANDS     r0,r0,r6              ;683
0000ba  b140              CBZ      r0,|L11.206|
0000bc  6d60              LDR      r0,[r4,#0x54]         ;686
0000be  f0400002          ORR      r0,r0,#2              ;686
0000c2  6560              STR      r0,[r4,#0x54]         ;686
0000c4  f894105c          LDRB     r1,[r4,#0x5c]         ;689
0000c8  2001              MOVS     r0,#1                 ;689
0000ca  4088              LSLS     r0,r0,r1              ;689
0000cc  60a8              STR      r0,[r5,#8]            ;689
                  |L11.206|
0000ce  f894105c          LDRB     r1,[r4,#0x5c]         ;692
0000d2  2004              MOVS     r0,#4                 ;692
0000d4  4088              LSLS     r0,r0,r1              ;692
0000d6  4030              ANDS     r0,r0,r6              ;692
0000d8  b140              CBZ      r0,|L11.236|
0000da  6d60              LDR      r0,[r4,#0x54]         ;695
0000dc  f0400004          ORR      r0,r0,#4              ;695
0000e0  6560              STR      r0,[r4,#0x54]         ;695
0000e2  f894105c          LDRB     r1,[r4,#0x5c]         ;698
0000e6  2004              MOVS     r0,#4                 ;698
0000e8  4088              LSLS     r0,r0,r1              ;698
0000ea  60a8              STR      r0,[r5,#8]            ;698
                  |L11.236|
0000ec  ea060009          AND      r0,r6,r9              ;651
0000f0  b920              CBNZ     r0,|L11.252|
0000f2  6d60              LDR      r0,[r4,#0x54]         ;651
0000f4  f0000001          AND      r0,r0,#1              ;651
0000f8  2800              CMP      r0,#0                 ;651
0000fa  d0b4              BEQ      |L11.102|
                  |L11.252|
0000fc  6d60              LDR      r0,[r4,#0x54]         ;702
0000fe  b1a0              CBZ      r0,|L11.298|
000100  6d60              LDR      r0,[r4,#0x54]         ;704
000102  f0000001          AND      r0,r0,#1              ;704
000106  b180              CBZ      r0,|L11.298|
000108  4620              MOV      r0,r4                 ;706
00010a  f7fffffe          BL       HAL_DMA_Abort
00010e  f894105c          LDRB     r1,[r4,#0x5c]         ;709
000112  2030              MOVS     r0,#0x30              ;709
000114  4088              LSLS     r0,r0,r1              ;709
000116  60a8              STR      r0,[r5,#8]            ;709
000118  bf00              NOP                            ;712
00011a  2000              MOVS     r0,#0                 ;712
00011c  f8840034          STRB     r0,[r4,#0x34]         ;712
000120  bf00              NOP                            ;712
000122  2001              MOVS     r0,#1                 ;715
000124  f8840035          STRB     r0,[r4,#0x35]         ;715
000128  e780              B        |L11.44|
                  |L11.298|
00012a  f1b80f00          CMP      r8,#0                 ;722
00012e  d10d              BNE      |L11.332|
000130  f894105c          LDRB     r1,[r4,#0x5c]         ;725
000134  2030              MOVS     r0,#0x30              ;725
000136  4088              LSLS     r0,r0,r1              ;725
000138  60a8              STR      r0,[r5,#8]            ;725
00013a  bf00              NOP                            ;728
00013c  2000              MOVS     r0,#0                 ;728
00013e  f8840034          STRB     r0,[r4,#0x34]         ;728
000142  bf00              NOP                            ;728
000144  2001              MOVS     r0,#1                 ;730
000146  f8840035          STRB     r0,[r4,#0x35]         ;730
00014a  e004              B        |L11.342|
                  |L11.332|
00014c  f894105c          LDRB     r1,[r4,#0x5c]         ;735
000150  2010              MOVS     r0,#0x10              ;735
000152  4088              LSLS     r0,r0,r1              ;735
000154  60a8              STR      r0,[r5,#8]            ;735
                  |L11.342|
000156  4650              MOV      r0,r10                ;738
000158  e768              B        |L11.44|
;;;740    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;967      */                      
;;;968    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  b510              PUSH     {r4,lr}
;;;969    {
000002  4603              MOV      r3,r0
;;;970    
;;;971      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;972    
;;;973      /* Process locked */
;;;974      __HAL_LOCK(hdma);
000006  bf00              NOP      
000008  f8930034          LDRB     r0,[r3,#0x34]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L12.20|
000010  2002              MOVS     r0,#2
                  |L12.18|
;;;975    
;;;976      if(HAL_DMA_STATE_READY == hdma->State)
;;;977      {
;;;978        switch (CallbackID)
;;;979        {
;;;980        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;981          hdma->XferCpltCallback = pCallback;
;;;982          break;
;;;983    
;;;984        case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;985          hdma->XferHalfCpltCallback = pCallback;
;;;986          break;
;;;987    
;;;988        case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;989          hdma->XferM1CpltCallback = pCallback;
;;;990          break;
;;;991    
;;;992        case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;993          hdma->XferM1HalfCpltCallback = pCallback;
;;;994          break;
;;;995    
;;;996        case  HAL_DMA_XFER_ERROR_CB_ID:
;;;997          hdma->XferErrorCallback = pCallback;
;;;998          break;
;;;999    
;;;1000       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1001         hdma->XferAbortCallback = pCallback;
;;;1002         break;
;;;1003   
;;;1004       default:
;;;1005         break;
;;;1006       }
;;;1007     }
;;;1008     else
;;;1009     {
;;;1010       /* Return error status */
;;;1011       status =  HAL_ERROR;
;;;1012     }
;;;1013   
;;;1014     /* Release Lock */
;;;1015     __HAL_UNLOCK(hdma);
;;;1016     
;;;1017     return status;
;;;1018   }
000012  bd10              POP      {r4,pc}
                  |L12.20|
000014  2001              MOVS     r0,#1                 ;974
000016  f8830034          STRB     r0,[r3,#0x34]         ;974
00001a  bf00              NOP                            ;974
00001c  f8930035          LDRB     r0,[r3,#0x35]         ;976
000020  2801              CMP      r0,#1                 ;976
000022  d114              BNE      |L12.78|
000024  2906              CMP      r1,#6                 ;978
000026  d210              BCS      |L12.74|
000028  e8dff001          TBB      [pc,r1]               ;978
00002c  03050709          DCB      0x03,0x05,0x07,0x09
000030  0b0d              DCB      0x0b,0x0d
000032  63da              STR      r2,[r3,#0x3c]         ;981
000034  e00a              B        |L12.76|
000036  641a              STR      r2,[r3,#0x40]         ;985
000038  e008              B        |L12.76|
00003a  645a              STR      r2,[r3,#0x44]         ;989
00003c  e006              B        |L12.76|
00003e  649a              STR      r2,[r3,#0x48]         ;993
000040  e004              B        |L12.76|
000042  64da              STR      r2,[r3,#0x4c]         ;997
000044  e002              B        |L12.76|
000046  651a              STR      r2,[r3,#0x50]         ;1001
000048  e000              B        |L12.76|
                  |L12.74|
00004a  bf00              NOP                            ;1005
                  |L12.76|
00004c  e000              B        |L12.80|
                  |L12.78|
00004e  2401              MOVS     r4,#1                 ;1011
                  |L12.80|
000050  bf00              NOP                            ;1015
000052  2000              MOVS     r0,#0                 ;1015
000054  f8830034          STRB     r0,[r3,#0x34]         ;1015
000058  bf00              NOP                            ;1015
00005a  4620              MOV      r0,r4                 ;1017
00005c  e7d9              B        |L12.18|
;;;1019   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;407      */
;;;408    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;409    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;410      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;411      
;;;412      /* Check the parameters */
;;;413      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;414    
;;;415      /* Process locked */
;;;416      __HAL_LOCK(hdma);
000010  bf00              NOP      
000012  f8940034          LDRB     r0,[r4,#0x34]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L13.32|
00001a  2002              MOVS     r0,#2
                  |L13.28|
;;;417    
;;;418      if(HAL_DMA_STATE_READY == hdma->State)
;;;419      {
;;;420        /* Change DMA peripheral state */
;;;421        hdma->State = HAL_DMA_STATE_BUSY;
;;;422        
;;;423        /* Initialize the error code */
;;;424        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;425        
;;;426        /* Configure the source, destination address and the data length */
;;;427        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;428    
;;;429        /* Enable the Peripheral */
;;;430        __HAL_DMA_ENABLE(hdma);
;;;431      }
;;;432      else
;;;433      {
;;;434        /* Process unlocked */
;;;435        __HAL_UNLOCK(hdma);
;;;436        
;;;437        /* Return error status */
;;;438        status = HAL_BUSY;
;;;439      } 
;;;440      return status; 
;;;441    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.32|
000020  2001              MOVS     r0,#1                 ;416
000022  f8840034          STRB     r0,[r4,#0x34]         ;416
000026  bf00              NOP                            ;416
000028  f8940035          LDRB     r0,[r4,#0x35]         ;418
00002c  2801              CMP      r0,#1                 ;418
00002e  d111              BNE      |L13.84|
000030  2002              MOVS     r0,#2                 ;421
000032  f8840035          STRB     r0,[r4,#0x35]         ;421
000036  2000              MOVS     r0,#0                 ;424
000038  6560              STR      r0,[r4,#0x54]         ;424
00003a  463b              MOV      r3,r7                 ;427
00003c  4632              MOV      r2,r6                 ;427
00003e  4629              MOV      r1,r5                 ;427
000040  4620              MOV      r0,r4                 ;427
000042  f7fffffe          BL       DMA_SetConfig
000046  6820              LDR      r0,[r4,#0]            ;430
000048  6800              LDR      r0,[r0,#0]            ;430
00004a  f0400001          ORR      r0,r0,#1              ;430
00004e  6821              LDR      r1,[r4,#0]            ;430
000050  6008              STR      r0,[r1,#0]            ;430
000052  e006              B        |L13.98|
                  |L13.84|
000054  bf00              NOP                            ;435
000056  2000              MOVS     r0,#0                 ;435
000058  f8840034          STRB     r0,[r4,#0x34]         ;435
00005c  bf00              NOP                            ;435
00005e  f04f0802          MOV      r8,#2                 ;438
                  |L13.98|
000062  4640              MOV      r0,r8                 ;440
000064  e7da              B        |L13.28|
;;;442    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;451      */
;;;452    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;453    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;454      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;455    
;;;456      /* calculate DMA base and stream number */
;;;457      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000010  f8d49058          LDR      r9,[r4,#0x58]
;;;458      
;;;459      /* Check the parameters */
;;;460      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;461     
;;;462      /* Process locked */
;;;463      __HAL_LOCK(hdma);
000014  bf00              NOP      
000016  f8940034          LDRB     r0,[r4,#0x34]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L14.36|
00001e  2002              MOVS     r0,#2
                  |L14.32|
;;;464      
;;;465      if(HAL_DMA_STATE_READY == hdma->State)
;;;466      {
;;;467        /* Change DMA peripheral state */
;;;468        hdma->State = HAL_DMA_STATE_BUSY;
;;;469        
;;;470        /* Initialize the error code */
;;;471        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;472        
;;;473        /* Configure the source, destination address and the data length */
;;;474        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;475        
;;;476        /* Clear all interrupt flags at correct offset within the register */
;;;477        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;478        
;;;479        /* Enable Common interrupts*/
;;;480        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;481        
;;;482        if(hdma->XferHalfCpltCallback != NULL)
;;;483        {
;;;484          hdma->Instance->CR  |= DMA_IT_HT;
;;;485        }
;;;486        
;;;487        /* Enable the Peripheral */
;;;488        __HAL_DMA_ENABLE(hdma);
;;;489      }
;;;490      else
;;;491      {
;;;492        /* Process unlocked */
;;;493        __HAL_UNLOCK(hdma);	  
;;;494        
;;;495        /* Return error status */
;;;496        status = HAL_BUSY;
;;;497      }
;;;498      
;;;499      return status;
;;;500    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L14.36|
000024  2001              MOVS     r0,#1                 ;463
000026  f8840034          STRB     r0,[r4,#0x34]         ;463
00002a  bf00              NOP                            ;463
00002c  f8940035          LDRB     r0,[r4,#0x35]         ;465
000030  2801              CMP      r0,#1                 ;465
000032  d125              BNE      |L14.128|
000034  2002              MOVS     r0,#2                 ;468
000036  f8840035          STRB     r0,[r4,#0x35]         ;468
00003a  2000              MOVS     r0,#0                 ;471
00003c  6560              STR      r0,[r4,#0x54]         ;471
00003e  463b              MOV      r3,r7                 ;474
000040  4632              MOV      r2,r6                 ;474
000042  4629              MOV      r1,r5                 ;474
000044  4620              MOV      r0,r4                 ;474
000046  f7fffffe          BL       DMA_SetConfig
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;477
00004e  203f              MOVS     r0,#0x3f              ;477
000050  4088              LSLS     r0,r0,r1              ;477
000052  f8c90008          STR      r0,[r9,#8]            ;477
000056  6820              LDR      r0,[r4,#0]            ;480
000058  6800              LDR      r0,[r0,#0]            ;480
00005a  f0400016          ORR      r0,r0,#0x16           ;480
00005e  6821              LDR      r1,[r4,#0]            ;480
000060  6008              STR      r0,[r1,#0]            ;480
000062  6c20              LDR      r0,[r4,#0x40]         ;482
000064  b128              CBZ      r0,|L14.114|
000066  6820              LDR      r0,[r4,#0]            ;484
000068  6800              LDR      r0,[r0,#0]            ;484
00006a  f0400008          ORR      r0,r0,#8              ;484
00006e  6821              LDR      r1,[r4,#0]            ;484
000070  6008              STR      r0,[r1,#0]            ;484
                  |L14.114|
000072  6820              LDR      r0,[r4,#0]            ;488
000074  6800              LDR      r0,[r0,#0]            ;488
000076  f0400001          ORR      r0,r0,#1              ;488
00007a  6821              LDR      r1,[r4,#0]            ;488
00007c  6008              STR      r0,[r1,#0]            ;488
00007e  e006              B        |L14.142|
                  |L14.128|
000080  bf00              NOP                            ;493
000082  2000              MOVS     r0,#0                 ;493
000084  f8840034          STRB     r0,[r4,#0x34]         ;493
000088  bf00              NOP                            ;493
00008a  f04f0802          MOV      r8,#2                 ;496
                  |L14.142|
00008e  4640              MOV      r0,r8                 ;499
000090  e7c6              B        |L14.32|
;;;501    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1027     */              
;;;1028   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;1029   {
;;;1030     HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1031     
;;;1032     /* Process locked */
;;;1033     __HAL_LOCK(hdma);
000004  bf00              NOP      
000006  f8920034          LDRB     r0,[r2,#0x34]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L15.18|
00000e  2002              MOVS     r0,#2
                  |L15.16|
;;;1034     
;;;1035     if(HAL_DMA_STATE_READY == hdma->State)
;;;1036     {
;;;1037       switch (CallbackID)
;;;1038       {
;;;1039       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1040         hdma->XferCpltCallback = NULL;
;;;1041         break;
;;;1042         
;;;1043       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1044         hdma->XferHalfCpltCallback = NULL;
;;;1045         break;
;;;1046         
;;;1047       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1048         hdma->XferM1CpltCallback = NULL;
;;;1049         break;
;;;1050         
;;;1051       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1052         hdma->XferM1HalfCpltCallback = NULL;
;;;1053         break;
;;;1054         
;;;1055       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1056         hdma->XferErrorCallback = NULL;
;;;1057         break;
;;;1058         
;;;1059       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1060         hdma->XferAbortCallback = NULL;
;;;1061         break; 
;;;1062         
;;;1063       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1064         hdma->XferCpltCallback = NULL;
;;;1065         hdma->XferHalfCpltCallback = NULL;
;;;1066         hdma->XferM1CpltCallback = NULL;
;;;1067         hdma->XferM1HalfCpltCallback = NULL;
;;;1068         hdma->XferErrorCallback = NULL;
;;;1069         hdma->XferAbortCallback = NULL;
;;;1070         break; 
;;;1071         
;;;1072       default:
;;;1073         status = HAL_ERROR;
;;;1074         break;
;;;1075       }
;;;1076     }
;;;1077     else
;;;1078     {
;;;1079       status = HAL_ERROR;
;;;1080     }
;;;1081     
;;;1082     /* Release Lock */
;;;1083     __HAL_UNLOCK(hdma);
;;;1084     
;;;1085     return status;
;;;1086   }
000010  4770              BX       lr
                  |L15.18|
000012  2001              MOVS     r0,#1                 ;1033
000014  f8820034          STRB     r0,[r2,#0x34]         ;1033
000018  bf00              NOP                            ;1033
00001a  f8920035          LDRB     r0,[r2,#0x35]         ;1035
00001e  2801              CMP      r0,#1                 ;1035
000020  d124              BNE      |L15.108|
000022  2907              CMP      r1,#7                 ;1037
000024  d21f              BCS      |L15.102|
000026  e8dff001          TBB      [pc,r1]               ;1037
00002a  0407              DCB      0x04,0x07
00002c  0a0d1013          DCB      0x0a,0x0d,0x10,0x13
000030  1600              DCB      0x16,0x00
000032  2000              MOVS     r0,#0                 ;1040
000034  63d0              STR      r0,[r2,#0x3c]         ;1040
000036  e018              B        |L15.106|
000038  2000              MOVS     r0,#0                 ;1044
00003a  6410              STR      r0,[r2,#0x40]         ;1044
00003c  e015              B        |L15.106|
00003e  2000              MOVS     r0,#0                 ;1048
000040  6450              STR      r0,[r2,#0x44]         ;1048
000042  e012              B        |L15.106|
000044  2000              MOVS     r0,#0                 ;1052
000046  6490              STR      r0,[r2,#0x48]         ;1052
000048  e00f              B        |L15.106|
00004a  2000              MOVS     r0,#0                 ;1056
00004c  64d0              STR      r0,[r2,#0x4c]         ;1056
00004e  e00c              B        |L15.106|
000050  2000              MOVS     r0,#0                 ;1060
000052  6510              STR      r0,[r2,#0x50]         ;1060
000054  e009              B        |L15.106|
000056  2000              MOVS     r0,#0                 ;1064
000058  63d0              STR      r0,[r2,#0x3c]         ;1064
00005a  6410              STR      r0,[r2,#0x40]         ;1065
00005c  6450              STR      r0,[r2,#0x44]         ;1066
00005e  6490              STR      r0,[r2,#0x48]         ;1067
000060  64d0              STR      r0,[r2,#0x4c]         ;1068
000062  6510              STR      r0,[r2,#0x50]         ;1069
000064  e001              B        |L15.106|
                  |L15.102|
000066  2301              MOVS     r3,#1                 ;1073
000068  bf00              NOP                            ;1074
                  |L15.106|
00006a  e000              B        |L15.110|
                  |L15.108|
00006c  2301              MOVS     r3,#1                 ;1079
                  |L15.110|
00006e  bf00              NOP                            ;1083
000070  2000              MOVS     r0,#0                 ;1083
000072  f8820034          STRB     r0,[r2,#0x34]         ;1083
000076  bf00              NOP                            ;1083
000078  4618              MOV      r0,r3                 ;1085
00007a  e7c9              B        |L15.16|
;;;1087   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH|
#line 478
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX|
#line 665
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
