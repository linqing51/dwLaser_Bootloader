; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_hcd.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_hcd.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_hcd.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_hcd.c]
                          THUMB

                          AREA ||i.HAL_HCD_Connect_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_Connect_Callback PROC
;;;633      */
;;;634    __weak void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;635    {
;;;636      /* Prevent unused argument(s) compilation warning */
;;;637      UNUSED(hhcd);
;;;638    
;;;639      /* NOTE : This function should not be modified, when the callback is needed,
;;;640                the HAL_HCD_Connect_Callback could be implemented in the user file
;;;641       */
;;;642    }
;;;643    
                          ENDP


                          AREA ||i.HAL_HCD_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_HCD_DeInit PROC
;;;264      */
;;;265    HAL_StatusTypeDef HAL_HCD_DeInit(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;266    {
000002  4604              MOV      r4,r0
;;;267      /* Check the HCD handle allocation */
;;;268      if (hhcd == NULL)
000004  b90c              CBNZ     r4,|L2.10|
;;;269      {
;;;270        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L2.8|
;;;271      }
;;;272    
;;;273      hhcd->State = HAL_HCD_STATE_BUSY;
;;;274    
;;;275    #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;276      if (hhcd->MspDeInitCallback == NULL)
;;;277      {
;;;278        hhcd->MspDeInitCallback = HAL_HCD_MspDeInit; /* Legacy weak MspDeInit  */
;;;279      }
;;;280    
;;;281      /* DeInit the low level hardware */
;;;282      hhcd->MspDeInitCallback(hhcd);
;;;283    #else
;;;284      /* DeInit the low level hardware: CLOCK, NVIC.*/
;;;285      HAL_HCD_MspDeInit(hhcd);
;;;286    #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;287    
;;;288      __HAL_HCD_DISABLE(hhcd);
;;;289    
;;;290      hhcd->State = HAL_HCD_STATE_RESET;
;;;291    
;;;292      return HAL_OK;
;;;293    }
000008  bd10              POP      {r4,pc}
                  |L2.10|
00000a  2003              MOVS     r0,#3                 ;273
00000c  f88402b9          STRB     r0,[r4,#0x2b9]        ;273
000010  4620              MOV      r0,r4                 ;285
000012  f7fffffe          BL       HAL_HCD_MspDeInit
000016  6820              LDR      r0,[r4,#0]            ;288
000018  f7fffffe          BL       USB_DisableGlobalInt
00001c  2000              MOVS     r0,#0                 ;290
00001e  f88402b9          STRB     r0,[r4,#0x2b9]        ;290
000022  bf00              NOP                            ;292
000024  e7f0              B        |L2.8|
;;;294    
                          ENDP


                          AREA ||i.HAL_HCD_Disconnect_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_Disconnect_Callback PROC
;;;648      */
;;;649    __weak void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;650    {
;;;651      /* Prevent unused argument(s) compilation warning */
;;;652      UNUSED(hhcd);
;;;653    
;;;654      /* NOTE : This function should not be modified, when the callback is needed,
;;;655                the HAL_HCD_Disconnect_Callback could be implemented in the user file
;;;656       */
;;;657    }
;;;658    
                          ENDP


                          AREA ||i.HAL_HCD_GetCurrentFrame||, CODE, READONLY, ALIGN=1

                  HAL_HCD_GetCurrentFrame PROC
;;;1141     */
;;;1142   uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;1143   {
000002  4604              MOV      r4,r0
;;;1144     return (USB_GetCurrentFrame(hhcd->Instance));
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       USB_GetCurrentFrame
;;;1145   }
00000a  bd10              POP      {r4,pc}
;;;1146   
                          ENDP


                          AREA ||i.HAL_HCD_GetCurrentSpeed||, CODE, READONLY, ALIGN=1

                  HAL_HCD_GetCurrentSpeed PROC
;;;1151     */
;;;1152   uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;1153   {
000002  4604              MOV      r4,r0
;;;1154     return (USB_GetHostSpeed(hhcd->Instance));
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       USB_GetHostSpeed
;;;1155   }
00000a  bd10              POP      {r4,pc}
;;;1156   
                          ENDP


                          AREA ||i.HAL_HCD_GetState||, CODE, READONLY, ALIGN=1

                  HAL_HCD_GetState PROC
;;;1077     */
;;;1078   HCD_StateTypeDef HAL_HCD_GetState(HCD_HandleTypeDef *hhcd)
000000  4601              MOV      r1,r0
;;;1079   {
;;;1080     return hhcd->State;
000002  f89102b9          LDRB     r0,[r1,#0x2b9]
;;;1081   }
000006  4770              BX       lr
;;;1082   
                          ENDP


                          AREA ||i.HAL_HCD_HC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_GetState PROC
;;;1131     */
;;;1132   HCD_HCStateTypeDef  HAL_HCD_HC_GetState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
000000  4602              MOV      r2,r0
;;;1133   {
;;;1134     return hhcd->hc[chnum].state;
000002  eb010381          ADD      r3,r1,r1,LSL #2
000006  f1020038          ADD      r0,r2,#0x38
00000a  eb0000c3          ADD      r0,r0,r3,LSL #3
00000e  f8900025          LDRB     r0,[r0,#0x25]
;;;1135   }
000012  4770              BX       lr
;;;1136   
                          ENDP


                          AREA ||i.HAL_HCD_HC_GetURBState||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_GetURBState PROC
;;;1096     */
;;;1097   HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
000000  4602              MOV      r2,r0
;;;1098   {
;;;1099     return hhcd->hc[chnum].urb_state;
000002  eb010381          ADD      r3,r1,r1,LSL #2
000006  f1020038          ADD      r0,r2,#0x38
00000a  eb0000c3          ADD      r0,r0,r3,LSL #3
00000e  f8900024          LDRB     r0,[r0,#0x24]
;;;1100   }
000012  4770              BX       lr
;;;1101   
                          ENDP


                          AREA ||i.HAL_HCD_HC_GetXferCount||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_GetXferCount PROC
;;;1109     */
;;;1110   uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
000000  4602              MOV      r2,r0
;;;1111   {
;;;1112     return hhcd->hc[chnum].xfer_count;
000002  eb010381          ADD      r3,r1,r1,LSL #2
000006  f1020038          ADD      r0,r2,#0x38
00000a  eb0000c3          ADD      r0,r0,r3,LSL #3
00000e  6940              LDR      r0,[r0,#0x14]
;;;1113   }
000010  4770              BX       lr
;;;1114   
                          ENDP


                          AREA ||i.HAL_HCD_HC_Halt||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_Halt PROC
;;;248      */
;;;249    HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;251      HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;252    
;;;253      __HAL_LOCK(hhcd);
000008  bf00              NOP      
00000a  f89402b8          LDRB     r0,[r4,#0x2b8]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L10.22|
000012  2002              MOVS     r0,#2
                  |L10.20|
;;;254      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
;;;255      __HAL_UNLOCK(hhcd);
;;;256    
;;;257      return status;
;;;258    }
000014  bd70              POP      {r4-r6,pc}
                  |L10.22|
000016  2001              MOVS     r0,#1                 ;253
000018  f88402b8          STRB     r0,[r4,#0x2b8]        ;253
00001c  bf00              NOP                            ;253
00001e  4629              MOV      r1,r5                 ;254
000020  6820              LDR      r0,[r4,#0]            ;254
000022  f7fffffe          BL       USB_HC_Halt
000026  bf00              NOP                            ;255
000028  2000              MOVS     r0,#0                 ;255
00002a  f88402b8          STRB     r0,[r4,#0x2b8]        ;255
00002e  bf00              NOP                            ;255
000030  4630              MOV      r0,r6                 ;257
000032  e7ef              B        |L10.20|
;;;259    
                          ENDP


                          AREA ||i.HAL_HCD_HC_Init||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_Init PROC
;;;200      */
;;;201    HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;202                                      uint8_t ch_num,
;;;203                                      uint8_t epnum,
;;;204                                      uint8_t dev_address,
;;;205                                      uint8_t speed,
;;;206                                      uint8_t ep_type,
;;;207                                      uint16_t mps)
;;;208    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9a0d          LDRD     r9,r10,[sp,#0x34]
000010  f8dd8030          LDR      r8,[sp,#0x30]
;;;209      HAL_StatusTypeDef status;
;;;210    
;;;211      __HAL_LOCK(hhcd);
000014  bf00              NOP      
000016  f89402b8          LDRB     r0,[r4,#0x2b8]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L11.36|
00001e  2002              MOVS     r0,#2
                  |L11.32|
;;;212      hhcd->hc[ch_num].do_ping = 0U;
;;;213      hhcd->hc[ch_num].dev_addr = dev_address;
;;;214      hhcd->hc[ch_num].max_packet = mps;
;;;215      hhcd->hc[ch_num].ch_num = ch_num;
;;;216      hhcd->hc[ch_num].ep_type = ep_type;
;;;217      hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
;;;218    
;;;219      if ((epnum & 0x80U) == 0x80U)
;;;220      {
;;;221        hhcd->hc[ch_num].ep_is_in = 1U;
;;;222      }
;;;223      else
;;;224      {
;;;225        hhcd->hc[ch_num].ep_is_in = 0U;
;;;226      }
;;;227    
;;;228      hhcd->hc[ch_num].speed = speed;
;;;229    
;;;230      status =  USB_HC_Init(hhcd->Instance,
;;;231                            ch_num,
;;;232                            epnum,
;;;233                            dev_address,
;;;234                            speed,
;;;235                            ep_type,
;;;236                            mps);
;;;237      __HAL_UNLOCK(hhcd);
;;;238    
;;;239      return status;
;;;240    }
000020  e8bd8ffe          POP      {r1-r11,pc}
                  |L11.36|
000024  2001              MOVS     r0,#1                 ;211
000026  f88402b8          STRB     r0,[r4,#0x2b8]        ;211
00002a  bf00              NOP                            ;211
00002c  2100              MOVS     r1,#0                 ;212
00002e  eb050285          ADD      r2,r5,r5,LSL #2       ;212
000032  f1040038          ADD      r0,r4,#0x38           ;212
000036  eb0000c2          ADD      r0,r0,r2,LSL #3       ;212
00003a  7141              STRB     r1,[r0,#5]            ;212
00003c  eb050185          ADD      r1,r5,r5,LSL #2       ;213
000040  f1040038          ADD      r0,r4,#0x38           ;213
000044  f8007031          STRB     r7,[r0,r1,LSL #3]     ;213
000048  eb050185          ADD      r1,r5,r5,LSL #2       ;214
00004c  eb0000c1          ADD      r0,r0,r1,LSL #3       ;214
000050  f8a0a008          STRH     r10,[r0,#8]           ;214
000054  eb050185          ADD      r1,r5,r5,LSL #2       ;215
000058  f1040038          ADD      r0,r4,#0x38           ;215
00005c  eb0000c1          ADD      r0,r0,r1,LSL #3       ;215
000060  7045              STRB     r5,[r0,#1]            ;215
000062  eb050185          ADD      r1,r5,r5,LSL #2       ;216
000066  f1040038          ADD      r0,r4,#0x38           ;216
00006a  eb0000c1          ADD      r0,r0,r1,LSL #3       ;216
00006e  f8809007          STRB     r9,[r0,#7]            ;216
000072  f006017f          AND      r1,r6,#0x7f           ;217
000076  eb050285          ADD      r2,r5,r5,LSL #2       ;217
00007a  f1040038          ADD      r0,r4,#0x38           ;217
00007e  eb0000c2          ADD      r0,r0,r2,LSL #3       ;217
000082  7081              STRB     r1,[r0,#2]            ;217
000084  f0060080          AND      r0,r6,#0x80           ;219
000088  2880              CMP      r0,#0x80              ;219
00008a  d108              BNE      |L11.158|
00008c  2101              MOVS     r1,#1                 ;221
00008e  eb050285          ADD      r2,r5,r5,LSL #2       ;221
000092  f1040038          ADD      r0,r4,#0x38           ;221
000096  eb0000c2          ADD      r0,r0,r2,LSL #3       ;221
00009a  70c1              STRB     r1,[r0,#3]            ;221
00009c  e007              B        |L11.174|
                  |L11.158|
00009e  2100              MOVS     r1,#0                 ;225
0000a0  eb050285          ADD      r2,r5,r5,LSL #2       ;225
0000a4  f1040038          ADD      r0,r4,#0x38           ;225
0000a8  eb0000c2          ADD      r0,r0,r2,LSL #3       ;225
0000ac  70c1              STRB     r1,[r0,#3]            ;225
                  |L11.174|
0000ae  eb050185          ADD      r1,r5,r5,LSL #2       ;228
0000b2  f1040038          ADD      r0,r4,#0x38           ;228
0000b6  eb0000c1          ADD      r0,r0,r1,LSL #3       ;228
0000ba  f8808004          STRB     r8,[r0,#4]            ;228
0000be  e88d0700          STM      sp,{r8-r10}           ;230
0000c2  463b              MOV      r3,r7                 ;230
0000c4  4632              MOV      r2,r6                 ;230
0000c6  4629              MOV      r1,r5                 ;230
0000c8  6820              LDR      r0,[r4,#0]            ;230
0000ca  f7fffffe          BL       USB_HC_Init
0000ce  4683              MOV      r11,r0                ;230
0000d0  bf00              NOP                            ;237
0000d2  2000              MOVS     r0,#0                 ;237
0000d4  f88402b8          STRB     r0,[r4,#0x2b8]        ;237
0000d8  bf00              NOP                            ;237
0000da  4658              MOV      r0,r11                ;239
0000dc  e7a0              B        |L11.32|
;;;241    
                          ENDP


                          AREA ||i.HAL_HCD_HC_NotifyURBChange_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_NotifyURBChange_Callback PROC
;;;703      */
;;;704    __weak void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
000000  4770              BX       lr
;;;705    {
;;;706      /* Prevent unused argument(s) compilation warning */
;;;707      UNUSED(hhcd);
;;;708      UNUSED(chnum);
;;;709      UNUSED(urb_state);
;;;710    
;;;711      /* NOTE : This function should not be modified, when the callback is needed,
;;;712                the HAL_HCD_HC_NotifyURBChange_Callback could be implemented in the user file
;;;713       */
;;;714    }
;;;715    
                          ENDP


                          AREA ||i.HAL_HCD_HC_SubmitRequest||, CODE, READONLY, ALIGN=1

                  HAL_HCD_HC_SubmitRequest PROC
;;;366      */
;;;367    HAL_StatusTypeDef HAL_HCD_HC_SubmitRequest(HCD_HandleTypeDef *hhcd,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;368                                               uint8_t ch_num,
;;;369                                               uint8_t direction,
;;;370                                               uint8_t ep_type,
;;;371                                               uint8_t token,
;;;372                                               uint8_t *pbuff,
;;;373                                               uint16_t length,
;;;374                                               uint8_t do_ping)
;;;375    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9b0c          LDRD     r9,r11,[sp,#0x30]
000010  e9dd8a0a          LDRD     r8,r10,[sp,#0x28]
;;;376      hhcd->hc[ch_num].ep_is_in = direction;
000014  eb050185          ADD      r1,r5,r5,LSL #2
000018  f1040038          ADD      r0,r4,#0x38
00001c  eb0000c1          ADD      r0,r0,r1,LSL #3
000020  70c6              STRB     r6,[r0,#3]
;;;377      hhcd->hc[ch_num].ep_type  = ep_type;
000022  eb050185          ADD      r1,r5,r5,LSL #2
000026  f1040038          ADD      r0,r4,#0x38
00002a  eb0000c1          ADD      r0,r0,r1,LSL #3
00002e  71c7              STRB     r7,[r0,#7]
;;;378    
;;;379      if (token == 0U)
000030  f1b80f00          CMP      r8,#0
000034  d110              BNE      |L13.88|
;;;380      {
;;;381        hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
000036  2103              MOVS     r1,#3
000038  eb050285          ADD      r2,r5,r5,LSL #2
00003c  f1040038          ADD      r0,r4,#0x38
000040  eb0000c2          ADD      r0,r0,r2,LSL #3
000044  7281              STRB     r1,[r0,#0xa]
;;;382        hhcd->hc[ch_num].do_ping = do_ping;
000046  eb050185          ADD      r1,r5,r5,LSL #2
00004a  f1040038          ADD      r0,r4,#0x38
00004e  eb0000c1          ADD      r0,r0,r1,LSL #3
000052  f880b005          STRB     r11,[r0,#5]
000056  e007              B        |L13.104|
                  |L13.88|
;;;383      }
;;;384      else
;;;385      {
;;;386        hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
000058  2102              MOVS     r1,#2
00005a  eb050285          ADD      r2,r5,r5,LSL #2
00005e  f1040038          ADD      r0,r4,#0x38
000062  eb0000c2          ADD      r0,r0,r2,LSL #3
000066  7281              STRB     r1,[r0,#0xa]
                  |L13.104|
;;;387      }
;;;388    
;;;389      /* Manage Data Toggle */
;;;390      switch (ep_type)
000068  b137              CBZ      r7,|L13.120|
00006a  2f01              CMP      r7,#1
00006c  d074              BEQ      |L13.344|
00006e  2f02              CMP      r7,#2
000070  d02b              BEQ      |L13.202|
000072  2f03              CMP      r7,#3
000074  d171              BNE      |L13.346|
000076  e05d              B        |L13.308|
                  |L13.120|
;;;391      {
;;;392        case EP_TYPE_CTRL:
;;;393          if ((token == 1U) && (direction == 0U)) /*send data */
000078  f1b80f01          CMP      r8,#1
00007c  d124              BNE      |L13.200|
00007e  bb1e              CBNZ     r6,|L13.200|
;;;394          {
;;;395            if (length == 0U)
000080  f1b90f00          CMP      r9,#0
000084  d107              BNE      |L13.150|
;;;396            {
;;;397              /* For Status OUT stage, Length==0, Status Out PID = 1 */
;;;398              hhcd->hc[ch_num].toggle_out = 1U;
000086  2101              MOVS     r1,#1
000088  eb050285          ADD      r2,r5,r5,LSL #2
00008c  f1040038          ADD      r0,r4,#0x38
000090  eb0000c2          ADD      r0,r0,r2,LSL #3
000094  7641              STRB     r1,[r0,#0x19]
                  |L13.150|
;;;399            }
;;;400    
;;;401            /* Set the Data Toggle bit as per the Flag */
;;;402            if (hhcd->hc[ch_num].toggle_out == 0U)
000096  eb050185          ADD      r1,r5,r5,LSL #2
00009a  f1040038          ADD      r0,r4,#0x38
00009e  eb0000c1          ADD      r0,r0,r1,LSL #3
0000a2  7e40              LDRB     r0,[r0,#0x19]
0000a4  b940              CBNZ     r0,|L13.184|
;;;403            {
;;;404              /* Put the PID 0 */
;;;405              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
0000a6  2100              MOVS     r1,#0
0000a8  eb050285          ADD      r2,r5,r5,LSL #2
0000ac  f1040038          ADD      r0,r4,#0x38
0000b0  eb0000c2          ADD      r0,r0,r2,LSL #3
0000b4  7281              STRB     r1,[r0,#0xa]
0000b6  e007              B        |L13.200|
                  |L13.184|
;;;406            }
;;;407            else
;;;408            {
;;;409              /* Put the PID 1 */
;;;410              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
0000b8  2102              MOVS     r1,#2
0000ba  eb050285          ADD      r2,r5,r5,LSL #2
0000be  f1040038          ADD      r0,r4,#0x38
0000c2  eb0000c2          ADD      r0,r0,r2,LSL #3
0000c6  7281              STRB     r1,[r0,#0xa]
                  |L13.200|
;;;411            }
;;;412          }
;;;413          break;
0000c8  e075              B        |L13.438|
                  |L13.202|
;;;414    
;;;415        case EP_TYPE_BULK:
;;;416          if (direction == 0U)
0000ca  b9ce              CBNZ     r6,|L13.256|
;;;417          {
;;;418            /* Set the Data Toggle bit as per the Flag */
;;;419            if (hhcd->hc[ch_num].toggle_out == 0U)
0000cc  eb050185          ADD      r1,r5,r5,LSL #2
0000d0  f1040038          ADD      r0,r4,#0x38
0000d4  eb0000c1          ADD      r0,r0,r1,LSL #3
0000d8  7e40              LDRB     r0,[r0,#0x19]
0000da  b940              CBNZ     r0,|L13.238|
;;;420            {
;;;421              /* Put the PID 0 */
;;;422              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
0000dc  2100              MOVS     r1,#0
0000de  eb050285          ADD      r2,r5,r5,LSL #2
0000e2  f1040038          ADD      r0,r4,#0x38
0000e6  eb0000c2          ADD      r0,r0,r2,LSL #3
0000ea  7281              STRB     r1,[r0,#0xa]
0000ec  e021              B        |L13.306|
                  |L13.238|
;;;423            }
;;;424            else
;;;425            {
;;;426              /* Put the PID 1 */
;;;427              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
0000ee  2102              MOVS     r1,#2
0000f0  eb050285          ADD      r2,r5,r5,LSL #2
0000f4  f1040038          ADD      r0,r4,#0x38
0000f8  eb0000c2          ADD      r0,r0,r2,LSL #3
0000fc  7281              STRB     r1,[r0,#0xa]
0000fe  e018              B        |L13.306|
                  |L13.256|
;;;428            }
;;;429          }
;;;430          else
;;;431          {
;;;432            if (hhcd->hc[ch_num].toggle_in == 0U)
000100  eb050185          ADD      r1,r5,r5,LSL #2
000104  f1040038          ADD      r0,r4,#0x38
000108  eb0000c1          ADD      r0,r0,r1,LSL #3
00010c  7e00              LDRB     r0,[r0,#0x18]
00010e  b940              CBNZ     r0,|L13.290|
;;;433            {
;;;434              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
000110  2100              MOVS     r1,#0
000112  eb050285          ADD      r2,r5,r5,LSL #2
000116  f1040038          ADD      r0,r4,#0x38
00011a  eb0000c2          ADD      r0,r0,r2,LSL #3
00011e  7281              STRB     r1,[r0,#0xa]
000120  e007              B        |L13.306|
                  |L13.290|
;;;435            }
;;;436            else
;;;437            {
;;;438              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
000122  2102              MOVS     r1,#2
000124  eb050285          ADD      r2,r5,r5,LSL #2
000128  f1040038          ADD      r0,r4,#0x38
00012c  eb0000c2          ADD      r0,r0,r2,LSL #3
000130  7281              STRB     r1,[r0,#0xa]
                  |L13.306|
;;;439            }
;;;440          }
;;;441    
;;;442          break;
000132  e040              B        |L13.438|
                  |L13.308|
;;;443        case EP_TYPE_INTR:
;;;444          if (direction == 0U)
000134  b9de              CBNZ     r6,|L13.366|
;;;445          {
;;;446            /* Set the Data Toggle bit as per the Flag */
;;;447            if (hhcd->hc[ch_num].toggle_out == 0U)
000136  eb050185          ADD      r1,r5,r5,LSL #2
00013a  f1040038          ADD      r0,r4,#0x38
00013e  eb0000c1          ADD      r0,r0,r1,LSL #3
000142  7e40              LDRB     r0,[r0,#0x19]
000144  b950              CBNZ     r0,|L13.348|
;;;448            {
;;;449              /* Put the PID 0 */
;;;450              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
000146  2100              MOVS     r1,#0
000148  eb050285          ADD      r2,r5,r5,LSL #2
00014c  f1040038          ADD      r0,r4,#0x38
000150  eb0000c2          ADD      r0,r0,r2,LSL #3
000154  7281              STRB     r1,[r0,#0xa]
000156  e023              B        |L13.416|
                  |L13.344|
000158  e023              B        |L13.418|
                  |L13.346|
00015a  e02b              B        |L13.436|
                  |L13.348|
;;;451            }
;;;452            else
;;;453            {
;;;454              /* Put the PID 1 */
;;;455              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
00015c  2102              MOVS     r1,#2
00015e  eb050285          ADD      r2,r5,r5,LSL #2
000162  f1040038          ADD      r0,r4,#0x38
000166  eb0000c2          ADD      r0,r0,r2,LSL #3
00016a  7281              STRB     r1,[r0,#0xa]
00016c  e018              B        |L13.416|
                  |L13.366|
;;;456            }
;;;457          }
;;;458          else
;;;459          {
;;;460            if (hhcd->hc[ch_num].toggle_in == 0U)
00016e  eb050185          ADD      r1,r5,r5,LSL #2
000172  f1040038          ADD      r0,r4,#0x38
000176  eb0000c1          ADD      r0,r0,r1,LSL #3
00017a  7e00              LDRB     r0,[r0,#0x18]
00017c  b940              CBNZ     r0,|L13.400|
;;;461            {
;;;462              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
00017e  2100              MOVS     r1,#0
000180  eb050285          ADD      r2,r5,r5,LSL #2
000184  f1040038          ADD      r0,r4,#0x38
000188  eb0000c2          ADD      r0,r0,r2,LSL #3
00018c  7281              STRB     r1,[r0,#0xa]
00018e  e007              B        |L13.416|
                  |L13.400|
;;;463            }
;;;464            else
;;;465            {
;;;466              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
000190  2102              MOVS     r1,#2
000192  eb050285          ADD      r2,r5,r5,LSL #2
000196  f1040038          ADD      r0,r4,#0x38
00019a  eb0000c2          ADD      r0,r0,r2,LSL #3
00019e  7281              STRB     r1,[r0,#0xa]
                  |L13.416|
;;;467            }
;;;468          }
;;;469          break;
0001a0  e009              B        |L13.438|
                  |L13.418|
;;;470    
;;;471        case EP_TYPE_ISOC:
;;;472          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
0001a2  2100              MOVS     r1,#0
0001a4  eb050285          ADD      r2,r5,r5,LSL #2
0001a8  f1040038          ADD      r0,r4,#0x38
0001ac  eb0000c2          ADD      r0,r0,r2,LSL #3
0001b0  7281              STRB     r1,[r0,#0xa]
;;;473          break;
0001b2  e000              B        |L13.438|
                  |L13.436|
;;;474    
;;;475        default:
;;;476          break;
0001b4  bf00              NOP      
                  |L13.438|
0001b6  bf00              NOP                            ;413
;;;477      }
;;;478    
;;;479      hhcd->hc[ch_num].xfer_buff = pbuff;
0001b8  eb050185          ADD      r1,r5,r5,LSL #2
0001bc  f1040038          ADD      r0,r4,#0x38
0001c0  eb0000c1          ADD      r0,r0,r1,LSL #3
0001c4  f8c0a00c          STR      r10,[r0,#0xc]
;;;480      hhcd->hc[ch_num].xfer_len  = length;
0001c8  eb050185          ADD      r1,r5,r5,LSL #2
0001cc  f1040038          ADD      r0,r4,#0x38
0001d0  eb0000c1          ADD      r0,r0,r1,LSL #3
0001d4  f8c09010          STR      r9,[r0,#0x10]
;;;481      hhcd->hc[ch_num].urb_state = URB_IDLE;
0001d8  2100              MOVS     r1,#0
0001da  eb050285          ADD      r2,r5,r5,LSL #2
0001de  f1040038          ADD      r0,r4,#0x38
0001e2  eb0000c2          ADD      r0,r0,r2,LSL #3
0001e6  f8801024          STRB     r1,[r0,#0x24]
;;;482      hhcd->hc[ch_num].xfer_count = 0U;
0001ea  eb050285          ADD      r2,r5,r5,LSL #2
0001ee  f1040038          ADD      r0,r4,#0x38
0001f2  eb0000c2          ADD      r0,r0,r2,LSL #3
0001f6  6141              STR      r1,[r0,#0x14]
;;;483      hhcd->hc[ch_num].ch_num = ch_num;
0001f8  eb050185          ADD      r1,r5,r5,LSL #2
0001fc  f1040038          ADD      r0,r4,#0x38
000200  eb0000c1          ADD      r0,r0,r1,LSL #3
000204  7045              STRB     r5,[r0,#1]
;;;484      hhcd->hc[ch_num].state = HC_IDLE;
000206  2100              MOVS     r1,#0
000208  eb050285          ADD      r2,r5,r5,LSL #2
00020c  f1040038          ADD      r0,r4,#0x38
000210  eb0000c2          ADD      r0,r0,r2,LSL #3
000214  f8801025          STRB     r1,[r0,#0x25]
;;;485    
;;;486      return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
000218  7c22              LDRB     r2,[r4,#0x10]
00021a  eb050c85          ADD      r12,r5,r5,LSL #2
00021e  f1040338          ADD      r3,r4,#0x38
000222  eb0301cc          ADD      r1,r3,r12,LSL #3
000226  6820              LDR      r0,[r4,#0]
000228  f7fffffe          BL       USB_HC_StartXfer
;;;487    }
00022c  e8bd9ff0          POP      {r4-r12,pc}
;;;488    
                          ENDP


                          AREA ||i.HAL_HCD_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_HCD_IRQHandler PROC
;;;493      */
;;;494    void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;495    {
000004  4604              MOV      r4,r0
;;;496      USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
000006  f8d48000          LDR      r8,[r4,#0]
;;;497      uint32_t USBx_BASE = (uint32_t)USBx;
00000a  4647              MOV      r7,r8
;;;498      uint32_t i, interrupt;
;;;499    
;;;500      /* Ensure that we are in device mode */
;;;501      if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       USB_GetMode
000012  2801              CMP      r0,#1
000014  d170              BNE      |L14.248|
;;;502      {
;;;503        /* Avoid spurious interrupt */
;;;504        if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       USB_ReadInterrupts
00001c  b908              CBNZ     r0,|L14.34|
                  |L14.30|
;;;505        {
;;;506          return;
;;;507        }
;;;508    
;;;509        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
;;;510        {
;;;511          /* Incorrect mode, acknowledge the interrupt */
;;;512          __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
;;;513        }
;;;514    
;;;515        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
;;;516        {
;;;517          /* Incorrect mode, acknowledge the interrupt */
;;;518          __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
;;;519        }
;;;520    
;;;521        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
;;;522        {
;;;523          /* Incorrect mode, acknowledge the interrupt */
;;;524          __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
;;;525        }
;;;526    
;;;527        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
;;;528        {
;;;529          /* Incorrect mode, acknowledge the interrupt */
;;;530          __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
;;;531        }
;;;532    
;;;533        /* Handle Host Disconnect Interrupts */
;;;534        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
;;;535        {
;;;536          __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
;;;537    
;;;538          if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
;;;539          {
;;;540            /* Handle Host Port Disconnect Interrupt */
;;;541    #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;542            hhcd->DisconnectCallback(hhcd);
;;;543    #else
;;;544            HAL_HCD_Disconnect_Callback(hhcd);
;;;545    #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;546    
;;;547            (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
;;;548          }
;;;549        }
;;;550    
;;;551        /* Handle Host Port Interrupts */
;;;552        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
;;;553        {
;;;554          HCD_Port_IRQHandler(hhcd);
;;;555        }
;;;556    
;;;557        /* Handle Host SOF Interrupt */
;;;558        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
;;;559        {
;;;560    #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;561          hhcd->SOFCallback(hhcd);
;;;562    #else
;;;563          HAL_HCD_SOF_Callback(hhcd);
;;;564    #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;565    
;;;566          __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
;;;567        }
;;;568    
;;;569        /* Handle Host channel Interrupt */
;;;570        if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
;;;571        {
;;;572          interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
;;;573          for (i = 0U; i < hhcd->Init.Host_channels; i++)
;;;574          {
;;;575            if ((interrupt & (1UL << (i & 0xFU))) != 0U)
;;;576            {
;;;577              if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
;;;578              {
;;;579                HCD_HC_IN_IRQHandler(hhcd, (uint8_t)i);
;;;580              }
;;;581              else
;;;582              {
;;;583                HCD_HC_OUT_IRQHandler(hhcd, (uint8_t)i);
;;;584              }
;;;585            }
;;;586          }
;;;587          __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
;;;588        }
;;;589    
;;;590        /* Handle Rx Queue Level Interrupts */
;;;591        if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
;;;592        {
;;;593          USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
;;;594    
;;;595          HCD_RXQLVL_IRQHandler(hhcd);
;;;596    
;;;597          USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
;;;598        }
;;;599      }
;;;600    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L14.34|
000022  6820              LDR      r0,[r4,#0]            ;509
000024  f7fffffe          BL       USB_ReadInterrupts
000028  f4001000          AND      r0,r0,#0x200000       ;509
00002c  f5b01f00          CMP      r0,#0x200000          ;509
000030  d103              BNE      |L14.58|
000032  f44f1000          MOV      r0,#0x200000          ;512
000036  6821              LDR      r1,[r4,#0]            ;512
000038  6148              STR      r0,[r1,#0x14]         ;512
                  |L14.58|
00003a  6820              LDR      r0,[r4,#0]            ;515
00003c  f7fffffe          BL       USB_ReadInterrupts
000040  f4001080          AND      r0,r0,#0x100000       ;515
000044  f5b01f80          CMP      r0,#0x100000          ;515
000048  d103              BNE      |L14.82|
00004a  f44f1080          MOV      r0,#0x100000          ;518
00004e  6821              LDR      r1,[r4,#0]            ;518
000050  6148              STR      r0,[r1,#0x14]         ;518
                  |L14.82|
000052  6820              LDR      r0,[r4,#0]            ;521
000054  f7fffffe          BL       USB_ReadInterrupts
000058  f0006080          AND      r0,r0,#0x4000000      ;521
00005c  f1b06f80          CMP      r0,#0x4000000         ;521
000060  d103              BNE      |L14.106|
000062  f04f6080          MOV      r0,#0x4000000         ;524
000066  6821              LDR      r1,[r4,#0]            ;524
000068  6148              STR      r0,[r1,#0x14]         ;524
                  |L14.106|
00006a  6820              LDR      r0,[r4,#0]            ;527
00006c  f7fffffe          BL       USB_ReadInterrupts
000070  f0000002          AND      r0,r0,#2              ;527
000074  2802              CMP      r0,#2                 ;527
000076  d101              BNE      |L14.124|
000078  6821              LDR      r1,[r4,#0]            ;530
00007a  6148              STR      r0,[r1,#0x14]         ;530
                  |L14.124|
00007c  6820              LDR      r0,[r4,#0]            ;534
00007e  f7fffffe          BL       USB_ReadInterrupts
000082  f0005000          AND      r0,r0,#0x20000000     ;534
000086  f1b05f00          CMP      r0,#0x20000000        ;534
00008a  d10f              BNE      |L14.172|
00008c  f04f5000          MOV      r0,#0x20000000        ;536
000090  6821              LDR      r1,[r4,#0]            ;536
000092  6148              STR      r0,[r1,#0x14]         ;536
000094  f8d70440          LDR      r0,[r7,#0x440]        ;538
000098  f0000001          AND      r0,r0,#1              ;538
00009c  b930              CBNZ     r0,|L14.172|
00009e  4620              MOV      r0,r4                 ;544
0000a0  f7fffffe          BL       HAL_HCD_Disconnect_Callback
0000a4  2101              MOVS     r1,#1                 ;547
0000a6  6820              LDR      r0,[r4,#0]            ;547
0000a8  f7fffffe          BL       USB_InitFSLSPClkSel
                  |L14.172|
0000ac  6820              LDR      r0,[r4,#0]            ;552
0000ae  f7fffffe          BL       USB_ReadInterrupts
0000b2  f0007080          AND      r0,r0,#0x1000000      ;552
0000b6  f1b07f80          CMP      r0,#0x1000000         ;552
0000ba  d102              BNE      |L14.194|
0000bc  4620              MOV      r0,r4                 ;554
0000be  f7fffffe          BL       HCD_Port_IRQHandler
                  |L14.194|
0000c2  6820              LDR      r0,[r4,#0]            ;558
0000c4  f7fffffe          BL       USB_ReadInterrupts
0000c8  f0000008          AND      r0,r0,#8              ;558
0000cc  2808              CMP      r0,#8                 ;558
0000ce  d105              BNE      |L14.220|
0000d0  4620              MOV      r0,r4                 ;563
0000d2  f7fffffe          BL       HAL_HCD_SOF_Callback
0000d6  2008              MOVS     r0,#8                 ;566
0000d8  6821              LDR      r1,[r4,#0]            ;566
0000da  6148              STR      r0,[r1,#0x14]         ;566
                  |L14.220|
0000dc  6820              LDR      r0,[r4,#0]            ;570
0000de  f7fffffe          BL       USB_ReadInterrupts
0000e2  f0007000          AND      r0,r0,#0x2000000      ;570
0000e6  f1b07f00          CMP      r0,#0x2000000         ;570
0000ea  d127              BNE      |L14.316|
0000ec  6820              LDR      r0,[r4,#0]            ;572
0000ee  f7fffffe          BL       USB_HC_ReadInterrupt
0000f2  4606              MOV      r6,r0                 ;572
0000f4  2500              MOVS     r5,#0                 ;573
0000f6  e01a              B        |L14.302|
                  |L14.248|
0000f8  e035              B        |L14.358|
                  |L14.250|
0000fa  f005010f          AND      r1,r5,#0xf            ;575
0000fe  2001              MOVS     r0,#1                 ;575
000100  4088              LSLS     r0,r0,r1              ;575
000102  4030              ANDS     r0,r0,r6              ;575
000104  b190              CBZ      r0,|L14.300|
000106  f50760a0          ADD      r0,r7,#0x500          ;577
00010a  eb001045          ADD      r0,r0,r5,LSL #5       ;577
00010e  6800              LDR      r0,[r0,#0]            ;577
000110  f4004000          AND      r0,r0,#0x8000         ;577
000114  f5b04f00          CMP      r0,#0x8000            ;577
000118  d104              BNE      |L14.292|
00011a  b2e9              UXTB     r1,r5                 ;579
00011c  4620              MOV      r0,r4                 ;579
00011e  f7fffffe          BL       HCD_HC_IN_IRQHandler
000122  e003              B        |L14.300|
                  |L14.292|
000124  b2e9              UXTB     r1,r5                 ;583
000126  4620              MOV      r0,r4                 ;583
000128  f7fffffe          BL       HCD_HC_OUT_IRQHandler
                  |L14.300|
00012c  1c6d              ADDS     r5,r5,#1              ;573
                  |L14.302|
00012e  68a0              LDR      r0,[r4,#8]            ;573
000130  42a8              CMP      r0,r5                 ;573
000132  d8e2              BHI      |L14.250|
000134  f04f7000          MOV      r0,#0x2000000         ;587
000138  6821              LDR      r1,[r4,#0]            ;587
00013a  6148              STR      r0,[r1,#0x14]         ;587
                  |L14.316|
00013c  6820              LDR      r0,[r4,#0]            ;591
00013e  f7fffffe          BL       USB_ReadInterrupts
000142  f3c01000          UBFX     r0,r0,#4,#1           ;591
000146  b170              CBZ      r0,|L14.358|
000148  6820              LDR      r0,[r4,#0]            ;593
00014a  6980              LDR      r0,[r0,#0x18]         ;593
00014c  f0200010          BIC      r0,r0,#0x10           ;593
000150  6821              LDR      r1,[r4,#0]            ;593
000152  6188              STR      r0,[r1,#0x18]         ;593
000154  4620              MOV      r0,r4                 ;595
000156  f7fffffe          BL       HCD_RXQLVL_IRQHandler
00015a  6820              LDR      r0,[r4,#0]            ;597
00015c  6980              LDR      r0,[r0,#0x18]         ;597
00015e  f0400010          ORR      r0,r0,#0x10           ;597
000162  6821              LDR      r1,[r4,#0]            ;597
000164  6188              STR      r0,[r1,#0x18]         ;597
                  |L14.358|
000166  bf00              NOP      
000168  e759              B        |L14.30|
;;;601    
                          ENDP


                          AREA ||i.HAL_HCD_Init||, CODE, READONLY, ALIGN=1

                  HAL_HCD_Init PROC
;;;110      */
;;;111    HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
000000  b530              PUSH     {r4,r5,lr}
;;;112    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
;;;113      USB_OTG_GlobalTypeDef *USBx;
;;;114    
;;;115      /* Check the HCD handle allocation */
;;;116      if (hhcd == NULL)
000006  b914              CBNZ     r4,|L15.14|
;;;117      {
;;;118        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L15.10|
;;;119      }
;;;120    
;;;121      /* Check the parameters */
;;;122      assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
;;;123    
;;;124      USBx = hhcd->Instance;
;;;125    
;;;126      if (hhcd->State == HAL_HCD_STATE_RESET)
;;;127      {
;;;128        /* Allocate lock resource and initialize it */
;;;129        hhcd->Lock = HAL_UNLOCKED;
;;;130    
;;;131    #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;132        hhcd->SOFCallback = HAL_HCD_SOF_Callback;
;;;133        hhcd->ConnectCallback = HAL_HCD_Connect_Callback;
;;;134        hhcd->DisconnectCallback = HAL_HCD_Disconnect_Callback;
;;;135        hhcd->PortEnabledCallback = HAL_HCD_PortEnabled_Callback;
;;;136        hhcd->PortDisabledCallback = HAL_HCD_PortDisabled_Callback;
;;;137        hhcd->HC_NotifyURBChangeCallback = HAL_HCD_HC_NotifyURBChange_Callback;
;;;138    
;;;139        if (hhcd->MspInitCallback == NULL)
;;;140        {
;;;141          hhcd->MspInitCallback = HAL_HCD_MspInit;
;;;142        }
;;;143    
;;;144        /* Init the low level hardware */
;;;145        hhcd->MspInitCallback(hhcd);
;;;146    #else
;;;147        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;148        HAL_HCD_MspInit(hhcd);
;;;149    #endif /* (USE_HAL_HCD_REGISTER_CALLBACKS) */
;;;150      }
;;;151    
;;;152      hhcd->State = HAL_HCD_STATE_BUSY;
;;;153    
;;;154      /* Disable DMA mode for FS instance */
;;;155      if ((USBx->CID & (0x1U << 8)) == 0U)
;;;156      {
;;;157        hhcd->Init.dma_enable = 0U;
;;;158      }
;;;159    
;;;160      /* Disable the Interrupts */
;;;161      __HAL_HCD_DISABLE(hhcd);
;;;162    
;;;163      /* Init the Core (common init.) */
;;;164      (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
;;;165    
;;;166      /* Force Host Mode*/
;;;167      (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
;;;168    
;;;169      /* Init Host */
;;;170      (void)USB_HostInit(hhcd->Instance, hhcd->Init);
;;;171    
;;;172      hhcd->State = HAL_HCD_STATE_READY;
;;;173    
;;;174      return HAL_OK;
;;;175    }
00000a  b00b              ADD      sp,sp,#0x2c
00000c  bd30              POP      {r4,r5,pc}
                  |L15.14|
00000e  6825              LDR      r5,[r4,#0]            ;124
000010  f89402b9          LDRB     r0,[r4,#0x2b9]        ;126
000014  b928              CBNZ     r0,|L15.34|
000016  2000              MOVS     r0,#0                 ;129
000018  f88402b8          STRB     r0,[r4,#0x2b8]        ;129
00001c  4620              MOV      r0,r4                 ;148
00001e  f7fffffe          BL       HAL_HCD_MspInit
                  |L15.34|
000022  2003              MOVS     r0,#3                 ;152
000024  f88402b9          STRB     r0,[r4,#0x2b9]        ;152
000028  6be8              LDR      r0,[r5,#0x3c]         ;155
00002a  f4007080          AND      r0,r0,#0x100          ;155
00002e  b908              CBNZ     r0,|L15.52|
000030  2100              MOVS     r1,#0                 ;157
000032  6121              STR      r1,[r4,#0x10]         ;157
                  |L15.52|
000034  6820              LDR      r0,[r4,#0]            ;161
000036  f7fffffe          BL       USB_DisableGlobalInt
00003a  2228              MOVS     r2,#0x28              ;164
00003c  f1040110          ADD      r1,r4,#0x10           ;164
000040  4668              MOV      r0,sp                 ;164
000042  f7fffffe          BL       __aeabi_memcpy4
000046  e894000f          LDM      r4,{r0-r3}            ;164
00004a  f7fffffe          BL       USB_CoreInit
00004e  2101              MOVS     r1,#1                 ;167
000050  6820              LDR      r0,[r4,#0]            ;167
000052  f7fffffe          BL       USB_SetCurrentMode
000056  2228              MOVS     r2,#0x28              ;170
000058  f1040110          ADD      r1,r4,#0x10           ;170
00005c  4668              MOV      r0,sp                 ;170
00005e  f7fffffe          BL       __aeabi_memcpy4
000062  e894000f          LDM      r4,{r0-r3}            ;170
000066  f7fffffe          BL       USB_HostInit
00006a  2001              MOVS     r0,#1                 ;172
00006c  f88402b9          STRB     r0,[r4,#0x2b9]        ;172
000070  2000              MOVS     r0,#0                 ;174
000072  e7ca              B        |L15.10|
;;;176    
                          ENDP


                          AREA ||i.HAL_HCD_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_HCD_MspDeInit PROC
;;;314      */
;;;315    __weak void  HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;316    {
;;;317      /* Prevent unused argument(s) compilation warning */
;;;318      UNUSED(hhcd);
;;;319    
;;;320      /* NOTE : This function should not be modified, when the callback is needed,
;;;321                the HAL_HCD_MspDeInit could be implemented in the user file
;;;322       */
;;;323    }
;;;324    
                          ENDP


                          AREA ||i.HAL_HCD_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_HCD_MspInit PROC
;;;299      */
;;;300    __weak void  HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;301    {
;;;302      /* Prevent unused argument(s) compilation warning */
;;;303      UNUSED(hhcd);
;;;304    
;;;305      /* NOTE : This function should not be modified, when the callback is needed,
;;;306                the HAL_HCD_MspInit could be implemented in the user file
;;;307       */
;;;308    }
;;;309    
                          ENDP


                          AREA ||i.HAL_HCD_PortDisabled_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_PortDisabled_Callback PROC
;;;678      */
;;;679    __weak void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;680    {
;;;681      /* Prevent unused argument(s) compilation warning */
;;;682      UNUSED(hhcd);
;;;683    
;;;684      /* NOTE : This function should not be modified, when the callback is needed,
;;;685                the HAL_HCD_Disconnect_Callback could be implemented in the user file
;;;686       */
;;;687    }
;;;688    
                          ENDP


                          AREA ||i.HAL_HCD_PortEnabled_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_PortEnabled_Callback PROC
;;;663      */
;;;664    __weak void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;665    {
;;;666      /* Prevent unused argument(s) compilation warning */
;;;667      UNUSED(hhcd);
;;;668    
;;;669      /* NOTE : This function should not be modified, when the callback is needed,
;;;670                the HAL_HCD_Disconnect_Callback could be implemented in the user file
;;;671       */
;;;672    }
;;;673    
                          ENDP


                          AREA ||i.HAL_HCD_ResetPort||, CODE, READONLY, ALIGN=1

                  HAL_HCD_ResetPort PROC
;;;1048     */
;;;1049   HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;1050   {
000002  4604              MOV      r4,r0
;;;1051     return (USB_ResetPort(hhcd->Instance));
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       USB_ResetPort
;;;1052   }
00000a  bd10              POP      {r4,pc}
;;;1053   
                          ENDP


                          AREA ||i.HAL_HCD_SOF_Callback||, CODE, READONLY, ALIGN=1

                  HAL_HCD_SOF_Callback PROC
;;;618      */
;;;619    __weak void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;620    {
;;;621      /* Prevent unused argument(s) compilation warning */
;;;622      UNUSED(hhcd);
;;;623    
;;;624      /* NOTE : This function should not be modified, when the callback is needed,
;;;625                the HAL_HCD_SOF_Callback could be implemented in the user file
;;;626       */
;;;627    }
;;;628    
                          ENDP


                          AREA ||i.HAL_HCD_Start||, CODE, READONLY, ALIGN=1

                  HAL_HCD_Start PROC
;;;1018     */
;;;1019   HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;1020   {
000002  4604              MOV      r4,r0
;;;1021     __HAL_LOCK(hhcd);
000004  bf00              NOP      
000006  f89402b8          LDRB     r0,[r4,#0x2b8]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L22.18|
00000e  2002              MOVS     r0,#2
                  |L22.16|
;;;1022     __HAL_HCD_ENABLE(hhcd);
;;;1023     (void)USB_DriveVbus(hhcd->Instance, 1U);
;;;1024     __HAL_UNLOCK(hhcd);
;;;1025   
;;;1026     return HAL_OK;
;;;1027   }
000010  bd10              POP      {r4,pc}
                  |L22.18|
000012  2001              MOVS     r0,#1                 ;1021
000014  f88402b8          STRB     r0,[r4,#0x2b8]        ;1021
000018  bf00              NOP                            ;1021
00001a  6820              LDR      r0,[r4,#0]            ;1022
00001c  f7fffffe          BL       USB_EnableGlobalInt
000020  2101              MOVS     r1,#1                 ;1023
000022  6820              LDR      r0,[r4,#0]            ;1023
000024  f7fffffe          BL       USB_DriveVbus
000028  bf00              NOP                            ;1024
00002a  2000              MOVS     r0,#0                 ;1024
00002c  f88402b8          STRB     r0,[r4,#0x2b8]        ;1024
000030  bf00              NOP                            ;1024
000032  bf00              NOP                            ;1026
000034  e7ec              B        |L22.16|
;;;1028   
                          ENDP


                          AREA ||i.HAL_HCD_Stop||, CODE, READONLY, ALIGN=1

                  HAL_HCD_Stop PROC
;;;1034   
;;;1035   HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
000000  b510              PUSH     {r4,lr}
;;;1036   {
000002  4604              MOV      r4,r0
;;;1037     __HAL_LOCK(hhcd);
000004  bf00              NOP      
000006  f89402b8          LDRB     r0,[r4,#0x2b8]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L23.18|
00000e  2002              MOVS     r0,#2
                  |L23.16|
;;;1038     (void)USB_StopHost(hhcd->Instance);
;;;1039     __HAL_UNLOCK(hhcd);
;;;1040   
;;;1041     return HAL_OK;
;;;1042   }
000010  bd10              POP      {r4,pc}
                  |L23.18|
000012  2001              MOVS     r0,#1                 ;1037
000014  f88402b8          STRB     r0,[r4,#0x2b8]        ;1037
000018  bf00              NOP                            ;1037
00001a  6820              LDR      r0,[r4,#0]            ;1038
00001c  f7fffffe          BL       USB_StopHost
000020  bf00              NOP                            ;1039
000022  2000              MOVS     r0,#0                 ;1039
000024  f88402b8          STRB     r0,[r4,#0x2b8]        ;1039
000028  bf00              NOP                            ;1039
00002a  bf00              NOP                            ;1041
00002c  e7f0              B        |L23.16|
;;;1043   
                          ENDP


                          AREA ||i.HAL_HCD_WKUP_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_HCD_WKUP_IRQHandler PROC
;;;607      */
;;;608    void HAL_HCD_WKUP_IRQHandler(HCD_HandleTypeDef *hhcd)
000000  4770              BX       lr
;;;609    {
;;;610      UNUSED(hhcd);
;;;611    }
;;;612    
                          ENDP


                          AREA ||i.HCD_HC_IN_IRQHandler||, CODE, READONLY, ALIGN=1

                  HCD_HC_IN_IRQHandler PROC
;;;1174     */
;;;1175   static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1176   {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;1177     USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
000008  f8d59000          LDR      r9,[r5,#0]
;;;1178     uint32_t USBx_BASE = (uint32_t)USBx;
00000c  464e              MOV      r6,r9
;;;1179     uint32_t ch_num = (uint32_t)chnum;
00000e  4644              MOV      r4,r8
;;;1180   
;;;1181     uint32_t tmpreg;
;;;1182   
;;;1183     if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
000010  f50660a0          ADD      r0,r6,#0x500
000014  eb001044          ADD      r0,r0,r4,LSL #5
000018  6880              LDR      r0,[r0,#8]
00001a  f0000004          AND      r0,r0,#4
00001e  2804              CMP      r0,#4
000020  d112              BNE      |L25.72|
;;;1184     {
;;;1185       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
000022  2104              MOVS     r1,#4
000024  f50660a0          ADD      r0,r6,#0x500
000028  eb001044          ADD      r0,r0,r4,LSL #5
00002c  6081              STR      r1,[r0,#8]
;;;1186       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00002e  f50660a0          ADD      r0,r6,#0x500
000032  eb001044          ADD      r0,r0,r4,LSL #5
000036  68c0              LDR      r0,[r0,#0xc]
000038  f0400102          ORR      r1,r0,#2
00003c  f50660a0          ADD      r0,r6,#0x500
000040  eb001044          ADD      r0,r0,r4,LSL #5
000044  60c1              STR      r1,[r0,#0xc]
000046  e098              B        |L25.378|
                  |L25.72|
;;;1187     }
;;;1188     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_BBERR) == USB_OTG_HCINT_BBERR)
000048  f50660a0          ADD      r0,r6,#0x500
00004c  eb001044          ADD      r0,r0,r4,LSL #5
000050  6880              LDR      r0,[r0,#8]
000052  f4007080          AND      r0,r0,#0x100
000056  f5b07f80          CMP      r0,#0x100
00005a  d120              BNE      |L25.158|
;;;1189     {
;;;1190       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_BBERR);
00005c  f44f7180          MOV      r1,#0x100
000060  f50660a0          ADD      r0,r6,#0x500
000064  eb001044          ADD      r0,r0,r4,LSL #5
000068  6081              STR      r1,[r0,#8]
;;;1191       hhcd->hc[ch_num].state = HC_BBLERR;
00006a  2107              MOVS     r1,#7
00006c  eb040284          ADD      r2,r4,r4,LSL #2
000070  f1050038          ADD      r0,r5,#0x38
000074  eb0000c2          ADD      r0,r0,r2,LSL #3
000078  f8801025          STRB     r1,[r0,#0x25]
;;;1192       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00007c  f50660a0          ADD      r0,r6,#0x500
000080  eb001044          ADD      r0,r0,r4,LSL #5
000084  68c0              LDR      r0,[r0,#0xc]
000086  f0400102          ORR      r1,r0,#2
00008a  f50660a0          ADD      r0,r6,#0x500
00008e  eb001044          ADD      r0,r0,r4,LSL #5
000092  60c1              STR      r1,[r0,#0xc]
;;;1193       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000094  b2e1              UXTB     r1,r4
000096  6828              LDR      r0,[r5,#0]
000098  f7fffffe          BL       USB_HC_Halt
00009c  e06d              B        |L25.378|
                  |L25.158|
;;;1194     }
;;;1195     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
00009e  f50660a0          ADD      r0,r6,#0x500
0000a2  eb001044          ADD      r0,r0,r4,LSL #5
0000a6  6880              LDR      r0,[r0,#8]
0000a8  f0000020          AND      r0,r0,#0x20
0000ac  2820              CMP      r0,#0x20
0000ae  d106              BNE      |L25.190|
;;;1196     {
;;;1197       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
0000b0  2120              MOVS     r1,#0x20
0000b2  f50660a0          ADD      r0,r6,#0x500
0000b6  eb001044          ADD      r0,r0,r4,LSL #5
0000ba  6081              STR      r1,[r0,#8]
0000bc  e05d              B        |L25.378|
                  |L25.190|
;;;1198     }
;;;1199     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
0000be  f50660a0          ADD      r0,r6,#0x500
0000c2  eb001044          ADD      r0,r0,r4,LSL #5
0000c6  6880              LDR      r0,[r0,#8]
0000c8  f0000008          AND      r0,r0,#8
0000cc  2808              CMP      r0,#8
0000ce  d125              BNE      |L25.284|
;;;1200     {
;;;1201       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
0000d0  f50660a0          ADD      r0,r6,#0x500
0000d4  eb001044          ADD      r0,r0,r4,LSL #5
0000d8  68c0              LDR      r0,[r0,#0xc]
0000da  f0400102          ORR      r1,r0,#2
0000de  f50660a0          ADD      r0,r6,#0x500
0000e2  eb001044          ADD      r0,r0,r4,LSL #5
0000e6  60c1              STR      r1,[r0,#0xc]
;;;1202       hhcd->hc[ch_num].state = HC_STALL;
0000e8  2105              MOVS     r1,#5
0000ea  eb040284          ADD      r2,r4,r4,LSL #2
0000ee  f1050038          ADD      r0,r5,#0x38
0000f2  eb0000c2          ADD      r0,r0,r2,LSL #3
0000f6  f8801025          STRB     r1,[r0,#0x25]
;;;1203       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
0000fa  2110              MOVS     r1,#0x10
0000fc  f50660a0          ADD      r0,r6,#0x500
000100  eb001044          ADD      r0,r0,r4,LSL #5
000104  6081              STR      r1,[r0,#8]
;;;1204       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
000106  2108              MOVS     r1,#8
000108  f50660a0          ADD      r0,r6,#0x500
00010c  eb001044          ADD      r0,r0,r4,LSL #5
000110  6081              STR      r1,[r0,#8]
;;;1205       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000112  b2e1              UXTB     r1,r4
000114  6828              LDR      r0,[r5,#0]
000116  f7fffffe          BL       USB_HC_Halt
00011a  e02e              B        |L25.378|
                  |L25.284|
;;;1206     }
;;;1207     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
00011c  f50660a0          ADD      r0,r6,#0x500
000120  eb001044          ADD      r0,r0,r4,LSL #5
000124  6880              LDR      r0,[r0,#8]
000126  f4006080          AND      r0,r0,#0x400
00012a  f5b06f80          CMP      r0,#0x400
00012e  d124              BNE      |L25.378|
;;;1208     {
;;;1209       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
000130  f50660a0          ADD      r0,r6,#0x500
000134  eb001044          ADD      r0,r0,r4,LSL #5
000138  68c0              LDR      r0,[r0,#0xc]
00013a  f0400102          ORR      r1,r0,#2
00013e  f50660a0          ADD      r0,r6,#0x500
000142  eb001044          ADD      r0,r0,r4,LSL #5
000146  60c1              STR      r1,[r0,#0xc]
;;;1210       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000148  b2e1              UXTB     r1,r4
00014a  6828              LDR      r0,[r5,#0]
00014c  f7fffffe          BL       USB_HC_Halt
;;;1211       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
000150  2110              MOVS     r1,#0x10
000152  f50660a0          ADD      r0,r6,#0x500
000156  eb001044          ADD      r0,r0,r4,LSL #5
00015a  6081              STR      r1,[r0,#8]
;;;1212       hhcd->hc[ch_num].state = HC_DATATGLERR;
00015c  2108              MOVS     r1,#8
00015e  eb040284          ADD      r2,r4,r4,LSL #2
000162  f1050038          ADD      r0,r5,#0x38
000166  eb0000c2          ADD      r0,r0,r2,LSL #3
00016a  f8801025          STRB     r1,[r0,#0x25]
;;;1213       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
00016e  01c9              LSLS     r1,r1,#7
000170  f50660a0          ADD      r0,r6,#0x500
000174  eb001044          ADD      r0,r0,r4,LSL #5
000178  6081              STR      r1,[r0,#8]
                  |L25.378|
;;;1214     }
;;;1215     else
;;;1216     {
;;;1217       /* ... */
;;;1218     }
;;;1219   
;;;1220     if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
00017a  f50660a0          ADD      r0,r6,#0x500
00017e  eb001044          ADD      r0,r0,r4,LSL #5
000182  6880              LDR      r0,[r0,#8]
000184  f4007000          AND      r0,r0,#0x200
000188  f5b07f00          CMP      r0,#0x200
00018c  d117              BNE      |L25.446|
;;;1221     {
;;;1222       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00018e  f50660a0          ADD      r0,r6,#0x500
000192  eb001044          ADD      r0,r0,r4,LSL #5
000196  68c0              LDR      r0,[r0,#0xc]
000198  f0400102          ORR      r1,r0,#2
00019c  f50660a0          ADD      r0,r6,#0x500
0001a0  eb001044          ADD      r0,r0,r4,LSL #5
0001a4  60c1              STR      r1,[r0,#0xc]
;;;1223       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
0001a6  b2e1              UXTB     r1,r4
0001a8  6828              LDR      r0,[r5,#0]
0001aa  f7fffffe          BL       USB_HC_Halt
;;;1224       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
0001ae  f44f7100          MOV      r1,#0x200
0001b2  f50660a0          ADD      r0,r6,#0x500
0001b6  eb001044          ADD      r0,r0,r4,LSL #5
0001ba  6081              STR      r1,[r0,#8]
0001bc  e253              B        |L25.1638|
                  |L25.446|
;;;1225     }
;;;1226     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
0001be  f50660a0          ADD      r0,r6,#0x500
0001c2  eb001044          ADD      r0,r0,r4,LSL #5
0001c6  6880              LDR      r0,[r0,#8]
0001c8  f0000001          AND      r0,r0,#1
0001cc  2800              CMP      r0,#0
0001ce  d07d              BEQ      |L25.716|
;;;1227     {
;;;1228       if (hhcd->Init.dma_enable != 0U)
0001d0  6928              LDR      r0,[r5,#0x10]
0001d2  b1a8              CBZ      r0,|L25.512|
;;;1229       {
;;;1230         hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
0001d4  eb040184          ADD      r1,r4,r4,LSL #2
0001d8  f1050038          ADD      r0,r5,#0x38
0001dc  eb0000c1          ADD      r0,r0,r1,LSL #3
0001e0  6901              LDR      r1,[r0,#0x10]
0001e2  f50660a0          ADD      r0,r6,#0x500
0001e6  eb001044          ADD      r0,r0,r4,LSL #5
0001ea  6900              LDR      r0,[r0,#0x10]
0001ec  f3c00012          UBFX     r0,r0,#0,#19
0001f0  1a09              SUBS     r1,r1,r0
0001f2  eb040284          ADD      r2,r4,r4,LSL #2
0001f6  f1050038          ADD      r0,r5,#0x38
0001fa  eb0000c2          ADD      r0,r0,r2,LSL #3
0001fe  6141              STR      r1,[r0,#0x14]
                  |L25.512|
;;;1231                                       (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
;;;1232       }
;;;1233   
;;;1234       hhcd->hc[ch_num].state = HC_XFRC;
000200  2101              MOVS     r1,#1
000202  eb040284          ADD      r2,r4,r4,LSL #2
000206  f1050038          ADD      r0,r5,#0x38
00020a  eb0000c2          ADD      r0,r0,r2,LSL #3
00020e  f8801025          STRB     r1,[r0,#0x25]
;;;1235       hhcd->hc[ch_num].ErrCnt = 0U;
000212  2100              MOVS     r1,#0
000214  eb040284          ADD      r2,r4,r4,LSL #2
000218  f1050038          ADD      r0,r5,#0x38
00021c  eb0000c2          ADD      r0,r0,r2,LSL #3
000220  6201              STR      r1,[r0,#0x20]
;;;1236       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
000222  2101              MOVS     r1,#1
000224  f50660a0          ADD      r0,r6,#0x500
000228  eb001044          ADD      r0,r0,r4,LSL #5
00022c  6081              STR      r1,[r0,#8]
;;;1237   
;;;1238       if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
00022e  eb040184          ADD      r1,r4,r4,LSL #2
000232  f1050038          ADD      r0,r5,#0x38
000236  eb0000c1          ADD      r0,r0,r1,LSL #3
00023a  79c0              LDRB     r0,[r0,#7]
00023c  b140              CBZ      r0,|L25.592|
;;;1239           (hhcd->hc[ch_num].ep_type == EP_TYPE_BULK))
00023e  eb040184          ADD      r1,r4,r4,LSL #2
000242  f1050038          ADD      r0,r5,#0x38
000246  eb0000c1          ADD      r0,r0,r1,LSL #3
00024a  79c0              LDRB     r0,[r0,#7]
00024c  2802              CMP      r0,#2
00024e  d116              BNE      |L25.638|
                  |L25.592|
;;;1240       {
;;;1241         __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
000250  f50660a0          ADD      r0,r6,#0x500
000254  eb001044          ADD      r0,r0,r4,LSL #5
000258  68c0              LDR      r0,[r0,#0xc]
00025a  f0400102          ORR      r1,r0,#2
00025e  f50660a0          ADD      r0,r6,#0x500
000262  eb001044          ADD      r0,r0,r4,LSL #5
000266  60c1              STR      r1,[r0,#0xc]
;;;1242         (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000268  b2e1              UXTB     r1,r4
00026a  6828              LDR      r0,[r5,#0]
00026c  f7fffffe          BL       USB_HC_Halt
;;;1243         __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
000270  2110              MOVS     r1,#0x10
000272  f50660a0          ADD      r0,r6,#0x500
000276  eb001044          ADD      r0,r0,r4,LSL #5
00027a  6081              STR      r1,[r0,#8]
00027c  e05a              B        |L25.820|
                  |L25.638|
;;;1244       }
;;;1245       else if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
00027e  eb040184          ADD      r1,r4,r4,LSL #2
000282  f1050038          ADD      r0,r5,#0x38
000286  eb0000c1          ADD      r0,r0,r1,LSL #3
00028a  79c0              LDRB     r0,[r0,#7]
00028c  2803              CMP      r0,#3
00028e  d123              BNE      |L25.728|
;;;1246       {
;;;1247         USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
000290  f50660a0          ADD      r0,r6,#0x500
000294  eb001044          ADD      r0,r0,r4,LSL #5
000298  6800              LDR      r0,[r0,#0]
00029a  f0405100          ORR      r1,r0,#0x20000000
00029e  f50660a0          ADD      r0,r6,#0x500
0002a2  eb001044          ADD      r0,r0,r4,LSL #5
0002a6  6001              STR      r1,[r0,#0]
;;;1248         hhcd->hc[ch_num].urb_state = URB_DONE;
0002a8  2101              MOVS     r1,#1
0002aa  eb040284          ADD      r2,r4,r4,LSL #2
0002ae  f1050038          ADD      r0,r5,#0x38
0002b2  eb0000c2          ADD      r0,r0,r2,LSL #3
0002b6  f8801024          STRB     r1,[r0,#0x24]
;;;1249   
;;;1250   #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;1251         hhcd->HC_NotifyURBChangeCallback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
;;;1252   #else
;;;1253         HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
0002ba  eb040384          ADD      r3,r4,r4,LSL #2
0002be  f1050038          ADD      r0,r5,#0x38
0002c2  eb0000c3          ADD      r0,r0,r3,LSL #3
0002c6  f8902024          LDRB     r2,[r0,#0x24]
0002ca  e000              B        |L25.718|
                  |L25.716|
0002cc  e043              B        |L25.854|
                  |L25.718|
0002ce  b2e1              UXTB     r1,r4
0002d0  4628              MOV      r0,r5
0002d2  f7fffffe          BL       HAL_HCD_HC_NotifyURBChange_Callback
0002d6  e02d              B        |L25.820|
                  |L25.728|
;;;1254   #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;1255       }
;;;1256       else if (hhcd->hc[ch_num].ep_type == EP_TYPE_ISOC)
0002d8  eb040184          ADD      r1,r4,r4,LSL #2
0002dc  f1050038          ADD      r0,r5,#0x38
0002e0  eb0000c1          ADD      r0,r0,r1,LSL #3
0002e4  79c0              LDRB     r0,[r0,#7]
0002e6  2801              CMP      r0,#1
0002e8  d124              BNE      |L25.820|
;;;1257       {
;;;1258         hhcd->hc[ch_num].urb_state = URB_DONE;
0002ea  2101              MOVS     r1,#1
0002ec  eb040284          ADD      r2,r4,r4,LSL #2
0002f0  f1050038          ADD      r0,r5,#0x38
0002f4  eb0000c2          ADD      r0,r0,r2,LSL #3
0002f8  f8801024          STRB     r1,[r0,#0x24]
;;;1259         hhcd->hc[ch_num].toggle_in ^= 1U;
0002fc  eb040184          ADD      r1,r4,r4,LSL #2
000300  f1050038          ADD      r0,r5,#0x38
000304  eb0000c1          ADD      r0,r0,r1,LSL #3
000308  7e00              LDRB     r0,[r0,#0x18]
00030a  f0800101          EOR      r1,r0,#1
00030e  eb040284          ADD      r2,r4,r4,LSL #2
000312  f1050038          ADD      r0,r5,#0x38
000316  eb0000c2          ADD      r0,r0,r2,LSL #3
00031a  7601              STRB     r1,[r0,#0x18]
;;;1260   
;;;1261   #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;1262         hhcd->HC_NotifyURBChangeCallback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
;;;1263   #else
;;;1264         HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
00031c  eb040384          ADD      r3,r4,r4,LSL #2
000320  f1050038          ADD      r0,r5,#0x38
000324  eb0000c3          ADD      r0,r0,r3,LSL #3
000328  f8902024          LDRB     r2,[r0,#0x24]
00032c  b2e1              UXTB     r1,r4
00032e  4628              MOV      r0,r5
000330  f7fffffe          BL       HAL_HCD_HC_NotifyURBChange_Callback
                  |L25.820|
;;;1265   #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;1266       }
;;;1267       else
;;;1268       {
;;;1269         /* ... */
;;;1270       }
;;;1271       hhcd->hc[ch_num].toggle_in ^= 1U;
000334  eb040184          ADD      r1,r4,r4,LSL #2
000338  f1050038          ADD      r0,r5,#0x38
00033c  eb0000c1          ADD      r0,r0,r1,LSL #3
000340  7e00              LDRB     r0,[r0,#0x18]
000342  f0800101          EOR      r1,r0,#1
000346  eb040284          ADD      r2,r4,r4,LSL #2
00034a  f1050038          ADD      r0,r5,#0x38
00034e  eb0000c2          ADD      r0,r0,r2,LSL #3
000352  7601              STRB     r1,[r0,#0x18]
000354  e187              B        |L25.1638|
                  |L25.854|
;;;1272   
;;;1273     }
;;;1274     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
000356  f50660a0          ADD      r0,r6,#0x500
00035a  eb001044          ADD      r0,r0,r4,LSL #5
00035e  6880              LDR      r0,[r0,#8]
000360  f0000002          AND      r0,r0,#2
000364  2802              CMP      r0,#2
000366  d171              BNE      |L25.1100|
;;;1275     {
;;;1276       __HAL_HCD_MASK_HALT_HC_INT(ch_num);
000368  f50660a0          ADD      r0,r6,#0x500
00036c  eb001044          ADD      r0,r0,r4,LSL #5
000370  68c0              LDR      r0,[r0,#0xc]
000372  f0200102          BIC      r1,r0,#2
000376  f50660a0          ADD      r0,r6,#0x500
00037a  eb001044          ADD      r0,r0,r4,LSL #5
00037e  60c1              STR      r1,[r0,#0xc]
;;;1277   
;;;1278       if (hhcd->hc[ch_num].state == HC_XFRC)
000380  eb040184          ADD      r1,r4,r4,LSL #2
000384  f1050038          ADD      r0,r5,#0x38
000388  eb0000c1          ADD      r0,r0,r1,LSL #3
00038c  f8900025          LDRB     r0,[r0,#0x25]
000390  2801              CMP      r0,#1
000392  d109              BNE      |L25.936|
;;;1279       {
;;;1280         hhcd->hc[ch_num].urb_state  = URB_DONE;
000394  2101              MOVS     r1,#1
000396  eb040284          ADD      r2,r4,r4,LSL #2
00039a  f1050038          ADD      r0,r5,#0x38
00039e  eb0000c2          ADD      r0,r0,r2,LSL #3
0003a2  f8801024          STRB     r1,[r0,#0x24]
0003a6  e0ae              B        |L25.1286|
                  |L25.936|
;;;1281       }
;;;1282       else if (hhcd->hc[ch_num].state == HC_STALL)
0003a8  eb040184          ADD      r1,r4,r4,LSL #2
0003ac  f1050038          ADD      r0,r5,#0x38
0003b0  eb0000c1          ADD      r0,r0,r1,LSL #3
0003b4  f8900025          LDRB     r0,[r0,#0x25]
0003b8  2805              CMP      r0,#5
0003ba  d109              BNE      |L25.976|
;;;1283       {
;;;1284         hhcd->hc[ch_num].urb_state  = URB_STALL;
0003bc  2105              MOVS     r1,#5
0003be  eb040284          ADD      r2,r4,r4,LSL #2
0003c2  f1050038          ADD      r0,r5,#0x38
0003c6  eb0000c2          ADD      r0,r0,r2,LSL #3
0003ca  f8801024          STRB     r1,[r0,#0x24]
0003ce  e09a              B        |L25.1286|
                  |L25.976|
;;;1285       }
;;;1286       else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
0003d0  eb040184          ADD      r1,r4,r4,LSL #2
0003d4  f1050038          ADD      r0,r5,#0x38
0003d8  eb0000c1          ADD      r0,r0,r1,LSL #3
0003dc  f8900025          LDRB     r0,[r0,#0x25]
0003e0  2806              CMP      r0,#6
0003e2  d009              BEQ      |L25.1016|
;;;1287                (hhcd->hc[ch_num].state == HC_DATATGLERR))
0003e4  eb040184          ADD      r1,r4,r4,LSL #2
0003e8  f1050038          ADD      r0,r5,#0x38
0003ec  eb0000c1          ADD      r0,r0,r1,LSL #3
0003f0  f8900025          LDRB     r0,[r0,#0x25]
0003f4  2808              CMP      r0,#8
0003f6  d142              BNE      |L25.1150|
                  |L25.1016|
;;;1288       {
;;;1289         hhcd->hc[ch_num].ErrCnt++;
0003f8  eb040184          ADD      r1,r4,r4,LSL #2
0003fc  f1050038          ADD      r0,r5,#0x38
000400  eb0000c1          ADD      r0,r0,r1,LSL #3
000404  6a00              LDR      r0,[r0,#0x20]
000406  1c40              ADDS     r0,r0,#1
000408  eb040284          ADD      r2,r4,r4,LSL #2
00040c  f1050138          ADD      r1,r5,#0x38
000410  eb0101c2          ADD      r1,r1,r2,LSL #3
000414  6208              STR      r0,[r1,#0x20]
;;;1290         if (hhcd->hc[ch_num].ErrCnt > 3U)
000416  eb040184          ADD      r1,r4,r4,LSL #2
00041a  f1050038          ADD      r0,r5,#0x38
00041e  eb0000c1          ADD      r0,r0,r1,LSL #3
000422  6a00              LDR      r0,[r0,#0x20]
000424  2803              CMP      r0,#3
000426  d912              BLS      |L25.1102|
;;;1291         {
;;;1292           hhcd->hc[ch_num].ErrCnt = 0U;
000428  2100              MOVS     r1,#0
00042a  eb040284          ADD      r2,r4,r4,LSL #2
00042e  f1050038          ADD      r0,r5,#0x38
000432  eb0000c2          ADD      r0,r0,r2,LSL #3
000436  6201              STR      r1,[r0,#0x20]
;;;1293           hhcd->hc[ch_num].urb_state = URB_ERROR;
000438  2104              MOVS     r1,#4
00043a  eb040284          ADD      r2,r4,r4,LSL #2
00043e  f1050038          ADD      r0,r5,#0x38
000442  eb0000c2          ADD      r0,r0,r2,LSL #3
000446  f8801024          STRB     r1,[r0,#0x24]
00044a  e009              B        |L25.1120|
                  |L25.1100|
00044c  e06e              B        |L25.1324|
                  |L25.1102|
;;;1294         }
;;;1295         else
;;;1296         {
;;;1297           hhcd->hc[ch_num].urb_state = URB_NOTREADY;
00044e  2102              MOVS     r1,#2
000450  eb040284          ADD      r2,r4,r4,LSL #2
000454  f1050038          ADD      r0,r5,#0x38
000458  eb0000c2          ADD      r0,r0,r2,LSL #3
00045c  f8801024          STRB     r1,[r0,#0x24]
                  |L25.1120|
;;;1298         }
;;;1299   
;;;1300         /* re-activate the channel  */
;;;1301         tmpreg = USBx_HC(ch_num)->HCCHAR;
000460  f50660a0          ADD      r0,r6,#0x500
000464  eb001044          ADD      r0,r0,r4,LSL #5
000468  6807              LDR      r7,[r0,#0]
;;;1302         tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
00046a  f0274780          BIC      r7,r7,#0x40000000
;;;1303         tmpreg |= USB_OTG_HCCHAR_CHENA;
00046e  f0474700          ORR      r7,r7,#0x80000000
;;;1304         USBx_HC(ch_num)->HCCHAR = tmpreg;
000472  f50660a0          ADD      r0,r6,#0x500
000476  eb001044          ADD      r0,r0,r4,LSL #5
00047a  6007              STR      r7,[r0,#0]
00047c  e043              B        |L25.1286|
                  |L25.1150|
;;;1305       }
;;;1306       else if (hhcd->hc[ch_num].state == HC_NAK)
00047e  eb040184          ADD      r1,r4,r4,LSL #2
000482  f1050038          ADD      r0,r5,#0x38
000486  eb0000c1          ADD      r0,r0,r1,LSL #3
00048a  f8900025          LDRB     r0,[r0,#0x25]
00048e  2803              CMP      r0,#3
000490  d117              BNE      |L25.1218|
;;;1307       {
;;;1308         hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
000492  2102              MOVS     r1,#2
000494  eb040284          ADD      r2,r4,r4,LSL #2
000498  f1050038          ADD      r0,r5,#0x38
00049c  eb0000c2          ADD      r0,r0,r2,LSL #3
0004a0  f8801024          STRB     r1,[r0,#0x24]
;;;1309         /* re-activate the channel  */
;;;1310         tmpreg = USBx_HC(ch_num)->HCCHAR;
0004a4  f50660a0          ADD      r0,r6,#0x500
0004a8  eb001044          ADD      r0,r0,r4,LSL #5
0004ac  6807              LDR      r7,[r0,#0]
;;;1311         tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
0004ae  f0274780          BIC      r7,r7,#0x40000000
;;;1312         tmpreg |= USB_OTG_HCCHAR_CHENA;
0004b2  f0474700          ORR      r7,r7,#0x80000000
;;;1313         USBx_HC(ch_num)->HCCHAR = tmpreg;
0004b6  f50660a0          ADD      r0,r6,#0x500
0004ba  eb001044          ADD      r0,r0,r4,LSL #5
0004be  6007              STR      r7,[r0,#0]
0004c0  e021              B        |L25.1286|
                  |L25.1218|
;;;1314       }
;;;1315       else if (hhcd->hc[ch_num].state == HC_BBLERR)
0004c2  eb040184          ADD      r1,r4,r4,LSL #2
0004c6  f1050038          ADD      r0,r5,#0x38
0004ca  eb0000c1          ADD      r0,r0,r1,LSL #3
0004ce  f8900025          LDRB     r0,[r0,#0x25]
0004d2  2807              CMP      r0,#7
0004d4  d117              BNE      |L25.1286|
;;;1316       {
;;;1317         hhcd->hc[ch_num].ErrCnt++;
0004d6  eb040184          ADD      r1,r4,r4,LSL #2
0004da  f1050038          ADD      r0,r5,#0x38
0004de  eb0000c1          ADD      r0,r0,r1,LSL #3
0004e2  6a00              LDR      r0,[r0,#0x20]
0004e4  1c40              ADDS     r0,r0,#1
0004e6  eb040284          ADD      r2,r4,r4,LSL #2
0004ea  f1050138          ADD      r1,r5,#0x38
0004ee  eb0101c2          ADD      r1,r1,r2,LSL #3
0004f2  6208              STR      r0,[r1,#0x20]
;;;1318         hhcd->hc[ch_num].urb_state = URB_ERROR;
0004f4  2104              MOVS     r1,#4
0004f6  eb040284          ADD      r2,r4,r4,LSL #2
0004fa  f1050038          ADD      r0,r5,#0x38
0004fe  eb0000c2          ADD      r0,r0,r2,LSL #3
000502  f8801024          STRB     r1,[r0,#0x24]
                  |L25.1286|
;;;1319       }
;;;1320       else
;;;1321       {
;;;1322         /* ... */
;;;1323       }
;;;1324       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
000506  2102              MOVS     r1,#2
000508  f50660a0          ADD      r0,r6,#0x500
00050c  eb001044          ADD      r0,r0,r4,LSL #5
000510  6081              STR      r1,[r0,#8]
;;;1325       HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
000512  eb040384          ADD      r3,r4,r4,LSL #2
000516  f1050038          ADD      r0,r5,#0x38
00051a  eb0000c3          ADD      r0,r0,r3,LSL #3
00051e  f8902024          LDRB     r2,[r0,#0x24]
000522  b2e1              UXTB     r1,r4
000524  4628              MOV      r0,r5
000526  f7fffffe          BL       HAL_HCD_HC_NotifyURBChange_Callback
00052a  e09c              B        |L25.1638|
                  |L25.1324|
;;;1326     }
;;;1327     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
00052c  f50660a0          ADD      r0,r6,#0x500
000530  eb001044          ADD      r0,r0,r4,LSL #5
000534  6880              LDR      r0,[r0,#8]
000536  f0000080          AND      r0,r0,#0x80
00053a  2880              CMP      r0,#0x80
00053c  d12e              BNE      |L25.1436|
;;;1328     {
;;;1329       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00053e  f50660a0          ADD      r0,r6,#0x500
000542  eb001044          ADD      r0,r0,r4,LSL #5
000546  68c0              LDR      r0,[r0,#0xc]
000548  f0400102          ORR      r1,r0,#2
00054c  f50660a0          ADD      r0,r6,#0x500
000550  eb001044          ADD      r0,r0,r4,LSL #5
000554  60c1              STR      r1,[r0,#0xc]
;;;1330       hhcd->hc[ch_num].ErrCnt++;
000556  eb040184          ADD      r1,r4,r4,LSL #2
00055a  f1050038          ADD      r0,r5,#0x38
00055e  eb0000c1          ADD      r0,r0,r1,LSL #3
000562  6a00              LDR      r0,[r0,#0x20]
000564  1c40              ADDS     r0,r0,#1
000566  eb040284          ADD      r2,r4,r4,LSL #2
00056a  f1050138          ADD      r1,r5,#0x38
00056e  eb0101c2          ADD      r1,r1,r2,LSL #3
000572  6208              STR      r0,[r1,#0x20]
;;;1331       hhcd->hc[ch_num].state = HC_XACTERR;
000574  2106              MOVS     r1,#6
000576  eb040284          ADD      r2,r4,r4,LSL #2
00057a  f1050038          ADD      r0,r5,#0x38
00057e  eb0000c2          ADD      r0,r0,r2,LSL #3
000582  f8801025          STRB     r1,[r0,#0x25]
;;;1332       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000586  b2e1              UXTB     r1,r4
000588  6828              LDR      r0,[r5,#0]
00058a  f7fffffe          BL       USB_HC_Halt
;;;1333       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
00058e  2180              MOVS     r1,#0x80
000590  f50660a0          ADD      r0,r6,#0x500
000594  eb001044          ADD      r0,r0,r4,LSL #5
000598  6081              STR      r1,[r0,#8]
00059a  e064              B        |L25.1638|
                  |L25.1436|
;;;1334     }
;;;1335     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
00059c  f50660a0          ADD      r0,r6,#0x500
0005a0  eb001044          ADD      r0,r0,r4,LSL #5
0005a4  6880              LDR      r0,[r0,#8]
0005a6  f0000010          AND      r0,r0,#0x10
0005aa  2810              CMP      r0,#0x10
0005ac  d15b              BNE      |L25.1638|
;;;1336     {
;;;1337       if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
0005ae  eb040184          ADD      r1,r4,r4,LSL #2
0005b2  f1050038          ADD      r0,r5,#0x38
0005b6  eb0000c1          ADD      r0,r0,r1,LSL #3
0005ba  79c0              LDRB     r0,[r0,#7]
0005bc  2803              CMP      r0,#3
0005be  d118              BNE      |L25.1522|
;;;1338       {
;;;1339         hhcd->hc[ch_num].ErrCnt = 0U;
0005c0  2100              MOVS     r1,#0
0005c2  eb040284          ADD      r2,r4,r4,LSL #2
0005c6  f1050038          ADD      r0,r5,#0x38
0005ca  eb0000c2          ADD      r0,r0,r2,LSL #3
0005ce  6201              STR      r1,[r0,#0x20]
;;;1340         __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
0005d0  f50660a0          ADD      r0,r6,#0x500
0005d4  eb001044          ADD      r0,r0,r4,LSL #5
0005d8  68c0              LDR      r0,[r0,#0xc]
0005da  f0400102          ORR      r1,r0,#2
0005de  f50660a0          ADD      r0,r6,#0x500
0005e2  eb001044          ADD      r0,r0,r4,LSL #5
0005e6  60c1              STR      r1,[r0,#0xc]
;;;1341         (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
0005e8  b2e1              UXTB     r1,r4
0005ea  6828              LDR      r0,[r5,#0]
0005ec  f7fffffe          BL       USB_HC_Halt
0005f0  e033              B        |L25.1626|
                  |L25.1522|
;;;1342       }
;;;1343       else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
0005f2  eb040184          ADD      r1,r4,r4,LSL #2
0005f6  f1050038          ADD      r0,r5,#0x38
0005fa  eb0000c1          ADD      r0,r0,r1,LSL #3
0005fe  79c0              LDRB     r0,[r0,#7]
000600  b140              CBZ      r0,|L25.1556|
;;;1344                (hhcd->hc[ch_num].ep_type == EP_TYPE_BULK))
000602  eb040184          ADD      r1,r4,r4,LSL #2
000606  f1050038          ADD      r0,r5,#0x38
00060a  eb0000c1          ADD      r0,r0,r1,LSL #3
00060e  79c0              LDRB     r0,[r0,#7]
000610  2802              CMP      r0,#2
000612  d122              BNE      |L25.1626|
                  |L25.1556|
;;;1345       {
;;;1346         hhcd->hc[ch_num].ErrCnt = 0U;
000614  2100              MOVS     r1,#0
000616  eb040284          ADD      r2,r4,r4,LSL #2
00061a  f1050038          ADD      r0,r5,#0x38
00061e  eb0000c2          ADD      r0,r0,r2,LSL #3
000622  6201              STR      r1,[r0,#0x20]
;;;1347   
;;;1348         if (hhcd->Init.dma_enable == 0U)
000624  6928              LDR      r0,[r5,#0x10]
000626  b9c0              CBNZ     r0,|L25.1626|
;;;1349         {
;;;1350           hhcd->hc[ch_num].state = HC_NAK;
000628  2103              MOVS     r1,#3
00062a  eb040284          ADD      r2,r4,r4,LSL #2
00062e  f1050038          ADD      r0,r5,#0x38
000632  eb0000c2          ADD      r0,r0,r2,LSL #3
000636  f8801025          STRB     r1,[r0,#0x25]
;;;1351           __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00063a  f50660a0          ADD      r0,r6,#0x500
00063e  eb001044          ADD      r0,r0,r4,LSL #5
000642  68c0              LDR      r0,[r0,#0xc]
000644  f0400102          ORR      r1,r0,#2
000648  f50660a0          ADD      r0,r6,#0x500
00064c  eb001044          ADD      r0,r0,r4,LSL #5
000650  60c1              STR      r1,[r0,#0xc]
;;;1352           (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000652  b2e1              UXTB     r1,r4
000654  6828              LDR      r0,[r5,#0]
000656  f7fffffe          BL       USB_HC_Halt
                  |L25.1626|
;;;1353         }
;;;1354       }
;;;1355       else
;;;1356       {
;;;1357         /* ... */
;;;1358       }
;;;1359       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
00065a  2110              MOVS     r1,#0x10
00065c  f50660a0          ADD      r0,r6,#0x500
000660  eb001044          ADD      r0,r0,r4,LSL #5
000664  6081              STR      r1,[r0,#8]
                  |L25.1638|
;;;1360     }
;;;1361     else
;;;1362     {
;;;1363       /* ... */
;;;1364     }
;;;1365   }
000666  e8bd87f0          POP      {r4-r10,pc}
;;;1366   
                          ENDP


                          AREA ||i.HCD_HC_OUT_IRQHandler||, CODE, READONLY, ALIGN=1

                  HCD_HC_OUT_IRQHandler PROC
;;;1373     */
;;;1374   static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1375   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;1376     USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
000008  f8d59000          LDR      r9,[r5,#0]
;;;1377     uint32_t USBx_BASE = (uint32_t)USBx;
00000c  464e              MOV      r6,r9
;;;1378     uint32_t ch_num = (uint32_t)chnum;
00000e  463c              MOV      r4,r7
;;;1379     uint32_t tmpreg;
;;;1380   
;;;1381     if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
000010  f50660a0          ADD      r0,r6,#0x500
000014  eb001044          ADD      r0,r0,r4,LSL #5
000018  6880              LDR      r0,[r0,#8]
00001a  f0000004          AND      r0,r0,#4
00001e  2804              CMP      r0,#4
000020  d112              BNE      |L26.72|
;;;1382     {
;;;1383       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
000022  2104              MOVS     r1,#4
000024  f50660a0          ADD      r0,r6,#0x500
000028  eb001044          ADD      r0,r0,r4,LSL #5
00002c  6081              STR      r1,[r0,#8]
;;;1384       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00002e  f50660a0          ADD      r0,r6,#0x500
000032  eb001044          ADD      r0,r0,r4,LSL #5
000036  68c0              LDR      r0,[r0,#0xc]
000038  f0400102          ORR      r1,r0,#2
00003c  f50660a0          ADD      r0,r6,#0x500
000040  eb001044          ADD      r0,r0,r4,LSL #5
000044  60c1              STR      r1,[r0,#0xc]
                  |L26.70|
000046  e27e              B        |L26.1350|
                  |L26.72|
;;;1385     }
;;;1386     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
000048  f50660a0          ADD      r0,r6,#0x500
00004c  eb001044          ADD      r0,r0,r4,LSL #5
000050  6880              LDR      r0,[r0,#8]
000052  f0000020          AND      r0,r0,#0x20
000056  2820              CMP      r0,#0x20
000058  d130              BNE      |L26.188|
;;;1387     {
;;;1388       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
00005a  2120              MOVS     r1,#0x20
00005c  f50660a0          ADD      r0,r6,#0x500
000060  eb001044          ADD      r0,r0,r4,LSL #5
000064  6081              STR      r1,[r0,#8]
;;;1389   
;;;1390       if (hhcd->hc[ch_num].do_ping == 1U)
000066  eb040184          ADD      r1,r4,r4,LSL #2
00006a  f1050038          ADD      r0,r5,#0x38
00006e  eb0000c1          ADD      r0,r0,r1,LSL #3
000072  7940              LDRB     r0,[r0,#5]
000074  2801              CMP      r0,#1
000076  d1e6              BNE      |L26.70|
;;;1391       {
;;;1392         hhcd->hc[ch_num].do_ping = 0U;
000078  2100              MOVS     r1,#0
00007a  eb040284          ADD      r2,r4,r4,LSL #2
00007e  f1050038          ADD      r0,r5,#0x38
000082  eb0000c2          ADD      r0,r0,r2,LSL #3
000086  7141              STRB     r1,[r0,#5]
;;;1393         hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
000088  2102              MOVS     r1,#2
00008a  eb040284          ADD      r2,r4,r4,LSL #2
00008e  f1050038          ADD      r0,r5,#0x38
000092  eb0000c2          ADD      r0,r0,r2,LSL #3
000096  f8801024          STRB     r1,[r0,#0x24]
;;;1394         __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00009a  f50660a0          ADD      r0,r6,#0x500
00009e  eb001044          ADD      r0,r0,r4,LSL #5
0000a2  68c0              LDR      r0,[r0,#0xc]
0000a4  f0400102          ORR      r1,r0,#2
0000a8  f50660a0          ADD      r0,r6,#0x500
0000ac  eb001044          ADD      r0,r0,r4,LSL #5
0000b0  60c1              STR      r1,[r0,#0xc]
;;;1395         (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
0000b2  b2e1              UXTB     r1,r4
0000b4  6828              LDR      r0,[r5,#0]
0000b6  f7fffffe          BL       USB_HC_Halt
0000ba  e244              B        |L26.1350|
                  |L26.188|
;;;1396       }
;;;1397     }
;;;1398     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NYET) == USB_OTG_HCINT_NYET)
0000bc  f50660a0          ADD      r0,r6,#0x500
0000c0  eb001044          ADD      r0,r0,r4,LSL #5
0000c4  6880              LDR      r0,[r0,#8]
0000c6  f0000040          AND      r0,r0,#0x40
0000ca  2840              CMP      r0,#0x40
0000cc  d12f              BNE      |L26.302|
;;;1399     {
;;;1400       hhcd->hc[ch_num].state = HC_NYET;
0000ce  2104              MOVS     r1,#4
0000d0  eb040284          ADD      r2,r4,r4,LSL #2
0000d4  f1050038          ADD      r0,r5,#0x38
0000d8  eb0000c2          ADD      r0,r0,r2,LSL #3
0000dc  f8801025          STRB     r1,[r0,#0x25]
;;;1401       hhcd->hc[ch_num].do_ping = 1U;
0000e0  2101              MOVS     r1,#1
0000e2  eb040284          ADD      r2,r4,r4,LSL #2
0000e6  f1050038          ADD      r0,r5,#0x38
0000ea  eb0000c2          ADD      r0,r0,r2,LSL #3
0000ee  7141              STRB     r1,[r0,#5]
;;;1402       hhcd->hc[ch_num].ErrCnt = 0U;
0000f0  2100              MOVS     r1,#0
0000f2  eb040284          ADD      r2,r4,r4,LSL #2
0000f6  f1050038          ADD      r0,r5,#0x38
0000fa  eb0000c2          ADD      r0,r0,r2,LSL #3
0000fe  6201              STR      r1,[r0,#0x20]
;;;1403       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
000100  f50660a0          ADD      r0,r6,#0x500
000104  eb001044          ADD      r0,r0,r4,LSL #5
000108  68c0              LDR      r0,[r0,#0xc]
00010a  f0400102          ORR      r1,r0,#2
00010e  f50660a0          ADD      r0,r6,#0x500
000112  eb001044          ADD      r0,r0,r4,LSL #5
000116  60c1              STR      r1,[r0,#0xc]
;;;1404       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000118  b2e1              UXTB     r1,r4
00011a  6828              LDR      r0,[r5,#0]
00011c  f7fffffe          BL       USB_HC_Halt
;;;1405       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
000120  2140              MOVS     r1,#0x40
000122  f50660a0          ADD      r0,r6,#0x500
000126  eb001044          ADD      r0,r0,r4,LSL #5
00012a  6081              STR      r1,[r0,#8]
00012c  e20b              B        |L26.1350|
                  |L26.302|
;;;1406     }
;;;1407     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
00012e  f50660a0          ADD      r0,r6,#0x500
000132  eb001044          ADD      r0,r0,r4,LSL #5
000136  6880              LDR      r0,[r0,#8]
000138  f4007000          AND      r0,r0,#0x200
00013c  f5b07f00          CMP      r0,#0x200
000140  d117              BNE      |L26.370|
;;;1408     {
;;;1409       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
000142  f50660a0          ADD      r0,r6,#0x500
000146  eb001044          ADD      r0,r0,r4,LSL #5
00014a  68c0              LDR      r0,[r0,#0xc]
00014c  f0400102          ORR      r1,r0,#2
000150  f50660a0          ADD      r0,r6,#0x500
000154  eb001044          ADD      r0,r0,r4,LSL #5
000158  60c1              STR      r1,[r0,#0xc]
;;;1410       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
00015a  b2e1              UXTB     r1,r4
00015c  6828              LDR      r0,[r5,#0]
00015e  f7fffffe          BL       USB_HC_Halt
;;;1411       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
000162  f44f7100          MOV      r1,#0x200
000166  f50660a0          ADD      r0,r6,#0x500
00016a  eb001044          ADD      r0,r0,r4,LSL #5
00016e  6081              STR      r1,[r0,#8]
000170  e1e9              B        |L26.1350|
                  |L26.370|
;;;1412     }
;;;1413     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
000172  f50660a0          ADD      r0,r6,#0x500
000176  eb001044          ADD      r0,r0,r4,LSL #5
00017a  6880              LDR      r0,[r0,#8]
00017c  f0000001          AND      r0,r0,#1
000180  b330              CBZ      r0,|L26.464|
;;;1414     {
;;;1415       hhcd->hc[ch_num].ErrCnt = 0U;
000182  2100              MOVS     r1,#0
000184  eb040284          ADD      r2,r4,r4,LSL #2
000188  f1050038          ADD      r0,r5,#0x38
00018c  eb0000c2          ADD      r0,r0,r2,LSL #3
000190  6201              STR      r1,[r0,#0x20]
;;;1416       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
000192  f50660a0          ADD      r0,r6,#0x500
000196  eb001044          ADD      r0,r0,r4,LSL #5
00019a  68c0              LDR      r0,[r0,#0xc]
00019c  f0400102          ORR      r1,r0,#2
0001a0  f50660a0          ADD      r0,r6,#0x500
0001a4  eb001044          ADD      r0,r0,r4,LSL #5
0001a8  60c1              STR      r1,[r0,#0xc]
;;;1417       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
0001aa  b2e1              UXTB     r1,r4
0001ac  6828              LDR      r0,[r5,#0]
0001ae  f7fffffe          BL       USB_HC_Halt
;;;1418       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
0001b2  2101              MOVS     r1,#1
0001b4  f50660a0          ADD      r0,r6,#0x500
0001b8  eb001044          ADD      r0,r0,r4,LSL #5
0001bc  6081              STR      r1,[r0,#8]
;;;1419       hhcd->hc[ch_num].state = HC_XFRC;
0001be  eb040284          ADD      r2,r4,r4,LSL #2
0001c2  f1050038          ADD      r0,r5,#0x38
0001c6  eb0000c2          ADD      r0,r0,r2,LSL #3
0001ca  f8801025          STRB     r1,[r0,#0x25]
0001ce  e1ba              B        |L26.1350|
                  |L26.464|
;;;1420     }
;;;1421     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
0001d0  f50660a0          ADD      r0,r6,#0x500
0001d4  eb001044          ADD      r0,r0,r4,LSL #5
0001d8  6880              LDR      r0,[r0,#8]
0001da  f0000008          AND      r0,r0,#8
0001de  2808              CMP      r0,#8
0001e0  d11f              BNE      |L26.546|
;;;1422     {
;;;1423       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
0001e2  2108              MOVS     r1,#8
0001e4  f50660a0          ADD      r0,r6,#0x500
0001e8  eb001044          ADD      r0,r0,r4,LSL #5
0001ec  6081              STR      r1,[r0,#8]
;;;1424       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
0001ee  f50660a0          ADD      r0,r6,#0x500
0001f2  eb001044          ADD      r0,r0,r4,LSL #5
0001f6  68c0              LDR      r0,[r0,#0xc]
0001f8  f0400102          ORR      r1,r0,#2
0001fc  f50660a0          ADD      r0,r6,#0x500
000200  eb001044          ADD      r0,r0,r4,LSL #5
000204  60c1              STR      r1,[r0,#0xc]
;;;1425       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000206  b2e1              UXTB     r1,r4
000208  6828              LDR      r0,[r5,#0]
00020a  f7fffffe          BL       USB_HC_Halt
;;;1426       hhcd->hc[ch_num].state = HC_STALL;
00020e  2105              MOVS     r1,#5
000210  eb040284          ADD      r2,r4,r4,LSL #2
000214  f1050038          ADD      r0,r5,#0x38
000218  eb0000c2          ADD      r0,r0,r2,LSL #3
00021c  f8801025          STRB     r1,[r0,#0x25]
000220  e191              B        |L26.1350|
                  |L26.546|
;;;1427     }
;;;1428     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
000222  f50660a0          ADD      r0,r6,#0x500
000226  eb001044          ADD      r0,r0,r4,LSL #5
00022a  6880              LDR      r0,[r0,#8]
00022c  f0000010          AND      r0,r0,#0x10
000230  2810              CMP      r0,#0x10
000232  d13f              BNE      |L26.692|
;;;1429     {
;;;1430       hhcd->hc[ch_num].ErrCnt = 0U;
000234  2100              MOVS     r1,#0
000236  eb040284          ADD      r2,r4,r4,LSL #2
00023a  f1050038          ADD      r0,r5,#0x38
00023e  eb0000c2          ADD      r0,r0,r2,LSL #3
000242  6201              STR      r1,[r0,#0x20]
;;;1431       hhcd->hc[ch_num].state = HC_NAK;
000244  2103              MOVS     r1,#3
000246  eb040284          ADD      r2,r4,r4,LSL #2
00024a  f1050038          ADD      r0,r5,#0x38
00024e  eb0000c2          ADD      r0,r0,r2,LSL #3
000252  f8801025          STRB     r1,[r0,#0x25]
;;;1432   
;;;1433       if (hhcd->hc[ch_num].do_ping == 0U)
000256  eb040184          ADD      r1,r4,r4,LSL #2
00025a  f1050038          ADD      r0,r5,#0x38
00025e  eb0000c1          ADD      r0,r0,r1,LSL #3
000262  7940              LDRB     r0,[r0,#5]
000264  b978              CBNZ     r0,|L26.646|
;;;1434       {
;;;1435         if (hhcd->hc[ch_num].speed == HCD_SPEED_HIGH)
000266  eb040184          ADD      r1,r4,r4,LSL #2
00026a  f1050038          ADD      r0,r5,#0x38
00026e  eb0000c1          ADD      r0,r0,r1,LSL #3
000272  7900              LDRB     r0,[r0,#4]
000274  b938              CBNZ     r0,|L26.646|
;;;1436         {
;;;1437           hhcd->hc[ch_num].do_ping = 1U;
000276  2101              MOVS     r1,#1
000278  eb040284          ADD      r2,r4,r4,LSL #2
00027c  f1050038          ADD      r0,r5,#0x38
000280  eb0000c2          ADD      r0,r0,r2,LSL #3
000284  7141              STRB     r1,[r0,#5]
                  |L26.646|
;;;1438         }
;;;1439       }
;;;1440   
;;;1441       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
000286  f50660a0          ADD      r0,r6,#0x500
00028a  eb001044          ADD      r0,r0,r4,LSL #5
00028e  68c0              LDR      r0,[r0,#0xc]
000290  f0400102          ORR      r1,r0,#2
000294  f50660a0          ADD      r0,r6,#0x500
000298  eb001044          ADD      r0,r0,r4,LSL #5
00029c  60c1              STR      r1,[r0,#0xc]
;;;1442       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
00029e  b2e1              UXTB     r1,r4
0002a0  6828              LDR      r0,[r5,#0]
0002a2  f7fffffe          BL       USB_HC_Halt
;;;1443       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
0002a6  2110              MOVS     r1,#0x10
0002a8  f50660a0          ADD      r0,r6,#0x500
0002ac  eb001044          ADD      r0,r0,r4,LSL #5
0002b0  6081              STR      r1,[r0,#8]
                  |L26.690|
0002b2  e148              B        |L26.1350|
                  |L26.692|
;;;1444     }
;;;1445     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
0002b4  f50660a0          ADD      r0,r6,#0x500
0002b8  eb001044          ADD      r0,r0,r4,LSL #5
0002bc  6880              LDR      r0,[r0,#8]
0002be  f0000080          AND      r0,r0,#0x80
0002c2  2880              CMP      r0,#0x80
0002c4  d11f              BNE      |L26.774|
;;;1446     {
;;;1447       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
0002c6  f50660a0          ADD      r0,r6,#0x500
0002ca  eb001044          ADD      r0,r0,r4,LSL #5
0002ce  68c0              LDR      r0,[r0,#0xc]
0002d0  f0400102          ORR      r1,r0,#2
0002d4  f50660a0          ADD      r0,r6,#0x500
0002d8  eb001044          ADD      r0,r0,r4,LSL #5
0002dc  60c1              STR      r1,[r0,#0xc]
;;;1448       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
0002de  b2e1              UXTB     r1,r4
0002e0  6828              LDR      r0,[r5,#0]
0002e2  f7fffffe          BL       USB_HC_Halt
;;;1449       hhcd->hc[ch_num].state = HC_XACTERR;
0002e6  2106              MOVS     r1,#6
0002e8  eb040284          ADD      r2,r4,r4,LSL #2
0002ec  f1050038          ADD      r0,r5,#0x38
0002f0  eb0000c2          ADD      r0,r0,r2,LSL #3
0002f4  f8801025          STRB     r1,[r0,#0x25]
;;;1450       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
0002f8  2180              MOVS     r1,#0x80
0002fa  f50660a0          ADD      r0,r6,#0x500
0002fe  eb001044          ADD      r0,r0,r4,LSL #5
000302  6081              STR      r1,[r0,#8]
000304  e11f              B        |L26.1350|
                  |L26.774|
;;;1451     }
;;;1452     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
000306  f50660a0          ADD      r0,r6,#0x500
00030a  eb001044          ADD      r0,r0,r4,LSL #5
00030e  6880              LDR      r0,[r0,#8]
000310  f4006080          AND      r0,r0,#0x400
000314  f5b06f80          CMP      r0,#0x400
000318  d125              BNE      |L26.870|
;;;1453     {
;;;1454       __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
00031a  f50660a0          ADD      r0,r6,#0x500
00031e  eb001044          ADD      r0,r0,r4,LSL #5
000322  68c0              LDR      r0,[r0,#0xc]
000324  f0400102          ORR      r1,r0,#2
000328  f50660a0          ADD      r0,r6,#0x500
00032c  eb001044          ADD      r0,r0,r4,LSL #5
000330  60c1              STR      r1,[r0,#0xc]
;;;1455       (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
000332  b2e1              UXTB     r1,r4
000334  6828              LDR      r0,[r5,#0]
000336  f7fffffe          BL       USB_HC_Halt
;;;1456       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
00033a  2110              MOVS     r1,#0x10
00033c  f50660a0          ADD      r0,r6,#0x500
000340  eb001044          ADD      r0,r0,r4,LSL #5
000344  6081              STR      r1,[r0,#8]
;;;1457       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
000346  0189              LSLS     r1,r1,#6
000348  f50660a0          ADD      r0,r6,#0x500
00034c  eb001044          ADD      r0,r0,r4,LSL #5
000350  6081              STR      r1,[r0,#8]
;;;1458       hhcd->hc[ch_num].state = HC_DATATGLERR;
000352  2108              MOVS     r1,#8
000354  eb040284          ADD      r2,r4,r4,LSL #2
000358  f1050038          ADD      r0,r5,#0x38
00035c  eb0000c2          ADD      r0,r0,r2,LSL #3
000360  f8801025          STRB     r1,[r0,#0x25]
000364  e0ef              B        |L26.1350|
                  |L26.870|
;;;1459     }
;;;1460     else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
000366  f50660a0          ADD      r0,r6,#0x500
00036a  eb001044          ADD      r0,r0,r4,LSL #5
00036e  6880              LDR      r0,[r0,#8]
000370  f0000002          AND      r0,r0,#2
000374  2802              CMP      r0,#2
000376  d19c              BNE      |L26.690|
;;;1461     {
;;;1462       __HAL_HCD_MASK_HALT_HC_INT(ch_num);
000378  f50660a0          ADD      r0,r6,#0x500
00037c  eb001044          ADD      r0,r0,r4,LSL #5
000380  68c0              LDR      r0,[r0,#0xc]
000382  f0200102          BIC      r1,r0,#2
000386  f50660a0          ADD      r0,r6,#0x500
00038a  eb001044          ADD      r0,r0,r4,LSL #5
00038e  60c1              STR      r1,[r0,#0xc]
;;;1463   
;;;1464       if (hhcd->hc[ch_num].state == HC_XFRC)
000390  eb040184          ADD      r1,r4,r4,LSL #2
000394  f1050038          ADD      r0,r5,#0x38
000398  eb0000c1          ADD      r0,r0,r1,LSL #3
00039c  f8900025          LDRB     r0,[r0,#0x25]
0003a0  2801              CMP      r0,#1
0003a2  d12b              BNE      |L26.1020|
;;;1465       {
;;;1466         hhcd->hc[ch_num].urb_state  = URB_DONE;
0003a4  2101              MOVS     r1,#1
0003a6  eb040284          ADD      r2,r4,r4,LSL #2
0003aa  f1050038          ADD      r0,r5,#0x38
0003ae  eb0000c2          ADD      r0,r0,r2,LSL #3
0003b2  f8801024          STRB     r1,[r0,#0x24]
;;;1467         if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
0003b6  eb040184          ADD      r1,r4,r4,LSL #2
0003ba  f1050038          ADD      r0,r5,#0x38
0003be  eb0000c1          ADD      r0,r0,r1,LSL #3
0003c2  79c0              LDRB     r0,[r0,#7]
0003c4  2802              CMP      r0,#2
0003c6  d008              BEQ      |L26.986|
;;;1468             (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR))
0003c8  eb040184          ADD      r1,r4,r4,LSL #2
0003cc  f1050038          ADD      r0,r5,#0x38
0003d0  eb0000c1          ADD      r0,r0,r1,LSL #3
0003d4  79c0              LDRB     r0,[r0,#7]
0003d6  2803              CMP      r0,#3
0003d8  d10f              BNE      |L26.1018|
                  |L26.986|
;;;1469         {
;;;1470           hhcd->hc[ch_num].toggle_out ^= 1U;
0003da  eb040184          ADD      r1,r4,r4,LSL #2
0003de  f1050038          ADD      r0,r5,#0x38
0003e2  eb0000c1          ADD      r0,r0,r1,LSL #3
0003e6  7e40              LDRB     r0,[r0,#0x19]
0003e8  f0800101          EOR      r1,r0,#1
0003ec  eb040284          ADD      r2,r4,r4,LSL #2
0003f0  f1050038          ADD      r0,r5,#0x38
0003f4  eb0000c2          ADD      r0,r0,r2,LSL #3
0003f8  7641              STRB     r1,[r0,#0x19]
                  |L26.1018|
0003fa  e092              B        |L26.1314|
                  |L26.1020|
;;;1471         }
;;;1472       }
;;;1473       else if (hhcd->hc[ch_num].state == HC_NAK)
0003fc  eb040184          ADD      r1,r4,r4,LSL #2
000400  f1050038          ADD      r0,r5,#0x38
000404  eb0000c1          ADD      r0,r0,r1,LSL #3
000408  f8900025          LDRB     r0,[r0,#0x25]
00040c  2803              CMP      r0,#3
00040e  d109              BNE      |L26.1060|
;;;1474       {
;;;1475         hhcd->hc[ch_num].urb_state = URB_NOTREADY;
000410  2102              MOVS     r1,#2
000412  eb040284          ADD      r2,r4,r4,LSL #2
000416  f1050038          ADD      r0,r5,#0x38
00041a  eb0000c2          ADD      r0,r0,r2,LSL #3
00041e  f8801024          STRB     r1,[r0,#0x24]
000422  e07e              B        |L26.1314|
                  |L26.1060|
;;;1476       }
;;;1477       else if (hhcd->hc[ch_num].state == HC_NYET)
000424  eb040184          ADD      r1,r4,r4,LSL #2
000428  f1050038          ADD      r0,r5,#0x38
00042c  eb0000c1          ADD      r0,r0,r1,LSL #3
000430  f8900025          LDRB     r0,[r0,#0x25]
000434  2804              CMP      r0,#4
000436  d109              BNE      |L26.1100|
;;;1478       {
;;;1479         hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
000438  2102              MOVS     r1,#2
00043a  eb040284          ADD      r2,r4,r4,LSL #2
00043e  f1050038          ADD      r0,r5,#0x38
000442  eb0000c2          ADD      r0,r0,r2,LSL #3
000446  f8801024          STRB     r1,[r0,#0x24]
00044a  e06a              B        |L26.1314|
                  |L26.1100|
;;;1480       }
;;;1481       else if (hhcd->hc[ch_num].state == HC_STALL)
00044c  eb040184          ADD      r1,r4,r4,LSL #2
000450  f1050038          ADD      r0,r5,#0x38
000454  eb0000c1          ADD      r0,r0,r1,LSL #3
000458  f8900025          LDRB     r0,[r0,#0x25]
00045c  2805              CMP      r0,#5
00045e  d109              BNE      |L26.1140|
;;;1482       {
;;;1483         hhcd->hc[ch_num].urb_state  = URB_STALL;
000460  2105              MOVS     r1,#5
000462  eb040284          ADD      r2,r4,r4,LSL #2
000466  f1050038          ADD      r0,r5,#0x38
00046a  eb0000c2          ADD      r0,r0,r2,LSL #3
00046e  f8801024          STRB     r1,[r0,#0x24]
000472  e056              B        |L26.1314|
                  |L26.1140|
;;;1484       }
;;;1485       else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
000474  eb040184          ADD      r1,r4,r4,LSL #2
000478  f1050038          ADD      r0,r5,#0x38
00047c  eb0000c1          ADD      r0,r0,r1,LSL #3
000480  f8900025          LDRB     r0,[r0,#0x25]
000484  2806              CMP      r0,#6
000486  d009              BEQ      |L26.1180|
;;;1486                (hhcd->hc[ch_num].state == HC_DATATGLERR))
000488  eb040184          ADD      r1,r4,r4,LSL #2
00048c  f1050038          ADD      r0,r5,#0x38
000490  eb0000c1          ADD      r0,r0,r1,LSL #3
000494  f8900025          LDRB     r0,[r0,#0x25]
000498  2808              CMP      r0,#8
00049a  d142              BNE      |L26.1314|
                  |L26.1180|
;;;1487       {
;;;1488         hhcd->hc[ch_num].ErrCnt++;
00049c  eb040184          ADD      r1,r4,r4,LSL #2
0004a0  f1050038          ADD      r0,r5,#0x38
0004a4  eb0000c1          ADD      r0,r0,r1,LSL #3
0004a8  6a00              LDR      r0,[r0,#0x20]
0004aa  1c40              ADDS     r0,r0,#1
0004ac  eb040284          ADD      r2,r4,r4,LSL #2
0004b0  f1050138          ADD      r1,r5,#0x38
0004b4  eb0101c2          ADD      r1,r1,r2,LSL #3
0004b8  6208              STR      r0,[r1,#0x20]
;;;1489         if (hhcd->hc[ch_num].ErrCnt > 3U)
0004ba  eb040184          ADD      r1,r4,r4,LSL #2
0004be  f1050038          ADD      r0,r5,#0x38
0004c2  eb0000c1          ADD      r0,r0,r1,LSL #3
0004c6  6a00              LDR      r0,[r0,#0x20]
0004c8  2803              CMP      r0,#3
0004ca  d911              BLS      |L26.1264|
;;;1490         {
;;;1491           hhcd->hc[ch_num].ErrCnt = 0U;
0004cc  2100              MOVS     r1,#0
0004ce  eb040284          ADD      r2,r4,r4,LSL #2
0004d2  f1050038          ADD      r0,r5,#0x38
0004d6  eb0000c2          ADD      r0,r0,r2,LSL #3
0004da  6201              STR      r1,[r0,#0x20]
;;;1492           hhcd->hc[ch_num].urb_state = URB_ERROR;
0004dc  2104              MOVS     r1,#4
0004de  eb040284          ADD      r2,r4,r4,LSL #2
0004e2  f1050038          ADD      r0,r5,#0x38
0004e6  eb0000c2          ADD      r0,r0,r2,LSL #3
0004ea  f8801024          STRB     r1,[r0,#0x24]
0004ee  e008              B        |L26.1282|
                  |L26.1264|
;;;1493         }
;;;1494         else
;;;1495         {
;;;1496           hhcd->hc[ch_num].urb_state = URB_NOTREADY;
0004f0  2102              MOVS     r1,#2
0004f2  eb040284          ADD      r2,r4,r4,LSL #2
0004f6  f1050038          ADD      r0,r5,#0x38
0004fa  eb0000c2          ADD      r0,r0,r2,LSL #3
0004fe  f8801024          STRB     r1,[r0,#0x24]
                  |L26.1282|
;;;1497         }
;;;1498   
;;;1499         /* re-activate the channel  */
;;;1500         tmpreg = USBx_HC(ch_num)->HCCHAR;
000502  f50660a0          ADD      r0,r6,#0x500
000506  eb001044          ADD      r0,r0,r4,LSL #5
00050a  f8d08000          LDR      r8,[r0,#0]
;;;1501         tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
00050e  f0284880          BIC      r8,r8,#0x40000000
;;;1502         tmpreg |= USB_OTG_HCCHAR_CHENA;
000512  f0484800          ORR      r8,r8,#0x80000000
;;;1503         USBx_HC(ch_num)->HCCHAR = tmpreg;
000516  f50660a0          ADD      r0,r6,#0x500
00051a  eb001044          ADD      r0,r0,r4,LSL #5
00051e  f8c08000          STR      r8,[r0,#0]
                  |L26.1314|
;;;1504       }
;;;1505       else
;;;1506       {
;;;1507         /* ... */
;;;1508       }
;;;1509   
;;;1510       __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
000522  2102              MOVS     r1,#2
000524  f50660a0          ADD      r0,r6,#0x500
000528  eb001044          ADD      r0,r0,r4,LSL #5
00052c  6081              STR      r1,[r0,#8]
;;;1511       HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
00052e  eb040384          ADD      r3,r4,r4,LSL #2
000532  f1050038          ADD      r0,r5,#0x38
000536  eb0000c3          ADD      r0,r0,r3,LSL #3
00053a  f8902024          LDRB     r2,[r0,#0x24]
00053e  b2e1              UXTB     r1,r4
000540  4628              MOV      r0,r5
000542  f7fffffe          BL       HAL_HCD_HC_NotifyURBChange_Callback
                  |L26.1350|
;;;1512     }
;;;1513     else
;;;1514     {
;;;1515       /* ... */
;;;1516     }
;;;1517   }
000546  e8bd87f0          POP      {r4-r10,pc}
;;;1518   
                          ENDP


                          AREA ||i.HCD_Port_IRQHandler||, CODE, READONLY, ALIGN=1

                  HCD_Port_IRQHandler PROC
;;;1577     */
;;;1578   static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
000000  b57c              PUSH     {r2-r6,lr}
;;;1579   {
000002  4604              MOV      r4,r0
;;;1580     USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
000004  6826              LDR      r6,[r4,#0]
;;;1581     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4635              MOV      r5,r6
;;;1582     __IO uint32_t hprt0, hprt0_dup;
;;;1583   
;;;1584     /* Handle Host Port Interrupts */
;;;1585     hprt0 = USBx_HPRT0;
000008  f8d50440          LDR      r0,[r5,#0x440]
00000c  9001              STR      r0,[sp,#4]
;;;1586     hprt0_dup = USBx_HPRT0;
00000e  f8d50440          LDR      r0,[r5,#0x440]
000012  9000              STR      r0,[sp,#0]
;;;1587   
;;;1588     hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
000014  9800              LDR      r0,[sp,#0]
000016  f020002e          BIC      r0,r0,#0x2e
00001a  9000              STR      r0,[sp,#0]
;;;1589                    USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);
;;;1590   
;;;1591     /* Check whether Port Connect detected */
;;;1592     if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
00001c  9801              LDR      r0,[sp,#4]
00001e  f0000002          AND      r0,r0,#2
000022  2802              CMP      r0,#2
000024  d10a              BNE      |L27.60|
;;;1593     {
;;;1594       if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
000026  9801              LDR      r0,[sp,#4]
000028  f0000001          AND      r0,r0,#1
00002c  b110              CBZ      r0,|L27.52|
;;;1595       {
;;;1596   #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;1597         hhcd->ConnectCallback(hhcd);
;;;1598   #else
;;;1599         HAL_HCD_Connect_Callback(hhcd);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_HCD_Connect_Callback
                  |L27.52|
;;;1600   #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;1601       }
;;;1602       hprt0_dup  |= USB_OTG_HPRT_PCDET;
000034  9800              LDR      r0,[sp,#0]
000036  f0400002          ORR      r0,r0,#2
00003a  9000              STR      r0,[sp,#0]
                  |L27.60|
;;;1603     }
;;;1604   
;;;1605     /* Check whether Port Enable Changed */
;;;1606     if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
00003c  9801              LDR      r0,[sp,#4]
00003e  f0000008          AND      r0,r0,#8
000042  2808              CMP      r0,#8
000044  d12a              BNE      |L27.156|
;;;1607     {
;;;1608       hprt0_dup |= USB_OTG_HPRT_PENCHNG;
000046  9800              LDR      r0,[sp,#0]
000048  f0400008          ORR      r0,r0,#8
00004c  9000              STR      r0,[sp,#0]
;;;1609   
;;;1610       if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
00004e  9801              LDR      r0,[sp,#4]
000050  f0000004          AND      r0,r0,#4
000054  2804              CMP      r0,#4
000056  d11e              BNE      |L27.150|
;;;1611       {
;;;1612         if (hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
000058  69a0              LDR      r0,[r4,#0x18]
00005a  2802              CMP      r0,#2
00005c  d10f              BNE      |L27.126|
;;;1613         {
;;;1614           if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
00005e  9801              LDR      r0,[sp,#4]
000060  f40020c0          AND      r0,r0,#0x60000
000064  f5b02f80          CMP      r0,#0x40000
000068  d104              BNE      |L27.116|
;;;1615           {
;;;1616             (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_6_MHZ);
00006a  2102              MOVS     r1,#2
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       USB_InitFSLSPClkSel
000072  e00c              B        |L27.142|
                  |L27.116|
;;;1617           }
;;;1618           else
;;;1619           {
;;;1620             (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
000074  2101              MOVS     r1,#1
000076  6820              LDR      r0,[r4,#0]
000078  f7fffffe          BL       USB_InitFSLSPClkSel
00007c  e007              B        |L27.142|
                  |L27.126|
;;;1621           }
;;;1622         }
;;;1623         else
;;;1624         {
;;;1625           if (hhcd->Init.speed == HCD_SPEED_FULL)
00007e  68e0              LDR      r0,[r4,#0xc]
000080  2801              CMP      r0,#1
000082  d104              BNE      |L27.142|
;;;1626           {
;;;1627             USBx_HOST->HFIR = 60000U;
000084  f64e2160          MOV      r1,#0xea60
000088  f2404004          MOV      r0,#0x404
00008c  5141              STR      r1,[r0,r5]
                  |L27.142|
;;;1628           }
;;;1629         }
;;;1630   #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;1631         hhcd->PortEnabledCallback(hhcd);
;;;1632   #else
;;;1633         HAL_HCD_PortEnabled_Callback(hhcd);
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       HAL_HCD_PortEnabled_Callback
000094  e002              B        |L27.156|
                  |L27.150|
;;;1634   #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;1635   
;;;1636       }
;;;1637       else
;;;1638       {
;;;1639   #if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
;;;1640         hhcd->PortDisabledCallback(hhcd);
;;;1641   #else
;;;1642         HAL_HCD_PortDisabled_Callback(hhcd);
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       HAL_HCD_PortDisabled_Callback
                  |L27.156|
;;;1643   #endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
;;;1644       }
;;;1645     }
;;;1646   
;;;1647     /* Check for an overcurrent */
;;;1648     if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
00009c  9801              LDR      r0,[sp,#4]
00009e  f0000020          AND      r0,r0,#0x20
0000a2  2820              CMP      r0,#0x20
0000a4  d103              BNE      |L27.174|
;;;1649     {
;;;1650       hprt0_dup |= USB_OTG_HPRT_POCCHNG;
0000a6  9800              LDR      r0,[sp,#0]
0000a8  f0400020          ORR      r0,r0,#0x20
0000ac  9000              STR      r0,[sp,#0]
                  |L27.174|
;;;1651     }
;;;1652   
;;;1653     /* Clear Port Interrupts */
;;;1654     USBx_HPRT0 = hprt0_dup;
0000ae  9800              LDR      r0,[sp,#0]
0000b0  f8c50440          STR      r0,[r5,#0x440]
;;;1655   }
0000b4  bd7c              POP      {r2-r6,pc}
;;;1656   
                          ENDP


                          AREA ||i.HCD_RXQLVL_IRQHandler||, CODE, READONLY, ALIGN=2

                  HCD_RXQLVL_IRQHandler PROC
;;;1523     */
;;;1524   static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1525   {
000004  4605              MOV      r5,r0
;;;1526     USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
000006  f8d5a000          LDR      r10,[r5,#0]
;;;1527     uint32_t USBx_BASE = (uint32_t)USBx;
00000a  4657              MOV      r7,r10
;;;1528     uint32_t pktsts;
;;;1529     uint32_t pktcnt;
;;;1530     uint32_t temp;
;;;1531     uint32_t tmpreg;
;;;1532     uint32_t ch_num;
;;;1533   
;;;1534     temp = hhcd->Instance->GRXSTSP;
00000c  6828              LDR      r0,[r5,#0]
00000e  f8d08020          LDR      r8,[r0,#0x20]
;;;1535     ch_num = temp & USB_OTG_GRXSTSP_EPNUM;
000012  f008040f          AND      r4,r8,#0xf
;;;1536     pktsts = (temp & USB_OTG_GRXSTSP_PKTSTS) >> 17;
000016  f3c84b43          UBFX     r11,r8,#17,#4
;;;1537     pktcnt = (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
00001a  f3c8160a          UBFX     r6,r8,#4,#11
;;;1538   
;;;1539     switch (pktsts)
00001e  f1bb0f02          CMP      r11,#2
000022  d009              BEQ      |L28.56|
000024  f1bb0f03          CMP      r11,#3
000028  d066              BEQ      |L28.248|
00002a  f1bb0f05          CMP      r11,#5
00002e  d061              BEQ      |L28.244|
000030  f1bb0f07          CMP      r11,#7
000034  d15f              BNE      |L28.246|
000036  e060              B        |L28.250|
                  |L28.56|
;;;1540     {
;;;1541       case GRXSTS_PKTSTS_IN:
;;;1542         /* Read the data into the host buffer. */
;;;1543         if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
000038  2e00              CMP      r6,#0
00003a  d05a              BEQ      |L28.242|
00003c  eb040184          ADD      r1,r4,r4,LSL #2
000040  f1050038          ADD      r0,r5,#0x38
000044  eb0000c1          ADD      r0,r0,r1,LSL #3
000048  68c0              LDR      r0,[r0,#0xc]
00004a  b3e8              CBZ      r0,|L28.200|
;;;1544         {
;;;1545           (void)USB_ReadPacket(hhcd->Instance, hhcd->hc[ch_num].xfer_buff, (uint16_t)pktcnt);
00004c  b2b2              UXTH     r2,r6
00004e  eb040c84          ADD      r12,r4,r4,LSL #2
000052  f1050338          ADD      r3,r5,#0x38
000056  eb0303cc          ADD      r3,r3,r12,LSL #3
00005a  68d9              LDR      r1,[r3,#0xc]
00005c  6828              LDR      r0,[r5,#0]
00005e  f7fffffe          BL       USB_ReadPacket
;;;1546   
;;;1547           /*manage multiple Xfer */
;;;1548           hhcd->hc[ch_num].xfer_buff += pktcnt;
000062  eb040184          ADD      r1,r4,r4,LSL #2
000066  f1050038          ADD      r0,r5,#0x38
00006a  eb0000c1          ADD      r0,r0,r1,LSL #3
00006e  68c0              LDR      r0,[r0,#0xc]
000070  1981              ADDS     r1,r0,r6
000072  eb040284          ADD      r2,r4,r4,LSL #2
000076  f1050038          ADD      r0,r5,#0x38
00007a  eb0000c2          ADD      r0,r0,r2,LSL #3
00007e  60c1              STR      r1,[r0,#0xc]
;;;1549           hhcd->hc[ch_num].xfer_count  += pktcnt;
000080  eb040184          ADD      r1,r4,r4,LSL #2
000084  f1050038          ADD      r0,r5,#0x38
000088  eb0000c1          ADD      r0,r0,r1,LSL #3
00008c  6940              LDR      r0,[r0,#0x14]
00008e  1981              ADDS     r1,r0,r6
000090  eb040284          ADD      r2,r4,r4,LSL #2
000094  f1050038          ADD      r0,r5,#0x38
000098  eb0000c2          ADD      r0,r0,r2,LSL #3
00009c  6141              STR      r1,[r0,#0x14]
;;;1550   
;;;1551           if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
00009e  f50760a0          ADD      r0,r7,#0x500
0000a2  eb001044          ADD      r0,r0,r4,LSL #5
0000a6  6900              LDR      r0,[r0,#0x10]
0000a8  4916              LDR      r1,|L28.260|
0000aa  4008              ANDS     r0,r0,r1
0000ac  b160              CBZ      r0,|L28.200|
;;;1552           {
;;;1553             /* re-activate the channel when more packets are expected */
;;;1554             tmpreg = USBx_HC(ch_num)->HCCHAR;
0000ae  f50760a0          ADD      r0,r7,#0x500
0000b2  eb001044          ADD      r0,r0,r4,LSL #5
0000b6  f8d09000          LDR      r9,[r0,#0]
;;;1555             tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
0000ba  f0294980          BIC      r9,r9,#0x40000000
;;;1556             tmpreg |= USB_OTG_HCCHAR_CHENA;
0000be  f0494900          ORR      r9,r9,#0x80000000
;;;1557             USBx_HC(ch_num)->HCCHAR = tmpreg;
0000c2  f50760a0          ADD      r0,r7,#0x500
0000c6  e000              B        |L28.202|
                  |L28.200|
0000c8  e013              B        |L28.242|
                  |L28.202|
0000ca  eb001044          ADD      r0,r0,r4,LSL #5
0000ce  f8c09000          STR      r9,[r0,#0]
;;;1558             hhcd->hc[ch_num].toggle_in ^= 1U;
0000d2  eb040184          ADD      r1,r4,r4,LSL #2
0000d6  f1050038          ADD      r0,r5,#0x38
0000da  eb0000c1          ADD      r0,r0,r1,LSL #3
0000de  7e00              LDRB     r0,[r0,#0x18]
0000e0  f0800101          EOR      r1,r0,#1
0000e4  eb040284          ADD      r2,r4,r4,LSL #2
0000e8  f1050038          ADD      r0,r5,#0x38
0000ec  eb0000c2          ADD      r0,r0,r2,LSL #3
0000f0  7601              STRB     r1,[r0,#0x18]
                  |L28.242|
;;;1559           }
;;;1560         }
;;;1561         break;
0000f2  e003              B        |L28.252|
                  |L28.244|
;;;1562   
;;;1563       case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
;;;1564         break;
0000f4  e002              B        |L28.252|
                  |L28.246|
;;;1565   
;;;1566       case GRXSTS_PKTSTS_IN_XFER_COMP:
0000f6  bf00              NOP      
                  |L28.248|
;;;1567       case GRXSTS_PKTSTS_CH_HALTED:
0000f8  bf00              NOP      
                  |L28.250|
;;;1568       default:
;;;1569         break;
0000fa  bf00              NOP      
                  |L28.252|
0000fc  bf00              NOP                            ;1561
;;;1570     }
;;;1571   }
0000fe  e8bd9ff0          POP      {r4-r12,pc}
;;;1572   
                          ENDP

000102  0000              DCW      0x0000
                  |L28.260|
                          DCD      0x1ff80000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_hcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_hcd_c_95029a4d____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_hcd_c_95029a4d____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_hcd_c_95029a4d____REVSH|
#line 478
|__asm___19_stm32f4xx_hal_hcd_c_95029a4d____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_hcd_c_95029a4d____RRX|
#line 665
|__asm___19_stm32f4xx_hal_hcd_c_95029a4d____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
