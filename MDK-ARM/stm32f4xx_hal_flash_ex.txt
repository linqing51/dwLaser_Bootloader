; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_flash_ex.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_flash_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_flash_ex.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_flash_ex.c]
                          THUMB

                          AREA ||i.FLASH_Erase_Sector||, CODE, READONLY, ALIGN=2

                  FLASH_Erase_Sector PROC
;;;981      */
;;;982    void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
000000  b510              PUSH     {r4,lr}
;;;983    {
;;;984      uint32_t tmp_psize = 0U;
000002  2200              MOVS     r2,#0
;;;985    
;;;986      /* Check the parameters */
;;;987      assert_param(IS_FLASH_SECTOR(Sector));
;;;988      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;989      
;;;990      if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
000004  b901              CBNZ     r1,|L1.8|
;;;991      {
;;;992         tmp_psize = FLASH_PSIZE_BYTE;
000006  e009              B        |L1.28|
                  |L1.8|
;;;993      }
;;;994      else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
000008  2901              CMP      r1,#1
00000a  d101              BNE      |L1.16|
;;;995      {
;;;996        tmp_psize = FLASH_PSIZE_HALF_WORD;
00000c  020a              LSLS     r2,r1,#8
00000e  e005              B        |L1.28|
                  |L1.16|
;;;997      }
;;;998      else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
000010  2902              CMP      r1,#2
000012  d101              BNE      |L1.24|
;;;999      {
;;;1000       tmp_psize = FLASH_PSIZE_WORD;
000014  020a              LSLS     r2,r1,#8
000016  e001              B        |L1.28|
                  |L1.24|
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000018  f44f7240          MOV      r2,#0x300
                  |L1.28|
;;;1005     }
;;;1006   
;;;1007     /* If the previous operation is completed, proceed to erase the sector */
;;;1008     CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
00001c  4b0e              LDR      r3,|L1.88|
00001e  681b              LDR      r3,[r3,#0]
000020  f4237340          BIC      r3,r3,#0x300
000024  4c0c              LDR      r4,|L1.88|
000026  6023              STR      r3,[r4,#0]
;;;1009     FLASH->CR |= tmp_psize;
000028  4623              MOV      r3,r4
00002a  681b              LDR      r3,[r3,#0]
00002c  4313              ORRS     r3,r3,r2
00002e  6023              STR      r3,[r4,#0]
;;;1010     CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
000030  4623              MOV      r3,r4
000032  681b              LDR      r3,[r3,#0]
000034  f0230378          BIC      r3,r3,#0x78
000038  6023              STR      r3,[r4,#0]
;;;1011     FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
00003a  4623              MOV      r3,r4
00003c  681b              LDR      r3,[r3,#0]
00003e  2402              MOVS     r4,#2
000040  ea4404c0          ORR      r4,r4,r0,LSL #3
000044  4323              ORRS     r3,r3,r4
000046  4c04              LDR      r4,|L1.88|
000048  6023              STR      r3,[r4,#0]
;;;1012     FLASH->CR |= FLASH_CR_STRT;
00004a  4623              MOV      r3,r4
00004c  681b              LDR      r3,[r3,#0]
00004e  f4433380          ORR      r3,r3,#0x10000
000052  6023              STR      r3,[r4,#0]
;;;1013   }
000054  bd10              POP      {r4,pc}
;;;1014   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_FlushCaches||, CODE, READONLY, ALIGN=2

                  FLASH_FlushCaches PROC
;;;1310     */
;;;1311   void FLASH_FlushCaches(void)
000000  481c              LDR      r0,|L2.116|
;;;1312   {
;;;1313     /* Flush instruction cache  */
;;;1314     if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f4007000          AND      r0,r0,#0x200
000008  b1b0              CBZ      r0,|L2.56|
;;;1315     {
;;;1316       /* Disable instruction cache  */
;;;1317       __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
00000a  481a              LDR      r0,|L2.116|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4207000          BIC      r0,r0,#0x200
000012  4918              LDR      r1,|L2.116|
000014  6008              STR      r0,[r1,#0]
;;;1318       /* Reset instruction cache */
;;;1319       __HAL_FLASH_INSTRUCTION_CACHE_RESET();
000016  bf00              NOP      
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f4406000          ORR      r0,r0,#0x800
000020  6008              STR      r0,[r1,#0]
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]
000026  f4206000          BIC      r0,r0,#0x800
00002a  6008              STR      r0,[r1,#0]
00002c  bf00              NOP      
;;;1320       /* Enable instruction cache */
;;;1321       __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
00002e  4608              MOV      r0,r1
000030  6800              LDR      r0,[r0,#0]
000032  f4407000          ORR      r0,r0,#0x200
000036  6008              STR      r0,[r1,#0]
                  |L2.56|
;;;1322     }
;;;1323     
;;;1324     /* Flush data cache */
;;;1325     if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
000038  480e              LDR      r0,|L2.116|
00003a  6800              LDR      r0,[r0,#0]
00003c  f4006080          AND      r0,r0,#0x400
000040  b1b0              CBZ      r0,|L2.112|
;;;1326     {
;;;1327       /* Disable data cache  */
;;;1328       __HAL_FLASH_DATA_CACHE_DISABLE();
000042  480c              LDR      r0,|L2.116|
000044  6800              LDR      r0,[r0,#0]
000046  f4206080          BIC      r0,r0,#0x400
00004a  490a              LDR      r1,|L2.116|
00004c  6008              STR      r0,[r1,#0]
;;;1329       /* Reset data cache */
;;;1330       __HAL_FLASH_DATA_CACHE_RESET();
00004e  bf00              NOP      
000050  4608              MOV      r0,r1
000052  6800              LDR      r0,[r0,#0]
000054  f4405080          ORR      r0,r0,#0x1000
000058  6008              STR      r0,[r1,#0]
00005a  4608              MOV      r0,r1
00005c  6800              LDR      r0,[r0,#0]
00005e  f4205080          BIC      r0,r0,#0x1000
000062  6008              STR      r0,[r1,#0]
000064  bf00              NOP      
;;;1331       /* Enable data cache */
;;;1332       __HAL_FLASH_DATA_CACHE_ENABLE();
000066  4608              MOV      r0,r1
000068  6800              LDR      r0,[r0,#0]
00006a  f4406080          ORR      r0,r0,#0x400
00006e  6008              STR      r0,[r1,#0]
                  |L2.112|
;;;1333     }
;;;1334   }
000070  4770              BX       lr
;;;1335   
                          ENDP

000072  0000              DCW      0x0000
                  |L2.116|
                          DCD      0x40023c00

                          AREA ||i.FLASH_MassErase||, CODE, READONLY, ALIGN=2

                  FLASH_MassErase PROC
;;;952      */
;;;953    static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
000000  4a0a              LDR      r2,|L3.44|
;;;954    {
;;;955      /* Check the parameters */
;;;956      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;957      assert_param(IS_FLASH_BANK(Banks));
;;;958      
;;;959      /* If the previous operation is completed, proceed to erase all sectors */
;;;960      CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
000002  6812              LDR      r2,[r2,#0]
000004  f4227240          BIC      r2,r2,#0x300
000008  4b08              LDR      r3,|L3.44|
00000a  601a              STR      r2,[r3,#0]
;;;961      FLASH->CR |= FLASH_CR_MER;
00000c  461a              MOV      r2,r3
00000e  6812              LDR      r2,[r2,#0]
000010  f0420204          ORR      r2,r2,#4
000014  601a              STR      r2,[r3,#0]
;;;962      FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
000016  461a              MOV      r2,r3
000018  6812              LDR      r2,[r2,#0]
00001a  f44f3380          MOV      r3,#0x10000
00001e  ea432300          ORR      r3,r3,r0,LSL #8
000022  431a              ORRS     r2,r2,r3
000024  4b01              LDR      r3,|L3.44|
000026  601a              STR      r2,[r3,#0]
;;;963    }
000028  4770              BX       lr
;;;964    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40023c10

                          AREA ||i.FLASH_OB_BOR_LevelConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BOR_LevelConfig PROC
;;;1230     */
;;;1231   static HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)
000000  4601              MOV      r1,r0
;;;1232   {
;;;1233     /* Check the parameters */
;;;1234     assert_param(IS_OB_BOR_LEVEL(Level));
;;;1235   
;;;1236     /* Set the BOR Level */
;;;1237     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
000002  4806              LDR      r0,|L4.28|
000004  7800              LDRB     r0,[r0,#0]
000006  f020000c          BIC      r0,r0,#0xc
00000a  4a04              LDR      r2,|L4.28|
00000c  7010              STRB     r0,[r2,#0]
;;;1238     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= Level;
00000e  4610              MOV      r0,r2
000010  7800              LDRB     r0,[r0,#0]
000012  4308              ORRS     r0,r0,r1
000014  7010              STRB     r0,[r2,#0]
;;;1239     
;;;1240     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1241     
;;;1242   }
000018  4770              BX       lr
;;;1243   
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_DisablePCROP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_DisablePCROP PROC
;;;1128     */
;;;1129   static HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t Sector)
000000  b570              PUSH     {r4-r6,lr}
;;;1130   {  
000002  4604              MOV      r4,r0
;;;1131     HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1132     
;;;1133     /* Check the parameters */
;;;1134     assert_param(IS_OB_PCROP(Sector));
;;;1135       
;;;1136     /* Wait for last operation to be completed */  
;;;1137     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000006  f24c3050          MOV      r0,#0xc350
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;1138   
;;;1139     if(status == HAL_OK)
000010  b925              CBNZ     r5,|L5.28|
;;;1140     { 
;;;1141       *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~Sector);
000012  4803              LDR      r0,|L5.32|
000014  8800              LDRH     r0,[r0,#0]
000016  43a0              BICS     r0,r0,r4
000018  4901              LDR      r1,|L5.32|
00001a  8008              STRH     r0,[r1,#0]
                  |L5.28|
;;;1142     }
;;;1143     
;;;1144     return status;
00001c  4628              MOV      r0,r5
;;;1145   
;;;1146   }
00001e  bd70              POP      {r4-r6,pc}
;;;1147   #endif /* STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
                          ENDP

                  |L5.32|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_DisableWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_DisableWRP PROC
;;;1067     */
;;;1068   static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
000000  b570              PUSH     {r4-r6,lr}
;;;1069   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1070     HAL_StatusTypeDef status = HAL_OK;
000006  2500              MOVS     r5,#0
;;;1071     
;;;1072     /* Check the parameters */
;;;1073     assert_param(IS_OB_WRP_SECTOR(WRPSector));
;;;1074     assert_param(IS_FLASH_BANK(Banks));
;;;1075       
;;;1076     /* Wait for last operation to be completed */
;;;1077     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000008  f24c3050          MOV      r0,#0xc350
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
000010  4605              MOV      r5,r0
;;;1078   
;;;1079     if(status == HAL_OK)
000012  b92d              CBNZ     r5,|L6.32|
;;;1080     { 
;;;1081       *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)WRPSector; 
000014  4803              LDR      r0,|L6.36|
000016  8800              LDRH     r0,[r0,#0]
000018  b2a1              UXTH     r1,r4
00001a  4308              ORRS     r0,r0,r1
00001c  4901              LDR      r1,|L6.36|
00001e  8008              STRH     r0,[r1,#0]
                  |L6.32|
;;;1082     }
;;;1083     
;;;1084     return status;
000020  4628              MOV      r0,r5
;;;1085   }
000022  bd70              POP      {r4-r6,pc}
;;;1086   #endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
                          ENDP

                  |L6.36|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_EnablePCROP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_EnablePCROP PROC
;;;1100     */
;;;1101   static HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t Sector)
000000  b570              PUSH     {r4-r6,lr}
;;;1102   {
000002  4604              MOV      r4,r0
;;;1103     HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1104     
;;;1105     /* Check the parameters */
;;;1106     assert_param(IS_OB_PCROP(Sector));
;;;1107       
;;;1108     /* Wait for last operation to be completed */  
;;;1109     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000006  f24c3050          MOV      r0,#0xc350
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;1110   
;;;1111     if(status == HAL_OK)
000010  b92d              CBNZ     r5,|L7.30|
;;;1112     { 
;;;1113       *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)Sector;
000012  4804              LDR      r0,|L7.36|
000014  8800              LDRH     r0,[r0,#0]
000016  b2a1              UXTH     r1,r4
000018  4308              ORRS     r0,r0,r1
00001a  4902              LDR      r1,|L7.36|
00001c  8008              STRH     r0,[r1,#0]
                  |L7.30|
;;;1114     }
;;;1115     
;;;1116     return status;
00001e  4628              MOV      r0,r5
;;;1117   }
000020  bd70              POP      {r4-r6,pc}
;;;1118   
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_EnableWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_EnableWRP PROC
;;;1031     */
;;;1032   static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
000000  b570              PUSH     {r4-r6,lr}
;;;1033   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1034     HAL_StatusTypeDef status = HAL_OK;
000006  2500              MOVS     r5,#0
;;;1035     
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_OB_WRP_SECTOR(WRPSector));
;;;1038     assert_param(IS_FLASH_BANK(Banks));
;;;1039       
;;;1040     /* Wait for last operation to be completed */
;;;1041     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000008  f24c3050          MOV      r0,#0xc350
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
000010  4605              MOV      r5,r0
;;;1042   
;;;1043     if(status == HAL_OK)
000012  b925              CBNZ     r5,|L8.30|
;;;1044     { 
;;;1045       *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~WRPSector);  
000014  4803              LDR      r0,|L8.36|
000016  8800              LDRH     r0,[r0,#0]
000018  43a0              BICS     r0,r0,r4
00001a  4902              LDR      r1,|L8.36|
00001c  8008              STRH     r0,[r1,#0]
                  |L8.30|
;;;1046     }
;;;1047     
;;;1048     return status;
00001e  4628              MOV      r0,r5
;;;1049   }
000020  bd70              POP      {r4-r6,pc}
;;;1050   
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;1300     */
;;;1301   static uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L9.12|
;;;1302   {
;;;1303     /* Return the FLASH BOR level */
;;;1304     return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000002  7800              LDRB     r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;1305   }
000008  4770              BX       lr
;;;1306   
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;1272     */
;;;1273   static uint8_t FLASH_OB_GetRDP(void)
000000  20aa              MOVS     r0,#0xaa
;;;1274   {
;;;1275     uint8_t readstatus = OB_RDP_LEVEL_0;
;;;1276   
;;;1277     if((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_2))
000002  4907              LDR      r1,|L10.32|
000004  7809              LDRB     r1,[r1,#0]
000006  29cc              CMP      r1,#0xcc
000008  d101              BNE      |L10.14|
;;;1278     {
;;;1279       readstatus = OB_RDP_LEVEL_2;
00000a  20cc              MOVS     r0,#0xcc
00000c  e006              B        |L10.28|
                  |L10.14|
;;;1280     }
;;;1281     else if((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_0))
00000e  4904              LDR      r1,|L10.32|
000010  7809              LDRB     r1,[r1,#0]
000012  29aa              CMP      r1,#0xaa
000014  d101              BNE      |L10.26|
;;;1282     {
;;;1283       readstatus = OB_RDP_LEVEL_0;
000016  20aa              MOVS     r0,#0xaa
000018  e000              B        |L10.28|
                  |L10.26|
;;;1284     }
;;;1285     else 
;;;1286     {
;;;1287       readstatus = OB_RDP_LEVEL_1;
00001a  2055              MOVS     r0,#0x55
                  |L10.28|
;;;1288     }
;;;1289   
;;;1290     return readstatus;
;;;1291   }
00001c  4770              BX       lr
;;;1292   
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;1248     */
;;;1249   static uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L11.12|
;;;1250   {
;;;1251     /* Return the User Option Byte */
;;;1252     return ((uint8_t)(FLASH->OPTCR & 0xE0));
000002  6800              LDR      r0,[r0,#0]
000004  f00000e0          AND      r0,r0,#0xe0
;;;1253   }
000008  4770              BX       lr
;;;1254   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;1258     */
;;;1259   static uint16_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L12.8|
;;;1260   {
;;;1261     /* Return the FLASH write protection Register value */
;;;1262     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1263   }
000004  4770              BX       lr
;;;1264   
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_RDP_LevelConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDP_LevelConfig PROC
;;;1161     */
;;;1162   static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t Level)
000000  b570              PUSH     {r4-r6,lr}
;;;1163   {
000002  4604              MOV      r4,r0
;;;1164     HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1165     
;;;1166     /* Check the parameters */
;;;1167     assert_param(IS_OB_RDP_LEVEL(Level));
;;;1168       
;;;1169     /* Wait for last operation to be completed */
;;;1170     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000006  f24c3050          MOV      r0,#0xc350
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;1171   
;;;1172     if(status == HAL_OK)
000010  b90d              CBNZ     r5,|L13.22|
;;;1173     { 
;;;1174       *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = Level;
000012  4802              LDR      r0,|L13.28|
000014  7004              STRB     r4,[r0,#0]
                  |L13.22|
;;;1175     }
;;;1176     
;;;1177     return status;
000016  4628              MOV      r0,r5
;;;1178   }
000018  bd70              POP      {r4-r6,pc}
;;;1179   
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;1195     */
;;;1196   static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t Iwdg, uint8_t Stop, uint8_t Stdby)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1197   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1198     uint8_t optiontmp = 0xFF;
00000a  f04f08ff          MOV      r8,#0xff
;;;1199     HAL_StatusTypeDef status = HAL_OK;
00000e  2700              MOVS     r7,#0
;;;1200   
;;;1201     /* Check the parameters */
;;;1202     assert_param(IS_OB_IWDG_SOURCE(Iwdg));
;;;1203     assert_param(IS_OB_STOP_SOURCE(Stop));
;;;1204     assert_param(IS_OB_STDBY_SOURCE(Stdby));
;;;1205   
;;;1206     /* Wait for last operation to be completed */
;;;1207     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000010  f24c3050          MOV      r0,#0xc350
000014  f7fffffe          BL       FLASH_WaitForLastOperation
000018  4607              MOV      r7,r0
;;;1208     
;;;1209     if(status == HAL_OK)
00001a  b94f              CBNZ     r7,|L14.48|
;;;1210     {     
;;;1211       /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
;;;1212       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
00001c  4806              LDR      r0,|L14.56|
00001e  7800              LDRB     r0,[r0,#0]
000020  f000081f          AND      r8,r0,#0x1f
;;;1213   
;;;1214       /* Update User Option Byte */
;;;1215       *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = Iwdg | (uint8_t)(Stdby | (uint8_t)(Stop | ((uint8_t)optiontmp))); 
000024  ea450008          ORR      r0,r5,r8
000028  4330              ORRS     r0,r0,r6
00002a  4320              ORRS     r0,r0,r4
00002c  4902              LDR      r1,|L14.56|
00002e  7008              STRB     r0,[r1,#0]
                  |L14.48|
;;;1216     }
;;;1217     
;;;1218     return status; 
000030  4638              MOV      r0,r7
;;;1219   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1220   
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x40023c14

                          AREA ||i.HAL_FLASHEx_AdvOBGetConfig||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_AdvOBGetConfig PROC
;;;429      */
;;;430    void HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
000000  4901              LDR      r1,|L15.8|
;;;431    {
;;;432    #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
;;;433        defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
;;;434        defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;435      /*Get Sector*/
;;;436      pAdvOBInit->Sectors = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8809              LDRH     r1,[r1,#0]
000004  8101              STRH     r1,[r0,#8]
;;;437    #else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
;;;438      /*Get Sector for Bank1*/
;;;439      pAdvOBInit->SectorsBank1 = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
;;;440    
;;;441      /*Get Sector for Bank2*/
;;;442      pAdvOBInit->SectorsBank2 = (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
;;;443    
;;;444      /*Get Boot config OB*/
;;;445      pAdvOBInit->BootConfig = *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS;
;;;446    #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
;;;447              STM32F413xx || STM32F423xx */
;;;448    }
000006  4770              BX       lr
;;;449    
                          ENDP

                  |L15.8|
                          DCD      0x40023c16

                          AREA ||i.HAL_FLASHEx_AdvOBProgram||, CODE, READONLY, ALIGN=1

                  HAL_FLASHEx_AdvOBProgram PROC
;;;373      */
;;;374    HAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram (FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
000000  b570              PUSH     {r4-r6,lr}
;;;375    {
000002  4604              MOV      r4,r0
;;;376      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;377      
;;;378      /* Check the parameters */
;;;379      assert_param(IS_OBEX(pAdvOBInit->OptionType));
;;;380    
;;;381      /*Program PCROP option byte*/
;;;382      if(((pAdvOBInit->OptionType) & OPTIONBYTE_PCROP) == OPTIONBYTE_PCROP)
000006  7820              LDRB     r0,[r4,#0]
000008  f0000001          AND      r0,r0,#1
00000c  b158              CBZ      r0,|L16.38|
;;;383      {
;;;384        /* Check the parameters */
;;;385        assert_param(IS_PCROPSTATE(pAdvOBInit->PCROPState));
;;;386        if((pAdvOBInit->PCROPState) == OB_PCROP_STATE_ENABLE)
00000e  6860              LDR      r0,[r4,#4]
000010  2801              CMP      r0,#1
000012  d104              BNE      |L16.30|
;;;387        {
;;;388          /*Enable of Write protection on the selected Sector*/
;;;389    #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
;;;390        defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
;;;391        defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;392          status = FLASH_OB_EnablePCROP(pAdvOBInit->Sectors);
000014  8920              LDRH     r0,[r4,#8]
000016  f7fffffe          BL       FLASH_OB_EnablePCROP
00001a  4605              MOV      r5,r0
00001c  e003              B        |L16.38|
                  |L16.30|
;;;393    #else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
;;;394          status = FLASH_OB_EnablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);
;;;395    #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
;;;396              STM32F413xx || STM32F423xx */
;;;397        }
;;;398        else
;;;399        {
;;;400          /*Disable of Write protection on the selected Sector*/
;;;401    #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
;;;402        defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
;;;403        defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;404          status = FLASH_OB_DisablePCROP(pAdvOBInit->Sectors);
00001e  8920              LDRH     r0,[r4,#8]
000020  f7fffffe          BL       FLASH_OB_DisablePCROP
000024  4605              MOV      r5,r0
                  |L16.38|
;;;405    #else /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
;;;406          status = FLASH_OB_DisablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);
;;;407    #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
;;;408              STM32F413xx || STM32F423xx */
;;;409        }
;;;410      }
;;;411       
;;;412    #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;413      /*Program BOOT config option byte*/
;;;414      if(((pAdvOBInit->OptionType) & OPTIONBYTE_BOOTCONFIG) == OPTIONBYTE_BOOTCONFIG)
;;;415      {
;;;416        status = FLASH_OB_BootConfig(pAdvOBInit->BootConfig);
;;;417      }
;;;418    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
;;;419    
;;;420      return status;
000026  4628              MOV      r0,r5
;;;421    }
000028  bd70              POP      {r4-r6,pc}
;;;422    
                          ENDP


                          AREA ||i.HAL_FLASHEx_Erase||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_Erase PROC
;;;161      */
;;;162    HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;163    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;164      HAL_StatusTypeDef status = HAL_ERROR;
000008  2701              MOVS     r7,#1
;;;165      uint32_t index = 0U;
00000a  2500              MOVS     r5,#0
;;;166      
;;;167      /* Process Locked */
;;;168      __HAL_LOCK(&pFlash);
00000c  bf00              NOP      
00000e  4825              LDR      r0,|L17.164|
000010  7e00              LDRB     r0,[r0,#0x18]  ; pFlash
000012  2801              CMP      r0,#1
000014  d102              BNE      |L17.28|
000016  2002              MOVS     r0,#2
                  |L17.24|
;;;169    
;;;170      /* Check the parameters */
;;;171      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;172    
;;;173      /* Wait for last operation to be completed */
;;;174      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;175    
;;;176      if(status == HAL_OK)
;;;177      {
;;;178        /*Initialization of SectorError variable*/
;;;179        *SectorError = 0xFFFFFFFFU;
;;;180        
;;;181        if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
;;;182        {
;;;183          /*Mass erase to be done*/
;;;184          FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
;;;185    
;;;186          /* Wait for last operation to be completed */
;;;187          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;188          
;;;189          /* if the erase operation is completed, disable the MER Bit */
;;;190          FLASH->CR &= (~FLASH_MER_BIT);
;;;191        }
;;;192        else
;;;193        {
;;;194          /* Check the parameters */
;;;195          assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
;;;196    
;;;197          /* Erase by sector by sector to be done*/
;;;198          for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
;;;199          {
;;;200            FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
;;;201    
;;;202            /* Wait for last operation to be completed */
;;;203            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;204            
;;;205            /* If the erase operation is completed, disable the SER and SNB Bits */
;;;206            CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
;;;207    
;;;208            if(status != HAL_OK) 
;;;209            {
;;;210              /* In case of error, stop erase procedure and return the faulty sector*/
;;;211              *SectorError = index;
;;;212              break;
;;;213            }
;;;214          }
;;;215        }
;;;216        /* Flush the caches to be sure of the data consistency */
;;;217        FLASH_FlushCaches();    
;;;218      }
;;;219    
;;;220      /* Process Unlocked */
;;;221      __HAL_UNLOCK(&pFlash);
;;;222    
;;;223      return status;
;;;224    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L17.28|
00001c  2001              MOVS     r0,#1                 ;168
00001e  4921              LDR      r1,|L17.164|
000020  7608              STRB     r0,[r1,#0x18]         ;168
000022  bf00              NOP                            ;168
000024  f24c3050          MOV      r0,#0xc350            ;174
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4607              MOV      r7,r0                 ;174
00002e  2f00              CMP      r7,#0                 ;176
000030  d131              BNE      |L17.150|
000032  1e40              SUBS     r0,r0,#1              ;179
000034  6030              STR      r0,[r6,#0]            ;179
000036  6820              LDR      r0,[r4,#0]            ;181
000038  2801              CMP      r0,#1                 ;181
00003a  d10f              BNE      |L17.92|
00003c  7c20              LDRB     r0,[r4,#0x10]         ;184
00003e  6861              LDR      r1,[r4,#4]            ;184
000040  f7fffffe          BL       FLASH_MassErase
000044  f24c3050          MOV      r0,#0xc350            ;187
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  4607              MOV      r7,r0                 ;187
00004e  4816              LDR      r0,|L17.168|
000050  6800              LDR      r0,[r0,#0]            ;190
000052  f0200004          BIC      r0,r0,#4              ;190
000056  4914              LDR      r1,|L17.168|
000058  6008              STR      r0,[r1,#0]            ;190
00005a  e01a              B        |L17.146|
                  |L17.92|
00005c  68a5              LDR      r5,[r4,#8]            ;198
00005e  e012              B        |L17.134|
                  |L17.96|
000060  7c21              LDRB     r1,[r4,#0x10]         ;200
000062  4628              MOV      r0,r5                 ;200
000064  f7fffffe          BL       FLASH_Erase_Sector
000068  f24c3050          MOV      r0,#0xc350            ;203
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4607              MOV      r7,r0                 ;203
000072  480d              LDR      r0,|L17.168|
000074  6800              LDR      r0,[r0,#0]            ;206
000076  f020007a          BIC      r0,r0,#0x7a           ;206
00007a  490b              LDR      r1,|L17.168|
00007c  6008              STR      r0,[r1,#0]            ;206
00007e  b10f              CBZ      r7,|L17.132|
000080  6035              STR      r5,[r6,#0]            ;211
000082  e005              B        |L17.144|
                  |L17.132|
000084  1c6d              ADDS     r5,r5,#1              ;198
                  |L17.134|
000086  e9d41002          LDRD     r1,r0,[r4,#8]         ;198
00008a  4408              ADD      r0,r0,r1              ;198
00008c  42a8              CMP      r0,r5                 ;198
00008e  d8e7              BHI      |L17.96|
                  |L17.144|
000090  bf00              NOP                            ;212
                  |L17.146|
000092  f7fffffe          BL       FLASH_FlushCaches
                  |L17.150|
000096  bf00              NOP                            ;221
000098  2000              MOVS     r0,#0                 ;221
00009a  4902              LDR      r1,|L17.164|
00009c  7608              STRB     r0,[r1,#0x18]         ;221
00009e  bf00              NOP                            ;221
0000a0  4638              MOV      r0,r7                 ;223
0000a2  e7b9              B        |L17.24|
;;;225    
                          ENDP

                  |L17.164|
                          DCD      pFlash
                  |L17.168|
                          DCD      0x40023c10

                          AREA ||i.HAL_FLASHEx_Erase_IT||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_Erase_IT PROC
;;;232      */
;;;233    HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
000000  b570              PUSH     {r4-r6,lr}
;;;234    {
000002  4604              MOV      r4,r0
;;;235      HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;236    
;;;237      /* Process Locked */
;;;238      __HAL_LOCK(&pFlash);
000006  bf00              NOP      
000008  4819              LDR      r0,|L18.112|
00000a  7e00              LDRB     r0,[r0,#0x18]  ; pFlash
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L18.20|
000010  2002              MOVS     r0,#2
                  |L18.18|
;;;239    
;;;240      /* Check the parameters */
;;;241      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;242    
;;;243      /* Enable End of FLASH Operation interrupt */
;;;244      __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
;;;245      
;;;246      /* Enable Error source interrupt */
;;;247      __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
;;;248      
;;;249      /* Clear pending flags (if any) */  
;;;250      __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
;;;251                             FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_PGSERR);  
;;;252      
;;;253      if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
;;;254      {
;;;255        /*Mass erase to be done*/
;;;256        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
;;;257        pFlash.Bank = pEraseInit->Banks;
;;;258        FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
;;;259      }
;;;260      else
;;;261      {
;;;262        /* Erase by sector to be done*/
;;;263    
;;;264        /* Check the parameters */
;;;265        assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
;;;266    
;;;267        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;
;;;268        pFlash.NbSectorsToErase = pEraseInit->NbSectors;
;;;269        pFlash.Sector = pEraseInit->Sector;
;;;270        pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;
;;;271    
;;;272        /*Erase 1st sector and wait for IT*/
;;;273        FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);
;;;274      }
;;;275    
;;;276      return status;
;;;277    }
000012  bd70              POP      {r4-r6,pc}
                  |L18.20|
000014  2001              MOVS     r0,#1                 ;238
000016  4916              LDR      r1,|L18.112|
000018  7608              STRB     r0,[r1,#0x18]         ;238
00001a  bf00              NOP                            ;238
00001c  4815              LDR      r0,|L18.116|
00001e  6800              LDR      r0,[r0,#0]            ;244
000020  f0407080          ORR      r0,r0,#0x1000000      ;244
000024  4913              LDR      r1,|L18.116|
000026  6008              STR      r0,[r1,#0]            ;244
000028  4608              MOV      r0,r1                 ;247
00002a  6800              LDR      r0,[r0,#0]            ;247
00002c  f0407000          ORR      r0,r0,#0x2000000      ;247
000030  6008              STR      r0,[r1,#0]            ;247
000032  20f3              MOVS     r0,#0xf3              ;250
000034  1f09              SUBS     r1,r1,#4              ;250
000036  6008              STR      r0,[r1,#0]            ;250
000038  6820              LDR      r0,[r4,#0]            ;253
00003a  2801              CMP      r0,#1                 ;253
00003c  d109              BNE      |L18.82|
00003e  2002              MOVS     r0,#2                 ;256
000040  490b              LDR      r1,|L18.112|
000042  7008              STRB     r0,[r1,#0]            ;256
000044  6860              LDR      r0,[r4,#4]            ;257
000046  6108              STR      r0,[r1,#0x10]         ;257  ; pFlash
000048  7c20              LDRB     r0,[r4,#0x10]         ;258
00004a  6861              LDR      r1,[r4,#4]            ;258
00004c  f7fffffe          BL       FLASH_MassErase
000050  e00c              B        |L18.108|
                  |L18.82|
000052  2001              MOVS     r0,#1                 ;267
000054  4906              LDR      r1,|L18.112|
000056  7008              STRB     r0,[r1,#0]            ;267
000058  68e0              LDR      r0,[r4,#0xc]          ;268
00005a  6048              STR      r0,[r1,#4]            ;268  ; pFlash
00005c  68a0              LDR      r0,[r4,#8]            ;269
00005e  60c8              STR      r0,[r1,#0xc]          ;269  ; pFlash
000060  7c20              LDRB     r0,[r4,#0x10]         ;270
000062  7208              STRB     r0,[r1,#8]            ;270
000064  7c21              LDRB     r1,[r4,#0x10]         ;273
000066  68a0              LDR      r0,[r4,#8]            ;273
000068  f7fffffe          BL       FLASH_Erase_Sector
                  |L18.108|
00006c  4628              MOV      r0,r5                 ;276
00006e  e7d0              B        |L18.18|
;;;278    
                          ENDP

                  |L18.112|
                          DCD      pFlash
                  |L18.116|
                          DCD      0x40023c10

                          AREA ||i.HAL_FLASHEx_OBGetConfig||, CODE, READONLY, ALIGN=1

                  HAL_FLASHEx_OBGetConfig PROC
;;;344      */
;;;345    void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
000000  b510              PUSH     {r4,lr}
;;;346    {
000002  4604              MOV      r4,r0
;;;347      pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR;
000004  200f              MOVS     r0,#0xf
000006  6020              STR      r0,[r4,#0]
;;;348    
;;;349      /*Get WRP*/
;;;350      pOBInit->WRPSector = (uint32_t)FLASH_OB_GetWRP();
000008  f7fffffe          BL       FLASH_OB_GetWRP
00000c  60a0              STR      r0,[r4,#8]
;;;351    
;;;352      /*Get RDP Level*/
;;;353      pOBInit->RDPLevel = (uint32_t)FLASH_OB_GetRDP();
00000e  f7fffffe          BL       FLASH_OB_GetRDP
000012  6120              STR      r0,[r4,#0x10]
;;;354    
;;;355      /*Get USER*/
;;;356      pOBInit->USERConfig = (uint8_t)FLASH_OB_GetUser();
000014  f7fffffe          BL       FLASH_OB_GetUser
000018  7620              STRB     r0,[r4,#0x18]
;;;357    
;;;358      /*Get BOR Level*/
;;;359      pOBInit->BORLevel = (uint32_t)FLASH_OB_GetBOR();
00001a  f7fffffe          BL       FLASH_OB_GetBOR
00001e  6160              STR      r0,[r4,#0x14]
;;;360    }
000020  bd10              POP      {r4,pc}
;;;361    
                          ENDP


                          AREA ||i.HAL_FLASHEx_OBProgram||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OBProgram PROC
;;;285      */
;;;286    HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
000000  b570              PUSH     {r4-r6,lr}
;;;287    {
000002  4604              MOV      r4,r0
;;;288      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;289      
;;;290      /* Process Locked */
;;;291      __HAL_LOCK(&pFlash);
000006  bf00              NOP      
000008  4821              LDR      r0,|L20.144|
00000a  7e00              LDRB     r0,[r0,#0x18]  ; pFlash
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L20.20|
000010  2002              MOVS     r0,#2
                  |L20.18|
;;;292    
;;;293      /* Check the parameters */
;;;294      assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
;;;295    
;;;296      /*Write protection configuration*/
;;;297      if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
;;;298      {
;;;299        assert_param(IS_WRPSTATE(pOBInit->WRPState));
;;;300        if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
;;;301        {
;;;302          /*Enable of Write protection on the selected Sector*/
;;;303          status = FLASH_OB_EnableWRP(pOBInit->WRPSector, pOBInit->Banks);
;;;304        }
;;;305        else
;;;306        {
;;;307          /*Disable of Write protection on the selected Sector*/
;;;308          status = FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
;;;309        }
;;;310      }
;;;311    
;;;312      /*Read protection configuration*/
;;;313      if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
;;;314      {
;;;315        status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
;;;316      }
;;;317    
;;;318      /*USER  configuration*/
;;;319      if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
;;;320      {
;;;321        status = FLASH_OB_UserConfig(pOBInit->USERConfig&OB_IWDG_SW, 
;;;322                                         pOBInit->USERConfig&OB_STOP_NO_RST,
;;;323                                         pOBInit->USERConfig&OB_STDBY_NO_RST);
;;;324      }
;;;325    
;;;326      /*BOR Level  configuration*/
;;;327      if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
;;;328      {
;;;329        status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
;;;330      }
;;;331    
;;;332      /* Process Unlocked */
;;;333      __HAL_UNLOCK(&pFlash);
;;;334    
;;;335      return status;
;;;336    }
000012  bd70              POP      {r4-r6,pc}
                  |L20.20|
000014  2001              MOVS     r0,#1                 ;291
000016  491e              LDR      r1,|L20.144|
000018  7608              STRB     r0,[r1,#0x18]         ;291
00001a  bf00              NOP                            ;291
00001c  7820              LDRB     r0,[r4,#0]            ;297
00001e  f0000001          AND      r0,r0,#1              ;297
000022  b168              CBZ      r0,|L20.64|
000024  6860              LDR      r0,[r4,#4]            ;300
000026  2801              CMP      r0,#1                 ;300
000028  d105              BNE      |L20.54|
00002a  e9d40102          LDRD     r0,r1,[r4,#8]         ;303
00002e  f7fffffe          BL       FLASH_OB_EnableWRP
000032  4605              MOV      r5,r0                 ;303
000034  e004              B        |L20.64|
                  |L20.54|
000036  e9d40102          LDRD     r0,r1,[r4,#8]         ;308
00003a  f7fffffe          BL       FLASH_OB_DisableWRP
00003e  4605              MOV      r5,r0                 ;308
                  |L20.64|
000040  7820              LDRB     r0,[r4,#0]            ;313
000042  f0000002          AND      r0,r0,#2              ;313
000046  2802              CMP      r0,#2                 ;313
000048  d103              BNE      |L20.82|
00004a  7c20              LDRB     r0,[r4,#0x10]         ;315
00004c  f7fffffe          BL       FLASH_OB_RDP_LevelConfig
000050  4605              MOV      r5,r0                 ;315
                  |L20.82|
000052  7820              LDRB     r0,[r4,#0]            ;319
000054  f0000004          AND      r0,r0,#4              ;319
000058  2804              CMP      r0,#4                 ;319
00005a  d109              BNE      |L20.112|
00005c  7e23              LDRB     r3,[r4,#0x18]         ;321
00005e  f0030280          AND      r2,r3,#0x80           ;321
000062  f0030140          AND      r1,r3,#0x40           ;321
000066  f0030020          AND      r0,r3,#0x20           ;321
00006a  f7fffffe          BL       FLASH_OB_UserConfig
00006e  4605              MOV      r5,r0                 ;321
                  |L20.112|
000070  7820              LDRB     r0,[r4,#0]            ;327
000072  f0000008          AND      r0,r0,#8              ;327
000076  2808              CMP      r0,#8                 ;327
000078  d103              BNE      |L20.130|
00007a  7d20              LDRB     r0,[r4,#0x14]         ;329
00007c  f7fffffe          BL       FLASH_OB_BOR_LevelConfig
000080  4605              MOV      r5,r0                 ;329
                  |L20.130|
000082  bf00              NOP                            ;333
000084  2000              MOVS     r0,#0                 ;333
000086  4902              LDR      r1,|L20.144|
000088  7608              STRB     r0,[r1,#0x18]         ;333
00008a  bf00              NOP                            ;333
00008c  4628              MOV      r0,r5                 ;335
00008e  e7c0              B        |L20.18|
;;;337    
                          ENDP

                  |L20.144|
                          DCD      pFlash

                          AREA ||i.HAL_FLASHEx_OB_DeSelectPCROP||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OB_DeSelectPCROP PROC
;;;486      */
;;;487    HAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void)
000000  21ff              MOVS     r1,#0xff
;;;488    {
;;;489      uint8_t optiontmp = 0xFF;
;;;490      
;;;491      /* Mask SPRMOD bit */
;;;492      optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
000002  4804              LDR      r0,|L21.20|
000004  7800              LDRB     r0,[r0,#0]
000006  f000017f          AND      r1,r0,#0x7f
;;;493      
;;;494      /* Update Option Byte */
;;;495      *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_DESELECTED | optiontmp);  
00000a  4802              LDR      r0,|L21.20|
00000c  7001              STRB     r1,[r0,#0]
;;;496      
;;;497      return HAL_OK;
00000e  2000              MOVS     r0,#0
;;;498    }
000010  4770              BX       lr
;;;499    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410xx ||\
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      0x40023c17

                          AREA ||i.HAL_FLASHEx_OB_SelectPCROP||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OB_SelectPCROP PROC
;;;461      */
;;;462    HAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void)
000000  21ff              MOVS     r1,#0xff
;;;463    {
;;;464      uint8_t optiontmp = 0xFF;
;;;465    
;;;466      /* Mask SPRMOD bit */
;;;467      optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
000002  4805              LDR      r0,|L22.24|
000004  7800              LDRB     r0,[r0,#0]
000006  f000017f          AND      r1,r0,#0x7f
;;;468      
;;;469      /* Update Option Byte */
;;;470      *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_SELECTED | optiontmp); 
00000a  f0410080          ORR      r0,r1,#0x80
00000e  4a02              LDR      r2,|L22.24|
000010  7010              STRB     r0,[r2,#0]
;;;471      
;;;472      return HAL_OK;
000012  2000              MOVS     r0,#0
;;;473    }
000014  4770              BX       lr
;;;474    
                          ENDP

000016  0000              DCW      0x0000
                  |L22.24|
                          DCD      0x40023c17

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_flash_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REVSH|
#line 478
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____RRX|
#line 665
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
