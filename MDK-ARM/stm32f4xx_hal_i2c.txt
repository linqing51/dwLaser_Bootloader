; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_i2c.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_i2c.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_i2c.c]
                          THUMB

                          AREA ||i.HAL_I2C_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AbortCpltCallback PROC
;;;5003     */
;;;5004   __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5005   {
;;;5006     /* Prevent unused argument(s) compilation warning */
;;;5007     UNUSED(hi2c);
;;;5008   
;;;5009     /* NOTE : This function should not be modified, when the callback is needed,
;;;5010               the HAL_I2C_AbortCpltCallback could be implemented in the user file
;;;5011      */
;;;5012   }
;;;5013   
                          ENDP


                          AREA ||i.HAL_I2C_AddrCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AddrCallback PROC
;;;4921     */
;;;4922   __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
000000  4770              BX       lr
;;;4923   {
;;;4924     /* Prevent unused argument(s) compilation warning */
;;;4925     UNUSED(hi2c);
;;;4926     UNUSED(TransferDirection);
;;;4927     UNUSED(AddrMatchCode);
;;;4928   
;;;4929     /* NOTE : This function should not be modified, when the callback is needed,
;;;4930               the HAL_I2C_AddrCallback() could be implemented in the user file
;;;4931      */
;;;4932   }
;;;4933   
                          ENDP


                          AREA ||i.HAL_I2C_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DeInit PROC
;;;549      */
;;;550    HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;551    {
000002  4604              MOV      r4,r0
;;;552      /* Check the I2C handle allocation */
;;;553      if (hi2c == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;554      {
;;;555        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;556      }
;;;557    
;;;558      /* Check the parameters */
;;;559      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;560    
;;;561      hi2c->State = HAL_I2C_STATE_BUSY;
;;;562    
;;;563      /* Disable the I2C Peripheral Clock */
;;;564      __HAL_I2C_DISABLE(hi2c);
;;;565    
;;;566    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;567      if (hi2c->MspDeInitCallback == NULL)
;;;568      {
;;;569        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
;;;570      }
;;;571    
;;;572      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;573      hi2c->MspDeInitCallback(hi2c);
;;;574    #else
;;;575      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;576      HAL_I2C_MspDeInit(hi2c);
;;;577    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;578    
;;;579      hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
;;;580      hi2c->State         = HAL_I2C_STATE_RESET;
;;;581      hi2c->PreviousState = I2C_STATE_NONE;
;;;582      hi2c->Mode          = HAL_I2C_MODE_NONE;
;;;583    
;;;584      /* Release Lock */
;;;585      __HAL_UNLOCK(hi2c);
;;;586    
;;;587      return HAL_OK;
;;;588    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  2024              MOVS     r0,#0x24              ;561
00000c  f884003d          STRB     r0,[r4,#0x3d]         ;561
000010  6820              LDR      r0,[r4,#0]            ;564
000012  6800              LDR      r0,[r0,#0]            ;564
000014  f0200001          BIC      r0,r0,#1              ;564
000018  6821              LDR      r1,[r4,#0]            ;564
00001a  6008              STR      r0,[r1,#0]            ;564
00001c  4620              MOV      r0,r4                 ;576
00001e  f7fffffe          BL       HAL_I2C_MspDeInit
000022  2000              MOVS     r0,#0                 ;579
000024  6420              STR      r0,[r4,#0x40]         ;579
000026  f884003d          STRB     r0,[r4,#0x3d]         ;580
00002a  6320              STR      r0,[r4,#0x30]         ;581
00002c  f884003e          STRB     r0,[r4,#0x3e]         ;582
000030  bf00              NOP                            ;585
000032  f884003c          STRB     r0,[r4,#0x3c]         ;585
000036  bf00              NOP                            ;585
000038  bf00              NOP                            ;587
00003a  e7e5              B        |L3.8|
;;;589    
                          ENDP


                          AREA ||i.HAL_I2C_DisableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DisableListen_IT PROC
;;;4516     */
;;;4517   HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4518   {
;;;4519     /* Declaration of tmp to prevent undefined behavior of volatile usage */
;;;4520     uint32_t tmp;
;;;4521   
;;;4522     /* Disable Address listen mode only if a transfer is not ongoing */
;;;4523     if (hi2c->State == HAL_I2C_STATE_LISTEN)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2828              CMP      r0,#0x28
000008  d11b              BNE      |L4.66|
;;;4524     {
;;;4525       tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
00000a  f891003d          LDRB     r0,[r1,#0x3d]
00000e  f0000203          AND      r2,r0,#3
;;;4526       hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
000012  f891003e          LDRB     r0,[r1,#0x3e]
000016  4310              ORRS     r0,r0,r2
000018  6308              STR      r0,[r1,#0x30]
;;;4527       hi2c->State = HAL_I2C_STATE_READY;
00001a  2020              MOVS     r0,#0x20
00001c  f881003d          STRB     r0,[r1,#0x3d]
;;;4528       hi2c->Mode = HAL_I2C_MODE_NONE;
000020  2000              MOVS     r0,#0
000022  f881003e          STRB     r0,[r1,#0x3e]
;;;4529   
;;;4530       /* Disable Address Acknowledge */
;;;4531       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4206080          BIC      r0,r0,#0x400
00002e  680b              LDR      r3,[r1,#0]
000030  6018              STR      r0,[r3,#0]
;;;4532   
;;;4533       /* Disable EVT and ERR interrupt */
;;;4534       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000032  6808              LDR      r0,[r1,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f4207040          BIC      r0,r0,#0x300
00003a  680b              LDR      r3,[r1,#0]
00003c  6058              STR      r0,[r3,#4]
;;;4535   
;;;4536       return HAL_OK;
00003e  2000              MOVS     r0,#0
                  |L4.64|
;;;4537     }
;;;4538     else
;;;4539     {
;;;4540       return HAL_BUSY;
;;;4541     }
;;;4542   }
000040  4770              BX       lr
                  |L4.66|
000042  2002              MOVS     r0,#2                 ;4540
000044  e7fc              B        |L4.64|
;;;4543   
                          ENDP


                          AREA ||i.HAL_I2C_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ER_IRQHandler PROC
;;;4776     */
;;;4777   void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4778   {
000004  4604              MOV      r4,r0
;;;4779     HAL_I2C_ModeTypeDef tmp1;
;;;4780     uint32_t tmp2;
;;;4781     HAL_I2C_StateTypeDef tmp3;
;;;4782     uint32_t tmp4;
;;;4783     uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
000006  6820              LDR      r0,[r4,#0]
000008  6947              LDR      r7,[r0,#0x14]
;;;4784     uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
00000a  6820              LDR      r0,[r4,#0]
00000c  f8d08004          LDR      r8,[r0,#4]
;;;4785     uint32_t error      = HAL_I2C_ERROR_NONE;
000010  2500              MOVS     r5,#0
;;;4786     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
000012  f894903e          LDRB     r9,[r4,#0x3e]
;;;4787   
;;;4788     /* I2C Bus error interrupt occurred ----------------------------------------*/
;;;4789     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
000016  f3c72000          UBFX     r0,r7,#8,#1
00001a  b140              CBZ      r0,|L5.46|
00001c  f3c82000          UBFX     r0,r8,#8,#1
000020  b128              CBZ      r0,|L5.46|
;;;4790     {
;;;4791       error |= HAL_I2C_ERROR_BERR;
000022  f0450501          ORR      r5,r5,#1
;;;4792   
;;;4793       /* Clear BERR flag */
;;;4794       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
000026  f46f7080          MVN      r0,#0x100
00002a  6821              LDR      r1,[r4,#0]
00002c  6148              STR      r0,[r1,#0x14]
                  |L5.46|
;;;4795     }
;;;4796   
;;;4797     /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
;;;4798     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
00002e  f3c72040          UBFX     r0,r7,#9,#1
000032  b140              CBZ      r0,|L5.70|
000034  f3c82000          UBFX     r0,r8,#8,#1
000038  b128              CBZ      r0,|L5.70|
;;;4799     {
;;;4800       error |= HAL_I2C_ERROR_ARLO;
00003a  f0450502          ORR      r5,r5,#2
;;;4801   
;;;4802       /* Clear ARLO flag */
;;;4803       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
00003e  f46f7000          MVN      r0,#0x200
000042  6821              LDR      r1,[r4,#0]
000044  6148              STR      r0,[r1,#0x14]
                  |L5.70|
;;;4804     }
;;;4805   
;;;4806     /* I2C Acknowledge failure error interrupt occurred ------------------------*/
;;;4807     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
000046  f3c72080          UBFX     r0,r7,#10,#1
00004a  b370              CBZ      r0,|L5.170|
00004c  f3c82000          UBFX     r0,r8,#8,#1
000050  b358              CBZ      r0,|L5.170|
;;;4808     {
;;;4809       tmp1 = CurrentMode;
000052  46ca              MOV      r10,r9
;;;4810       tmp2 = hi2c->XferCount;
000054  f8b4b02a          LDRH     r11,[r4,#0x2a]
;;;4811       tmp3 = hi2c->State;
000058  f894603d          LDRB     r6,[r4,#0x3d]
;;;4812       tmp4 = hi2c->PreviousState;
00005c  6b20              LDR      r0,[r4,#0x30]
00005e  9000              STR      r0,[sp,#0]
;;;4813       if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
000060  f1ba0f20          CMP      r10,#0x20
000064  d10f              BNE      |L5.134|
000066  f1bb0f00          CMP      r11,#0
00006a  d10c              BNE      |L5.134|
;;;4814           ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
00006c  2e21              CMP      r6,#0x21
00006e  d006              BEQ      |L5.126|
000070  2e29              CMP      r6,#0x29
000072  d004              BEQ      |L5.126|
;;;4815            ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
000074  2e28              CMP      r6,#0x28
000076  d106              BNE      |L5.134|
000078  9800              LDR      r0,[sp,#0]
00007a  2821              CMP      r0,#0x21
00007c  d103              BNE      |L5.134|
                  |L5.126|
;;;4816       {
;;;4817         I2C_Slave_AF(hi2c);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       I2C_Slave_AF
000084  e011              B        |L5.170|
                  |L5.134|
;;;4818       }
;;;4819       else
;;;4820       {
;;;4821         /* Clear AF flag */
;;;4822         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000086  f46f6080          MVN      r0,#0x400
00008a  6821              LDR      r1,[r4,#0]
00008c  6148              STR      r0,[r1,#0x14]
;;;4823   
;;;4824         error |= HAL_I2C_ERROR_AF;
00008e  f0450504          ORR      r5,r5,#4
;;;4825   
;;;4826         /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
;;;4827         if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
000092  f1b90f10          CMP      r9,#0x10
000096  d002              BEQ      |L5.158|
000098  f1b90f40          CMP      r9,#0x40
00009c  d105              BNE      |L5.170|
                  |L5.158|
;;;4828         {
;;;4829           /* Generate Stop */
;;;4830           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00009e  6820              LDR      r0,[r4,#0]
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f4407000          ORR      r0,r0,#0x200
0000a6  6821              LDR      r1,[r4,#0]
0000a8  6008              STR      r0,[r1,#0]
                  |L5.170|
;;;4831         }
;;;4832       }
;;;4833     }
;;;4834   
;;;4835     /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
;;;4836     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
0000aa  f3c720c0          UBFX     r0,r7,#11,#1
0000ae  b140              CBZ      r0,|L5.194|
0000b0  f3c82000          UBFX     r0,r8,#8,#1
0000b4  b128              CBZ      r0,|L5.194|
;;;4837     {
;;;4838       error |= HAL_I2C_ERROR_OVR;
0000b6  f0450508          ORR      r5,r5,#8
;;;4839       /* Clear OVR flag */
;;;4840       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
0000ba  f46f6000          MVN      r0,#0x800
0000be  6821              LDR      r1,[r4,#0]
0000c0  6148              STR      r0,[r1,#0x14]
                  |L5.194|
;;;4841     }
;;;4842   
;;;4843     /* Call the Error Callback in case of Error detected -----------------------*/
;;;4844     if (error != HAL_I2C_ERROR_NONE)
0000c2  b12d              CBZ      r5,|L5.208|
;;;4845     {
;;;4846       hi2c->ErrorCode |= error;
0000c4  6c20              LDR      r0,[r4,#0x40]
0000c6  4328              ORRS     r0,r0,r5
0000c8  6420              STR      r0,[r4,#0x40]
;;;4847       I2C_ITError(hi2c);
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       I2C_ITError
                  |L5.208|
;;;4848     }
;;;4849   }
0000d0  e8bd8ff8          POP      {r3-r11,pc}
;;;4850   
                          ENDP


                          AREA ||i.HAL_I2C_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EV_IRQHandler PROC
;;;4610     */
;;;4611   void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4612   {
000004  4605              MOV      r5,r0
;;;4613     uint32_t sr1itflags;
;;;4614     uint32_t sr2itflags               = 0U;
000006  f04f0800          MOV      r8,#0
;;;4615     uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
00000a  6828              LDR      r0,[r5,#0]
00000c  6846              LDR      r6,[r0,#4]
;;;4616     uint32_t CurrentXferOptions       = hi2c->XferOptions;
00000e  f8d5902c          LDR      r9,[r5,#0x2c]
;;;4617     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
000012  f895703e          LDRB     r7,[r5,#0x3e]
;;;4618     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000016  f895a03d          LDRB     r10,[r5,#0x3d]
;;;4619   
;;;4620     /* Master or Memory mode selected */
;;;4621     if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
00001a  2f10              CMP      r7,#0x10
00001c  d001              BEQ      |L6.34|
00001e  2f40              CMP      r7,#0x40
000020  d17f              BNE      |L6.290|
                  |L6.34|
;;;4622     {
;;;4623       sr2itflags   = READ_REG(hi2c->Instance->SR2);
000022  6828              LDR      r0,[r5,#0]
000024  f8d08018          LDR      r8,[r0,#0x18]
;;;4624       sr1itflags   = READ_REG(hi2c->Instance->SR1);
000028  6828              LDR      r0,[r5,#0]
00002a  6944              LDR      r4,[r0,#0x14]
;;;4625   
;;;4626       /* Exit IRQ event until Start Bit detected in case of Other frame requested */
;;;4627       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
00002c  f0040001          AND      r0,r4,#1
000030  b960              CBNZ     r0,|L6.76|
000032  f5b90f2a          CMP      r9,#0xaa0000
000036  d002              BEQ      |L6.62|
000038  f1b94f2a          CMP      r9,#0xaa000000
00003c  d101              BNE      |L6.66|
                  |L6.62|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L6.68|
                  |L6.66|
000042  2000              MOVS     r0,#0
                  |L6.68|
000044  2801              CMP      r0,#1
000046  d101              BNE      |L6.76|
                  |L6.72|
;;;4628       {
;;;4629         return;
;;;4630       }
;;;4631   
;;;4632       /* SB Set ----------------------------------------------------------------*/
;;;4633       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4634       {
;;;4635         /* Convert OTHER_xxx XferOptions if any */
;;;4636         I2C_ConvertOtherXferOptions(hi2c);
;;;4637   
;;;4638         I2C_Master_SB(hi2c);
;;;4639       }
;;;4640       /* ADD10 Set -------------------------------------------------------------*/
;;;4641       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4642       {
;;;4643         I2C_Master_ADD10(hi2c);
;;;4644       }
;;;4645       /* ADDR Set --------------------------------------------------------------*/
;;;4646       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4647       {
;;;4648         I2C_Master_ADDR(hi2c);
;;;4649       }
;;;4650       /* I2C in mode Transmitter -----------------------------------------------*/
;;;4651       else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
;;;4652       {
;;;4653         /* Do not check buffer and BTF flag if a Xfer DMA is on going */
;;;4654         if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
;;;4655         {
;;;4656           /* TXE set and BTF reset -----------------------------------------------*/
;;;4657           if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4658           {
;;;4659             I2C_MasterTransmit_TXE(hi2c);
;;;4660           }
;;;4661           /* BTF set -------------------------------------------------------------*/
;;;4662           else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4663           {
;;;4664             if (CurrentMode == HAL_I2C_MODE_MASTER)
;;;4665             {
;;;4666               I2C_MasterTransmit_BTF(hi2c);
;;;4667             }
;;;4668             else /* HAL_I2C_MODE_MEM */
;;;4669             {
;;;4670               I2C_MemoryTransmit_TXE_BTF(hi2c);
;;;4671             }
;;;4672           }
;;;4673           else
;;;4674           {
;;;4675             /* Do nothing */
;;;4676           }
;;;4677         }
;;;4678       }
;;;4679       /* I2C in mode Receiver --------------------------------------------------*/
;;;4680       else
;;;4681       {
;;;4682         /* Do not check buffer and BTF flag if a Xfer DMA is on going */
;;;4683         if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
;;;4684         {
;;;4685           /* RXNE set and BTF reset -----------------------------------------------*/
;;;4686           if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4687           {
;;;4688             I2C_MasterReceive_RXNE(hi2c);
;;;4689           }
;;;4690           /* BTF set -------------------------------------------------------------*/
;;;4691           else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4692           {
;;;4693             I2C_MasterReceive_BTF(hi2c);
;;;4694           }
;;;4695           else
;;;4696           {
;;;4697             /* Do nothing */
;;;4698           }
;;;4699         }
;;;4700       }
;;;4701     }
;;;4702     /* Slave mode selected */
;;;4703     else
;;;4704     {
;;;4705       /* If an error is detected, read only SR1 register to prevent */
;;;4706       /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
;;;4707       if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
;;;4708       {
;;;4709         sr1itflags   = READ_REG(hi2c->Instance->SR1);
;;;4710       }
;;;4711       else
;;;4712       {
;;;4713         sr2itflags   = READ_REG(hi2c->Instance->SR2);
;;;4714         sr1itflags   = READ_REG(hi2c->Instance->SR1);
;;;4715       }
;;;4716   
;;;4717       /* ADDR set --------------------------------------------------------------*/
;;;4718       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4719       {
;;;4720         /* Now time to read SR2, this will clear ADDR flag automatically */
;;;4721         if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
;;;4722         {
;;;4723           sr2itflags   = READ_REG(hi2c->Instance->SR2);
;;;4724         }
;;;4725         I2C_Slave_ADDR(hi2c, sr2itflags);
;;;4726       }
;;;4727       /* STOPF set --------------------------------------------------------------*/
;;;4728       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4729       {
;;;4730         I2C_Slave_STOPF(hi2c);
;;;4731       }
;;;4732       /* I2C in mode Transmitter -----------------------------------------------*/
;;;4733       else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
;;;4734       {
;;;4735         /* TXE set and BTF reset -----------------------------------------------*/
;;;4736         if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4737         {
;;;4738           I2C_SlaveTransmit_TXE(hi2c);
;;;4739         }
;;;4740         /* BTF set -------------------------------------------------------------*/
;;;4741         else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4742         {
;;;4743           I2C_SlaveTransmit_BTF(hi2c);
;;;4744         }
;;;4745         else
;;;4746         {
;;;4747           /* Do nothing */
;;;4748         }
;;;4749       }
;;;4750       /* I2C in mode Receiver --------------------------------------------------*/
;;;4751       else
;;;4752       {
;;;4753         /* RXNE set and BTF reset ----------------------------------------------*/
;;;4754         if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4755         {
;;;4756           I2C_SlaveReceive_RXNE(hi2c);
;;;4757         }
;;;4758         /* BTF set -------------------------------------------------------------*/
;;;4759         else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4760         {
;;;4761           I2C_SlaveReceive_BTF(hi2c);
;;;4762         }
;;;4763         else
;;;4764         {
;;;4765           /* Do nothing */
;;;4766         }
;;;4767       }
;;;4768     }
;;;4769   }
000048  e8bd87f0          POP      {r4-r10,pc}
                  |L6.76|
00004c  f0040001          AND      r0,r4,#1              ;4633
000050  b148              CBZ      r0,|L6.102|
000052  f3c62040          UBFX     r0,r6,#9,#1           ;4633
000056  b130              CBZ      r0,|L6.102|
000058  4628              MOV      r0,r5                 ;4636
00005a  f7fffffe          BL       I2C_ConvertOtherXferOptions
00005e  4628              MOV      r0,r5                 ;4638
000060  f7fffffe          BL       I2C_Master_SB
                  |L6.100|
000064  e0b4              B        |L6.464|
                  |L6.102|
000066  f3c400c0          UBFX     r0,r4,#3,#1           ;4641
00006a  b130              CBZ      r0,|L6.122|
00006c  f3c62040          UBFX     r0,r6,#9,#1           ;4641
000070  b118              CBZ      r0,|L6.122|
000072  4628              MOV      r0,r5                 ;4643
000074  f7fffffe          BL       I2C_Master_ADD10
000078  e0aa              B        |L6.464|
                  |L6.122|
00007a  f3c40040          UBFX     r0,r4,#1,#1           ;4646
00007e  b130              CBZ      r0,|L6.142|
000080  f3c62040          UBFX     r0,r6,#9,#1           ;4646
000084  b118              CBZ      r0,|L6.142|
000086  4628              MOV      r0,r5                 ;4648
000088  f7fffffe          BL       I2C_Master_ADDR
00008c  e0a0              B        |L6.464|
                  |L6.142|
00008e  f3c80080          UBFX     r0,r8,#2,#1           ;4651
000092  b328              CBZ      r0,|L6.224|
000094  6828              LDR      r0,[r5,#0]            ;4654
000096  6840              LDR      r0,[r0,#4]            ;4654
000098  f4006000          AND      r0,r0,#0x800          ;4654
00009c  f5b06f00          CMP      r0,#0x800             ;4654
0000a0  d0e0              BEQ      |L6.100|
0000a2  f3c410c0          UBFX     r0,r4,#7,#1           ;4657
0000a6  b148              CBZ      r0,|L6.188|
0000a8  f3c62080          UBFX     r0,r6,#10,#1          ;4657
0000ac  b130              CBZ      r0,|L6.188|
0000ae  f3c40080          UBFX     r0,r4,#2,#1           ;4657
0000b2  b918              CBNZ     r0,|L6.188|
0000b4  4628              MOV      r0,r5                 ;4659
0000b6  f7fffffe          BL       I2C_MasterTransmit_TXE
0000ba  e089              B        |L6.464|
                  |L6.188|
0000bc  f3c40080          UBFX     r0,r4,#2,#1           ;4662
0000c0  2800              CMP      r0,#0                 ;4662
0000c2  d0cf              BEQ      |L6.100|
0000c4  f3c62040          UBFX     r0,r6,#9,#1           ;4662
0000c8  2800              CMP      r0,#0                 ;4662
0000ca  d0cb              BEQ      |L6.100|
0000cc  2f10              CMP      r7,#0x10              ;4664
0000ce  d103              BNE      |L6.216|
0000d0  4628              MOV      r0,r5                 ;4666
0000d2  f7fffffe          BL       I2C_MasterTransmit_BTF
0000d6  e07b              B        |L6.464|
                  |L6.216|
0000d8  4628              MOV      r0,r5                 ;4670
0000da  f7fffffe          BL       I2C_MemoryTransmit_TXE_BTF
0000de  e077              B        |L6.464|
                  |L6.224|
0000e0  6828              LDR      r0,[r5,#0]            ;4683
0000e2  6840              LDR      r0,[r0,#4]            ;4683
0000e4  f4006000          AND      r0,r0,#0x800          ;4683
0000e8  f5b06f00          CMP      r0,#0x800             ;4683
0000ec  d070              BEQ      |L6.464|
0000ee  f3c41080          UBFX     r0,r4,#6,#1           ;4686
0000f2  b150              CBZ      r0,|L6.266|
0000f4  f3c62080          UBFX     r0,r6,#10,#1          ;4686
0000f8  b138              CBZ      r0,|L6.266|
0000fa  f3c40080          UBFX     r0,r4,#2,#1           ;4686
0000fe  b920              CBNZ     r0,|L6.266|
000100  4628              MOV      r0,r5                 ;4688
000102  f7fffffe          BL       I2C_MasterReceive_RXNE
000106  e063              B        |L6.464|
000108  e00b              B        |L6.290|
                  |L6.266|
00010a  f3c40080          UBFX     r0,r4,#2,#1           ;4691
00010e  2800              CMP      r0,#0                 ;4691
000110  d05e              BEQ      |L6.464|
000112  f3c62040          UBFX     r0,r6,#9,#1           ;4691
000116  2800              CMP      r0,#0                 ;4691
000118  d05a              BEQ      |L6.464|
00011a  4628              MOV      r0,r5                 ;4693
00011c  f7fffffe          BL       I2C_MasterReceive_BTF
000120  e056              B        |L6.464|
                  |L6.290|
000122  6c28              LDR      r0,[r5,#0x40]         ;4707
000124  b110              CBZ      r0,|L6.300|
000126  6828              LDR      r0,[r5,#0]            ;4709
000128  6944              LDR      r4,[r0,#0x14]         ;4709
00012a  e004              B        |L6.310|
                  |L6.300|
00012c  6828              LDR      r0,[r5,#0]            ;4713
00012e  f8d08018          LDR      r8,[r0,#0x18]         ;4713
000132  6828              LDR      r0,[r5,#0]            ;4714
000134  6944              LDR      r4,[r0,#0x14]         ;4714
                  |L6.310|
000136  f3c40040          UBFX     r0,r4,#1,#1           ;4718
00013a  b160              CBZ      r0,|L6.342|
00013c  f3c62040          UBFX     r0,r6,#9,#1           ;4718
000140  b148              CBZ      r0,|L6.342|
000142  6c28              LDR      r0,[r5,#0x40]         ;4721
000144  b110              CBZ      r0,|L6.332|
000146  6828              LDR      r0,[r5,#0]            ;4723
000148  f8d08018          LDR      r8,[r0,#0x18]         ;4723
                  |L6.332|
00014c  4641              MOV      r1,r8                 ;4725
00014e  4628              MOV      r0,r5                 ;4725
000150  f7fffffe          BL       I2C_Slave_ADDR
000154  e03c              B        |L6.464|
                  |L6.342|
000156  f3c41000          UBFX     r0,r4,#4,#1           ;4728
00015a  b130              CBZ      r0,|L6.362|
00015c  f3c62040          UBFX     r0,r6,#9,#1           ;4728
000160  b118              CBZ      r0,|L6.362|
000162  4628              MOV      r0,r5                 ;4730
000164  f7fffffe          BL       I2C_Slave_STOPF
000168  e032              B        |L6.464|
                  |L6.362|
00016a  f1ba0f21          CMP      r10,#0x21             ;4733
00016e  d002              BEQ      |L6.374|
000170  f1ba0f29          CMP      r10,#0x29             ;4733
000174  d116              BNE      |L6.420|
                  |L6.374|
000176  f3c410c0          UBFX     r0,r4,#7,#1           ;4736
00017a  b148              CBZ      r0,|L6.400|
00017c  f3c62080          UBFX     r0,r6,#10,#1          ;4736
000180  b130              CBZ      r0,|L6.400|
000182  f3c40080          UBFX     r0,r4,#2,#1           ;4736
000186  b918              CBNZ     r0,|L6.400|
000188  4628              MOV      r0,r5                 ;4738
00018a  f7fffffe          BL       I2C_SlaveTransmit_TXE
00018e  e01f              B        |L6.464|
                  |L6.400|
000190  f3c40080          UBFX     r0,r4,#2,#1           ;4741
000194  b1e0              CBZ      r0,|L6.464|
000196  f3c62040          UBFX     r0,r6,#9,#1           ;4741
00019a  b1c8              CBZ      r0,|L6.464|
00019c  4628              MOV      r0,r5                 ;4743
00019e  f7fffffe          BL       I2C_SlaveTransmit_BTF
0001a2  e015              B        |L6.464|
                  |L6.420|
0001a4  f3c41080          UBFX     r0,r4,#6,#1           ;4754
0001a8  b148              CBZ      r0,|L6.446|
0001aa  f3c62080          UBFX     r0,r6,#10,#1          ;4754
0001ae  b130              CBZ      r0,|L6.446|
0001b0  f3c40080          UBFX     r0,r4,#2,#1           ;4754
0001b4  b918              CBNZ     r0,|L6.446|
0001b6  4628              MOV      r0,r5                 ;4756
0001b8  f7fffffe          BL       I2C_SlaveReceive_RXNE
0001bc  e008              B        |L6.464|
                  |L6.446|
0001be  f3c40080          UBFX     r0,r4,#2,#1           ;4759
0001c2  b128              CBZ      r0,|L6.464|
0001c4  f3c62040          UBFX     r0,r6,#9,#1           ;4759
0001c8  b110              CBZ      r0,|L6.464|
0001ca  4628              MOV      r0,r5                 ;4761
0001cc  f7fffffe          BL       I2C_SlaveReceive_BTF
                  |L6.464|
0001d0  bf00              NOP      
0001d2  e739              B        |L6.72|
;;;4770   
                          ENDP


                          AREA ||i.HAL_I2C_EnableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EnableListen_IT PROC
;;;4483     */
;;;4484   HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4485   {
;;;4486     if (hi2c->State == HAL_I2C_STATE_READY)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2820              CMP      r0,#0x20
000008  d11b              BNE      |L7.66|
;;;4487     {
;;;4488       hi2c->State = HAL_I2C_STATE_LISTEN;
00000a  2028              MOVS     r0,#0x28
00000c  f881003d          STRB     r0,[r1,#0x3d]
;;;4489   
;;;4490       /* Check if the I2C is already enabled */
;;;4491       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
000010  6808              LDR      r0,[r1,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0000001          AND      r0,r0,#1
000018  b928              CBNZ     r0,|L7.38|
;;;4492       {
;;;4493         /* Enable I2C peripheral */
;;;4494         __HAL_I2C_ENABLE(hi2c);
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  680a              LDR      r2,[r1,#0]
000024  6010              STR      r0,[r2,#0]
                  |L7.38|
;;;4495       }
;;;4496   
;;;4497       /* Enable Address Acknowledge */
;;;4498       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4406080          ORR      r0,r0,#0x400
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
;;;4499   
;;;4500       /* Enable EVT and ERR interrupt */
;;;4501       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000032  6808              LDR      r0,[r1,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f4407040          ORR      r0,r0,#0x300
00003a  680a              LDR      r2,[r1,#0]
00003c  6050              STR      r0,[r2,#4]
;;;4502   
;;;4503       return HAL_OK;
00003e  2000              MOVS     r0,#0
                  |L7.64|
;;;4504     }
;;;4505     else
;;;4506     {
;;;4507       return HAL_BUSY;
;;;4508     }
;;;4509   }
000040  4770              BX       lr
                  |L7.66|
000042  2002              MOVS     r0,#2                 ;4507
000044  e7fc              B        |L7.64|
;;;4510   
                          ENDP


                          AREA ||i.HAL_I2C_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ErrorCallback PROC
;;;4987     */
;;;4988   __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4989   {
;;;4990     /* Prevent unused argument(s) compilation warning */
;;;4991     UNUSED(hi2c);
;;;4992   
;;;4993     /* NOTE : This function should not be modified, when the callback is needed,
;;;4994               the HAL_I2C_ErrorCallback could be implemented in the user file
;;;4995      */
;;;4996   }
;;;4997   
                          ENDP


                          AREA ||i.HAL_I2C_GetError||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetError PROC
;;;5061     */
;;;5062   uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;5063   {
;;;5064     return hi2c->ErrorCode;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5065   }
000004  4770              BX       lr
;;;5066   
                          ENDP


                          AREA ||i.HAL_I2C_GetMode||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetMode PROC
;;;5050     */
;;;5051   HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;5052   {
;;;5053     return hi2c->Mode;
000002  f891003e          LDRB     r0,[r1,#0x3e]
;;;5054   }
000006  4770              BX       lr
;;;5055   
                          ENDP


                          AREA ||i.HAL_I2C_GetState||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetState PROC
;;;5038     */
;;;5039   HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;5040   {
;;;5041     /* Return I2C handle state */
;;;5042     return hi2c->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5043   }
000006  4770              BX       lr
;;;5044   
                          ENDP


                          AREA ||i.HAL_I2C_Init||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Init PROC
;;;434      */
;;;435    HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437      uint32_t freqrange;
;;;438      uint32_t pclk1;
;;;439    
;;;440      /* Check the I2C handle allocation */
;;;441      if (hi2c == NULL)
000004  b90c              CBNZ     r4,|L12.10|
;;;442      {
;;;443        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;444      }
;;;445    
;;;446      /* Check the parameters */
;;;447      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;448      assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
;;;449      assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
;;;450      assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
;;;451      assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
;;;452      assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
;;;453      assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
;;;454      assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
;;;455      assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
;;;456    
;;;457      if (hi2c->State == HAL_I2C_STATE_RESET)
;;;458      {
;;;459        /* Allocate lock resource and initialize it */
;;;460        hi2c->Lock = HAL_UNLOCKED;
;;;461    
;;;462    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;463        /* Init the I2C Callback settings */
;;;464        hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
;;;465        hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
;;;466        hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
;;;467        hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
;;;468        hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
;;;469        hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
;;;470        hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
;;;471        hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;472        hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;473        hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
;;;474    
;;;475        if (hi2c->MspInitCallback == NULL)
;;;476        {
;;;477          hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
;;;478        }
;;;479    
;;;480        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;481        hi2c->MspInitCallback(hi2c);
;;;482    #else
;;;483        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;484        HAL_I2C_MspInit(hi2c);
;;;485    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;486      }
;;;487    
;;;488      hi2c->State = HAL_I2C_STATE_BUSY;
;;;489    
;;;490      /* Disable the selected I2C peripheral */
;;;491      __HAL_I2C_DISABLE(hi2c);
;;;492    
;;;493      /*Reset I2C*/
;;;494      hi2c->Instance->CR1 |= I2C_CR1_SWRST;
;;;495      hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
;;;496    
;;;497      /* Get PCLK1 frequency */
;;;498      pclk1 = HAL_RCC_GetPCLK1Freq();
;;;499    
;;;500      /* Check the minimum allowed PCLK1 frequency */
;;;501      if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
;;;502      {
;;;503        return HAL_ERROR;
;;;504      }
;;;505    
;;;506      /* Calculate frequency range */
;;;507      freqrange = I2C_FREQRANGE(pclk1);
;;;508    
;;;509      /*---------------------------- I2Cx CR2 Configuration ----------------------*/
;;;510      /* Configure I2Cx: Frequency range */
;;;511      MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
;;;512    
;;;513      /*---------------------------- I2Cx TRISE Configuration --------------------*/
;;;514      /* Configure I2Cx: Rise Time */
;;;515      MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
;;;516    
;;;517      /*---------------------------- I2Cx CCR Configuration ----------------------*/
;;;518      /* Configure I2Cx: Speed */
;;;519      MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
;;;520    
;;;521      /*---------------------------- I2Cx CR1 Configuration ----------------------*/
;;;522      /* Configure I2Cx: Generalcall and NoStretch mode */
;;;523      MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
;;;524    
;;;525      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;526      /* Configure I2Cx: Own Address1 and addressing mode */
;;;527      MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
;;;528    
;;;529      /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
;;;530      /* Configure I2Cx: Dual mode and Own Address2 */
;;;531      MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
;;;532    
;;;533      /* Enable the selected I2C peripheral */
;;;534      __HAL_I2C_ENABLE(hi2c);
;;;535    
;;;536      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;537      hi2c->State = HAL_I2C_STATE_READY;
;;;538      hi2c->PreviousState = I2C_STATE_NONE;
;;;539      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;540    
;;;541      return HAL_OK;
;;;542    }
000008  bd70              POP      {r4-r6,pc}
                  |L12.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;457
00000e  b928              CBNZ     r0,|L12.28|
000010  2000              MOVS     r0,#0                 ;460
000012  f884003c          STRB     r0,[r4,#0x3c]         ;460
000016  4620              MOV      r0,r4                 ;484
000018  f7fffffe          BL       HAL_I2C_MspInit
                  |L12.28|
00001c  2024              MOVS     r0,#0x24              ;488
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;488
000022  6820              LDR      r0,[r4,#0]            ;491
000024  6800              LDR      r0,[r0,#0]            ;491
000026  f0200001          BIC      r0,r0,#1              ;491
00002a  6821              LDR      r1,[r4,#0]            ;491
00002c  6008              STR      r0,[r1,#0]            ;491
00002e  6820              LDR      r0,[r4,#0]            ;494
000030  6800              LDR      r0,[r0,#0]            ;494
000032  f4404000          ORR      r0,r0,#0x8000         ;494
000036  6821              LDR      r1,[r4,#0]            ;494
000038  6008              STR      r0,[r1,#0]            ;494
00003a  6820              LDR      r0,[r4,#0]            ;495
00003c  6800              LDR      r0,[r0,#0]            ;495
00003e  f4204000          BIC      r0,r0,#0x8000         ;495
000042  6821              LDR      r1,[r4,#0]            ;495
000044  6008              STR      r0,[r1,#0]            ;495
000046  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00004a  4605              MOV      r5,r0                 ;498
00004c  495c              LDR      r1,|L12.448|
00004e  6860              LDR      r0,[r4,#4]            ;501
000050  4288              CMP      r0,r1                 ;501
000052  d806              BHI      |L12.98|
000054  485b              LDR      r0,|L12.452|
000056  4285              CMP      r5,r0                 ;501
000058  d201              BCS      |L12.94|
00005a  2001              MOVS     r0,#1                 ;501
00005c  e007              B        |L12.110|
                  |L12.94|
00005e  2000              MOVS     r0,#0                 ;501
000060  e005              B        |L12.110|
                  |L12.98|
000062  4859              LDR      r0,|L12.456|
000064  4285              CMP      r5,r0                 ;501
000066  d201              BCS      |L12.108|
000068  2001              MOVS     r0,#1                 ;501
00006a  e000              B        |L12.110|
                  |L12.108|
00006c  2000              MOVS     r0,#0                 ;501
                  |L12.110|
00006e  2801              CMP      r0,#1                 ;501
000070  d100              BNE      |L12.116|
000072  e7c9              B        |L12.8|
                  |L12.116|
000074  4855              LDR      r0,|L12.460|
000076  fbb5f6f0          UDIV     r6,r5,r0              ;507
00007a  6820              LDR      r0,[r4,#0]            ;511
00007c  6840              LDR      r0,[r0,#4]            ;511
00007e  f020003f          BIC      r0,r0,#0x3f           ;511
000082  4330              ORRS     r0,r0,r6              ;511
000084  6821              LDR      r1,[r4,#0]            ;511
000086  6048              STR      r0,[r1,#4]            ;511
000088  494d              LDR      r1,|L12.448|
00008a  6860              LDR      r0,[r4,#4]            ;515
00008c  4288              CMP      r0,r1                 ;515
00008e  d801              BHI      |L12.148|
000090  1c70              ADDS     r0,r6,#1              ;515
000092  e007              B        |L12.164|
                  |L12.148|
000094  f44f7096          MOV      r0,#0x12c             ;515
000098  4370              MULS     r0,r6,r0              ;515
00009a  f44f717a          MOV      r1,#0x3e8             ;515
00009e  fbb0f0f1          UDIV     r0,r0,r1              ;515
0000a2  1c40              ADDS     r0,r0,#1              ;515
                  |L12.164|
0000a4  6821              LDR      r1,[r4,#0]            ;515
0000a6  6a09              LDR      r1,[r1,#0x20]         ;515
0000a8  f021013f          BIC      r1,r1,#0x3f           ;515
0000ac  4308              ORRS     r0,r0,r1              ;515
0000ae  6821              LDR      r1,[r4,#0]            ;515
0000b0  6208              STR      r0,[r1,#0x20]         ;515
0000b2  4943              LDR      r1,|L12.448|
0000b4  6860              LDR      r0,[r4,#4]            ;519
0000b6  4288              CMP      r0,r1                 ;519
0000b8  d814              BHI      |L12.228|
0000ba  1e68              SUBS     r0,r5,#1              ;519
0000bc  6861              LDR      r1,[r4,#4]            ;519
0000be  0049              LSLS     r1,r1,#1              ;519
0000c0  fbb0f0f1          UDIV     r0,r0,r1              ;519
0000c4  1c40              ADDS     r0,r0,#1              ;519
0000c6  f3c0000b          UBFX     r0,r0,#0,#12          ;519
0000ca  2804              CMP      r0,#4                 ;519
0000cc  d201              BCS      |L12.210|
0000ce  2004              MOVS     r0,#4                 ;519
0000d0  e03d              B        |L12.334|
                  |L12.210|
0000d2  1e68              SUBS     r0,r5,#1              ;519
0000d4  6861              LDR      r1,[r4,#4]            ;519
0000d6  0049              LSLS     r1,r1,#1              ;519
0000d8  fbb0f0f1          UDIV     r0,r0,r1              ;519
0000dc  1c40              ADDS     r0,r0,#1              ;519
0000de  f3c0000b          UBFX     r0,r0,#0,#12          ;519
0000e2  e034              B        |L12.334|
                  |L12.228|
0000e4  68a0              LDR      r0,[r4,#8]            ;519
0000e6  b938              CBNZ     r0,|L12.248|
0000e8  1e68              SUBS     r0,r5,#1              ;519
0000ea  6861              LDR      r1,[r4,#4]            ;519
0000ec  eb010141          ADD      r1,r1,r1,LSL #1       ;519
0000f0  fbb0f0f1          UDIV     r0,r0,r1              ;519
0000f4  1c40              ADDS     r0,r0,#1              ;519
0000f6  e00a              B        |L12.270|
                  |L12.248|
0000f8  1e68              SUBS     r0,r5,#1              ;519
0000fa  6861              LDR      r1,[r4,#4]            ;519
0000fc  eb0102c1          ADD      r2,r1,r1,LSL #3       ;519
000100  eb021101          ADD      r1,r2,r1,LSL #4       ;519
000104  fbb0f0f1          UDIV     r0,r0,r1              ;519
000108  1c40              ADDS     r0,r0,#1              ;519
00010a  f4404080          ORR      r0,r0,#0x4000         ;519
                  |L12.270|
00010e  f3c0000b          UBFX     r0,r0,#0,#12          ;519
000112  b908              CBNZ     r0,|L12.280|
000114  2001              MOVS     r0,#1                 ;519
000116  e01a              B        |L12.334|
                  |L12.280|
000118  68a0              LDR      r0,[r4,#8]            ;519
00011a  b948              CBNZ     r0,|L12.304|
00011c  1e68              SUBS     r0,r5,#1              ;519
00011e  6861              LDR      r1,[r4,#4]            ;519
000120  eb010141          ADD      r1,r1,r1,LSL #1       ;519
000124  fbb0f0f1          UDIV     r0,r0,r1              ;519
000128  1c40              ADDS     r0,r0,#1              ;519
00012a  f3c0000b          UBFX     r0,r0,#0,#12          ;519
00012e  e00c              B        |L12.330|
                  |L12.304|
000130  1e68              SUBS     r0,r5,#1              ;519
000132  6861              LDR      r1,[r4,#4]            ;519
000134  eb0102c1          ADD      r2,r1,r1,LSL #3       ;519
000138  eb021101          ADD      r1,r2,r1,LSL #4       ;519
00013c  fbb0f0f1          UDIV     r0,r0,r1              ;519
000140  1c40              ADDS     r0,r0,#1              ;519
000142  f3c0000b          UBFX     r0,r0,#0,#12          ;519
000146  f4404080          ORR      r0,r0,#0x4000         ;519
                  |L12.330|
00014a  f4404000          ORR      r0,r0,#0x8000         ;519
                  |L12.334|
00014e  6821              LDR      r1,[r4,#0]            ;519
000150  69c9              LDR      r1,[r1,#0x1c]         ;519
000152  f64c72ff          MOV      r2,#0xcfff            ;519
000156  4391              BICS     r1,r1,r2              ;519
000158  4308              ORRS     r0,r0,r1              ;519
00015a  6821              LDR      r1,[r4,#0]            ;519
00015c  61c8              STR      r0,[r1,#0x1c]         ;519
00015e  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;523
000162  4308              ORRS     r0,r0,r1              ;523
000164  6821              LDR      r1,[r4,#0]            ;523
000166  6809              LDR      r1,[r1,#0]            ;523
000168  f02101c0          BIC      r1,r1,#0xc0           ;523
00016c  4308              ORRS     r0,r0,r1              ;523
00016e  6821              LDR      r1,[r4,#0]            ;523
000170  6008              STR      r0,[r1,#0]            ;523
000172  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;527
000176  4308              ORRS     r0,r0,r1              ;527
000178  6821              LDR      r1,[r4,#0]            ;527
00017a  6889              LDR      r1,[r1,#8]            ;527
00017c  f24832ff          MOV      r2,#0x83ff            ;527
000180  4391              BICS     r1,r1,r2              ;527
000182  4308              ORRS     r0,r0,r1              ;527
000184  6821              LDR      r1,[r4,#0]            ;527
000186  6088              STR      r0,[r1,#8]            ;527
000188  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;531
00018c  4308              ORRS     r0,r0,r1              ;531
00018e  6821              LDR      r1,[r4,#0]            ;531
000190  68c9              LDR      r1,[r1,#0xc]          ;531
000192  f02101ff          BIC      r1,r1,#0xff           ;531
000196  4308              ORRS     r0,r0,r1              ;531
000198  6821              LDR      r1,[r4,#0]            ;531
00019a  60c8              STR      r0,[r1,#0xc]          ;531
00019c  6820              LDR      r0,[r4,#0]            ;534
00019e  6800              LDR      r0,[r0,#0]            ;534
0001a0  f0400001          ORR      r0,r0,#1              ;534
0001a4  6821              LDR      r1,[r4,#0]            ;534
0001a6  6008              STR      r0,[r1,#0]            ;534
0001a8  2000              MOVS     r0,#0                 ;536
0001aa  6420              STR      r0,[r4,#0x40]         ;536
0001ac  2020              MOVS     r0,#0x20              ;537
0001ae  f884003d          STRB     r0,[r4,#0x3d]         ;537
0001b2  2000              MOVS     r0,#0                 ;538
0001b4  6320              STR      r0,[r4,#0x30]         ;538
0001b6  f884003e          STRB     r0,[r4,#0x3e]         ;539
0001ba  bf00              NOP                            ;541
0001bc  e724              B        |L12.8|
;;;543    
                          ENDP

0001be  0000              DCW      0x0000
                  |L12.448|
                          DCD      0x000186a0
                  |L12.452|
                          DCD      0x001e8480
                  |L12.456|
                          DCD      0x003d0900
                  |L12.460|
                          DCD      0x000f4240

                          AREA ||i.HAL_I2C_IsDeviceReady||, CODE, READONLY, ALIGN=2

                  HAL_I2C_IsDeviceReady PROC
;;;3314     */
;;;3315   HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3316   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;3317     /* Get tick */
;;;3318     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;3319     uint32_t I2C_Trials = 1U;
000012  f04f0901          MOV      r9,#1
;;;3320     FlagStatus tmp1;
;;;3321     FlagStatus tmp2;
;;;3322   
;;;3323     if (hi2c->State == HAL_I2C_STATE_READY)
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2820              CMP      r0,#0x20
00001c  d17e              BNE      |L13.284|
;;;3324     {
;;;3325       /* Wait until BUSY flag is reset */
;;;3326       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001e  2319              MOVS     r3,#0x19
000020  2201              MOVS     r2,#1
000022  4963              LDR      r1,|L13.432|
000024  4620              MOV      r0,r4
000026  9500              STR      r5,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b110              CBZ      r0,|L13.52|
;;;3327       {
;;;3328         return HAL_BUSY;
00002e  2002              MOVS     r0,#2
                  |L13.48|
;;;3329       }
;;;3330   
;;;3331       /* Process Locked */
;;;3332       __HAL_LOCK(hi2c);
;;;3333   
;;;3334       /* Check if the I2C is already enabled */
;;;3335       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3336       {
;;;3337         /* Enable I2C peripheral */
;;;3338         __HAL_I2C_ENABLE(hi2c);
;;;3339       }
;;;3340   
;;;3341       /* Disable Pos */
;;;3342       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3343   
;;;3344       hi2c->State = HAL_I2C_STATE_BUSY;
;;;3345       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3346       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3347   
;;;3348       do
;;;3349       {
;;;3350         /* Generate Start */
;;;3351         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3352   
;;;3353         /* Wait until SB flag is set */
;;;3354         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
;;;3355         {
;;;3356           if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
;;;3357           {
;;;3358             hi2c->ErrorCode = HAL_I2C_WRONG_START;
;;;3359           }
;;;3360           return HAL_TIMEOUT;
;;;3361         }
;;;3362   
;;;3363         /* Send slave address */
;;;3364         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;3365   
;;;3366         /* Wait until ADDR or AF flag are set */
;;;3367         /* Get tick */
;;;3368         tickstart = HAL_GetTick();
;;;3369   
;;;3370         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3371         tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3372         while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
;;;3373         {
;;;3374           if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;3375           {
;;;3376             hi2c->State = HAL_I2C_STATE_TIMEOUT;
;;;3377           }
;;;3378           tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3379           tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3380         }
;;;3381   
;;;3382         hi2c->State = HAL_I2C_STATE_READY;
;;;3383   
;;;3384         /* Check if the ADDR flag has been set */
;;;3385         if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
;;;3386         {
;;;3387           /* Generate Stop */
;;;3388           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3389   
;;;3390           /* Clear ADDR Flag */
;;;3391           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3392   
;;;3393           /* Wait until BUSY flag is reset */
;;;3394           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3395           {
;;;3396             return HAL_ERROR;
;;;3397           }
;;;3398   
;;;3399           hi2c->State = HAL_I2C_STATE_READY;
;;;3400   
;;;3401           /* Process Unlocked */
;;;3402           __HAL_UNLOCK(hi2c);
;;;3403   
;;;3404           return HAL_OK;
;;;3405         }
;;;3406         else
;;;3407         {
;;;3408           /* Generate Stop */
;;;3409           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3410   
;;;3411           /* Clear AF Flag */
;;;3412           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3413   
;;;3414           /* Wait until BUSY flag is reset */
;;;3415           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3416           {
;;;3417             return HAL_ERROR;
;;;3418           }
;;;3419         }
;;;3420   
;;;3421         /* Increment Trials */
;;;3422         I2C_Trials++;
;;;3423       }
;;;3424       while (I2C_Trials < Trials);
;;;3425   
;;;3426       hi2c->State = HAL_I2C_STATE_READY;
;;;3427   
;;;3428       /* Process Unlocked */
;;;3429       __HAL_UNLOCK(hi2c);
;;;3430   
;;;3431       return HAL_ERROR;
;;;3432     }
;;;3433     else
;;;3434     {
;;;3435       return HAL_BUSY;
;;;3436     }
;;;3437   }
000030  e8bd8ff8          POP      {r3-r11,pc}
                  |L13.52|
000034  bf00              NOP                            ;3332
000036  f894003c          LDRB     r0,[r4,#0x3c]         ;3332
00003a  2801              CMP      r0,#1                 ;3332
00003c  d101              BNE      |L13.66|
00003e  2002              MOVS     r0,#2                 ;3332
000040  e7f6              B        |L13.48|
                  |L13.66|
000042  2001              MOVS     r0,#1                 ;3332
000044  f884003c          STRB     r0,[r4,#0x3c]         ;3332
000048  bf00              NOP                            ;3332
00004a  6820              LDR      r0,[r4,#0]            ;3335
00004c  6800              LDR      r0,[r0,#0]            ;3335
00004e  f0000001          AND      r0,r0,#1              ;3335
000052  b928              CBNZ     r0,|L13.96|
000054  6820              LDR      r0,[r4,#0]            ;3338
000056  6800              LDR      r0,[r0,#0]            ;3338
000058  f0400001          ORR      r0,r0,#1              ;3338
00005c  6821              LDR      r1,[r4,#0]            ;3338
00005e  6008              STR      r0,[r1,#0]            ;3338
                  |L13.96|
000060  6820              LDR      r0,[r4,#0]            ;3342
000062  6800              LDR      r0,[r0,#0]            ;3342
000064  f4206000          BIC      r0,r0,#0x800          ;3342
000068  6821              LDR      r1,[r4,#0]            ;3342
00006a  6008              STR      r0,[r1,#0]            ;3342
00006c  2024              MOVS     r0,#0x24              ;3344
00006e  f884003d          STRB     r0,[r4,#0x3d]         ;3344
000072  2000              MOVS     r0,#0                 ;3345
000074  6420              STR      r0,[r4,#0x40]         ;3345
000076  484f              LDR      r0,|L13.436|
000078  62e0              STR      r0,[r4,#0x2c]         ;3346
00007a  bf00              NOP                            ;3348
                  |L13.124|
00007c  6820              LDR      r0,[r4,#0]            ;3351
00007e  6800              LDR      r0,[r0,#0]            ;3351
000080  f4407080          ORR      r0,r0,#0x100          ;3351
000084  6821              LDR      r1,[r4,#0]            ;3351
000086  6008              STR      r0,[r1,#0]            ;3351
000088  4633              MOV      r3,r6                 ;3354
00008a  2200              MOVS     r2,#0                 ;3354
00008c  f04f1101          MOV      r1,#0x10001           ;3354
000090  4620              MOV      r0,r4                 ;3354
000092  9500              STR      r5,[sp,#0]            ;3354
000094  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000098  b158              CBZ      r0,|L13.178|
00009a  6820              LDR      r0,[r4,#0]            ;3356
00009c  6800              LDR      r0,[r0,#0]            ;3356
00009e  f4007080          AND      r0,r0,#0x100          ;3356
0000a2  f5b07f80          CMP      r0,#0x100             ;3356
0000a6  d102              BNE      |L13.174|
0000a8  f44f7000          MOV      r0,#0x200             ;3358
0000ac  6420              STR      r0,[r4,#0x40]         ;3358
                  |L13.174|
0000ae  2003              MOVS     r0,#3                 ;3360
0000b0  e7be              B        |L13.48|
                  |L13.178|
0000b2  f00700fe          AND      r0,r7,#0xfe           ;3364
0000b6  6821              LDR      r1,[r4,#0]            ;3364
0000b8  6108              STR      r0,[r1,#0x10]         ;3364
0000ba  f7fffffe          BL       HAL_GetTick
0000be  4605              MOV      r5,r0                 ;3368
0000c0  6820              LDR      r0,[r4,#0]            ;3370
0000c2  6940              LDR      r0,[r0,#0x14]         ;3370
0000c4  f3c00a40          UBFX     r10,r0,#1,#1          ;3370
0000c8  6820              LDR      r0,[r4,#0]            ;3371
0000ca  6940              LDR      r0,[r0,#0x14]         ;3371
0000cc  f3c02b80          UBFX     r11,r0,#10,#1         ;3371
0000d0  e010              B        |L13.244|
                  |L13.210|
0000d2  f7fffffe          BL       HAL_GetTick
0000d6  1b40              SUBS     r0,r0,r5              ;3374
0000d8  42b0              CMP      r0,r6                 ;3374
0000da  d800              BHI      |L13.222|
0000dc  b916              CBNZ     r6,|L13.228|
                  |L13.222|
0000de  20a0              MOVS     r0,#0xa0              ;3376
0000e0  f884003d          STRB     r0,[r4,#0x3d]         ;3376
                  |L13.228|
0000e4  6820              LDR      r0,[r4,#0]            ;3378
0000e6  6940              LDR      r0,[r0,#0x14]         ;3378
0000e8  f3c00a40          UBFX     r10,r0,#1,#1          ;3378
0000ec  6820              LDR      r0,[r4,#0]            ;3379
0000ee  6940              LDR      r0,[r0,#0x14]         ;3379
0000f0  f3c02b80          UBFX     r11,r0,#10,#1         ;3379
                  |L13.244|
0000f4  f894003d          LDRB     r0,[r4,#0x3d]         ;3372
0000f8  28a0              CMP      r0,#0xa0              ;3372
0000fa  d005              BEQ      |L13.264|
0000fc  f1ba0f00          CMP      r10,#0                ;3372
000100  d102              BNE      |L13.264|
000102  f1bb0f00          CMP      r11,#0                ;3372
000106  d0e4              BEQ      |L13.210|
                  |L13.264|
000108  2020              MOVS     r0,#0x20              ;3382
00010a  f884003d          STRB     r0,[r4,#0x3d]         ;3382
00010e  6820              LDR      r0,[r4,#0]            ;3385
000110  6940              LDR      r0,[r0,#0x14]         ;3385
000112  f3c00040          UBFX     r0,r0,#1,#1           ;3385
000116  b328              CBZ      r0,|L13.356|
000118  6820              LDR      r0,[r4,#0]            ;3388
00011a  e000              B        |L13.286|
                  |L13.284|
00011c  e045              B        |L13.426|
                  |L13.286|
00011e  6800              LDR      r0,[r0,#0]            ;3388
000120  f4407000          ORR      r0,r0,#0x200          ;3388
000124  6821              LDR      r1,[r4,#0]            ;3388
000126  6008              STR      r0,[r1,#0]            ;3388
000128  bf00              NOP                            ;3391
00012a  2000              MOVS     r0,#0                 ;3391
00012c  9000              STR      r0,[sp,#0]            ;3391
00012e  6820              LDR      r0,[r4,#0]            ;3391
000130  6940              LDR      r0,[r0,#0x14]         ;3391
000132  9000              STR      r0,[sp,#0]            ;3391
000134  6820              LDR      r0,[r4,#0]            ;3391
000136  6980              LDR      r0,[r0,#0x18]         ;3391
000138  9000              STR      r0,[sp,#0]            ;3391
00013a  bf00              NOP                            ;3391
00013c  bf00              NOP                            ;3391
00013e  2319              MOVS     r3,#0x19              ;3394
000140  2201              MOVS     r2,#1                 ;3394
000142  491b              LDR      r1,|L13.432|
000144  4620              MOV      r0,r4                 ;3394
000146  9500              STR      r5,[sp,#0]            ;3394
000148  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00014c  b108              CBZ      r0,|L13.338|
00014e  2001              MOVS     r0,#1                 ;3396
000150  e76e              B        |L13.48|
                  |L13.338|
000152  2020              MOVS     r0,#0x20              ;3399
000154  f884003d          STRB     r0,[r4,#0x3d]         ;3399
000158  bf00              NOP                            ;3402
00015a  2000              MOVS     r0,#0                 ;3402
00015c  f884003c          STRB     r0,[r4,#0x3c]         ;3402
000160  bf00              NOP                            ;3402
000162  e765              B        |L13.48|
                  |L13.356|
000164  6820              LDR      r0,[r4,#0]            ;3409
000166  6800              LDR      r0,[r0,#0]            ;3409
000168  f4407000          ORR      r0,r0,#0x200          ;3409
00016c  6821              LDR      r1,[r4,#0]            ;3409
00016e  6008              STR      r0,[r1,#0]            ;3409
000170  f46f6080          MVN      r0,#0x400             ;3412
000174  6821              LDR      r1,[r4,#0]            ;3412
000176  6148              STR      r0,[r1,#0x14]         ;3412
000178  2319              MOVS     r3,#0x19              ;3415
00017a  2201              MOVS     r2,#1                 ;3415
00017c  490c              LDR      r1,|L13.432|
00017e  4620              MOV      r0,r4                 ;3415
000180  9500              STR      r5,[sp,#0]            ;3415
000182  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000186  b108              CBZ      r0,|L13.396|
000188  2001              MOVS     r0,#1                 ;3417
00018a  e751              B        |L13.48|
                  |L13.396|
00018c  f1090901          ADD      r9,r9,#1              ;3422
000190  45c1              CMP      r9,r8                 ;3424
000192  f4ffaf73          BCC      |L13.124|
000196  2020              MOVS     r0,#0x20              ;3426
000198  f884003d          STRB     r0,[r4,#0x3d]         ;3426
00019c  bf00              NOP                            ;3429
00019e  2000              MOVS     r0,#0                 ;3429
0001a0  f884003c          STRB     r0,[r4,#0x3c]         ;3429
0001a4  bf00              NOP                            ;3429
0001a6  2001              MOVS     r0,#1                 ;3431
0001a8  e742              B        |L13.48|
                  |L13.426|
0001aa  2002              MOVS     r0,#2                 ;3435
0001ac  e740              B        |L13.48|
;;;3438   
                          ENDP

0001ae  0000              DCW      0x0000
                  |L13.432|
                          DCD      0x00100002
                  |L13.436|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_ListenCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ListenCpltCallback PROC
;;;4939     */
;;;4940   __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4941   {
;;;4942     /* Prevent unused argument(s) compilation warning */
;;;4943     UNUSED(hi2c);
;;;4944   
;;;4945     /* NOTE : This function should not be modified, when the callback is needed,
;;;4946               the HAL_I2C_ListenCpltCallback() could be implemented in the user file
;;;4947     */
;;;4948   }
;;;4949   
                          ENDP


                          AREA ||i.HAL_I2C_MasterRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterRxCpltCallback PROC
;;;4872     */
;;;4873   __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4874   {
;;;4875     /* Prevent unused argument(s) compilation warning */
;;;4876     UNUSED(hi2c);
;;;4877   
;;;4878     /* NOTE : This function should not be modified, when the callback is needed,
;;;4879               the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
;;;4880      */
;;;4881   }
;;;4882   
                          ENDP


                          AREA ||i.HAL_I2C_MasterTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterTxCpltCallback PROC
;;;4856     */
;;;4857   __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4858   {
;;;4859     /* Prevent unused argument(s) compilation warning */
;;;4860     UNUSED(hi2c);
;;;4861   
;;;4862     /* NOTE : This function should not be modified, when the callback is needed,
;;;4863               the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
;;;4864      */
;;;4865   }
;;;4866   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Master_Abort_IT PROC
;;;4551     */
;;;4552   HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
000000  b570              PUSH     {r4-r6,lr}
;;;4553   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;4554     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;4555     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
000006  f894503e          LDRB     r5,[r4,#0x3e]
;;;4556   
;;;4557     /* Prevent unused argument(s) compilation warning */
;;;4558     UNUSED(DevAddress);
;;;4559   
;;;4560     /* Abort Master transfer during Receive or Transmit process    */
;;;4561     if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && (CurrentMode == HAL_I2C_MODE_MASTER))
00000a  6820              LDR      r0,[r4,#0]
00000c  6980              LDR      r0,[r0,#0x18]
00000e  f3c00040          UBFX     r0,r0,#1,#1
000012  b378              CBZ      r0,|L17.116|
000014  2d10              CMP      r5,#0x10
000016  d12e              BNE      |L17.118|
;;;4562     {
;;;4563       /* Process Locked */
;;;4564       __HAL_LOCK(hi2c);
000018  bf00              NOP      
00001a  f894003c          LDRB     r0,[r4,#0x3c]
00001e  2801              CMP      r0,#1
000020  d101              BNE      |L17.38|
000022  2002              MOVS     r0,#2
                  |L17.36|
;;;4565   
;;;4566       hi2c->PreviousState = I2C_STATE_NONE;
;;;4567       hi2c->State = HAL_I2C_STATE_ABORT;
;;;4568   
;;;4569       /* Disable Acknowledge */
;;;4570       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4571   
;;;4572       /* Generate Stop */
;;;4573       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;4574   
;;;4575       hi2c->XferCount = 0U;
;;;4576   
;;;4577       /* Disable EVT, BUF and ERR interrupt */
;;;4578       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4579   
;;;4580       /* Process Unlocked */
;;;4581       __HAL_UNLOCK(hi2c);
;;;4582   
;;;4583       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4584       I2C_ITError(hi2c);
;;;4585   
;;;4586       return HAL_OK;
;;;4587     }
;;;4588     else
;;;4589     {
;;;4590       /* Wrong usage of abort function */
;;;4591       /* This function should be used only in case of abort monitored by master device */
;;;4592       /* Or periphal is not in busy state, mean there is no active sequence to be abort */
;;;4593       return HAL_ERROR;
;;;4594     }
;;;4595   }
000024  bd70              POP      {r4-r6,pc}
                  |L17.38|
000026  2001              MOVS     r0,#1                 ;4564
000028  f884003c          STRB     r0,[r4,#0x3c]         ;4564
00002c  bf00              NOP                            ;4564
00002e  2000              MOVS     r0,#0                 ;4566
000030  6320              STR      r0,[r4,#0x30]         ;4566
000032  2060              MOVS     r0,#0x60              ;4567
000034  f884003d          STRB     r0,[r4,#0x3d]         ;4567
000038  6820              LDR      r0,[r4,#0]            ;4570
00003a  6800              LDR      r0,[r0,#0]            ;4570
00003c  f4206080          BIC      r0,r0,#0x400          ;4570
000040  6821              LDR      r1,[r4,#0]            ;4570
000042  6008              STR      r0,[r1,#0]            ;4570
000044  6820              LDR      r0,[r4,#0]            ;4573
000046  6800              LDR      r0,[r0,#0]            ;4573
000048  f4407000          ORR      r0,r0,#0x200          ;4573
00004c  6821              LDR      r1,[r4,#0]            ;4573
00004e  6008              STR      r0,[r1,#0]            ;4573
000050  2000              MOVS     r0,#0                 ;4575
000052  8560              STRH     r0,[r4,#0x2a]         ;4575
000054  6820              LDR      r0,[r4,#0]            ;4578
000056  6840              LDR      r0,[r0,#4]            ;4578
000058  f42060e0          BIC      r0,r0,#0x700          ;4578
00005c  6821              LDR      r1,[r4,#0]            ;4578
00005e  6048              STR      r0,[r1,#4]            ;4578
000060  bf00              NOP                            ;4581
000062  2000              MOVS     r0,#0                 ;4581
000064  f884003c          STRB     r0,[r4,#0x3c]         ;4581
000068  bf00              NOP                            ;4581
00006a  4620              MOV      r0,r4                 ;4584
00006c  f7fffffe          BL       I2C_ITError
000070  2000              MOVS     r0,#0                 ;4586
000072  e7d7              B        |L17.36|
                  |L17.116|
000074  e7ff              B        |L17.118|
                  |L17.118|
000076  2001              MOVS     r0,#1                 ;4593
000078  e7d4              B        |L17.36|
;;;4596   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive PROC
;;;1152     */
;;;1153   HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1154   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e08              LDR      r6,[sp,#0x20]
;;;1155     /* Init tickstart for timeout management*/
;;;1156     uint32_t tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;1157   
;;;1158     if (hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d17d              BNE      |L18.280|
;;;1159     {
;;;1160       /* Wait until BUSY flag is reset */
;;;1161       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001c  2319              MOVS     r3,#0x19
00001e  2201              MOVS     r2,#1
000020  49b2              LDR      r1,|L18.748|
000022  4620              MOV      r0,r4
000024  9500              STR      r5,[sp,#0]
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  b110              CBZ      r0,|L18.50|
;;;1162       {
;;;1163         return HAL_BUSY;
00002c  2002              MOVS     r0,#2
                  |L18.46|
;;;1164       }
;;;1165   
;;;1166       /* Process Locked */
;;;1167       __HAL_LOCK(hi2c);
;;;1168   
;;;1169       /* Check if the I2C is already enabled */
;;;1170       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1171       {
;;;1172         /* Enable I2C peripheral */
;;;1173         __HAL_I2C_ENABLE(hi2c);
;;;1174       }
;;;1175   
;;;1176       /* Disable Pos */
;;;1177       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1178   
;;;1179       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1180       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1181       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1182   
;;;1183       /* Prepare transfer parameters */
;;;1184       hi2c->pBuffPtr    = pData;
;;;1185       hi2c->XferCount   = Size;
;;;1186       hi2c->XferSize    = hi2c->XferCount;
;;;1187       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1188   
;;;1189       /* Send Slave Address */
;;;1190       if (I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;1191       {
;;;1192         return HAL_ERROR;
;;;1193       }
;;;1194   
;;;1195       if (hi2c->XferSize == 0U)
;;;1196       {
;;;1197         /* Clear ADDR flag */
;;;1198         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1199   
;;;1200         /* Generate Stop */
;;;1201         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1202       }
;;;1203       else if (hi2c->XferSize == 1U)
;;;1204       {
;;;1205         /* Disable Acknowledge */
;;;1206         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1207   
;;;1208         /* Clear ADDR flag */
;;;1209         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1210   
;;;1211         /* Generate Stop */
;;;1212         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1213       }
;;;1214       else if (hi2c->XferSize == 2U)
;;;1215       {
;;;1216         /* Disable Acknowledge */
;;;1217         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1218   
;;;1219         /* Enable Pos */
;;;1220         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1221   
;;;1222         /* Clear ADDR flag */
;;;1223         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1224       }
;;;1225       else
;;;1226       {
;;;1227         /* Enable Acknowledge */
;;;1228         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1229   
;;;1230         /* Clear ADDR flag */
;;;1231         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1232       }
;;;1233   
;;;1234       while (hi2c->XferSize > 0U)
;;;1235       {
;;;1236         if (hi2c->XferSize <= 3U)
;;;1237         {
;;;1238           /* One byte */
;;;1239           if (hi2c->XferSize == 1U)
;;;1240           {
;;;1241             /* Wait until RXNE flag is set */
;;;1242             if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1243             {
;;;1244               return HAL_ERROR;
;;;1245             }
;;;1246   
;;;1247             /* Read data from DR */
;;;1248             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1249   
;;;1250             /* Increment Buffer pointer */
;;;1251             hi2c->pBuffPtr++;
;;;1252   
;;;1253             /* Update counter */
;;;1254             hi2c->XferSize--;
;;;1255             hi2c->XferCount--;
;;;1256           }
;;;1257           /* Two bytes */
;;;1258           else if (hi2c->XferSize == 2U)
;;;1259           {
;;;1260             /* Wait until BTF flag is set */
;;;1261             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1262             {
;;;1263               return HAL_ERROR;
;;;1264             }
;;;1265   
;;;1266             /* Generate Stop */
;;;1267             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1268   
;;;1269             /* Read data from DR */
;;;1270             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1271   
;;;1272             /* Increment Buffer pointer */
;;;1273             hi2c->pBuffPtr++;
;;;1274   
;;;1275             /* Update counter */
;;;1276             hi2c->XferSize--;
;;;1277             hi2c->XferCount--;
;;;1278   
;;;1279             /* Read data from DR */
;;;1280             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1281   
;;;1282             /* Increment Buffer pointer */
;;;1283             hi2c->pBuffPtr++;
;;;1284   
;;;1285             /* Update counter */
;;;1286             hi2c->XferSize--;
;;;1287             hi2c->XferCount--;
;;;1288           }
;;;1289           /* 3 Last bytes */
;;;1290           else
;;;1291           {
;;;1292             /* Wait until BTF flag is set */
;;;1293             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1294             {
;;;1295               return HAL_ERROR;
;;;1296             }
;;;1297   
;;;1298             /* Disable Acknowledge */
;;;1299             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1300   
;;;1301             /* Read data from DR */
;;;1302             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1303   
;;;1304             /* Increment Buffer pointer */
;;;1305             hi2c->pBuffPtr++;
;;;1306   
;;;1307             /* Update counter */
;;;1308             hi2c->XferSize--;
;;;1309             hi2c->XferCount--;
;;;1310   
;;;1311             /* Wait until BTF flag is set */
;;;1312             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1313             {
;;;1314               return HAL_ERROR;
;;;1315             }
;;;1316   
;;;1317             /* Generate Stop */
;;;1318             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1319   
;;;1320             /* Read data from DR */
;;;1321             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1322   
;;;1323             /* Increment Buffer pointer */
;;;1324             hi2c->pBuffPtr++;
;;;1325   
;;;1326             /* Update counter */
;;;1327             hi2c->XferSize--;
;;;1328             hi2c->XferCount--;
;;;1329   
;;;1330             /* Read data from DR */
;;;1331             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1332   
;;;1333             /* Increment Buffer pointer */
;;;1334             hi2c->pBuffPtr++;
;;;1335   
;;;1336             /* Update counter */
;;;1337             hi2c->XferSize--;
;;;1338             hi2c->XferCount--;
;;;1339           }
;;;1340         }
;;;1341         else
;;;1342         {
;;;1343           /* Wait until RXNE flag is set */
;;;1344           if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1345           {
;;;1346             return HAL_ERROR;
;;;1347           }
;;;1348   
;;;1349           /* Read data from DR */
;;;1350           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1351   
;;;1352           /* Increment Buffer pointer */
;;;1353           hi2c->pBuffPtr++;
;;;1354   
;;;1355           /* Update counter */
;;;1356           hi2c->XferSize--;
;;;1357           hi2c->XferCount--;
;;;1358   
;;;1359           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;1360           {
;;;1361             /* Read data from DR */
;;;1362             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1363   
;;;1364             /* Increment Buffer pointer */
;;;1365             hi2c->pBuffPtr++;
;;;1366   
;;;1367             /* Update counter */
;;;1368             hi2c->XferSize--;
;;;1369             hi2c->XferCount--;
;;;1370           }
;;;1371         }
;;;1372       }
;;;1373   
;;;1374       hi2c->State = HAL_I2C_STATE_READY;
;;;1375       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1376   
;;;1377       /* Process Unlocked */
;;;1378       __HAL_UNLOCK(hi2c);
;;;1379   
;;;1380       return HAL_OK;
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       return HAL_BUSY;
;;;1385     }
;;;1386   }
00002e  e8bd83f8          POP      {r3-r9,pc}
                  |L18.50|
000032  bf00              NOP                            ;1167
000034  f894003c          LDRB     r0,[r4,#0x3c]         ;1167
000038  2801              CMP      r0,#1                 ;1167
00003a  d101              BNE      |L18.64|
00003c  2002              MOVS     r0,#2                 ;1167
00003e  e7f6              B        |L18.46|
                  |L18.64|
000040  2001              MOVS     r0,#1                 ;1167
000042  f884003c          STRB     r0,[r4,#0x3c]         ;1167
000046  bf00              NOP                            ;1167
000048  6820              LDR      r0,[r4,#0]            ;1170
00004a  6800              LDR      r0,[r0,#0]            ;1170
00004c  f0000001          AND      r0,r0,#1              ;1170
000050  b928              CBNZ     r0,|L18.94|
000052  6820              LDR      r0,[r4,#0]            ;1173
000054  6800              LDR      r0,[r0,#0]            ;1173
000056  f0400001          ORR      r0,r0,#1              ;1173
00005a  6821              LDR      r1,[r4,#0]            ;1173
00005c  6008              STR      r0,[r1,#0]            ;1173
                  |L18.94|
00005e  6820              LDR      r0,[r4,#0]            ;1177
000060  6800              LDR      r0,[r0,#0]            ;1177
000062  f4206000          BIC      r0,r0,#0x800          ;1177
000066  6821              LDR      r1,[r4,#0]            ;1177
000068  6008              STR      r0,[r1,#0]            ;1177
00006a  2022              MOVS     r0,#0x22              ;1179
00006c  f884003d          STRB     r0,[r4,#0x3d]         ;1179
000070  2010              MOVS     r0,#0x10              ;1180
000072  f884003e          STRB     r0,[r4,#0x3e]         ;1180
000076  2000              MOVS     r0,#0                 ;1181
000078  6420              STR      r0,[r4,#0x40]         ;1181
00007a  6267              STR      r7,[r4,#0x24]         ;1184
00007c  f8a4802a          STRH     r8,[r4,#0x2a]         ;1185
000080  8d60              LDRH     r0,[r4,#0x2a]         ;1186
000082  8520              STRH     r0,[r4,#0x28]         ;1186
000084  489a              LDR      r0,|L18.752|
000086  62e0              STR      r0,[r4,#0x2c]         ;1187
000088  462b              MOV      r3,r5                 ;1190
00008a  4632              MOV      r2,r6                 ;1190
00008c  4649              MOV      r1,r9                 ;1190
00008e  4620              MOV      r0,r4                 ;1190
000090  f7fffffe          BL       I2C_MasterRequestRead
000094  b108              CBZ      r0,|L18.154|
000096  2001              MOVS     r0,#1                 ;1192
000098  e7c9              B        |L18.46|
                  |L18.154|
00009a  8d20              LDRH     r0,[r4,#0x28]         ;1195
00009c  b988              CBNZ     r0,|L18.194|
00009e  bf00              NOP                            ;1198
0000a0  2000              MOVS     r0,#0                 ;1198
0000a2  9000              STR      r0,[sp,#0]            ;1198
0000a4  6820              LDR      r0,[r4,#0]            ;1198
0000a6  6940              LDR      r0,[r0,#0x14]         ;1198
0000a8  9000              STR      r0,[sp,#0]            ;1198
0000aa  6820              LDR      r0,[r4,#0]            ;1198
0000ac  6980              LDR      r0,[r0,#0x18]         ;1198
0000ae  9000              STR      r0,[sp,#0]            ;1198
0000b0  bf00              NOP                            ;1198
0000b2  bf00              NOP                            ;1198
0000b4  6820              LDR      r0,[r4,#0]            ;1201
0000b6  6800              LDR      r0,[r0,#0]            ;1201
0000b8  f4407000          ORR      r0,r0,#0x200          ;1201
0000bc  6821              LDR      r1,[r4,#0]            ;1201
0000be  6008              STR      r0,[r1,#0]            ;1201
0000c0  e047              B        |L18.338|
                  |L18.194|
0000c2  8d20              LDRH     r0,[r4,#0x28]         ;1203
0000c4  2801              CMP      r0,#1                 ;1203
0000c6  d117              BNE      |L18.248|
0000c8  6820              LDR      r0,[r4,#0]            ;1206
0000ca  6800              LDR      r0,[r0,#0]            ;1206
0000cc  f4206080          BIC      r0,r0,#0x400          ;1206
0000d0  6821              LDR      r1,[r4,#0]            ;1206
0000d2  6008              STR      r0,[r1,#0]            ;1206
0000d4  bf00              NOP                            ;1209
0000d6  2000              MOVS     r0,#0                 ;1209
0000d8  9000              STR      r0,[sp,#0]            ;1209
0000da  6820              LDR      r0,[r4,#0]            ;1209
0000dc  6940              LDR      r0,[r0,#0x14]         ;1209
0000de  9000              STR      r0,[sp,#0]            ;1209
0000e0  6820              LDR      r0,[r4,#0]            ;1209
0000e2  6980              LDR      r0,[r0,#0x18]         ;1209
0000e4  9000              STR      r0,[sp,#0]            ;1209
0000e6  bf00              NOP                            ;1209
0000e8  bf00              NOP                            ;1209
0000ea  6820              LDR      r0,[r4,#0]            ;1212
0000ec  6800              LDR      r0,[r0,#0]            ;1212
0000ee  f4407000          ORR      r0,r0,#0x200          ;1212
0000f2  6821              LDR      r1,[r4,#0]            ;1212
0000f4  6008              STR      r0,[r1,#0]            ;1212
0000f6  e02c              B        |L18.338|
                  |L18.248|
0000f8  8d20              LDRH     r0,[r4,#0x28]         ;1214
0000fa  2802              CMP      r0,#2                 ;1214
0000fc  d118              BNE      |L18.304|
0000fe  6820              LDR      r0,[r4,#0]            ;1217
000100  6800              LDR      r0,[r0,#0]            ;1217
000102  f4206080          BIC      r0,r0,#0x400          ;1217
000106  6821              LDR      r1,[r4,#0]            ;1217
000108  6008              STR      r0,[r1,#0]            ;1217
00010a  6820              LDR      r0,[r4,#0]            ;1220
00010c  6800              LDR      r0,[r0,#0]            ;1220
00010e  f4406000          ORR      r0,r0,#0x800          ;1220
000112  6821              LDR      r1,[r4,#0]            ;1220
000114  6008              STR      r0,[r1,#0]            ;1220
000116  e000              B        |L18.282|
                  |L18.280|
000118  e0e6              B        |L18.744|
                  |L18.282|
00011a  bf00              NOP                            ;1223
00011c  2000              MOVS     r0,#0                 ;1223
00011e  9000              STR      r0,[sp,#0]            ;1223
000120  6820              LDR      r0,[r4,#0]            ;1223
000122  6940              LDR      r0,[r0,#0x14]         ;1223
000124  9000              STR      r0,[sp,#0]            ;1223
000126  6820              LDR      r0,[r4,#0]            ;1223
000128  6980              LDR      r0,[r0,#0x18]         ;1223
00012a  9000              STR      r0,[sp,#0]            ;1223
00012c  bf00              NOP                            ;1223
00012e  e010              B        |L18.338|
                  |L18.304|
000130  6820              LDR      r0,[r4,#0]            ;1228
000132  6800              LDR      r0,[r0,#0]            ;1228
000134  f4406080          ORR      r0,r0,#0x400          ;1228
000138  6821              LDR      r1,[r4,#0]            ;1228
00013a  6008              STR      r0,[r1,#0]            ;1228
00013c  bf00              NOP                            ;1231
00013e  2000              MOVS     r0,#0                 ;1231
000140  9000              STR      r0,[sp,#0]            ;1231
000142  6820              LDR      r0,[r4,#0]            ;1231
000144  6940              LDR      r0,[r0,#0x14]         ;1231
000146  9000              STR      r0,[sp,#0]            ;1231
000148  6820              LDR      r0,[r4,#0]            ;1231
00014a  6980              LDR      r0,[r0,#0x18]         ;1231
00014c  9000              STR      r0,[sp,#0]            ;1231
00014e  bf00              NOP                            ;1231
000150  bf00              NOP                            ;1231
                  |L18.338|
000152  e0ba              B        |L18.714|
                  |L18.340|
000154  8d20              LDRH     r0,[r4,#0x28]         ;1236
000156  2803              CMP      r0,#3                 ;1236
000158  d87e              BHI      |L18.600|
00015a  8d20              LDRH     r0,[r4,#0x28]         ;1239
00015c  2801              CMP      r0,#1                 ;1239
00015e  d115              BNE      |L18.396|
000160  462a              MOV      r2,r5                 ;1242
000162  4631              MOV      r1,r6                 ;1242
000164  4620              MOV      r0,r4                 ;1242
000166  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
00016a  b108              CBZ      r0,|L18.368|
00016c  2001              MOVS     r0,#1                 ;1244
00016e  e75e              B        |L18.46|
                  |L18.368|
000170  6820              LDR      r0,[r4,#0]            ;1248
000172  6900              LDR      r0,[r0,#0x10]         ;1248
000174  6a61              LDR      r1,[r4,#0x24]         ;1248
000176  7008              STRB     r0,[r1,#0]            ;1248
000178  6a60              LDR      r0,[r4,#0x24]         ;1251
00017a  1c40              ADDS     r0,r0,#1              ;1251
00017c  6260              STR      r0,[r4,#0x24]         ;1251
00017e  8d20              LDRH     r0,[r4,#0x28]         ;1254
000180  1e40              SUBS     r0,r0,#1              ;1254
000182  8520              STRH     r0,[r4,#0x28]         ;1254
000184  8d60              LDRH     r0,[r4,#0x2a]         ;1255
000186  1e40              SUBS     r0,r0,#1              ;1255
000188  8560              STRH     r0,[r4,#0x2a]         ;1255
00018a  e09e              B        |L18.714|
                  |L18.396|
00018c  8d20              LDRH     r0,[r4,#0x28]         ;1258
00018e  2802              CMP      r0,#2                 ;1258
000190  d12a              BNE      |L18.488|
000192  4633              MOV      r3,r6                 ;1261
000194  2200              MOVS     r2,#0                 ;1261
000196  4957              LDR      r1,|L18.756|
000198  4620              MOV      r0,r4                 ;1261
00019a  9500              STR      r5,[sp,#0]            ;1261
00019c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001a0  b108              CBZ      r0,|L18.422|
0001a2  2001              MOVS     r0,#1                 ;1263
0001a4  e743              B        |L18.46|
                  |L18.422|
0001a6  6820              LDR      r0,[r4,#0]            ;1267
0001a8  6800              LDR      r0,[r0,#0]            ;1267
0001aa  f4407000          ORR      r0,r0,#0x200          ;1267
0001ae  6821              LDR      r1,[r4,#0]            ;1267
0001b0  6008              STR      r0,[r1,#0]            ;1267
0001b2  6820              LDR      r0,[r4,#0]            ;1270
0001b4  6900              LDR      r0,[r0,#0x10]         ;1270
0001b6  6a61              LDR      r1,[r4,#0x24]         ;1270
0001b8  7008              STRB     r0,[r1,#0]            ;1270
0001ba  6a60              LDR      r0,[r4,#0x24]         ;1273
0001bc  1c40              ADDS     r0,r0,#1              ;1273
0001be  6260              STR      r0,[r4,#0x24]         ;1273
0001c0  8d20              LDRH     r0,[r4,#0x28]         ;1276
0001c2  1e40              SUBS     r0,r0,#1              ;1276
0001c4  8520              STRH     r0,[r4,#0x28]         ;1276
0001c6  8d60              LDRH     r0,[r4,#0x2a]         ;1277
0001c8  1e40              SUBS     r0,r0,#1              ;1277
0001ca  8560              STRH     r0,[r4,#0x2a]         ;1277
0001cc  6820              LDR      r0,[r4,#0]            ;1280
0001ce  6900              LDR      r0,[r0,#0x10]         ;1280
0001d0  6a61              LDR      r1,[r4,#0x24]         ;1280
0001d2  7008              STRB     r0,[r1,#0]            ;1280
0001d4  6a60              LDR      r0,[r4,#0x24]         ;1283
0001d6  1c40              ADDS     r0,r0,#1              ;1283
0001d8  6260              STR      r0,[r4,#0x24]         ;1283
0001da  8d20              LDRH     r0,[r4,#0x28]         ;1286
0001dc  1e40              SUBS     r0,r0,#1              ;1286
0001de  8520              STRH     r0,[r4,#0x28]         ;1286
0001e0  8d60              LDRH     r0,[r4,#0x2a]         ;1287
0001e2  1e40              SUBS     r0,r0,#1              ;1287
0001e4  8560              STRH     r0,[r4,#0x2a]         ;1287
0001e6  e070              B        |L18.714|
                  |L18.488|
0001e8  4633              MOV      r3,r6                 ;1293
0001ea  2200              MOVS     r2,#0                 ;1293
0001ec  4941              LDR      r1,|L18.756|
0001ee  4620              MOV      r0,r4                 ;1293
0001f0  9500              STR      r5,[sp,#0]            ;1293
0001f2  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001f6  b108              CBZ      r0,|L18.508|
0001f8  2001              MOVS     r0,#1                 ;1295
0001fa  e718              B        |L18.46|
                  |L18.508|
0001fc  6820              LDR      r0,[r4,#0]            ;1299
0001fe  6800              LDR      r0,[r0,#0]            ;1299
000200  f4206080          BIC      r0,r0,#0x400          ;1299
000204  6821              LDR      r1,[r4,#0]            ;1299
000206  6008              STR      r0,[r1,#0]            ;1299
000208  6820              LDR      r0,[r4,#0]            ;1302
00020a  6900              LDR      r0,[r0,#0x10]         ;1302
00020c  6a61              LDR      r1,[r4,#0x24]         ;1302
00020e  7008              STRB     r0,[r1,#0]            ;1302
000210  6a60              LDR      r0,[r4,#0x24]         ;1305
000212  1c40              ADDS     r0,r0,#1              ;1305
000214  6260              STR      r0,[r4,#0x24]         ;1305
000216  8d20              LDRH     r0,[r4,#0x28]         ;1308
000218  1e40              SUBS     r0,r0,#1              ;1308
00021a  8520              STRH     r0,[r4,#0x28]         ;1308
00021c  8d60              LDRH     r0,[r4,#0x2a]         ;1309
00021e  1e40              SUBS     r0,r0,#1              ;1309
000220  8560              STRH     r0,[r4,#0x2a]         ;1309
000222  4633              MOV      r3,r6                 ;1312
000224  2200              MOVS     r2,#0                 ;1312
000226  4933              LDR      r1,|L18.756|
000228  4620              MOV      r0,r4                 ;1312
00022a  9500              STR      r5,[sp,#0]            ;1312
00022c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000230  b108              CBZ      r0,|L18.566|
000232  2001              MOVS     r0,#1                 ;1314
000234  e6fb              B        |L18.46|
                  |L18.566|
000236  6820              LDR      r0,[r4,#0]            ;1318
000238  6800              LDR      r0,[r0,#0]            ;1318
00023a  f4407000          ORR      r0,r0,#0x200          ;1318
00023e  6821              LDR      r1,[r4,#0]            ;1318
000240  6008              STR      r0,[r1,#0]            ;1318
000242  6820              LDR      r0,[r4,#0]            ;1321
000244  6900              LDR      r0,[r0,#0x10]         ;1321
000246  6a61              LDR      r1,[r4,#0x24]         ;1321
000248  7008              STRB     r0,[r1,#0]            ;1321
00024a  6a60              LDR      r0,[r4,#0x24]         ;1324
00024c  1c40              ADDS     r0,r0,#1              ;1324
00024e  6260              STR      r0,[r4,#0x24]         ;1324
000250  8d20              LDRH     r0,[r4,#0x28]         ;1327
000252  1e40              SUBS     r0,r0,#1              ;1327
000254  8520              STRH     r0,[r4,#0x28]         ;1327
000256  e000              B        |L18.602|
                  |L18.600|
000258  e010              B        |L18.636|
                  |L18.602|
00025a  8d60              LDRH     r0,[r4,#0x2a]         ;1328
00025c  1e40              SUBS     r0,r0,#1              ;1328
00025e  8560              STRH     r0,[r4,#0x2a]         ;1328
000260  6820              LDR      r0,[r4,#0]            ;1331
000262  6900              LDR      r0,[r0,#0x10]         ;1331
000264  6a61              LDR      r1,[r4,#0x24]         ;1331
000266  7008              STRB     r0,[r1,#0]            ;1331
000268  6a60              LDR      r0,[r4,#0x24]         ;1334
00026a  1c40              ADDS     r0,r0,#1              ;1334
00026c  6260              STR      r0,[r4,#0x24]         ;1334
00026e  8d20              LDRH     r0,[r4,#0x28]         ;1337
000270  1e40              SUBS     r0,r0,#1              ;1337
000272  8520              STRH     r0,[r4,#0x28]         ;1337
000274  8d60              LDRH     r0,[r4,#0x2a]         ;1338
000276  1e40              SUBS     r0,r0,#1              ;1338
000278  8560              STRH     r0,[r4,#0x2a]         ;1338
00027a  e026              B        |L18.714|
                  |L18.636|
00027c  462a              MOV      r2,r5                 ;1344
00027e  4631              MOV      r1,r6                 ;1344
000280  4620              MOV      r0,r4                 ;1344
000282  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000286  b108              CBZ      r0,|L18.652|
000288  2001              MOVS     r0,#1                 ;1346
00028a  e6d0              B        |L18.46|
                  |L18.652|
00028c  6820              LDR      r0,[r4,#0]            ;1350
00028e  6900              LDR      r0,[r0,#0x10]         ;1350
000290  6a61              LDR      r1,[r4,#0x24]         ;1350
000292  7008              STRB     r0,[r1,#0]            ;1350
000294  6a60              LDR      r0,[r4,#0x24]         ;1353
000296  1c40              ADDS     r0,r0,#1              ;1353
000298  6260              STR      r0,[r4,#0x24]         ;1353
00029a  8d20              LDRH     r0,[r4,#0x28]         ;1356
00029c  1e40              SUBS     r0,r0,#1              ;1356
00029e  8520              STRH     r0,[r4,#0x28]         ;1356
0002a0  8d60              LDRH     r0,[r4,#0x2a]         ;1357
0002a2  1e40              SUBS     r0,r0,#1              ;1357
0002a4  8560              STRH     r0,[r4,#0x2a]         ;1357
0002a6  6820              LDR      r0,[r4,#0]            ;1359
0002a8  6940              LDR      r0,[r0,#0x14]         ;1359
0002aa  f3c00080          UBFX     r0,r0,#2,#1           ;1359
0002ae  b160              CBZ      r0,|L18.714|
0002b0  6820              LDR      r0,[r4,#0]            ;1362
0002b2  6900              LDR      r0,[r0,#0x10]         ;1362
0002b4  6a61              LDR      r1,[r4,#0x24]         ;1362
0002b6  7008              STRB     r0,[r1,#0]            ;1362
0002b8  6a60              LDR      r0,[r4,#0x24]         ;1365
0002ba  1c40              ADDS     r0,r0,#1              ;1365
0002bc  6260              STR      r0,[r4,#0x24]         ;1365
0002be  8d20              LDRH     r0,[r4,#0x28]         ;1368
0002c0  1e40              SUBS     r0,r0,#1              ;1368
0002c2  8520              STRH     r0,[r4,#0x28]         ;1368
0002c4  8d60              LDRH     r0,[r4,#0x2a]         ;1369
0002c6  1e40              SUBS     r0,r0,#1              ;1369
0002c8  8560              STRH     r0,[r4,#0x2a]         ;1369
                  |L18.714|
0002ca  8d20              LDRH     r0,[r4,#0x28]         ;1234
0002cc  2800              CMP      r0,#0                 ;1234
0002ce  f47faf41          BNE      |L18.340|
0002d2  2020              MOVS     r0,#0x20              ;1374
0002d4  f884003d          STRB     r0,[r4,#0x3d]         ;1374
0002d8  2000              MOVS     r0,#0                 ;1375
0002da  f884003e          STRB     r0,[r4,#0x3e]         ;1375
0002de  bf00              NOP                            ;1378
0002e0  f884003c          STRB     r0,[r4,#0x3c]         ;1378
0002e4  bf00              NOP                            ;1378
0002e6  e6a2              B        |L18.46|
                  |L18.744|
0002e8  2002              MOVS     r0,#2                 ;1384
0002ea  e6a0              B        |L18.46|
;;;1387   
                          ENDP

                  |L18.748|
                          DCD      0x00100002
                  |L18.752|
                          DCD      0xffff0000
                  |L18.756|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Master_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_DMA PROC
;;;2076     */
;;;2077   HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2078   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;2079     __IO uint32_t count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;2080     HAL_StatusTypeDef dmaxferstatus;
;;;2081   
;;;2082     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d17d              BNE      |L19.276|
;;;2083     {
;;;2084       /* Wait until BUSY flag is reset */
;;;2085       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000018  4861              LDR      r0,|L19.416|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  2119              MOVS     r1,#0x19
00001e  fbb0f0f1          UDIV     r0,r0,r1
000022  f44f717a          MOV      r1,#0x3e8
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  eb0001c0          ADD      r1,r0,r0,LSL #3
00002e  eb011000          ADD      r0,r1,r0,LSL #4
000032  9000              STR      r0,[sp,#0]
;;;2086       do
000034  bf00              NOP      
                  |L19.54|
;;;2087       {
;;;2088         count--;
000036  9800              LDR      r0,[sp,#0]
000038  1e40              SUBS     r0,r0,#1
00003a  9000              STR      r0,[sp,#0]
;;;2089         if (count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b998              CBNZ     r0,|L19.104|
;;;2090         {
;;;2091           hi2c->PreviousState       = I2C_STATE_NONE;
000040  2000              MOVS     r0,#0
000042  6320              STR      r0,[r4,#0x30]
;;;2092           hi2c->State               = HAL_I2C_STATE_READY;
000044  2020              MOVS     r0,#0x20
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;2093           hi2c->Mode                = HAL_I2C_MODE_NONE;
00004a  2000              MOVS     r0,#0
00004c  f884003e          STRB     r0,[r4,#0x3e]
;;;2094           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000050  6c20              LDR      r0,[r4,#0x40]
000052  f0400020          ORR      r0,r0,#0x20
000056  6420              STR      r0,[r4,#0x40]
;;;2095   
;;;2096           /* Process Unlocked */
;;;2097           __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
;;;2098   
;;;2099           return HAL_ERROR;
000062  2001              MOVS     r0,#1
                  |L19.100|
;;;2100         }
;;;2101       }
;;;2102       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2103   
;;;2104       /* Process Locked */
;;;2105       __HAL_LOCK(hi2c);
;;;2106   
;;;2107       /* Check if the I2C is already enabled */
;;;2108       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2109       {
;;;2110         /* Enable I2C peripheral */
;;;2111         __HAL_I2C_ENABLE(hi2c);
;;;2112       }
;;;2113   
;;;2114       /* Disable Pos */
;;;2115       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2116   
;;;2117       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2118       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;2119       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2120   
;;;2121       /* Prepare transfer parameters */
;;;2122       hi2c->pBuffPtr    = pData;
;;;2123       hi2c->XferCount   = Size;
;;;2124       hi2c->XferSize    = hi2c->XferCount;
;;;2125       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2126       hi2c->Devaddress  = DevAddress;
;;;2127   
;;;2128       if (hi2c->XferSize > 0U)
;;;2129       {
;;;2130         /* Set the I2C DMA transfer complete callback */
;;;2131         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2132   
;;;2133         /* Set the DMA error callback */
;;;2134         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2135   
;;;2136         /* Set the unused DMA callbacks to NULL */
;;;2137         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2138         hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;2139         hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;2140         hi2c->hdmarx->XferAbortCallback = NULL;
;;;2141   
;;;2142         /* Enable the DMA stream */
;;;2143         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2144   
;;;2145         if (dmaxferstatus == HAL_OK)
;;;2146         {
;;;2147           /* Enable Acknowledge */
;;;2148           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2149   
;;;2150           /* Generate Start */
;;;2151           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2152   
;;;2153           /* Process Unlocked */
;;;2154           __HAL_UNLOCK(hi2c);
;;;2155   
;;;2156           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2157           to avoid the risk of I2C interrupt handle execution before current
;;;2158           process unlock */
;;;2159   
;;;2160           /* Enable EVT and ERR interrupt */
;;;2161           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2162   
;;;2163           /* Enable DMA Request */
;;;2164           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2165         }
;;;2166         else
;;;2167         {
;;;2168           /* Update I2C state */
;;;2169           hi2c->State     = HAL_I2C_STATE_READY;
;;;2170           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2171   
;;;2172           /* Update I2C error code */
;;;2173           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2174   
;;;2175           /* Process Unlocked */
;;;2176           __HAL_UNLOCK(hi2c);
;;;2177   
;;;2178           return HAL_ERROR;
;;;2179         }
;;;2180       }
;;;2181       else
;;;2182       {
;;;2183         /* Enable Acknowledge */
;;;2184         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2185   
;;;2186         /* Generate Start */
;;;2187         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2188   
;;;2189         /* Process Unlocked */
;;;2190         __HAL_UNLOCK(hi2c);
;;;2191   
;;;2192         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2193         to avoid the risk of I2C interrupt handle execution before current
;;;2194         process unlock */
;;;2195   
;;;2196         /* Enable EVT, BUF and ERR interrupt */
;;;2197         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2198       }
;;;2199   
;;;2200       return HAL_OK;
;;;2201     }
;;;2202     else
;;;2203     {
;;;2204       return HAL_BUSY;
;;;2205     }
;;;2206   }
000064  e8bd83f8          POP      {r3-r9,pc}
                  |L19.104|
000068  6820              LDR      r0,[r4,#0]            ;2102
00006a  6980              LDR      r0,[r0,#0x18]         ;2102
00006c  f3c00040          UBFX     r0,r0,#1,#1           ;2102
000070  2800              CMP      r0,#0                 ;2102
000072  d1e0              BNE      |L19.54|
000074  bf00              NOP                            ;2105
000076  f894003c          LDRB     r0,[r4,#0x3c]         ;2105
00007a  2801              CMP      r0,#1                 ;2105
00007c  d101              BNE      |L19.130|
00007e  2002              MOVS     r0,#2                 ;2105
000080  e7f0              B        |L19.100|
                  |L19.130|
000082  2001              MOVS     r0,#1                 ;2105
000084  f884003c          STRB     r0,[r4,#0x3c]         ;2105
000088  bf00              NOP                            ;2105
00008a  6820              LDR      r0,[r4,#0]            ;2108
00008c  6800              LDR      r0,[r0,#0]            ;2108
00008e  f0000001          AND      r0,r0,#1              ;2108
000092  b928              CBNZ     r0,|L19.160|
000094  6820              LDR      r0,[r4,#0]            ;2111
000096  6800              LDR      r0,[r0,#0]            ;2111
000098  f0400001          ORR      r0,r0,#1              ;2111
00009c  6821              LDR      r1,[r4,#0]            ;2111
00009e  6008              STR      r0,[r1,#0]            ;2111
                  |L19.160|
0000a0  6820              LDR      r0,[r4,#0]            ;2115
0000a2  6800              LDR      r0,[r0,#0]            ;2115
0000a4  f4206000          BIC      r0,r0,#0x800          ;2115
0000a8  6821              LDR      r1,[r4,#0]            ;2115
0000aa  6008              STR      r0,[r1,#0]            ;2115
0000ac  2022              MOVS     r0,#0x22              ;2117
0000ae  f884003d          STRB     r0,[r4,#0x3d]         ;2117
0000b2  2010              MOVS     r0,#0x10              ;2118
0000b4  f884003e          STRB     r0,[r4,#0x3e]         ;2118
0000b8  2000              MOVS     r0,#0                 ;2119
0000ba  6420              STR      r0,[r4,#0x40]         ;2119
0000bc  6267              STR      r7,[r4,#0x24]         ;2122
0000be  f8a4802a          STRH     r8,[r4,#0x2a]         ;2123
0000c2  8d60              LDRH     r0,[r4,#0x2a]         ;2124
0000c4  8520              STRH     r0,[r4,#0x28]         ;2124
0000c6  4837              LDR      r0,|L19.420|
0000c8  62e0              STR      r0,[r4,#0x2c]         ;2125
0000ca  6466              STR      r6,[r4,#0x44]         ;2126
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;2128
0000ce  2800              CMP      r0,#0                 ;2128
0000d0  d04a              BEQ      |L19.360|
0000d2  4835              LDR      r0,|L19.424|
0000d4  6ba1              LDR      r1,[r4,#0x38]         ;2131
0000d6  63c8              STR      r0,[r1,#0x3c]         ;2131
0000d8  4834              LDR      r0,|L19.428|
0000da  6ba1              LDR      r1,[r4,#0x38]         ;2134
0000dc  64c8              STR      r0,[r1,#0x4c]         ;2134
0000de  2000              MOVS     r0,#0                 ;2137
0000e0  6ba1              LDR      r1,[r4,#0x38]         ;2137
0000e2  6408              STR      r0,[r1,#0x40]         ;2137
0000e4  6ba1              LDR      r1,[r4,#0x38]         ;2138
0000e6  6448              STR      r0,[r1,#0x44]         ;2138
0000e8  6ba1              LDR      r1,[r4,#0x38]         ;2139
0000ea  6488              STR      r0,[r1,#0x48]         ;2139
0000ec  6ba1              LDR      r1,[r4,#0x38]         ;2140
0000ee  6508              STR      r0,[r1,#0x50]         ;2140
0000f0  8d23              LDRH     r3,[r4,#0x28]         ;2143
0000f2  f8d4c000          LDR      r12,[r4,#0]           ;2143
0000f6  f10c0110          ADD      r1,r12,#0x10          ;2143
0000fa  6a62              LDR      r2,[r4,#0x24]         ;2143
0000fc  6ba0              LDR      r0,[r4,#0x38]         ;2143
0000fe  f7fffffe          BL       HAL_DMA_Start_IT
000102  4605              MOV      r5,r0                 ;2143
000104  b9fd              CBNZ     r5,|L19.326|
000106  6820              LDR      r0,[r4,#0]            ;2148
000108  6800              LDR      r0,[r0,#0]            ;2148
00010a  f4406080          ORR      r0,r0,#0x400          ;2148
00010e  6821              LDR      r1,[r4,#0]            ;2148
000110  6008              STR      r0,[r1,#0]            ;2148
000112  e000              B        |L19.278|
                  |L19.276|
000114  e041              B        |L19.410|
                  |L19.278|
000116  6820              LDR      r0,[r4,#0]            ;2151
000118  6800              LDR      r0,[r0,#0]            ;2151
00011a  f4407080          ORR      r0,r0,#0x100          ;2151
00011e  6821              LDR      r1,[r4,#0]            ;2151
000120  6008              STR      r0,[r1,#0]            ;2151
000122  bf00              NOP                            ;2154
000124  2000              MOVS     r0,#0                 ;2154
000126  f884003c          STRB     r0,[r4,#0x3c]         ;2154
00012a  bf00              NOP                            ;2154
00012c  6820              LDR      r0,[r4,#0]            ;2161
00012e  6840              LDR      r0,[r0,#4]            ;2161
000130  f4407040          ORR      r0,r0,#0x300          ;2161
000134  6821              LDR      r1,[r4,#0]            ;2161
000136  6048              STR      r0,[r1,#4]            ;2161
000138  6820              LDR      r0,[r4,#0]            ;2164
00013a  6840              LDR      r0,[r0,#4]            ;2164
00013c  f4406000          ORR      r0,r0,#0x800          ;2164
000140  6821              LDR      r1,[r4,#0]            ;2164
000142  6048              STR      r0,[r1,#4]            ;2164
000144  e027              B        |L19.406|
                  |L19.326|
000146  2020              MOVS     r0,#0x20              ;2169
000148  f884003d          STRB     r0,[r4,#0x3d]         ;2169
00014c  2000              MOVS     r0,#0                 ;2170
00014e  f884003e          STRB     r0,[r4,#0x3e]         ;2170
000152  6c20              LDR      r0,[r4,#0x40]         ;2173
000154  f0400010          ORR      r0,r0,#0x10           ;2173
000158  6420              STR      r0,[r4,#0x40]         ;2173
00015a  bf00              NOP                            ;2176
00015c  2000              MOVS     r0,#0                 ;2176
00015e  f884003c          STRB     r0,[r4,#0x3c]         ;2176
000162  bf00              NOP                            ;2176
000164  2001              MOVS     r0,#1                 ;2178
000166  e77d              B        |L19.100|
                  |L19.360|
000168  6820              LDR      r0,[r4,#0]            ;2184
00016a  6800              LDR      r0,[r0,#0]            ;2184
00016c  f4406080          ORR      r0,r0,#0x400          ;2184
000170  6821              LDR      r1,[r4,#0]            ;2184
000172  6008              STR      r0,[r1,#0]            ;2184
000174  6820              LDR      r0,[r4,#0]            ;2187
000176  6800              LDR      r0,[r0,#0]            ;2187
000178  f4407080          ORR      r0,r0,#0x100          ;2187
00017c  6821              LDR      r1,[r4,#0]            ;2187
00017e  6008              STR      r0,[r1,#0]            ;2187
000180  bf00              NOP                            ;2190
000182  2000              MOVS     r0,#0                 ;2190
000184  f884003c          STRB     r0,[r4,#0x3c]         ;2190
000188  bf00              NOP                            ;2190
00018a  6820              LDR      r0,[r4,#0]            ;2197
00018c  6840              LDR      r0,[r0,#4]            ;2197
00018e  f44060e0          ORR      r0,r0,#0x700          ;2197
000192  6821              LDR      r1,[r4,#0]            ;2197
000194  6048              STR      r0,[r1,#4]            ;2197
                  |L19.406|
000196  2000              MOVS     r0,#0                 ;2200
000198  e764              B        |L19.100|
                  |L19.410|
00019a  2002              MOVS     r0,#2                 ;2204
00019c  e762              B        |L19.100|
;;;2207   
                          ENDP

00019e  0000              DCW      0x0000
                  |L19.416|
                          DCD      SystemCoreClock
                  |L19.420|
                          DCD      0xffff0000
                  |L19.424|
                          DCD      I2C_DMAXferCplt
                  |L19.428|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_IT PROC
;;;1727     */
;;;1728   HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;1729   {
000002  4604              MOV      r4,r0
;;;1730     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1731   
;;;1732     if (hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d171              BNE      |L20.244|
;;;1733     {
;;;1734       /* Wait until BUSY flag is reset */
;;;1735       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000010  4839              LDR      r0,|L20.248|
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  2519              MOVS     r5,#0x19
000016  fbb0f0f5          UDIV     r0,r0,r5
00001a  f44f757a          MOV      r5,#0x3e8
00001e  fbb0f0f5          UDIV     r0,r0,r5
000022  eb0005c0          ADD      r5,r0,r0,LSL #3
000026  eb051000          ADD      r0,r5,r0,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;1736       do
00002c  bf00              NOP      
                  |L20.46|
;;;1737       {
;;;1738         count--;
00002e  9800              LDR      r0,[sp,#0]
000030  1e40              SUBS     r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;1739         if (count == 0U)
000034  9800              LDR      r0,[sp,#0]
000036  b990              CBNZ     r0,|L20.94|
;;;1740         {
;;;1741           hi2c->PreviousState       = I2C_STATE_NONE;
000038  2000              MOVS     r0,#0
00003a  6320              STR      r0,[r4,#0x30]
;;;1742           hi2c->State               = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;1743           hi2c->Mode                = HAL_I2C_MODE_NONE;
000042  2000              MOVS     r0,#0
000044  f884003e          STRB     r0,[r4,#0x3e]
;;;1744           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000048  6c20              LDR      r0,[r4,#0x40]
00004a  f0400020          ORR      r0,r0,#0x20
00004e  6420              STR      r0,[r4,#0x40]
;;;1745   
;;;1746           /* Process Unlocked */
;;;1747           __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2000              MOVS     r0,#0
000054  f884003c          STRB     r0,[r4,#0x3c]
000058  bf00              NOP      
;;;1748   
;;;1749           return HAL_ERROR;
00005a  2001              MOVS     r0,#1
                  |L20.92|
;;;1750         }
;;;1751       }
;;;1752       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1753   
;;;1754       /* Process Locked */
;;;1755       __HAL_LOCK(hi2c);
;;;1756   
;;;1757       /* Check if the I2C is already enabled */
;;;1758       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1759       {
;;;1760         /* Enable I2C peripheral */
;;;1761         __HAL_I2C_ENABLE(hi2c);
;;;1762       }
;;;1763   
;;;1764       /* Disable Pos */
;;;1765       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1766   
;;;1767       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1768       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1769       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1770   
;;;1771       /* Prepare transfer parameters */
;;;1772       hi2c->pBuffPtr    = pData;
;;;1773       hi2c->XferCount   = Size;
;;;1774       hi2c->XferSize    = hi2c->XferCount;
;;;1775       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1776       hi2c->Devaddress  = DevAddress;
;;;1777   
;;;1778       /* Enable Acknowledge */
;;;1779       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1780   
;;;1781       /* Generate Start */
;;;1782       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;1783   
;;;1784       /* Process Unlocked */
;;;1785       __HAL_UNLOCK(hi2c);
;;;1786   
;;;1787       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1788       to avoid the risk of I2C interrupt handle execution before current
;;;1789       process unlock */
;;;1790   
;;;1791       /* Enable EVT, BUF and ERR interrupt */
;;;1792       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1793   
;;;1794       return HAL_OK;
;;;1795     }
;;;1796     else
;;;1797     {
;;;1798       return HAL_BUSY;
;;;1799     }
;;;1800   }
00005c  bd38              POP      {r3-r5,pc}
                  |L20.94|
00005e  6820              LDR      r0,[r4,#0]            ;1752
000060  6980              LDR      r0,[r0,#0x18]         ;1752
000062  f3c00040          UBFX     r0,r0,#1,#1           ;1752
000066  2800              CMP      r0,#0                 ;1752
000068  d1e1              BNE      |L20.46|
00006a  bf00              NOP                            ;1755
00006c  f894003c          LDRB     r0,[r4,#0x3c]         ;1755
000070  2801              CMP      r0,#1                 ;1755
000072  d101              BNE      |L20.120|
000074  2002              MOVS     r0,#2                 ;1755
000076  e7f1              B        |L20.92|
                  |L20.120|
000078  2001              MOVS     r0,#1                 ;1755
00007a  f884003c          STRB     r0,[r4,#0x3c]         ;1755
00007e  bf00              NOP                            ;1755
000080  6820              LDR      r0,[r4,#0]            ;1758
000082  6800              LDR      r0,[r0,#0]            ;1758
000084  f0000001          AND      r0,r0,#1              ;1758
000088  b928              CBNZ     r0,|L20.150|
00008a  6820              LDR      r0,[r4,#0]            ;1761
00008c  6800              LDR      r0,[r0,#0]            ;1761
00008e  f0400001          ORR      r0,r0,#1              ;1761
000092  6825              LDR      r5,[r4,#0]            ;1761
000094  6028              STR      r0,[r5,#0]            ;1761
                  |L20.150|
000096  6820              LDR      r0,[r4,#0]            ;1765
000098  6800              LDR      r0,[r0,#0]            ;1765
00009a  f4206000          BIC      r0,r0,#0x800          ;1765
00009e  6825              LDR      r5,[r4,#0]            ;1765
0000a0  6028              STR      r0,[r5,#0]            ;1765
0000a2  2022              MOVS     r0,#0x22              ;1767
0000a4  f884003d          STRB     r0,[r4,#0x3d]         ;1767
0000a8  2010              MOVS     r0,#0x10              ;1768
0000aa  f884003e          STRB     r0,[r4,#0x3e]         ;1768
0000ae  2000              MOVS     r0,#0                 ;1769
0000b0  6420              STR      r0,[r4,#0x40]         ;1769
0000b2  6262              STR      r2,[r4,#0x24]         ;1772
0000b4  8563              STRH     r3,[r4,#0x2a]         ;1773
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1774
0000b8  8520              STRH     r0,[r4,#0x28]         ;1774
0000ba  4810              LDR      r0,|L20.252|
0000bc  62e0              STR      r0,[r4,#0x2c]         ;1775
0000be  6461              STR      r1,[r4,#0x44]         ;1776
0000c0  6820              LDR      r0,[r4,#0]            ;1779
0000c2  6800              LDR      r0,[r0,#0]            ;1779
0000c4  f4406080          ORR      r0,r0,#0x400          ;1779
0000c8  6825              LDR      r5,[r4,#0]            ;1779
0000ca  6028              STR      r0,[r5,#0]            ;1779
0000cc  6820              LDR      r0,[r4,#0]            ;1782
0000ce  6800              LDR      r0,[r0,#0]            ;1782
0000d0  f4407080          ORR      r0,r0,#0x100          ;1782
0000d4  6825              LDR      r5,[r4,#0]            ;1782
0000d6  6028              STR      r0,[r5,#0]            ;1782
0000d8  bf00              NOP                            ;1785
0000da  2000              MOVS     r0,#0                 ;1785
0000dc  f884003c          STRB     r0,[r4,#0x3c]         ;1785
0000e0  bf00              NOP                            ;1785
0000e2  6820              LDR      r0,[r4,#0]            ;1792
0000e4  6840              LDR      r0,[r0,#4]            ;1792
0000e6  f44060e0          ORR      r0,r0,#0x700          ;1792
0000ea  6825              LDR      r5,[r4,#0]            ;1792
0000ec  6068              STR      r0,[r5,#4]            ;1792
0000ee  2000              MOVS     r0,#0                 ;1794
0000f0  e7b4              B        |L20.92|
0000f2  e7ff              B        |L20.244|
                  |L20.244|
0000f4  2002              MOVS     r0,#2                 ;1798
0000f6  e7b1              B        |L20.92|
;;;1801   
                          ENDP

                  |L20.248|
                          DCD      SystemCoreClock
                  |L20.252|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_DMA PROC
;;;3838     */
;;;3839   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3840   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;3841     __IO uint32_t Prev_State = 0x00U;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;3842     __IO uint32_t count = 0U;
000012  9000              STR      r0,[sp,#0]
;;;3843     uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000014  f44f6ae0          MOV      r10,#0x700
;;;3844     HAL_StatusTypeDef dmaxferstatus;
;;;3845   
;;;3846     /* Check the parameters */
;;;3847     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3848   
;;;3849     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d17c              BNE      |L21.282|
;;;3850     {
;;;3851       /* Check Busy Flag only if FIRST call of Master interface */
;;;3852       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f4007000          AND      r0,r0,#0x200
000028  f5b07f00          CMP      r0,#0x200
00002c  d003              BEQ      |L21.54|
00002e  2d08              CMP      r5,#8
000030  d001              BEQ      |L21.54|
000032  2d01              CMP      r5,#1
000034  d12d              BNE      |L21.146|
                  |L21.54|
;;;3853       {
;;;3854         /* Wait until BUSY flag is reset */
;;;3855         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000036  4891              LDR      r0,|L21.636|
000038  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00003a  2119              MOVS     r1,#0x19
00003c  fbb0f0f1          UDIV     r0,r0,r1
000040  f44f717a          MOV      r1,#0x3e8
000044  fbb0f0f1          UDIV     r0,r0,r1
000048  eb0001c0          ADD      r1,r0,r0,LSL #3
00004c  eb011000          ADD      r0,r1,r0,LSL #4
000050  9000              STR      r0,[sp,#0]
;;;3856         do
000052  bf00              NOP      
                  |L21.84|
;;;3857         {
;;;3858           count--;
000054  9800              LDR      r0,[sp,#0]
000056  1e40              SUBS     r0,r0,#1
000058  9000              STR      r0,[sp,#0]
;;;3859           if (count == 0U)
00005a  9800              LDR      r0,[sp,#0]
00005c  b998              CBNZ     r0,|L21.134|
;;;3860           {
;;;3861             hi2c->PreviousState       = I2C_STATE_NONE;
00005e  2000              MOVS     r0,#0
000060  6320              STR      r0,[r4,#0x30]
;;;3862             hi2c->State               = HAL_I2C_STATE_READY;
000062  2020              MOVS     r0,#0x20
000064  f884003d          STRB     r0,[r4,#0x3d]
;;;3863             hi2c->Mode                = HAL_I2C_MODE_NONE;
000068  2000              MOVS     r0,#0
00006a  f884003e          STRB     r0,[r4,#0x3e]
;;;3864             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00006e  6c20              LDR      r0,[r4,#0x40]
000070  f0400020          ORR      r0,r0,#0x20
000074  6420              STR      r0,[r4,#0x40]
;;;3865   
;;;3866             /* Process Unlocked */
;;;3867             __HAL_UNLOCK(hi2c);
000076  bf00              NOP      
000078  2000              MOVS     r0,#0
00007a  f884003c          STRB     r0,[r4,#0x3c]
00007e  bf00              NOP      
;;;3868   
;;;3869             return HAL_ERROR;
000080  2001              MOVS     r0,#1
                  |L21.130|
;;;3870           }
;;;3871         }
;;;3872         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3873       }
;;;3874   
;;;3875       /* Process Locked */
;;;3876       __HAL_LOCK(hi2c);
;;;3877   
;;;3878       /* Check if the I2C is already enabled */
;;;3879       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3880       {
;;;3881         /* Enable I2C peripheral */
;;;3882         __HAL_I2C_ENABLE(hi2c);
;;;3883       }
;;;3884   
;;;3885       /* Disable Pos */
;;;3886       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3887   
;;;3888       /* Clear Last DMA bit */
;;;3889       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3890   
;;;3891       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3892       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3893       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3894   
;;;3895       /* Prepare transfer parameters */
;;;3896       hi2c->pBuffPtr    = pData;
;;;3897       hi2c->XferCount   = Size;
;;;3898       hi2c->XferSize    = hi2c->XferCount;
;;;3899       hi2c->XferOptions = XferOptions;
;;;3900       hi2c->Devaddress  = DevAddress;
;;;3901   
;;;3902       Prev_State = hi2c->PreviousState;
;;;3903   
;;;3904       if (hi2c->XferSize > 0U)
;;;3905       {
;;;3906         if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
;;;3907         {
;;;3908           if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
;;;3909           {
;;;3910             /* Disable Acknowledge */
;;;3911             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3912   
;;;3913             /* Enable Pos */
;;;3914             SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3915   
;;;3916             /* Enable Last DMA bit */
;;;3917             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3918           }
;;;3919           else
;;;3920           {
;;;3921             /* Enable Acknowledge */
;;;3922             SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3923           }
;;;3924         }
;;;3925         else
;;;3926         {
;;;3927           /* Enable Acknowledge */
;;;3928           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3929   
;;;3930           if ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_OTHER_AND_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;3931           {
;;;3932             /* Enable Last DMA bit */
;;;3933             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3934           }
;;;3935         }
;;;3936   
;;;3937         /* Set the I2C DMA transfer complete callback */
;;;3938         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;3939   
;;;3940         /* Set the DMA error callback */
;;;3941         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;3942   
;;;3943         /* Set the unused DMA callbacks to NULL */
;;;3944         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;3945         hi2c->hdmarx->XferAbortCallback = NULL;
;;;3946   
;;;3947         /* Enable the DMA stream */
;;;3948         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;3949   
;;;3950         if (dmaxferstatus == HAL_OK)
;;;3951         {
;;;3952           /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3953           /* Mean Previous state is same as current state */
;;;3954           if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3955           {
;;;3956             /* Generate Start */
;;;3957             SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3958   
;;;3959             /* Update interrupt for only EVT and ERR */
;;;3960             enableIT = (I2C_IT_EVT | I2C_IT_ERR);
;;;3961           }
;;;3962           else
;;;3963           {
;;;3964             /* Update interrupt for only ERR */
;;;3965             enableIT = I2C_IT_ERR;
;;;3966           }
;;;3967   
;;;3968           /* Process Unlocked */
;;;3969           __HAL_UNLOCK(hi2c);
;;;3970   
;;;3971           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3972           to avoid the risk of I2C interrupt handle execution before current
;;;3973           process unlock */
;;;3974   
;;;3975           /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
;;;3976           /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
;;;3977           if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;3978           {
;;;3979             /* Enable DMA Request */
;;;3980             SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3981           }
;;;3982   
;;;3983           /* Enable EVT and ERR interrupt */
;;;3984           __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;3985         }
;;;3986         else
;;;3987         {
;;;3988           /* Update I2C state */
;;;3989           hi2c->State     = HAL_I2C_STATE_READY;
;;;3990           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3991   
;;;3992           /* Update I2C error code */
;;;3993           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3994   
;;;3995           /* Process Unlocked */
;;;3996           __HAL_UNLOCK(hi2c);
;;;3997   
;;;3998           return HAL_ERROR;
;;;3999         }
;;;4000       }
;;;4001       else
;;;4002       {
;;;4003         /* Enable Acknowledge */
;;;4004         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4005   
;;;4006         /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;4007         /* Mean Previous state is same as current state */
;;;4008         if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;4009         {
;;;4010           /* Generate Start */
;;;4011           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;4012         }
;;;4013   
;;;4014         /* Process Unlocked */
;;;4015         __HAL_UNLOCK(hi2c);
;;;4016   
;;;4017         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4018         to avoid the risk of I2C interrupt handle execution before current
;;;4019         process unlock */
;;;4020   
;;;4021         /* Enable interrupts */
;;;4022         __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;4023       }
;;;4024       return HAL_OK;
;;;4025     }
;;;4026     else
;;;4027     {
;;;4028       return HAL_BUSY;
;;;4029     }
;;;4030   }
000082  e8bd87fc          POP      {r2-r10,pc}
                  |L21.134|
000086  6820              LDR      r0,[r4,#0]            ;3872
000088  6980              LDR      r0,[r0,#0x18]         ;3872
00008a  f3c00040          UBFX     r0,r0,#1,#1           ;3872
00008e  2800              CMP      r0,#0                 ;3872
000090  d1e0              BNE      |L21.84|
                  |L21.146|
000092  bf00              NOP                            ;3876
000094  f894003c          LDRB     r0,[r4,#0x3c]         ;3876
000098  2801              CMP      r0,#1                 ;3876
00009a  d101              BNE      |L21.160|
00009c  2002              MOVS     r0,#2                 ;3876
00009e  e7f0              B        |L21.130|
                  |L21.160|
0000a0  2001              MOVS     r0,#1                 ;3876
0000a2  f884003c          STRB     r0,[r4,#0x3c]         ;3876
0000a6  bf00              NOP                            ;3876
0000a8  6820              LDR      r0,[r4,#0]            ;3879
0000aa  6800              LDR      r0,[r0,#0]            ;3879
0000ac  f0000001          AND      r0,r0,#1              ;3879
0000b0  b928              CBNZ     r0,|L21.190|
0000b2  6820              LDR      r0,[r4,#0]            ;3882
0000b4  6800              LDR      r0,[r0,#0]            ;3882
0000b6  f0400001          ORR      r0,r0,#1              ;3882
0000ba  6821              LDR      r1,[r4,#0]            ;3882
0000bc  6008              STR      r0,[r1,#0]            ;3882
                  |L21.190|
0000be  6820              LDR      r0,[r4,#0]            ;3886
0000c0  6800              LDR      r0,[r0,#0]            ;3886
0000c2  f4206000          BIC      r0,r0,#0x800          ;3886
0000c6  6821              LDR      r1,[r4,#0]            ;3886
0000c8  6008              STR      r0,[r1,#0]            ;3886
0000ca  6820              LDR      r0,[r4,#0]            ;3889
0000cc  6840              LDR      r0,[r0,#4]            ;3889
0000ce  f4205080          BIC      r0,r0,#0x1000         ;3889
0000d2  6821              LDR      r1,[r4,#0]            ;3889
0000d4  6048              STR      r0,[r1,#4]            ;3889
0000d6  2022              MOVS     r0,#0x22              ;3891
0000d8  f884003d          STRB     r0,[r4,#0x3d]         ;3891
0000dc  2010              MOVS     r0,#0x10              ;3892
0000de  f884003e          STRB     r0,[r4,#0x3e]         ;3892
0000e2  2000              MOVS     r0,#0                 ;3893
0000e4  6420              STR      r0,[r4,#0x40]         ;3893
0000e6  f8c48024          STR      r8,[r4,#0x24]         ;3896
0000ea  f8a4902a          STRH     r9,[r4,#0x2a]         ;3897
0000ee  8d60              LDRH     r0,[r4,#0x2a]         ;3898
0000f0  8520              STRH     r0,[r4,#0x28]         ;3898
0000f2  62e5              STR      r5,[r4,#0x2c]         ;3899
0000f4  6467              STR      r7,[r4,#0x44]         ;3900
0000f6  6b20              LDR      r0,[r4,#0x30]         ;3902
0000f8  9001              STR      r0,[sp,#4]            ;3902
0000fa  8d20              LDRH     r0,[r4,#0x28]         ;3904
0000fc  2800              CMP      r0,#0                 ;3904
0000fe  d07d              BEQ      |L21.508|
000100  8d60              LDRH     r0,[r4,#0x2a]         ;3906
000102  2802              CMP      r0,#2                 ;3906
000104  d122              BNE      |L21.332|
000106  2d20              CMP      r5,#0x20              ;3906
000108  d001              BEQ      |L21.270|
00010a  2d10              CMP      r5,#0x10              ;3906
00010c  d11e              BNE      |L21.332|
                  |L21.270|
00010e  9801              LDR      r0,[sp,#4]            ;3908
000110  2812              CMP      r0,#0x12              ;3908
000112  d114              BNE      |L21.318|
000114  6820              LDR      r0,[r4,#0]            ;3911
000116  6800              LDR      r0,[r0,#0]            ;3911
000118  e000              B        |L21.284|
                  |L21.282|
00011a  e0ac              B        |L21.630|
                  |L21.284|
00011c  f4206080          BIC      r0,r0,#0x400          ;3911
000120  6821              LDR      r1,[r4,#0]            ;3911
000122  6008              STR      r0,[r1,#0]            ;3911
000124  6820              LDR      r0,[r4,#0]            ;3914
000126  6800              LDR      r0,[r0,#0]            ;3914
000128  f4406000          ORR      r0,r0,#0x800          ;3914
00012c  6821              LDR      r1,[r4,#0]            ;3914
00012e  6008              STR      r0,[r1,#0]            ;3914
000130  6820              LDR      r0,[r4,#0]            ;3917
000132  6840              LDR      r0,[r0,#4]            ;3917
000134  f4405080          ORR      r0,r0,#0x1000         ;3917
000138  6821              LDR      r1,[r4,#0]            ;3917
00013a  6048              STR      r0,[r1,#4]            ;3917
00013c  e019              B        |L21.370|
                  |L21.318|
00013e  6820              LDR      r0,[r4,#0]            ;3922
000140  6800              LDR      r0,[r0,#0]            ;3922
000142  f4406080          ORR      r0,r0,#0x400          ;3922
000146  6821              LDR      r1,[r4,#0]            ;3922
000148  6008              STR      r0,[r1,#0]            ;3922
00014a  e012              B        |L21.370|
                  |L21.332|
00014c  6820              LDR      r0,[r4,#0]            ;3928
00014e  6800              LDR      r0,[r0,#0]            ;3928
000150  f4406080          ORR      r0,r0,#0x400          ;3928
000154  6821              LDR      r1,[r4,#0]            ;3928
000156  6008              STR      r0,[r1,#0]            ;3928
000158  2d20              CMP      r5,#0x20              ;3930
00015a  d004              BEQ      |L21.358|
00015c  f1b54f2a          CMP      r5,#0xaa000000        ;3930
000160  d001              BEQ      |L21.358|
000162  2d10              CMP      r5,#0x10              ;3930
000164  d105              BNE      |L21.370|
                  |L21.358|
000166  6820              LDR      r0,[r4,#0]            ;3933
000168  6840              LDR      r0,[r0,#4]            ;3933
00016a  f4405080          ORR      r0,r0,#0x1000         ;3933
00016e  6821              LDR      r1,[r4,#0]            ;3933
000170  6048              STR      r0,[r1,#4]            ;3933
                  |L21.370|
000172  4843              LDR      r0,|L21.640|
000174  6ba1              LDR      r1,[r4,#0x38]         ;3938
000176  63c8              STR      r0,[r1,#0x3c]         ;3938
000178  4842              LDR      r0,|L21.644|
00017a  6ba1              LDR      r1,[r4,#0x38]         ;3941
00017c  64c8              STR      r0,[r1,#0x4c]         ;3941
00017e  2000              MOVS     r0,#0                 ;3944
000180  6ba1              LDR      r1,[r4,#0x38]         ;3944
000182  6408              STR      r0,[r1,#0x40]         ;3944
000184  6ba1              LDR      r1,[r4,#0x38]         ;3945
000186  6508              STR      r0,[r1,#0x50]         ;3945
000188  8d23              LDRH     r3,[r4,#0x28]         ;3948
00018a  f8d4c000          LDR      r12,[r4,#0]           ;3948
00018e  f10c0110          ADD      r1,r12,#0x10          ;3948
000192  6a62              LDR      r2,[r4,#0x24]         ;3948
000194  6ba0              LDR      r0,[r4,#0x38]         ;3948
000196  f7fffffe          BL       HAL_DMA_Start_IT
00019a  4606              MOV      r6,r0                 ;3948
00019c  bb7e              CBNZ     r6,|L21.510|
00019e  9801              LDR      r0,[sp,#4]            ;3954
0001a0  2812              CMP      r0,#0x12              ;3954
0001a2  d10a              BNE      |L21.442|
0001a4  f5b50f2a          CMP      r5,#0xaa0000          ;3954
0001a8  d002              BEQ      |L21.432|
0001aa  f1b54f2a          CMP      r5,#0xaa000000        ;3954
0001ae  d101              BNE      |L21.436|
                  |L21.432|
0001b0  2001              MOVS     r0,#1                 ;3954
0001b2  e000              B        |L21.438|
                  |L21.436|
0001b4  2000              MOVS     r0,#0                 ;3954
                  |L21.438|
0001b6  2801              CMP      r0,#1                 ;3954
0001b8  d108              BNE      |L21.460|
                  |L21.442|
0001ba  6820              LDR      r0,[r4,#0]            ;3957
0001bc  6800              LDR      r0,[r0,#0]            ;3957
0001be  f4407080          ORR      r0,r0,#0x100          ;3957
0001c2  6821              LDR      r1,[r4,#0]            ;3957
0001c4  6008              STR      r0,[r1,#0]            ;3957
0001c6  f44f7a40          MOV      r10,#0x300            ;3960
0001ca  e001              B        |L21.464|
                  |L21.460|
0001cc  f44f7a80          MOV      r10,#0x100            ;3965
                  |L21.464|
0001d0  bf00              NOP                            ;3969
0001d2  2000              MOVS     r0,#0                 ;3969
0001d4  f884003c          STRB     r0,[r4,#0x3c]         ;3969
0001d8  bf00              NOP                            ;3969
0001da  2d04              CMP      r5,#4                 ;3977
0001dc  d003              BEQ      |L21.486|
0001de  2d20              CMP      r5,#0x20              ;3977
0001e0  d001              BEQ      |L21.486|
0001e2  2d10              CMP      r5,#0x10              ;3977
0001e4  d105              BNE      |L21.498|
                  |L21.486|
0001e6  6820              LDR      r0,[r4,#0]            ;3980
0001e8  6840              LDR      r0,[r0,#4]            ;3980
0001ea  f4406000          ORR      r0,r0,#0x800          ;3980
0001ee  6821              LDR      r1,[r4,#0]            ;3980
0001f0  6048              STR      r0,[r1,#4]            ;3980
                  |L21.498|
0001f2  6820              LDR      r0,[r4,#0]            ;3984
0001f4  6840              LDR      r0,[r0,#4]            ;3984
0001f6  ea40000a          ORR      r0,r0,r10             ;3984
0001fa  e001              B        |L21.512|
                  |L21.508|
0001fc  e014              B        |L21.552|
                  |L21.510|
0001fe  e002              B        |L21.518|
                  |L21.512|
000200  6821              LDR      r1,[r4,#0]            ;3984
000202  6048              STR      r0,[r1,#4]            ;3984
000204  e035              B        |L21.626|
                  |L21.518|
000206  2020              MOVS     r0,#0x20              ;3989
000208  f884003d          STRB     r0,[r4,#0x3d]         ;3989
00020c  2000              MOVS     r0,#0                 ;3990
00020e  f884003e          STRB     r0,[r4,#0x3e]         ;3990
000212  6c20              LDR      r0,[r4,#0x40]         ;3993
000214  f0400010          ORR      r0,r0,#0x10           ;3993
000218  6420              STR      r0,[r4,#0x40]         ;3993
00021a  bf00              NOP                            ;3996
00021c  2000              MOVS     r0,#0                 ;3996
00021e  f884003c          STRB     r0,[r4,#0x3c]         ;3996
000222  bf00              NOP                            ;3996
000224  2001              MOVS     r0,#1                 ;3998
000226  e72c              B        |L21.130|
                  |L21.552|
000228  6820              LDR      r0,[r4,#0]            ;4004
00022a  6800              LDR      r0,[r0,#0]            ;4004
00022c  f4406080          ORR      r0,r0,#0x400          ;4004
000230  6821              LDR      r1,[r4,#0]            ;4004
000232  6008              STR      r0,[r1,#0]            ;4004
000234  9801              LDR      r0,[sp,#4]            ;4008
000236  2812              CMP      r0,#0x12              ;4008
000238  d10a              BNE      |L21.592|
00023a  f5b50f2a          CMP      r5,#0xaa0000          ;4008
00023e  d002              BEQ      |L21.582|
000240  f1b54f2a          CMP      r5,#0xaa000000        ;4008
000244  d101              BNE      |L21.586|
                  |L21.582|
000246  2001              MOVS     r0,#1                 ;4008
000248  e000              B        |L21.588|
                  |L21.586|
00024a  2000              MOVS     r0,#0                 ;4008
                  |L21.588|
00024c  2801              CMP      r0,#1                 ;4008
00024e  d105              BNE      |L21.604|
                  |L21.592|
000250  6820              LDR      r0,[r4,#0]            ;4011
000252  6800              LDR      r0,[r0,#0]            ;4011
000254  f4407080          ORR      r0,r0,#0x100          ;4011
000258  6821              LDR      r1,[r4,#0]            ;4011
00025a  6008              STR      r0,[r1,#0]            ;4011
                  |L21.604|
00025c  bf00              NOP                            ;4015
00025e  2000              MOVS     r0,#0                 ;4015
000260  f884003c          STRB     r0,[r4,#0x3c]         ;4015
000264  bf00              NOP                            ;4015
000266  6820              LDR      r0,[r4,#0]            ;4022
000268  6840              LDR      r0,[r0,#4]            ;4022
00026a  ea40000a          ORR      r0,r0,r10             ;4022
00026e  6821              LDR      r1,[r4,#0]            ;4022
000270  6048              STR      r0,[r1,#4]            ;4022
                  |L21.626|
000272  2000              MOVS     r0,#0                 ;4024
000274  e705              B        |L21.130|
                  |L21.630|
000276  2002              MOVS     r0,#2                 ;4028
000278  e703              B        |L21.130|
;;;4031   
                          ENDP

00027a  0000              DCW      0x0000
                  |L21.636|
                          DCD      SystemCoreClock
                  |L21.640|
                          DCD      I2C_DMAXferCplt
                  |L21.644|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Seq_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_IT PROC
;;;3714     */
;;;3715   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5fc              PUSH     {r2-r7,lr}
;;;3716   {
000002  4604              MOV      r4,r0
000004  9d07              LDR      r5,[sp,#0x1c]
;;;3717     __IO uint32_t Prev_State = 0x00U;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;3718     __IO uint32_t count = 0U;
00000a  9000              STR      r0,[sp,#0]
;;;3719     uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00000c  f44f66e0          MOV      r6,#0x700
;;;3720   
;;;3721     /* Check the parameters */
;;;3722     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3723   
;;;3724     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d17c              BNE      |L22.274|
;;;3725     {
;;;3726       /* Check Busy Flag only if FIRST call of Master interface */
;;;3727       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000018  6820              LDR      r0,[r4,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  f4007000          AND      r0,r0,#0x200
000020  f5b07f00          CMP      r0,#0x200
000024  d003              BEQ      |L22.46|
000026  2d08              CMP      r5,#8
000028  d001              BEQ      |L22.46|
00002a  2d01              CMP      r5,#1
00002c  d12c              BNE      |L22.136|
                  |L22.46|
;;;3728       {
;;;3729         /* Wait until BUSY flag is reset */
;;;3730         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
00002e  4851              LDR      r0,|L22.372|
000030  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000032  2719              MOVS     r7,#0x19
000034  fbb0f0f7          UDIV     r0,r0,r7
000038  f44f777a          MOV      r7,#0x3e8
00003c  fbb0f0f7          UDIV     r0,r0,r7
000040  eb0007c0          ADD      r7,r0,r0,LSL #3
000044  eb071000          ADD      r0,r7,r0,LSL #4
000048  9000              STR      r0,[sp,#0]
;;;3731         do
00004a  bf00              NOP      
                  |L22.76|
;;;3732         {
;;;3733           count--;
00004c  9800              LDR      r0,[sp,#0]
00004e  1e40              SUBS     r0,r0,#1
000050  9000              STR      r0,[sp,#0]
;;;3734           if (count == 0U)
000052  9800              LDR      r0,[sp,#0]
000054  b990              CBNZ     r0,|L22.124|
;;;3735           {
;;;3736             hi2c->PreviousState       = I2C_STATE_NONE;
000056  2000              MOVS     r0,#0
000058  6320              STR      r0,[r4,#0x30]
;;;3737             hi2c->State               = HAL_I2C_STATE_READY;
00005a  2020              MOVS     r0,#0x20
00005c  f884003d          STRB     r0,[r4,#0x3d]
;;;3738             hi2c->Mode                = HAL_I2C_MODE_NONE;
000060  2000              MOVS     r0,#0
000062  f884003e          STRB     r0,[r4,#0x3e]
;;;3739             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000066  6c20              LDR      r0,[r4,#0x40]
000068  f0400020          ORR      r0,r0,#0x20
00006c  6420              STR      r0,[r4,#0x40]
;;;3740   
;;;3741             /* Process Unlocked */
;;;3742             __HAL_UNLOCK(hi2c);
00006e  bf00              NOP      
000070  2000              MOVS     r0,#0
000072  f884003c          STRB     r0,[r4,#0x3c]
000076  bf00              NOP      
;;;3743   
;;;3744             return HAL_ERROR;
000078  2001              MOVS     r0,#1
                  |L22.122|
;;;3745           }
;;;3746         }
;;;3747         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3748       }
;;;3749   
;;;3750       /* Process Locked */
;;;3751       __HAL_LOCK(hi2c);
;;;3752   
;;;3753       /* Check if the I2C is already enabled */
;;;3754       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3755       {
;;;3756         /* Enable I2C peripheral */
;;;3757         __HAL_I2C_ENABLE(hi2c);
;;;3758       }
;;;3759   
;;;3760       /* Disable Pos */
;;;3761       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3762   
;;;3763       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3764       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3765       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3766   
;;;3767       /* Prepare transfer parameters */
;;;3768       hi2c->pBuffPtr    = pData;
;;;3769       hi2c->XferCount   = Size;
;;;3770       hi2c->XferSize    = hi2c->XferCount;
;;;3771       hi2c->XferOptions = XferOptions;
;;;3772       hi2c->Devaddress  = DevAddress;
;;;3773   
;;;3774       Prev_State = hi2c->PreviousState;
;;;3775   
;;;3776       if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
;;;3777       {
;;;3778         if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
;;;3779         {
;;;3780           /* Disable Acknowledge */
;;;3781           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3782   
;;;3783           /* Enable Pos */
;;;3784           SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3785   
;;;3786           /* Remove Enabling of IT_BUF, mean RXNE treatment, treat the 2 bytes through BTF */
;;;3787           enableIT &= ~I2C_IT_BUF;
;;;3788         }
;;;3789         else
;;;3790         {
;;;3791           /* Enable Acknowledge */
;;;3792           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3793         }
;;;3794       }
;;;3795       else
;;;3796       {
;;;3797         /* Enable Acknowledge */
;;;3798         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3799       }
;;;3800   
;;;3801       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3802       /* Mean Previous state is same as current state */
;;;3803       if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3804       {
;;;3805         /* Generate Start */
;;;3806         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3807       }
;;;3808   
;;;3809       /* Process Unlocked */
;;;3810       __HAL_UNLOCK(hi2c);
;;;3811   
;;;3812       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3813       to avoid the risk of I2C interrupt handle execution before current
;;;3814       process unlock */
;;;3815   
;;;3816       /* Enable interrupts */
;;;3817       __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;3818   
;;;3819       return HAL_OK;
;;;3820     }
;;;3821     else
;;;3822     {
;;;3823       return HAL_BUSY;
;;;3824     }
;;;3825   }
00007a  bdfc              POP      {r2-r7,pc}
                  |L22.124|
00007c  6820              LDR      r0,[r4,#0]            ;3747
00007e  6980              LDR      r0,[r0,#0x18]         ;3747
000080  f3c00040          UBFX     r0,r0,#1,#1           ;3747
000084  2800              CMP      r0,#0                 ;3747
000086  d1e1              BNE      |L22.76|
                  |L22.136|
000088  bf00              NOP                            ;3751
00008a  f894003c          LDRB     r0,[r4,#0x3c]         ;3751
00008e  2801              CMP      r0,#1                 ;3751
000090  d101              BNE      |L22.150|
000092  2002              MOVS     r0,#2                 ;3751
000094  e7f1              B        |L22.122|
                  |L22.150|
000096  2001              MOVS     r0,#1                 ;3751
000098  f884003c          STRB     r0,[r4,#0x3c]         ;3751
00009c  bf00              NOP                            ;3751
00009e  6820              LDR      r0,[r4,#0]            ;3754
0000a0  6800              LDR      r0,[r0,#0]            ;3754
0000a2  f0000001          AND      r0,r0,#1              ;3754
0000a6  b928              CBNZ     r0,|L22.180|
0000a8  6820              LDR      r0,[r4,#0]            ;3757
0000aa  6800              LDR      r0,[r0,#0]            ;3757
0000ac  f0400001          ORR      r0,r0,#1              ;3757
0000b0  6827              LDR      r7,[r4,#0]            ;3757
0000b2  6038              STR      r0,[r7,#0]            ;3757
                  |L22.180|
0000b4  6820              LDR      r0,[r4,#0]            ;3761
0000b6  6800              LDR      r0,[r0,#0]            ;3761
0000b8  f4206000          BIC      r0,r0,#0x800          ;3761
0000bc  6827              LDR      r7,[r4,#0]            ;3761
0000be  6038              STR      r0,[r7,#0]            ;3761
0000c0  2022              MOVS     r0,#0x22              ;3763
0000c2  f884003d          STRB     r0,[r4,#0x3d]         ;3763
0000c6  2010              MOVS     r0,#0x10              ;3764
0000c8  f884003e          STRB     r0,[r4,#0x3e]         ;3764
0000cc  2000              MOVS     r0,#0                 ;3765
0000ce  6420              STR      r0,[r4,#0x40]         ;3765
0000d0  6262              STR      r2,[r4,#0x24]         ;3768
0000d2  8563              STRH     r3,[r4,#0x2a]         ;3769
0000d4  8d60              LDRH     r0,[r4,#0x2a]         ;3770
0000d6  8520              STRH     r0,[r4,#0x28]         ;3770
0000d8  62e5              STR      r5,[r4,#0x2c]         ;3771
0000da  6461              STR      r1,[r4,#0x44]         ;3772
0000dc  6b20              LDR      r0,[r4,#0x30]         ;3774
0000de  9001              STR      r0,[sp,#4]            ;3774
0000e0  8d60              LDRH     r0,[r4,#0x2a]         ;3776
0000e2  2802              CMP      r0,#2                 ;3776
0000e4  d11d              BNE      |L22.290|
0000e6  2d20              CMP      r5,#0x20              ;3776
0000e8  d001              BEQ      |L22.238|
0000ea  2d10              CMP      r5,#0x10              ;3776
0000ec  d119              BNE      |L22.290|
                  |L22.238|
0000ee  9801              LDR      r0,[sp,#4]            ;3778
0000f0  2812              CMP      r0,#0x12              ;3778
0000f2  d10f              BNE      |L22.276|
0000f4  6820              LDR      r0,[r4,#0]            ;3781
0000f6  6800              LDR      r0,[r0,#0]            ;3781
0000f8  f4206080          BIC      r0,r0,#0x400          ;3781
0000fc  6827              LDR      r7,[r4,#0]            ;3781
0000fe  6038              STR      r0,[r7,#0]            ;3781
000100  6820              LDR      r0,[r4,#0]            ;3784
000102  6800              LDR      r0,[r0,#0]            ;3784
000104  f4406000          ORR      r0,r0,#0x800          ;3784
000108  6827              LDR      r7,[r4,#0]            ;3784
00010a  6038              STR      r0,[r7,#0]            ;3784
00010c  f4266680          BIC      r6,r6,#0x400          ;3787
000110  e00d              B        |L22.302|
                  |L22.274|
000112  e02c              B        |L22.366|
                  |L22.276|
000114  6820              LDR      r0,[r4,#0]            ;3792
000116  6800              LDR      r0,[r0,#0]            ;3792
000118  f4406080          ORR      r0,r0,#0x400          ;3792
00011c  6827              LDR      r7,[r4,#0]            ;3792
00011e  6038              STR      r0,[r7,#0]            ;3792
000120  e005              B        |L22.302|
                  |L22.290|
000122  6820              LDR      r0,[r4,#0]            ;3798
000124  6800              LDR      r0,[r0,#0]            ;3798
000126  f4406080          ORR      r0,r0,#0x400          ;3798
00012a  6827              LDR      r7,[r4,#0]            ;3798
00012c  6038              STR      r0,[r7,#0]            ;3798
                  |L22.302|
00012e  9801              LDR      r0,[sp,#4]            ;3803
000130  2812              CMP      r0,#0x12              ;3803
000132  d10a              BNE      |L22.330|
000134  f5b50f2a          CMP      r5,#0xaa0000          ;3803
000138  d002              BEQ      |L22.320|
00013a  f1b54f2a          CMP      r5,#0xaa000000        ;3803
00013e  d101              BNE      |L22.324|
                  |L22.320|
000140  2001              MOVS     r0,#1                 ;3803
000142  e000              B        |L22.326|
                  |L22.324|
000144  2000              MOVS     r0,#0                 ;3803
                  |L22.326|
000146  2801              CMP      r0,#1                 ;3803
000148  d105              BNE      |L22.342|
                  |L22.330|
00014a  6820              LDR      r0,[r4,#0]            ;3806
00014c  6800              LDR      r0,[r0,#0]            ;3806
00014e  f4407080          ORR      r0,r0,#0x100          ;3806
000152  6827              LDR      r7,[r4,#0]            ;3806
000154  6038              STR      r0,[r7,#0]            ;3806
                  |L22.342|
000156  bf00              NOP                            ;3810
000158  2000              MOVS     r0,#0                 ;3810
00015a  f884003c          STRB     r0,[r4,#0x3c]         ;3810
00015e  bf00              NOP                            ;3810
000160  6820              LDR      r0,[r4,#0]            ;3817
000162  6840              LDR      r0,[r0,#4]            ;3817
000164  4330              ORRS     r0,r0,r6              ;3817
000166  6827              LDR      r7,[r4,#0]            ;3817
000168  6078              STR      r0,[r7,#4]            ;3817
00016a  2000              MOVS     r0,#0                 ;3819
00016c  e785              B        |L22.122|
                  |L22.366|
00016e  2002              MOVS     r0,#2                 ;3823
000170  e783              B        |L22.122|
;;;3826   
                          ENDP

000172  0000              DCW      0x0000
                  |L22.372|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_DMA PROC
;;;3548     */
;;;3549   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3550   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;3551     __IO uint32_t Prev_State = 0x00U;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;3552     __IO uint32_t count      = 0x00U;
000012  9000              STR      r0,[sp,#0]
;;;3553     HAL_StatusTypeDef dmaxferstatus;
;;;3554   
;;;3555     /* Check the parameters */
;;;3556     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3557   
;;;3558     if (hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d17c              BNE      |L23.278|
;;;3559     {
;;;3560       /* Check Busy Flag only if FIRST call of Master interface */
;;;3561       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4007000          AND      r0,r0,#0x200
000024  f5b07f00          CMP      r0,#0x200
000028  d003              BEQ      |L23.50|
00002a  2d08              CMP      r5,#8
00002c  d001              BEQ      |L23.50|
00002e  2d01              CMP      r5,#1
000030  d12d              BNE      |L23.142|
                  |L23.50|
;;;3562       {
;;;3563         /* Wait until BUSY flag is reset */
;;;3564         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000032  4872              LDR      r0,|L23.508|
000034  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000036  2119              MOVS     r1,#0x19
000038  fbb0f0f1          UDIV     r0,r0,r1
00003c  f44f717a          MOV      r1,#0x3e8
000040  fbb0f0f1          UDIV     r0,r0,r1
000044  eb0001c0          ADD      r1,r0,r0,LSL #3
000048  eb011000          ADD      r0,r1,r0,LSL #4
00004c  9000              STR      r0,[sp,#0]
;;;3565         do
00004e  bf00              NOP      
                  |L23.80|
;;;3566         {
;;;3567           count--;
000050  9800              LDR      r0,[sp,#0]
000052  1e40              SUBS     r0,r0,#1
000054  9000              STR      r0,[sp,#0]
;;;3568           if (count == 0U)
000056  9800              LDR      r0,[sp,#0]
000058  b998              CBNZ     r0,|L23.130|
;;;3569           {
;;;3570             hi2c->PreviousState       = I2C_STATE_NONE;
00005a  2000              MOVS     r0,#0
00005c  6320              STR      r0,[r4,#0x30]
;;;3571             hi2c->State               = HAL_I2C_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;3572             hi2c->Mode                = HAL_I2C_MODE_NONE;
000064  2000              MOVS     r0,#0
000066  f884003e          STRB     r0,[r4,#0x3e]
;;;3573             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00006a  6c20              LDR      r0,[r4,#0x40]
00006c  f0400020          ORR      r0,r0,#0x20
000070  6420              STR      r0,[r4,#0x40]
;;;3574   
;;;3575             /* Process Unlocked */
;;;3576             __HAL_UNLOCK(hi2c);
000072  bf00              NOP      
000074  2000              MOVS     r0,#0
000076  f884003c          STRB     r0,[r4,#0x3c]
00007a  bf00              NOP      
;;;3577   
;;;3578             return HAL_ERROR;
00007c  2001              MOVS     r0,#1
                  |L23.126|
;;;3579           }
;;;3580         }
;;;3581         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3582       }
;;;3583   
;;;3584       /* Process Locked */
;;;3585       __HAL_LOCK(hi2c);
;;;3586   
;;;3587       /* Check if the I2C is already enabled */
;;;3588       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3589       {
;;;3590         /* Enable I2C peripheral */
;;;3591         __HAL_I2C_ENABLE(hi2c);
;;;3592       }
;;;3593   
;;;3594       /* Disable Pos */
;;;3595       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3596   
;;;3597       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3598       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3599       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3600   
;;;3601       /* Prepare transfer parameters */
;;;3602       hi2c->pBuffPtr    = pData;
;;;3603       hi2c->XferCount   = Size;
;;;3604       hi2c->XferSize    = hi2c->XferCount;
;;;3605       hi2c->XferOptions = XferOptions;
;;;3606       hi2c->Devaddress  = DevAddress;
;;;3607   
;;;3608       Prev_State = hi2c->PreviousState;
;;;3609   
;;;3610       if (hi2c->XferSize > 0U)
;;;3611       {
;;;3612         /* Set the I2C DMA transfer complete callback */
;;;3613         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;3614   
;;;3615         /* Set the DMA error callback */
;;;3616         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3617   
;;;3618         /* Set the unused DMA callbacks to NULL */
;;;3619         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3620         hi2c->hdmatx->XferAbortCallback = NULL;
;;;3621   
;;;3622         /* Enable the DMA stream */
;;;3623         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;3624   
;;;3625         if (dmaxferstatus == HAL_OK)
;;;3626         {
;;;3627           /* Enable Acknowledge */
;;;3628           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3629   
;;;3630           /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3631           /* Mean Previous state is same as current state */
;;;3632           if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3633           {
;;;3634             /* Generate Start */
;;;3635             SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3636           }
;;;3637   
;;;3638           /* Process Unlocked */
;;;3639           __HAL_UNLOCK(hi2c);
;;;3640   
;;;3641           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3642           to avoid the risk of I2C interrupt handle execution before current
;;;3643           process unlock */
;;;3644   
;;;3645           /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
;;;3646           /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
;;;3647           if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;3648           {
;;;3649             /* Enable DMA Request */
;;;3650             SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3651           }
;;;3652   
;;;3653           /* Enable EVT and ERR interrupt */
;;;3654           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;3655         }
;;;3656         else
;;;3657         {
;;;3658           /* Update I2C state */
;;;3659           hi2c->State     = HAL_I2C_STATE_READY;
;;;3660           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3661   
;;;3662           /* Update I2C error code */
;;;3663           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3664   
;;;3665           /* Process Unlocked */
;;;3666           __HAL_UNLOCK(hi2c);
;;;3667   
;;;3668           return HAL_ERROR;
;;;3669         }
;;;3670       }
;;;3671       else
;;;3672       {
;;;3673         /* Enable Acknowledge */
;;;3674         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3675   
;;;3676         /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3677         /* Mean Previous state is same as current state */
;;;3678         if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3679         {
;;;3680           /* Generate Start */
;;;3681           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3682         }
;;;3683   
;;;3684         /* Process Unlocked */
;;;3685         __HAL_UNLOCK(hi2c);
;;;3686   
;;;3687         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3688         to avoid the risk of I2C interrupt handle execution before current
;;;3689         process unlock */
;;;3690   
;;;3691         /* Enable EVT, BUF and ERR interrupt */
;;;3692         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3693       }
;;;3694   
;;;3695       return HAL_OK;
;;;3696     }
;;;3697     else
;;;3698     {
;;;3699       return HAL_BUSY;
;;;3700     }
;;;3701   }
00007e  e8bd87fc          POP      {r2-r10,pc}
                  |L23.130|
000082  6820              LDR      r0,[r4,#0]            ;3581
000084  6980              LDR      r0,[r0,#0x18]         ;3581
000086  f3c00040          UBFX     r0,r0,#1,#1           ;3581
00008a  2800              CMP      r0,#0                 ;3581
00008c  d1e0              BNE      |L23.80|
                  |L23.142|
00008e  bf00              NOP                            ;3585
000090  f894003c          LDRB     r0,[r4,#0x3c]         ;3585
000094  2801              CMP      r0,#1                 ;3585
000096  d101              BNE      |L23.156|
000098  2002              MOVS     r0,#2                 ;3585
00009a  e7f0              B        |L23.126|
                  |L23.156|
00009c  2001              MOVS     r0,#1                 ;3585
00009e  f884003c          STRB     r0,[r4,#0x3c]         ;3585
0000a2  bf00              NOP                            ;3585
0000a4  6820              LDR      r0,[r4,#0]            ;3588
0000a6  6800              LDR      r0,[r0,#0]            ;3588
0000a8  f0000001          AND      r0,r0,#1              ;3588
0000ac  b928              CBNZ     r0,|L23.186|
0000ae  6820              LDR      r0,[r4,#0]            ;3591
0000b0  6800              LDR      r0,[r0,#0]            ;3591
0000b2  f0400001          ORR      r0,r0,#1              ;3591
0000b6  6821              LDR      r1,[r4,#0]            ;3591
0000b8  6008              STR      r0,[r1,#0]            ;3591
                  |L23.186|
0000ba  6820              LDR      r0,[r4,#0]            ;3595
0000bc  6800              LDR      r0,[r0,#0]            ;3595
0000be  f4206000          BIC      r0,r0,#0x800          ;3595
0000c2  6821              LDR      r1,[r4,#0]            ;3595
0000c4  6008              STR      r0,[r1,#0]            ;3595
0000c6  2021              MOVS     r0,#0x21              ;3597
0000c8  f884003d          STRB     r0,[r4,#0x3d]         ;3597
0000cc  2010              MOVS     r0,#0x10              ;3598
0000ce  f884003e          STRB     r0,[r4,#0x3e]         ;3598
0000d2  2000              MOVS     r0,#0                 ;3599
0000d4  6420              STR      r0,[r4,#0x40]         ;3599
0000d6  f8c48024          STR      r8,[r4,#0x24]         ;3602
0000da  f8a4902a          STRH     r9,[r4,#0x2a]         ;3603
0000de  8d60              LDRH     r0,[r4,#0x2a]         ;3604
0000e0  8520              STRH     r0,[r4,#0x28]         ;3604
0000e2  62e5              STR      r5,[r4,#0x2c]         ;3605
0000e4  6467              STR      r7,[r4,#0x44]         ;3606
0000e6  6b20              LDR      r0,[r4,#0x30]         ;3608
0000e8  9001              STR      r0,[sp,#4]            ;3608
0000ea  8d20              LDRH     r0,[r4,#0x28]         ;3610
0000ec  2800              CMP      r0,#0                 ;3610
0000ee  d05b              BEQ      |L23.424|
0000f0  4843              LDR      r0,|L23.512|
0000f2  6b61              LDR      r1,[r4,#0x34]         ;3613
0000f4  63c8              STR      r0,[r1,#0x3c]         ;3613
0000f6  4843              LDR      r0,|L23.516|
0000f8  6b61              LDR      r1,[r4,#0x34]         ;3616
0000fa  64c8              STR      r0,[r1,#0x4c]         ;3616
0000fc  2000              MOVS     r0,#0                 ;3619
0000fe  6b61              LDR      r1,[r4,#0x34]         ;3619
000100  6408              STR      r0,[r1,#0x40]         ;3619
000102  6b61              LDR      r1,[r4,#0x34]         ;3620
000104  6508              STR      r0,[r1,#0x50]         ;3620
000106  8d23              LDRH     r3,[r4,#0x28]         ;3623
000108  f8d4c000          LDR      r12,[r4,#0]           ;3623
00010c  f10c0210          ADD      r2,r12,#0x10          ;3623
000110  6a61              LDR      r1,[r4,#0x24]         ;3623
000112  6b60              LDR      r0,[r4,#0x34]         ;3623
000114  e000              B        |L23.280|
                  |L23.278|
000116  e06e              B        |L23.502|
                  |L23.280|
000118  f7fffffe          BL       HAL_DMA_Start_IT
00011c  4606              MOV      r6,r0                 ;3623
00011e  bb8e              CBNZ     r6,|L23.388|
000120  6820              LDR      r0,[r4,#0]            ;3628
000122  6800              LDR      r0,[r0,#0]            ;3628
000124  f4406080          ORR      r0,r0,#0x400          ;3628
000128  6821              LDR      r1,[r4,#0]            ;3628
00012a  6008              STR      r0,[r1,#0]            ;3628
00012c  9801              LDR      r0,[sp,#4]            ;3632
00012e  2811              CMP      r0,#0x11              ;3632
000130  d10a              BNE      |L23.328|
000132  f5b50f2a          CMP      r5,#0xaa0000          ;3632
000136  d002              BEQ      |L23.318|
000138  f1b54f2a          CMP      r5,#0xaa000000        ;3632
00013c  d101              BNE      |L23.322|
                  |L23.318|
00013e  2001              MOVS     r0,#1                 ;3632
000140  e000              B        |L23.324|
                  |L23.322|
000142  2000              MOVS     r0,#0                 ;3632
                  |L23.324|
000144  2801              CMP      r0,#1                 ;3632
000146  d105              BNE      |L23.340|
                  |L23.328|
000148  6820              LDR      r0,[r4,#0]            ;3635
00014a  6800              LDR      r0,[r0,#0]            ;3635
00014c  f4407080          ORR      r0,r0,#0x100          ;3635
000150  6821              LDR      r1,[r4,#0]            ;3635
000152  6008              STR      r0,[r1,#0]            ;3635
                  |L23.340|
000154  bf00              NOP                            ;3639
000156  2000              MOVS     r0,#0                 ;3639
000158  f884003c          STRB     r0,[r4,#0x3c]         ;3639
00015c  bf00              NOP                            ;3639
00015e  2d04              CMP      r5,#4                 ;3647
000160  d003              BEQ      |L23.362|
000162  2d20              CMP      r5,#0x20              ;3647
000164  d001              BEQ      |L23.362|
000166  2d10              CMP      r5,#0x10              ;3647
000168  d105              BNE      |L23.374|
                  |L23.362|
00016a  6820              LDR      r0,[r4,#0]            ;3650
00016c  6840              LDR      r0,[r0,#4]            ;3650
00016e  f4406000          ORR      r0,r0,#0x800          ;3650
000172  6821              LDR      r1,[r4,#0]            ;3650
000174  6048              STR      r0,[r1,#4]            ;3650
                  |L23.374|
000176  6820              LDR      r0,[r4,#0]            ;3654
000178  6840              LDR      r0,[r0,#4]            ;3654
00017a  f4407040          ORR      r0,r0,#0x300          ;3654
00017e  6821              LDR      r1,[r4,#0]            ;3654
000180  6048              STR      r0,[r1,#4]            ;3654
000182  e036              B        |L23.498|
                  |L23.388|
000184  e7ff              B        |L23.390|
                  |L23.390|
000186  2020              MOVS     r0,#0x20              ;3659
000188  f884003d          STRB     r0,[r4,#0x3d]         ;3659
00018c  2000              MOVS     r0,#0                 ;3660
00018e  f884003e          STRB     r0,[r4,#0x3e]         ;3660
000192  6c20              LDR      r0,[r4,#0x40]         ;3663
000194  f0400010          ORR      r0,r0,#0x10           ;3663
000198  6420              STR      r0,[r4,#0x40]         ;3663
00019a  bf00              NOP                            ;3666
00019c  2000              MOVS     r0,#0                 ;3666
00019e  f884003c          STRB     r0,[r4,#0x3c]         ;3666
0001a2  bf00              NOP                            ;3666
0001a4  2001              MOVS     r0,#1                 ;3668
0001a6  e76a              B        |L23.126|
                  |L23.424|
0001a8  6820              LDR      r0,[r4,#0]            ;3674
0001aa  6800              LDR      r0,[r0,#0]            ;3674
0001ac  f4406080          ORR      r0,r0,#0x400          ;3674
0001b0  6821              LDR      r1,[r4,#0]            ;3674
0001b2  6008              STR      r0,[r1,#0]            ;3674
0001b4  9801              LDR      r0,[sp,#4]            ;3678
0001b6  2811              CMP      r0,#0x11              ;3678
0001b8  d10a              BNE      |L23.464|
0001ba  f5b50f2a          CMP      r5,#0xaa0000          ;3678
0001be  d002              BEQ      |L23.454|
0001c0  f1b54f2a          CMP      r5,#0xaa000000        ;3678
0001c4  d101              BNE      |L23.458|
                  |L23.454|
0001c6  2001              MOVS     r0,#1                 ;3678
0001c8  e000              B        |L23.460|
                  |L23.458|
0001ca  2000              MOVS     r0,#0                 ;3678
                  |L23.460|
0001cc  2801              CMP      r0,#1                 ;3678
0001ce  d105              BNE      |L23.476|
                  |L23.464|
0001d0  6820              LDR      r0,[r4,#0]            ;3681
0001d2  6800              LDR      r0,[r0,#0]            ;3681
0001d4  f4407080          ORR      r0,r0,#0x100          ;3681
0001d8  6821              LDR      r1,[r4,#0]            ;3681
0001da  6008              STR      r0,[r1,#0]            ;3681
                  |L23.476|
0001dc  bf00              NOP                            ;3685
0001de  2000              MOVS     r0,#0                 ;3685
0001e0  f884003c          STRB     r0,[r4,#0x3c]         ;3685
0001e4  bf00              NOP                            ;3685
0001e6  6820              LDR      r0,[r4,#0]            ;3692
0001e8  6840              LDR      r0,[r0,#4]            ;3692
0001ea  f44060e0          ORR      r0,r0,#0x700          ;3692
0001ee  6821              LDR      r1,[r4,#0]            ;3692
0001f0  6048              STR      r0,[r1,#4]            ;3692
                  |L23.498|
0001f2  2000              MOVS     r0,#0                 ;3695
0001f4  e743              B        |L23.126|
                  |L23.502|
0001f6  2002              MOVS     r0,#2                 ;3699
0001f8  e741              B        |L23.126|
;;;3702   
                          ENDP

0001fa  0000              DCW      0x0000
                  |L23.508|
                          DCD      SystemCoreClock
                  |L23.512|
                          DCD      I2C_DMAXferCplt
                  |L23.516|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_IT PROC
;;;3450     */
;;;3451   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b57c              PUSH     {r2-r6,lr}
;;;3452   {
000002  4604              MOV      r4,r0
000004  9d06              LDR      r5,[sp,#0x18]
;;;3453     __IO uint32_t Prev_State = 0x00U;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;3454     __IO uint32_t count      = 0x00U;
00000a  9000              STR      r0,[sp,#0]
;;;3455   
;;;3456     /* Check the parameters */
;;;3457     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3458   
;;;3459     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d16e              BNE      |L24.242|
;;;3460     {
;;;3461       /* Check Busy Flag only if FIRST call of Master interface */
;;;3462       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  f4007000          AND      r0,r0,#0x200
00001c  f5b07f00          CMP      r0,#0x200
000020  d003              BEQ      |L24.42|
000022  2d08              CMP      r5,#8
000024  d001              BEQ      |L24.42|
000026  2d01              CMP      r5,#1
000028  d12c              BNE      |L24.132|
                  |L24.42|
;;;3463       {
;;;3464         /* Wait until BUSY flag is reset */
;;;3465         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
00002a  483e              LDR      r0,|L24.292|
00002c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00002e  2619              MOVS     r6,#0x19
000030  fbb0f0f6          UDIV     r0,r0,r6
000034  f44f767a          MOV      r6,#0x3e8
000038  fbb0f0f6          UDIV     r0,r0,r6
00003c  eb0006c0          ADD      r6,r0,r0,LSL #3
000040  eb061000          ADD      r0,r6,r0,LSL #4
000044  9000              STR      r0,[sp,#0]
;;;3466         do
000046  bf00              NOP      
                  |L24.72|
;;;3467         {
;;;3468           count--;
000048  9800              LDR      r0,[sp,#0]
00004a  1e40              SUBS     r0,r0,#1
00004c  9000              STR      r0,[sp,#0]
;;;3469           if (count == 0U)
00004e  9800              LDR      r0,[sp,#0]
000050  b990              CBNZ     r0,|L24.120|
;;;3470           {
;;;3471             hi2c->PreviousState       = I2C_STATE_NONE;
000052  2000              MOVS     r0,#0
000054  6320              STR      r0,[r4,#0x30]
;;;3472             hi2c->State               = HAL_I2C_STATE_READY;
000056  2020              MOVS     r0,#0x20
000058  f884003d          STRB     r0,[r4,#0x3d]
;;;3473             hi2c->Mode                = HAL_I2C_MODE_NONE;
00005c  2000              MOVS     r0,#0
00005e  f884003e          STRB     r0,[r4,#0x3e]
;;;3474             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000062  6c20              LDR      r0,[r4,#0x40]
000064  f0400020          ORR      r0,r0,#0x20
000068  6420              STR      r0,[r4,#0x40]
;;;3475   
;;;3476             /* Process Unlocked */
;;;3477             __HAL_UNLOCK(hi2c);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  f884003c          STRB     r0,[r4,#0x3c]
000072  bf00              NOP      
;;;3478   
;;;3479             return HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L24.118|
;;;3480           }
;;;3481         }
;;;3482         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3483       }
;;;3484   
;;;3485       /* Process Locked */
;;;3486       __HAL_LOCK(hi2c);
;;;3487   
;;;3488       /* Check if the I2C is already enabled */
;;;3489       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3490       {
;;;3491         /* Enable I2C peripheral */
;;;3492         __HAL_I2C_ENABLE(hi2c);
;;;3493       }
;;;3494   
;;;3495       /* Disable Pos */
;;;3496       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3497   
;;;3498       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3499       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3500       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3501   
;;;3502       /* Prepare transfer parameters */
;;;3503       hi2c->pBuffPtr    = pData;
;;;3504       hi2c->XferCount   = Size;
;;;3505       hi2c->XferSize    = hi2c->XferCount;
;;;3506       hi2c->XferOptions = XferOptions;
;;;3507       hi2c->Devaddress  = DevAddress;
;;;3508   
;;;3509       Prev_State = hi2c->PreviousState;
;;;3510   
;;;3511       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3512       /* Mean Previous state is same as current state */
;;;3513       if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3514       {
;;;3515         /* Generate Start */
;;;3516         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3517       }
;;;3518   
;;;3519       /* Process Unlocked */
;;;3520       __HAL_UNLOCK(hi2c);
;;;3521   
;;;3522       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3523       to avoid the risk of I2C interrupt handle execution before current
;;;3524       process unlock */
;;;3525   
;;;3526       /* Enable EVT, BUF and ERR interrupt */
;;;3527       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3528   
;;;3529       return HAL_OK;
;;;3530     }
;;;3531     else
;;;3532     {
;;;3533       return HAL_BUSY;
;;;3534     }
;;;3535   }
000076  bd7c              POP      {r2-r6,pc}
                  |L24.120|
000078  6820              LDR      r0,[r4,#0]            ;3482
00007a  6980              LDR      r0,[r0,#0x18]         ;3482
00007c  f3c00040          UBFX     r0,r0,#1,#1           ;3482
000080  2800              CMP      r0,#0                 ;3482
000082  d1e1              BNE      |L24.72|
                  |L24.132|
000084  bf00              NOP                            ;3486
000086  f894003c          LDRB     r0,[r4,#0x3c]         ;3486
00008a  2801              CMP      r0,#1                 ;3486
00008c  d101              BNE      |L24.146|
00008e  2002              MOVS     r0,#2                 ;3486
000090  e7f1              B        |L24.118|
                  |L24.146|
000092  2001              MOVS     r0,#1                 ;3486
000094  f884003c          STRB     r0,[r4,#0x3c]         ;3486
000098  bf00              NOP                            ;3486
00009a  6820              LDR      r0,[r4,#0]            ;3489
00009c  6800              LDR      r0,[r0,#0]            ;3489
00009e  f0000001          AND      r0,r0,#1              ;3489
0000a2  b928              CBNZ     r0,|L24.176|
0000a4  6820              LDR      r0,[r4,#0]            ;3492
0000a6  6800              LDR      r0,[r0,#0]            ;3492
0000a8  f0400001          ORR      r0,r0,#1              ;3492
0000ac  6826              LDR      r6,[r4,#0]            ;3492
0000ae  6030              STR      r0,[r6,#0]            ;3492
                  |L24.176|
0000b0  6820              LDR      r0,[r4,#0]            ;3496
0000b2  6800              LDR      r0,[r0,#0]            ;3496
0000b4  f4206000          BIC      r0,r0,#0x800          ;3496
0000b8  6826              LDR      r6,[r4,#0]            ;3496
0000ba  6030              STR      r0,[r6,#0]            ;3496
0000bc  2021              MOVS     r0,#0x21              ;3498
0000be  f884003d          STRB     r0,[r4,#0x3d]         ;3498
0000c2  2010              MOVS     r0,#0x10              ;3499
0000c4  f884003e          STRB     r0,[r4,#0x3e]         ;3499
0000c8  2000              MOVS     r0,#0                 ;3500
0000ca  6420              STR      r0,[r4,#0x40]         ;3500
0000cc  6262              STR      r2,[r4,#0x24]         ;3503
0000ce  8563              STRH     r3,[r4,#0x2a]         ;3504
0000d0  8d60              LDRH     r0,[r4,#0x2a]         ;3505
0000d2  8520              STRH     r0,[r4,#0x28]         ;3505
0000d4  62e5              STR      r5,[r4,#0x2c]         ;3506
0000d6  6461              STR      r1,[r4,#0x44]         ;3507
0000d8  6b20              LDR      r0,[r4,#0x30]         ;3509
0000da  9001              STR      r0,[sp,#4]            ;3509
0000dc  9801              LDR      r0,[sp,#4]            ;3513
0000de  2811              CMP      r0,#0x11              ;3513
0000e0  d10b              BNE      |L24.250|
0000e2  f5b50f2a          CMP      r5,#0xaa0000          ;3513
0000e6  d002              BEQ      |L24.238|
0000e8  f1b54f2a          CMP      r5,#0xaa000000        ;3513
0000ec  d102              BNE      |L24.244|
                  |L24.238|
0000ee  2001              MOVS     r0,#1                 ;3513
0000f0  e001              B        |L24.246|
                  |L24.242|
0000f2  e015              B        |L24.288|
                  |L24.244|
0000f4  2000              MOVS     r0,#0                 ;3513
                  |L24.246|
0000f6  2801              CMP      r0,#1                 ;3513
0000f8  d105              BNE      |L24.262|
                  |L24.250|
0000fa  6820              LDR      r0,[r4,#0]            ;3516
0000fc  6800              LDR      r0,[r0,#0]            ;3516
0000fe  f4407080          ORR      r0,r0,#0x100          ;3516
000102  6826              LDR      r6,[r4,#0]            ;3516
000104  6030              STR      r0,[r6,#0]            ;3516
                  |L24.262|
000106  bf00              NOP                            ;3520
000108  2000              MOVS     r0,#0                 ;3520
00010a  f884003c          STRB     r0,[r4,#0x3c]         ;3520
00010e  bf00              NOP                            ;3520
000110  6820              LDR      r0,[r4,#0]            ;3527
000112  6840              LDR      r0,[r0,#4]            ;3527
000114  f44060e0          ORR      r0,r0,#0x700          ;3527
000118  6826              LDR      r6,[r4,#0]            ;3527
00011a  6070              STR      r0,[r6,#4]            ;3527
00011c  2000              MOVS     r0,#0                 ;3529
00011e  e7aa              B        |L24.118|
                  |L24.288|
000120  2002              MOVS     r0,#2                 ;3533
000122  e7a8              B        |L24.118|
;;;3536   
                          ENDP

                  |L24.292|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit PROC
;;;1031     */
;;;1032   HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1033   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;1034     /* Init tickstart for timeout management*/
;;;1035     uint32_t tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4605              MOV      r5,r0
;;;1036   
;;;1037     if (hi2c->State == HAL_I2C_STATE_READY)
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2820              CMP      r0,#0x20
00001c  d17e              BNE      |L25.284|
;;;1038     {
;;;1039       /* Wait until BUSY flag is reset */
;;;1040       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001e  2319              MOVS     r3,#0x19
000020  2201              MOVS     r2,#1
000022  4951              LDR      r1,|L25.360|
000024  4620              MOV      r0,r4
000026  9500              STR      r5,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b110              CBZ      r0,|L25.52|
;;;1041       {
;;;1042         return HAL_BUSY;
00002e  2002              MOVS     r0,#2
                  |L25.48|
;;;1043       }
;;;1044   
;;;1045       /* Process Locked */
;;;1046       __HAL_LOCK(hi2c);
;;;1047   
;;;1048       /* Check if the I2C is already enabled */
;;;1049       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1050       {
;;;1051         /* Enable I2C peripheral */
;;;1052         __HAL_I2C_ENABLE(hi2c);
;;;1053       }
;;;1054   
;;;1055       /* Disable Pos */
;;;1056       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1057   
;;;1058       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1059       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1060       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1061   
;;;1062       /* Prepare transfer parameters */
;;;1063       hi2c->pBuffPtr    = pData;
;;;1064       hi2c->XferCount   = Size;
;;;1065       hi2c->XferSize    = hi2c->XferCount;
;;;1066       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1067   
;;;1068       /* Send Slave Address */
;;;1069       if (I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;1070       {
;;;1071         return HAL_ERROR;
;;;1072       }
;;;1073   
;;;1074       /* Clear ADDR flag */
;;;1075       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1076   
;;;1077       while (hi2c->XferSize > 0U)
;;;1078       {
;;;1079         /* Wait until TXE flag is set */
;;;1080         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1081         {
;;;1082           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1083           {
;;;1084             /* Generate Stop */
;;;1085             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1086           }
;;;1087           return HAL_ERROR;
;;;1088         }
;;;1089   
;;;1090         /* Write data to DR */
;;;1091         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1092   
;;;1093         /* Increment Buffer pointer */
;;;1094         hi2c->pBuffPtr++;
;;;1095   
;;;1096         /* Update counter */
;;;1097         hi2c->XferCount--;
;;;1098         hi2c->XferSize--;
;;;1099   
;;;1100         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1101         {
;;;1102           /* Write data to DR */
;;;1103           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1104   
;;;1105           /* Increment Buffer pointer */
;;;1106           hi2c->pBuffPtr++;
;;;1107   
;;;1108           /* Update counter */
;;;1109           hi2c->XferCount--;
;;;1110           hi2c->XferSize--;
;;;1111         }
;;;1112   
;;;1113         /* Wait until BTF flag is set */
;;;1114         if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1115         {
;;;1116           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1117           {
;;;1118             /* Generate Stop */
;;;1119             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1120           }
;;;1121           return HAL_ERROR;
;;;1122         }
;;;1123       }
;;;1124   
;;;1125       /* Generate Stop */
;;;1126       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1127   
;;;1128       hi2c->State = HAL_I2C_STATE_READY;
;;;1129       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1130   
;;;1131       /* Process Unlocked */
;;;1132       __HAL_UNLOCK(hi2c);
;;;1133   
;;;1134       return HAL_OK;
;;;1135     }
;;;1136     else
;;;1137     {
;;;1138       return HAL_BUSY;
;;;1139     }
;;;1140   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L25.52|
000034  bf00              NOP                            ;1046
000036  f894003c          LDRB     r0,[r4,#0x3c]         ;1046
00003a  2801              CMP      r0,#1                 ;1046
00003c  d101              BNE      |L25.66|
00003e  2002              MOVS     r0,#2                 ;1046
000040  e7f6              B        |L25.48|
                  |L25.66|
000042  2001              MOVS     r0,#1                 ;1046
000044  f884003c          STRB     r0,[r4,#0x3c]         ;1046
000048  bf00              NOP                            ;1046
00004a  6820              LDR      r0,[r4,#0]            ;1049
00004c  6800              LDR      r0,[r0,#0]            ;1049
00004e  f0000001          AND      r0,r0,#1              ;1049
000052  b928              CBNZ     r0,|L25.96|
000054  6820              LDR      r0,[r4,#0]            ;1052
000056  6800              LDR      r0,[r0,#0]            ;1052
000058  f0400001          ORR      r0,r0,#1              ;1052
00005c  6821              LDR      r1,[r4,#0]            ;1052
00005e  6008              STR      r0,[r1,#0]            ;1052
                  |L25.96|
000060  6820              LDR      r0,[r4,#0]            ;1056
000062  6800              LDR      r0,[r0,#0]            ;1056
000064  f4206000          BIC      r0,r0,#0x800          ;1056
000068  6821              LDR      r1,[r4,#0]            ;1056
00006a  6008              STR      r0,[r1,#0]            ;1056
00006c  2021              MOVS     r0,#0x21              ;1058
00006e  f884003d          STRB     r0,[r4,#0x3d]         ;1058
000072  2010              MOVS     r0,#0x10              ;1059
000074  f884003e          STRB     r0,[r4,#0x3e]         ;1059
000078  2000              MOVS     r0,#0                 ;1060
00007a  6420              STR      r0,[r4,#0x40]         ;1060
00007c  6266              STR      r6,[r4,#0x24]         ;1063
00007e  8567              STRH     r7,[r4,#0x2a]         ;1064
000080  8d60              LDRH     r0,[r4,#0x2a]         ;1065
000082  8520              STRH     r0,[r4,#0x28]         ;1065
000084  4839              LDR      r0,|L25.364|
000086  62e0              STR      r0,[r4,#0x2c]         ;1066
000088  462b              MOV      r3,r5                 ;1069
00008a  4642              MOV      r2,r8                 ;1069
00008c  4649              MOV      r1,r9                 ;1069
00008e  4620              MOV      r0,r4                 ;1069
000090  f7fffffe          BL       I2C_MasterRequestWrite
000094  b108              CBZ      r0,|L25.154|
000096  2001              MOVS     r0,#1                 ;1071
000098  e7ca              B        |L25.48|
                  |L25.154|
00009a  bf00              NOP                            ;1075
00009c  2000              MOVS     r0,#0                 ;1075
00009e  9000              STR      r0,[sp,#0]            ;1075
0000a0  6820              LDR      r0,[r4,#0]            ;1075
0000a2  6940              LDR      r0,[r0,#0x14]         ;1075
0000a4  9000              STR      r0,[sp,#0]            ;1075
0000a6  6820              LDR      r0,[r4,#0]            ;1075
0000a8  6980              LDR      r0,[r0,#0x18]         ;1075
0000aa  9000              STR      r0,[sp,#0]            ;1075
0000ac  bf00              NOP                            ;1075
0000ae  bf00              NOP                            ;1075
0000b0  e044              B        |L25.316|
                  |L25.178|
0000b2  462a              MOV      r2,r5                 ;1080
0000b4  4641              MOV      r1,r8                 ;1080
0000b6  4620              MOV      r0,r4                 ;1080
0000b8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000bc  b150              CBZ      r0,|L25.212|
0000be  6c20              LDR      r0,[r4,#0x40]         ;1082
0000c0  2804              CMP      r0,#4                 ;1082
0000c2  d105              BNE      |L25.208|
0000c4  6820              LDR      r0,[r4,#0]            ;1085
0000c6  6800              LDR      r0,[r0,#0]            ;1085
0000c8  f4407000          ORR      r0,r0,#0x200          ;1085
0000cc  6821              LDR      r1,[r4,#0]            ;1085
0000ce  6008              STR      r0,[r1,#0]            ;1085
                  |L25.208|
0000d0  2001              MOVS     r0,#1                 ;1087
0000d2  e7ad              B        |L25.48|
                  |L25.212|
0000d4  6a60              LDR      r0,[r4,#0x24]         ;1091
0000d6  7800              LDRB     r0,[r0,#0]            ;1091
0000d8  6821              LDR      r1,[r4,#0]            ;1091
0000da  6108              STR      r0,[r1,#0x10]         ;1091
0000dc  6a60              LDR      r0,[r4,#0x24]         ;1094
0000de  1c40              ADDS     r0,r0,#1              ;1094
0000e0  6260              STR      r0,[r4,#0x24]         ;1094
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1097
0000e4  1e40              SUBS     r0,r0,#1              ;1097
0000e6  8560              STRH     r0,[r4,#0x2a]         ;1097
0000e8  8d20              LDRH     r0,[r4,#0x28]         ;1098
0000ea  1e40              SUBS     r0,r0,#1              ;1098
0000ec  8520              STRH     r0,[r4,#0x28]         ;1098
0000ee  6820              LDR      r0,[r4,#0]            ;1100
0000f0  6940              LDR      r0,[r0,#0x14]         ;1100
0000f2  f3c00080          UBFX     r0,r0,#2,#1           ;1100
0000f6  b170              CBZ      r0,|L25.278|
0000f8  8d20              LDRH     r0,[r4,#0x28]         ;1100
0000fa  b160              CBZ      r0,|L25.278|
0000fc  6a60              LDR      r0,[r4,#0x24]         ;1103
0000fe  7800              LDRB     r0,[r0,#0]            ;1103
000100  6821              LDR      r1,[r4,#0]            ;1103
000102  6108              STR      r0,[r1,#0x10]         ;1103
000104  6a60              LDR      r0,[r4,#0x24]         ;1106
000106  1c40              ADDS     r0,r0,#1              ;1106
000108  6260              STR      r0,[r4,#0x24]         ;1106
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;1109
00010c  1e40              SUBS     r0,r0,#1              ;1109
00010e  8560              STRH     r0,[r4,#0x2a]         ;1109
000110  8d20              LDRH     r0,[r4,#0x28]         ;1110
000112  1e40              SUBS     r0,r0,#1              ;1110
000114  8520              STRH     r0,[r4,#0x28]         ;1110
                  |L25.278|
000116  462a              MOV      r2,r5                 ;1114
000118  4641              MOV      r1,r8                 ;1114
00011a  e000              B        |L25.286|
                  |L25.284|
00011c  e022              B        |L25.356|
                  |L25.286|
00011e  4620              MOV      r0,r4                 ;1114
000120  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
000124  b150              CBZ      r0,|L25.316|
000126  6c20              LDR      r0,[r4,#0x40]         ;1116
000128  2804              CMP      r0,#4                 ;1116
00012a  d105              BNE      |L25.312|
00012c  6820              LDR      r0,[r4,#0]            ;1119
00012e  6800              LDR      r0,[r0,#0]            ;1119
000130  f4407000          ORR      r0,r0,#0x200          ;1119
000134  6821              LDR      r1,[r4,#0]            ;1119
000136  6008              STR      r0,[r1,#0]            ;1119
                  |L25.312|
000138  2001              MOVS     r0,#1                 ;1121
00013a  e779              B        |L25.48|
                  |L25.316|
00013c  8d20              LDRH     r0,[r4,#0x28]         ;1077
00013e  2800              CMP      r0,#0                 ;1077
000140  d1b7              BNE      |L25.178|
000142  6820              LDR      r0,[r4,#0]            ;1126
000144  6800              LDR      r0,[r0,#0]            ;1126
000146  f4407000          ORR      r0,r0,#0x200          ;1126
00014a  6821              LDR      r1,[r4,#0]            ;1126
00014c  6008              STR      r0,[r1,#0]            ;1126
00014e  2020              MOVS     r0,#0x20              ;1128
000150  f884003d          STRB     r0,[r4,#0x3d]         ;1128
000154  2000              MOVS     r0,#0                 ;1129
000156  f884003e          STRB     r0,[r4,#0x3e]         ;1129
00015a  bf00              NOP                            ;1132
00015c  f884003c          STRB     r0,[r4,#0x3c]         ;1132
000160  bf00              NOP                            ;1132
000162  e765              B        |L25.48|
                  |L25.356|
000164  2002              MOVS     r0,#2                 ;1138
000166  e763              B        |L25.48|
;;;1141   
                          ENDP

                  |L25.360|
                          DCD      0x00100002
                  |L25.364|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_DMA PROC
;;;1935     */
;;;1936   HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1937   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1938     __IO uint32_t count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;1939     HAL_StatusTypeDef dmaxferstatus;
;;;1940   
;;;1941     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d17d              BNE      |L26.276|
;;;1942     {
;;;1943       /* Wait until BUSY flag is reset */
;;;1944       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000018  4861              LDR      r0,|L26.416|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  2119              MOVS     r1,#0x19
00001e  fbb0f0f1          UDIV     r0,r0,r1
000022  f44f717a          MOV      r1,#0x3e8
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  eb0001c0          ADD      r1,r0,r0,LSL #3
00002e  eb011000          ADD      r0,r1,r0,LSL #4
000032  9000              STR      r0,[sp,#0]
;;;1945       do
000034  bf00              NOP      
                  |L26.54|
;;;1946       {
;;;1947         count--;
000036  9800              LDR      r0,[sp,#0]
000038  1e40              SUBS     r0,r0,#1
00003a  9000              STR      r0,[sp,#0]
;;;1948         if (count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b998              CBNZ     r0,|L26.104|
;;;1949         {
;;;1950           hi2c->PreviousState       = I2C_STATE_NONE;
000040  2000              MOVS     r0,#0
000042  6320              STR      r0,[r4,#0x30]
;;;1951           hi2c->State               = HAL_I2C_STATE_READY;
000044  2020              MOVS     r0,#0x20
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;1952           hi2c->Mode                = HAL_I2C_MODE_NONE;
00004a  2000              MOVS     r0,#0
00004c  f884003e          STRB     r0,[r4,#0x3e]
;;;1953           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000050  6c20              LDR      r0,[r4,#0x40]
000052  f0400020          ORR      r0,r0,#0x20
000056  6420              STR      r0,[r4,#0x40]
;;;1954   
;;;1955           /* Process Unlocked */
;;;1956           __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
;;;1957   
;;;1958           return HAL_ERROR;
000062  2001              MOVS     r0,#1
                  |L26.100|
;;;1959         }
;;;1960       }
;;;1961       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1962   
;;;1963       /* Process Locked */
;;;1964       __HAL_LOCK(hi2c);
;;;1965   
;;;1966       /* Check if the I2C is already enabled */
;;;1967       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1968       {
;;;1969         /* Enable I2C peripheral */
;;;1970         __HAL_I2C_ENABLE(hi2c);
;;;1971       }
;;;1972   
;;;1973       /* Disable Pos */
;;;1974       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1975   
;;;1976       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1977       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1978       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1979   
;;;1980       /* Prepare transfer parameters */
;;;1981       hi2c->pBuffPtr    = pData;
;;;1982       hi2c->XferCount   = Size;
;;;1983       hi2c->XferSize    = hi2c->XferCount;
;;;1984       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1985       hi2c->Devaddress  = DevAddress;
;;;1986   
;;;1987       if (hi2c->XferSize > 0U)
;;;1988       {
;;;1989         /* Set the I2C DMA transfer complete callback */
;;;1990         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;1991   
;;;1992         /* Set the DMA error callback */
;;;1993         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1994   
;;;1995         /* Set the unused DMA callbacks to NULL */
;;;1996         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;1997         hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;1998         hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;1999         hi2c->hdmatx->XferAbortCallback = NULL;
;;;2000   
;;;2001         /* Enable the DMA stream */
;;;2002         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;2003   
;;;2004         if (dmaxferstatus == HAL_OK)
;;;2005         {
;;;2006           /* Enable Acknowledge */
;;;2007           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2008   
;;;2009           /* Generate Start */
;;;2010           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2011   
;;;2012           /* Process Unlocked */
;;;2013           __HAL_UNLOCK(hi2c);
;;;2014   
;;;2015           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2016           to avoid the risk of I2C interrupt handle execution before current
;;;2017           process unlock */
;;;2018   
;;;2019           /* Enable EVT and ERR interrupt */
;;;2020           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2021   
;;;2022           /* Enable DMA Request */
;;;2023           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2024         }
;;;2025         else
;;;2026         {
;;;2027           /* Update I2C state */
;;;2028           hi2c->State     = HAL_I2C_STATE_READY;
;;;2029           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2030   
;;;2031           /* Update I2C error code */
;;;2032           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2033   
;;;2034           /* Process Unlocked */
;;;2035           __HAL_UNLOCK(hi2c);
;;;2036   
;;;2037           return HAL_ERROR;
;;;2038         }
;;;2039       }
;;;2040       else
;;;2041       {
;;;2042         /* Enable Acknowledge */
;;;2043         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2044   
;;;2045         /* Generate Start */
;;;2046         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2047   
;;;2048         /* Process Unlocked */
;;;2049         __HAL_UNLOCK(hi2c);
;;;2050   
;;;2051         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2052         to avoid the risk of I2C interrupt handle execution before current
;;;2053         process unlock */
;;;2054   
;;;2055         /* Enable EVT, BUF and ERR interrupt */
;;;2056         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2057       }
;;;2058   
;;;2059       return HAL_OK;
;;;2060     }
;;;2061     else
;;;2062     {
;;;2063       return HAL_BUSY;
;;;2064     }
;;;2065   }
000064  e8bd83f8          POP      {r3-r9,pc}
                  |L26.104|
000068  6820              LDR      r0,[r4,#0]            ;1961
00006a  6980              LDR      r0,[r0,#0x18]         ;1961
00006c  f3c00040          UBFX     r0,r0,#1,#1           ;1961
000070  2800              CMP      r0,#0                 ;1961
000072  d1e0              BNE      |L26.54|
000074  bf00              NOP                            ;1964
000076  f894003c          LDRB     r0,[r4,#0x3c]         ;1964
00007a  2801              CMP      r0,#1                 ;1964
00007c  d101              BNE      |L26.130|
00007e  2002              MOVS     r0,#2                 ;1964
000080  e7f0              B        |L26.100|
                  |L26.130|
000082  2001              MOVS     r0,#1                 ;1964
000084  f884003c          STRB     r0,[r4,#0x3c]         ;1964
000088  bf00              NOP                            ;1964
00008a  6820              LDR      r0,[r4,#0]            ;1967
00008c  6800              LDR      r0,[r0,#0]            ;1967
00008e  f0000001          AND      r0,r0,#1              ;1967
000092  b928              CBNZ     r0,|L26.160|
000094  6820              LDR      r0,[r4,#0]            ;1970
000096  6800              LDR      r0,[r0,#0]            ;1970
000098  f0400001          ORR      r0,r0,#1              ;1970
00009c  6821              LDR      r1,[r4,#0]            ;1970
00009e  6008              STR      r0,[r1,#0]            ;1970
                  |L26.160|
0000a0  6820              LDR      r0,[r4,#0]            ;1974
0000a2  6800              LDR      r0,[r0,#0]            ;1974
0000a4  f4206000          BIC      r0,r0,#0x800          ;1974
0000a8  6821              LDR      r1,[r4,#0]            ;1974
0000aa  6008              STR      r0,[r1,#0]            ;1974
0000ac  2021              MOVS     r0,#0x21              ;1976
0000ae  f884003d          STRB     r0,[r4,#0x3d]         ;1976
0000b2  2010              MOVS     r0,#0x10              ;1977
0000b4  f884003e          STRB     r0,[r4,#0x3e]         ;1977
0000b8  2000              MOVS     r0,#0                 ;1978
0000ba  6420              STR      r0,[r4,#0x40]         ;1978
0000bc  6267              STR      r7,[r4,#0x24]         ;1981
0000be  f8a4802a          STRH     r8,[r4,#0x2a]         ;1982
0000c2  8d60              LDRH     r0,[r4,#0x2a]         ;1983
0000c4  8520              STRH     r0,[r4,#0x28]         ;1983
0000c6  4837              LDR      r0,|L26.420|
0000c8  62e0              STR      r0,[r4,#0x2c]         ;1984
0000ca  6466              STR      r6,[r4,#0x44]         ;1985
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;1987
0000ce  2800              CMP      r0,#0                 ;1987
0000d0  d04a              BEQ      |L26.360|
0000d2  4835              LDR      r0,|L26.424|
0000d4  6b61              LDR      r1,[r4,#0x34]         ;1990
0000d6  63c8              STR      r0,[r1,#0x3c]         ;1990
0000d8  4834              LDR      r0,|L26.428|
0000da  6b61              LDR      r1,[r4,#0x34]         ;1993
0000dc  64c8              STR      r0,[r1,#0x4c]         ;1993
0000de  2000              MOVS     r0,#0                 ;1996
0000e0  6b61              LDR      r1,[r4,#0x34]         ;1996
0000e2  6408              STR      r0,[r1,#0x40]         ;1996
0000e4  6b61              LDR      r1,[r4,#0x34]         ;1997
0000e6  6448              STR      r0,[r1,#0x44]         ;1997
0000e8  6b61              LDR      r1,[r4,#0x34]         ;1998
0000ea  6488              STR      r0,[r1,#0x48]         ;1998
0000ec  6b61              LDR      r1,[r4,#0x34]         ;1999
0000ee  6508              STR      r0,[r1,#0x50]         ;1999
0000f0  8d23              LDRH     r3,[r4,#0x28]         ;2002
0000f2  f8d4c000          LDR      r12,[r4,#0]           ;2002
0000f6  f10c0210          ADD      r2,r12,#0x10          ;2002
0000fa  6a61              LDR      r1,[r4,#0x24]         ;2002
0000fc  6b60              LDR      r0,[r4,#0x34]         ;2002
0000fe  f7fffffe          BL       HAL_DMA_Start_IT
000102  4605              MOV      r5,r0                 ;2002
000104  b9fd              CBNZ     r5,|L26.326|
000106  6820              LDR      r0,[r4,#0]            ;2007
000108  6800              LDR      r0,[r0,#0]            ;2007
00010a  f4406080          ORR      r0,r0,#0x400          ;2007
00010e  6821              LDR      r1,[r4,#0]            ;2007
000110  6008              STR      r0,[r1,#0]            ;2007
000112  e000              B        |L26.278|
                  |L26.276|
000114  e041              B        |L26.410|
                  |L26.278|
000116  6820              LDR      r0,[r4,#0]            ;2010
000118  6800              LDR      r0,[r0,#0]            ;2010
00011a  f4407080          ORR      r0,r0,#0x100          ;2010
00011e  6821              LDR      r1,[r4,#0]            ;2010
000120  6008              STR      r0,[r1,#0]            ;2010
000122  bf00              NOP                            ;2013
000124  2000              MOVS     r0,#0                 ;2013
000126  f884003c          STRB     r0,[r4,#0x3c]         ;2013
00012a  bf00              NOP                            ;2013
00012c  6820              LDR      r0,[r4,#0]            ;2020
00012e  6840              LDR      r0,[r0,#4]            ;2020
000130  f4407040          ORR      r0,r0,#0x300          ;2020
000134  6821              LDR      r1,[r4,#0]            ;2020
000136  6048              STR      r0,[r1,#4]            ;2020
000138  6820              LDR      r0,[r4,#0]            ;2023
00013a  6840              LDR      r0,[r0,#4]            ;2023
00013c  f4406000          ORR      r0,r0,#0x800          ;2023
000140  6821              LDR      r1,[r4,#0]            ;2023
000142  6048              STR      r0,[r1,#4]            ;2023
000144  e027              B        |L26.406|
                  |L26.326|
000146  2020              MOVS     r0,#0x20              ;2028
000148  f884003d          STRB     r0,[r4,#0x3d]         ;2028
00014c  2000              MOVS     r0,#0                 ;2029
00014e  f884003e          STRB     r0,[r4,#0x3e]         ;2029
000152  6c20              LDR      r0,[r4,#0x40]         ;2032
000154  f0400010          ORR      r0,r0,#0x10           ;2032
000158  6420              STR      r0,[r4,#0x40]         ;2032
00015a  bf00              NOP                            ;2035
00015c  2000              MOVS     r0,#0                 ;2035
00015e  f884003c          STRB     r0,[r4,#0x3c]         ;2035
000162  bf00              NOP                            ;2035
000164  2001              MOVS     r0,#1                 ;2037
000166  e77d              B        |L26.100|
                  |L26.360|
000168  6820              LDR      r0,[r4,#0]            ;2043
00016a  6800              LDR      r0,[r0,#0]            ;2043
00016c  f4406080          ORR      r0,r0,#0x400          ;2043
000170  6821              LDR      r1,[r4,#0]            ;2043
000172  6008              STR      r0,[r1,#0]            ;2043
000174  6820              LDR      r0,[r4,#0]            ;2046
000176  6800              LDR      r0,[r0,#0]            ;2046
000178  f4407080          ORR      r0,r0,#0x100          ;2046
00017c  6821              LDR      r1,[r4,#0]            ;2046
00017e  6008              STR      r0,[r1,#0]            ;2046
000180  bf00              NOP                            ;2049
000182  2000              MOVS     r0,#0                 ;2049
000184  f884003c          STRB     r0,[r4,#0x3c]         ;2049
000188  bf00              NOP                            ;2049
00018a  6820              LDR      r0,[r4,#0]            ;2056
00018c  6840              LDR      r0,[r0,#4]            ;2056
00018e  f44060e0          ORR      r0,r0,#0x700          ;2056
000192  6821              LDR      r1,[r4,#0]            ;2056
000194  6048              STR      r0,[r1,#4]            ;2056
                  |L26.406|
000196  2000              MOVS     r0,#0                 ;2059
000198  e764              B        |L26.100|
                  |L26.410|
00019a  2002              MOVS     r0,#2                 ;2063
00019c  e762              B        |L26.100|
;;;2066   
                          ENDP

00019e  0000              DCW      0x0000
                  |L26.416|
                          DCD      SystemCoreClock
                  |L26.420|
                          DCD      0xffff0000
                  |L26.424|
                          DCD      I2C_DMAXferCplt
                  |L26.428|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_IT PROC
;;;1647     */
;;;1648   HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;1649   {
000002  4604              MOV      r4,r0
;;;1650     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1651   
;;;1652     if (hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d16a              BNE      |L27.230|
;;;1653     {
;;;1654       /* Wait until BUSY flag is reset */
;;;1655       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000010  4836              LDR      r0,|L27.236|
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  2519              MOVS     r5,#0x19
000016  fbb0f0f5          UDIV     r0,r0,r5
00001a  f44f757a          MOV      r5,#0x3e8
00001e  fbb0f0f5          UDIV     r0,r0,r5
000022  eb0005c0          ADD      r5,r0,r0,LSL #3
000026  eb051000          ADD      r0,r5,r0,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;1656       do
00002c  bf00              NOP      
                  |L27.46|
;;;1657       {
;;;1658         count--;
00002e  9800              LDR      r0,[sp,#0]
000030  1e40              SUBS     r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;1659         if (count == 0U)
000034  9800              LDR      r0,[sp,#0]
000036  b990              CBNZ     r0,|L27.94|
;;;1660         {
;;;1661           hi2c->PreviousState       = I2C_STATE_NONE;
000038  2000              MOVS     r0,#0
00003a  6320              STR      r0,[r4,#0x30]
;;;1662           hi2c->State               = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;1663           hi2c->Mode                = HAL_I2C_MODE_NONE;
000042  2000              MOVS     r0,#0
000044  f884003e          STRB     r0,[r4,#0x3e]
;;;1664           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000048  6c20              LDR      r0,[r4,#0x40]
00004a  f0400020          ORR      r0,r0,#0x20
00004e  6420              STR      r0,[r4,#0x40]
;;;1665   
;;;1666           /* Process Unlocked */
;;;1667           __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2000              MOVS     r0,#0
000054  f884003c          STRB     r0,[r4,#0x3c]
000058  bf00              NOP      
;;;1668   
;;;1669           return HAL_ERROR;
00005a  2001              MOVS     r0,#1
                  |L27.92|
;;;1670         }
;;;1671       }
;;;1672       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1673   
;;;1674       /* Process Locked */
;;;1675       __HAL_LOCK(hi2c);
;;;1676   
;;;1677       /* Check if the I2C is already enabled */
;;;1678       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1679       {
;;;1680         /* Enable I2C peripheral */
;;;1681         __HAL_I2C_ENABLE(hi2c);
;;;1682       }
;;;1683   
;;;1684       /* Disable Pos */
;;;1685       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1686   
;;;1687       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1688       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1689       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1690   
;;;1691       /* Prepare transfer parameters */
;;;1692       hi2c->pBuffPtr    = pData;
;;;1693       hi2c->XferCount   = Size;
;;;1694       hi2c->XferSize    = hi2c->XferCount;
;;;1695       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1696       hi2c->Devaddress  = DevAddress;
;;;1697   
;;;1698       /* Generate Start */
;;;1699       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;1700   
;;;1701       /* Process Unlocked */
;;;1702       __HAL_UNLOCK(hi2c);
;;;1703   
;;;1704       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1705                 to avoid the risk of I2C interrupt handle execution before current
;;;1706                 process unlock */
;;;1707       /* Enable EVT, BUF and ERR interrupt */
;;;1708       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1709   
;;;1710       return HAL_OK;
;;;1711     }
;;;1712     else
;;;1713     {
;;;1714       return HAL_BUSY;
;;;1715     }
;;;1716   }
00005c  bd38              POP      {r3-r5,pc}
                  |L27.94|
00005e  6820              LDR      r0,[r4,#0]            ;1672
000060  6980              LDR      r0,[r0,#0x18]         ;1672
000062  f3c00040          UBFX     r0,r0,#1,#1           ;1672
000066  2800              CMP      r0,#0                 ;1672
000068  d1e1              BNE      |L27.46|
00006a  bf00              NOP                            ;1675
00006c  f894003c          LDRB     r0,[r4,#0x3c]         ;1675
000070  2801              CMP      r0,#1                 ;1675
000072  d101              BNE      |L27.120|
000074  2002              MOVS     r0,#2                 ;1675
000076  e7f1              B        |L27.92|
                  |L27.120|
000078  2001              MOVS     r0,#1                 ;1675
00007a  f884003c          STRB     r0,[r4,#0x3c]         ;1675
00007e  bf00              NOP                            ;1675
000080  6820              LDR      r0,[r4,#0]            ;1678
000082  6800              LDR      r0,[r0,#0]            ;1678
000084  f0000001          AND      r0,r0,#1              ;1678
000088  b928              CBNZ     r0,|L27.150|
00008a  6820              LDR      r0,[r4,#0]            ;1681
00008c  6800              LDR      r0,[r0,#0]            ;1681
00008e  f0400001          ORR      r0,r0,#1              ;1681
000092  6825              LDR      r5,[r4,#0]            ;1681
000094  6028              STR      r0,[r5,#0]            ;1681
                  |L27.150|
000096  6820              LDR      r0,[r4,#0]            ;1685
000098  6800              LDR      r0,[r0,#0]            ;1685
00009a  f4206000          BIC      r0,r0,#0x800          ;1685
00009e  6825              LDR      r5,[r4,#0]            ;1685
0000a0  6028              STR      r0,[r5,#0]            ;1685
0000a2  2021              MOVS     r0,#0x21              ;1687
0000a4  f884003d          STRB     r0,[r4,#0x3d]         ;1687
0000a8  2010              MOVS     r0,#0x10              ;1688
0000aa  f884003e          STRB     r0,[r4,#0x3e]         ;1688
0000ae  2000              MOVS     r0,#0                 ;1689
0000b0  6420              STR      r0,[r4,#0x40]         ;1689
0000b2  6262              STR      r2,[r4,#0x24]         ;1692
0000b4  8563              STRH     r3,[r4,#0x2a]         ;1693
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1694
0000b8  8520              STRH     r0,[r4,#0x28]         ;1694
0000ba  480d              LDR      r0,|L27.240|
0000bc  62e0              STR      r0,[r4,#0x2c]         ;1695
0000be  6461              STR      r1,[r4,#0x44]         ;1696
0000c0  6820              LDR      r0,[r4,#0]            ;1699
0000c2  6800              LDR      r0,[r0,#0]            ;1699
0000c4  f4407080          ORR      r0,r0,#0x100          ;1699
0000c8  6825              LDR      r5,[r4,#0]            ;1699
0000ca  6028              STR      r0,[r5,#0]            ;1699
0000cc  bf00              NOP                            ;1702
0000ce  2000              MOVS     r0,#0                 ;1702
0000d0  f884003c          STRB     r0,[r4,#0x3c]         ;1702
0000d4  bf00              NOP                            ;1702
0000d6  6820              LDR      r0,[r4,#0]            ;1708
0000d8  6840              LDR      r0,[r0,#4]            ;1708
0000da  f44060e0          ORR      r0,r0,#0x700          ;1708
0000de  6825              LDR      r5,[r4,#0]            ;1708
0000e0  6068              STR      r0,[r5,#4]            ;1708
0000e2  2000              MOVS     r0,#0                 ;1710
0000e4  e7ba              B        |L27.92|
                  |L27.230|
0000e6  2002              MOVS     r0,#2                 ;1714
0000e8  e7b8              B        |L27.92|
;;;1717   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L27.236|
                          DCD      SystemCoreClock
                  |L27.240|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MemRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemRxCpltCallback PROC
;;;4971     */
;;;4972   __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4973   {
;;;4974     /* Prevent unused argument(s) compilation warning */
;;;4975     UNUSED(hi2c);
;;;4976   
;;;4977     /* NOTE : This function should not be modified, when the callback is needed,
;;;4978               the HAL_I2C_MemRxCpltCallback could be implemented in the user file
;;;4979      */
;;;4980   }
;;;4981   
                          ENDP


                          AREA ||i.HAL_I2C_MemTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemTxCpltCallback PROC
;;;4955     */
;;;4956   __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4957   {
;;;4958     /* Prevent unused argument(s) compilation warning */
;;;4959     UNUSED(hi2c);
;;;4960   
;;;4961     /* NOTE : This function should not be modified, when the callback is needed,
;;;4962               the HAL_I2C_MemTxCpltCallback could be implemented in the user file
;;;4963      */
;;;4964   }
;;;4965   
                          ENDP


                          AREA ||i.HAL_I2C_Mem_Read||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read PROC
;;;2537     */
;;;2538   HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2539   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  9e0e              LDR      r6,[sp,#0x38]
;;;2540     /* Init tickstart for timeout management*/
;;;2541     uint32_t tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2542   
;;;2543     /* Check the parameters */
;;;2544     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2545   
;;;2546     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d170              BNE      |L30.258|
;;;2547     {
;;;2548       /* Wait until BUSY flag is reset */
;;;2549       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
000020  2319              MOVS     r3,#0x19
000022  2201              MOVS     r2,#1
000024  49b0              LDR      r1,|L30.744|
000026  4620              MOV      r0,r4
000028  9500              STR      r5,[sp,#0]
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  b110              CBZ      r0,|L30.54|
;;;2550       {
;;;2551         return HAL_BUSY;
000030  2002              MOVS     r0,#2
                  |L30.50|
;;;2552       }
;;;2553   
;;;2554       /* Process Locked */
;;;2555       __HAL_LOCK(hi2c);
;;;2556   
;;;2557       /* Check if the I2C is already enabled */
;;;2558       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2559       {
;;;2560         /* Enable I2C peripheral */
;;;2561         __HAL_I2C_ENABLE(hi2c);
;;;2562       }
;;;2563   
;;;2564       /* Disable Pos */
;;;2565       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2566   
;;;2567       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2568       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2569       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2570   
;;;2571       /* Prepare transfer parameters */
;;;2572       hi2c->pBuffPtr    = pData;
;;;2573       hi2c->XferCount   = Size;
;;;2574       hi2c->XferSize    = hi2c->XferCount;
;;;2575       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2576   
;;;2577       /* Send Slave Address and Memory Address */
;;;2578       if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2579       {
;;;2580         return HAL_ERROR;
;;;2581       }
;;;2582   
;;;2583       if (hi2c->XferSize == 0U)
;;;2584       {
;;;2585         /* Clear ADDR flag */
;;;2586         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2587   
;;;2588         /* Generate Stop */
;;;2589         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2590       }
;;;2591       else if (hi2c->XferSize == 1U)
;;;2592       {
;;;2593         /* Disable Acknowledge */
;;;2594         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2595   
;;;2596         /* Clear ADDR flag */
;;;2597         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2598   
;;;2599         /* Generate Stop */
;;;2600         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2601       }
;;;2602       else if (hi2c->XferSize == 2U)
;;;2603       {
;;;2604         /* Disable Acknowledge */
;;;2605         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2606   
;;;2607         /* Enable Pos */
;;;2608         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2609   
;;;2610         /* Clear ADDR flag */
;;;2611         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2612       }
;;;2613       else
;;;2614       {
;;;2615         /* Clear ADDR flag */
;;;2616         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2617       }
;;;2618   
;;;2619       while (hi2c->XferSize > 0U)
;;;2620       {
;;;2621         if (hi2c->XferSize <= 3U)
;;;2622         {
;;;2623           /* One byte */
;;;2624           if (hi2c->XferSize == 1U)
;;;2625           {
;;;2626             /* Wait until RXNE flag is set */
;;;2627             if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2628             {
;;;2629               return HAL_ERROR;
;;;2630             }
;;;2631   
;;;2632             /* Read data from DR */
;;;2633             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2634   
;;;2635             /* Increment Buffer pointer */
;;;2636             hi2c->pBuffPtr++;
;;;2637   
;;;2638             /* Update counter */
;;;2639             hi2c->XferSize--;
;;;2640             hi2c->XferCount--;
;;;2641           }
;;;2642           /* Two bytes */
;;;2643           else if (hi2c->XferSize == 2U)
;;;2644           {
;;;2645             /* Wait until BTF flag is set */
;;;2646             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2647             {
;;;2648               return HAL_ERROR;
;;;2649             }
;;;2650   
;;;2651             /* Generate Stop */
;;;2652             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2653   
;;;2654             /* Read data from DR */
;;;2655             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2656   
;;;2657             /* Increment Buffer pointer */
;;;2658             hi2c->pBuffPtr++;
;;;2659   
;;;2660             /* Update counter */
;;;2661             hi2c->XferSize--;
;;;2662             hi2c->XferCount--;
;;;2663   
;;;2664             /* Read data from DR */
;;;2665             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2666   
;;;2667             /* Increment Buffer pointer */
;;;2668             hi2c->pBuffPtr++;
;;;2669   
;;;2670             /* Update counter */
;;;2671             hi2c->XferSize--;
;;;2672             hi2c->XferCount--;
;;;2673           }
;;;2674           /* 3 Last bytes */
;;;2675           else
;;;2676           {
;;;2677             /* Wait until BTF flag is set */
;;;2678             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2679             {
;;;2680               return HAL_ERROR;
;;;2681             }
;;;2682   
;;;2683             /* Disable Acknowledge */
;;;2684             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2685   
;;;2686             /* Read data from DR */
;;;2687             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2688   
;;;2689             /* Increment Buffer pointer */
;;;2690             hi2c->pBuffPtr++;
;;;2691   
;;;2692             /* Update counter */
;;;2693             hi2c->XferSize--;
;;;2694             hi2c->XferCount--;
;;;2695   
;;;2696             /* Wait until BTF flag is set */
;;;2697             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2698             {
;;;2699               return HAL_ERROR;
;;;2700             }
;;;2701   
;;;2702             /* Generate Stop */
;;;2703             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2704   
;;;2705             /* Read data from DR */
;;;2706             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2707   
;;;2708             /* Increment Buffer pointer */
;;;2709             hi2c->pBuffPtr++;
;;;2710   
;;;2711             /* Update counter */
;;;2712             hi2c->XferSize--;
;;;2713             hi2c->XferCount--;
;;;2714   
;;;2715             /* Read data from DR */
;;;2716             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2717   
;;;2718             /* Increment Buffer pointer */
;;;2719             hi2c->pBuffPtr++;
;;;2720   
;;;2721             /* Update counter */
;;;2722             hi2c->XferSize--;
;;;2723             hi2c->XferCount--;
;;;2724           }
;;;2725         }
;;;2726         else
;;;2727         {
;;;2728           /* Wait until RXNE flag is set */
;;;2729           if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2730           {
;;;2731             return HAL_ERROR;
;;;2732           }
;;;2733   
;;;2734           /* Read data from DR */
;;;2735           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2736   
;;;2737           /* Increment Buffer pointer */
;;;2738           hi2c->pBuffPtr++;
;;;2739   
;;;2740           /* Update counter */
;;;2741           hi2c->XferSize--;
;;;2742           hi2c->XferCount--;
;;;2743   
;;;2744           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;2745           {
;;;2746             /* Read data from DR */
;;;2747             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2748   
;;;2749             /* Increment Buffer pointer */
;;;2750             hi2c->pBuffPtr++;
;;;2751   
;;;2752             /* Update counter */
;;;2753             hi2c->XferSize--;
;;;2754             hi2c->XferCount--;
;;;2755           }
;;;2756         }
;;;2757       }
;;;2758   
;;;2759       hi2c->State = HAL_I2C_STATE_READY;
;;;2760       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2761   
;;;2762       /* Process Unlocked */
;;;2763       __HAL_UNLOCK(hi2c);
;;;2764   
;;;2765       return HAL_OK;
;;;2766     }
;;;2767     else
;;;2768     {
;;;2769       return HAL_BUSY;
;;;2770     }
;;;2771   }
000032  e8bd9ffc          POP      {r2-r12,pc}
                  |L30.54|
000036  bf00              NOP                            ;2555
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;2555
00003c  2801              CMP      r0,#1                 ;2555
00003e  d101              BNE      |L30.68|
000040  2002              MOVS     r0,#2                 ;2555
000042  e7f6              B        |L30.50|
                  |L30.68|
000044  2001              MOVS     r0,#1                 ;2555
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2555
00004a  bf00              NOP                            ;2555
00004c  6820              LDR      r0,[r4,#0]            ;2558
00004e  6800              LDR      r0,[r0,#0]            ;2558
000050  f0000001          AND      r0,r0,#1              ;2558
000054  b928              CBNZ     r0,|L30.98|
000056  6820              LDR      r0,[r4,#0]            ;2561
000058  6800              LDR      r0,[r0,#0]            ;2561
00005a  f0400001          ORR      r0,r0,#1              ;2561
00005e  6821              LDR      r1,[r4,#0]            ;2561
000060  6008              STR      r0,[r1,#0]            ;2561
                  |L30.98|
000062  6820              LDR      r0,[r4,#0]            ;2565
000064  6800              LDR      r0,[r0,#0]            ;2565
000066  f4206000          BIC      r0,r0,#0x800          ;2565
00006a  6821              LDR      r1,[r4,#0]            ;2565
00006c  6008              STR      r0,[r1,#0]            ;2565
00006e  2022              MOVS     r0,#0x22              ;2567
000070  f884003d          STRB     r0,[r4,#0x3d]         ;2567
000074  2040              MOVS     r0,#0x40              ;2568
000076  f884003e          STRB     r0,[r4,#0x3e]         ;2568
00007a  2000              MOVS     r0,#0                 ;2569
00007c  6420              STR      r0,[r4,#0x40]         ;2569
00007e  f8c4a024          STR      r10,[r4,#0x24]        ;2572
000082  f8a4b02a          STRH     r11,[r4,#0x2a]        ;2573
000086  8d60              LDRH     r0,[r4,#0x2a]         ;2574
000088  8520              STRH     r0,[r4,#0x28]         ;2574
00008a  4898              LDR      r0,|L30.748|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2575
00008e  464b              MOV      r3,r9                 ;2578
000090  4642              MOV      r2,r8                 ;2578
000092  4639              MOV      r1,r7                 ;2578
000094  4620              MOV      r0,r4                 ;2578
000096  e9cd6500          STRD     r6,r5,[sp,#0]         ;2578
00009a  f7fffffe          BL       I2C_RequestMemoryRead
00009e  b108              CBZ      r0,|L30.164|
0000a0  2001              MOVS     r0,#1                 ;2580
0000a2  e7c6              B        |L30.50|
                  |L30.164|
0000a4  8d20              LDRH     r0,[r4,#0x28]         ;2583
0000a6  b988              CBNZ     r0,|L30.204|
0000a8  bf00              NOP                            ;2586
0000aa  2000              MOVS     r0,#0                 ;2586
0000ac  9001              STR      r0,[sp,#4]            ;2586
0000ae  6820              LDR      r0,[r4,#0]            ;2586
0000b0  6940              LDR      r0,[r0,#0x14]         ;2586
0000b2  9001              STR      r0,[sp,#4]            ;2586
0000b4  6820              LDR      r0,[r4,#0]            ;2586
0000b6  6980              LDR      r0,[r0,#0x18]         ;2586
0000b8  9001              STR      r0,[sp,#4]            ;2586
0000ba  bf00              NOP                            ;2586
0000bc  bf00              NOP                            ;2586
0000be  6820              LDR      r0,[r4,#0]            ;2589
0000c0  6800              LDR      r0,[r0,#0]            ;2589
0000c2  f4407000          ORR      r0,r0,#0x200          ;2589
0000c6  6821              LDR      r1,[r4,#0]            ;2589
0000c8  6008              STR      r0,[r1,#0]            ;2589
0000ca  e040              B        |L30.334|
                  |L30.204|
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;2591
0000ce  2801              CMP      r0,#1                 ;2591
0000d0  d118              BNE      |L30.260|
0000d2  6820              LDR      r0,[r4,#0]            ;2594
0000d4  6800              LDR      r0,[r0,#0]            ;2594
0000d6  f4206080          BIC      r0,r0,#0x400          ;2594
0000da  6821              LDR      r1,[r4,#0]            ;2594
0000dc  6008              STR      r0,[r1,#0]            ;2594
0000de  bf00              NOP                            ;2597
0000e0  2000              MOVS     r0,#0                 ;2597
0000e2  9001              STR      r0,[sp,#4]            ;2597
0000e4  6820              LDR      r0,[r4,#0]            ;2597
0000e6  6940              LDR      r0,[r0,#0x14]         ;2597
0000e8  9001              STR      r0,[sp,#4]            ;2597
0000ea  6820              LDR      r0,[r4,#0]            ;2597
0000ec  6980              LDR      r0,[r0,#0x18]         ;2597
0000ee  9001              STR      r0,[sp,#4]            ;2597
0000f0  bf00              NOP                            ;2597
0000f2  bf00              NOP                            ;2597
0000f4  6820              LDR      r0,[r4,#0]            ;2600
0000f6  6800              LDR      r0,[r0,#0]            ;2600
0000f8  f4407000          ORR      r0,r0,#0x200          ;2600
0000fc  6821              LDR      r1,[r4,#0]            ;2600
0000fe  6008              STR      r0,[r1,#0]            ;2600
000100  e025              B        |L30.334|
                  |L30.258|
000102  e0ef              B        |L30.740|
                  |L30.260|
000104  8d20              LDRH     r0,[r4,#0x28]         ;2602
000106  2802              CMP      r0,#2                 ;2602
000108  d116              BNE      |L30.312|
00010a  6820              LDR      r0,[r4,#0]            ;2605
00010c  6800              LDR      r0,[r0,#0]            ;2605
00010e  f4206080          BIC      r0,r0,#0x400          ;2605
000112  6821              LDR      r1,[r4,#0]            ;2605
000114  6008              STR      r0,[r1,#0]            ;2605
000116  6820              LDR      r0,[r4,#0]            ;2608
000118  6800              LDR      r0,[r0,#0]            ;2608
00011a  f4406000          ORR      r0,r0,#0x800          ;2608
00011e  6821              LDR      r1,[r4,#0]            ;2608
000120  6008              STR      r0,[r1,#0]            ;2608
000122  bf00              NOP                            ;2611
000124  2000              MOVS     r0,#0                 ;2611
000126  9001              STR      r0,[sp,#4]            ;2611
000128  6820              LDR      r0,[r4,#0]            ;2611
00012a  6940              LDR      r0,[r0,#0x14]         ;2611
00012c  9001              STR      r0,[sp,#4]            ;2611
00012e  6820              LDR      r0,[r4,#0]            ;2611
000130  6980              LDR      r0,[r0,#0x18]         ;2611
000132  9001              STR      r0,[sp,#4]            ;2611
000134  bf00              NOP                            ;2611
000136  e00a              B        |L30.334|
                  |L30.312|
000138  bf00              NOP                            ;2616
00013a  2000              MOVS     r0,#0                 ;2616
00013c  9001              STR      r0,[sp,#4]            ;2616
00013e  6820              LDR      r0,[r4,#0]            ;2616
000140  6940              LDR      r0,[r0,#0x14]         ;2616
000142  9001              STR      r0,[sp,#4]            ;2616
000144  6820              LDR      r0,[r4,#0]            ;2616
000146  6980              LDR      r0,[r0,#0x18]         ;2616
000148  9001              STR      r0,[sp,#4]            ;2616
00014a  bf00              NOP                            ;2616
00014c  bf00              NOP                            ;2616
                  |L30.334|
00014e  e0ba              B        |L30.710|
                  |L30.336|
000150  8d20              LDRH     r0,[r4,#0x28]         ;2621
000152  2803              CMP      r0,#3                 ;2621
000154  d87e              BHI      |L30.596|
000156  8d20              LDRH     r0,[r4,#0x28]         ;2624
000158  2801              CMP      r0,#1                 ;2624
00015a  d115              BNE      |L30.392|
00015c  462a              MOV      r2,r5                 ;2627
00015e  4631              MOV      r1,r6                 ;2627
000160  4620              MOV      r0,r4                 ;2627
000162  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000166  b108              CBZ      r0,|L30.364|
000168  2001              MOVS     r0,#1                 ;2629
00016a  e762              B        |L30.50|
                  |L30.364|
00016c  6820              LDR      r0,[r4,#0]            ;2633
00016e  6900              LDR      r0,[r0,#0x10]         ;2633
000170  6a61              LDR      r1,[r4,#0x24]         ;2633
000172  7008              STRB     r0,[r1,#0]            ;2633
000174  6a60              LDR      r0,[r4,#0x24]         ;2636
000176  1c40              ADDS     r0,r0,#1              ;2636
000178  6260              STR      r0,[r4,#0x24]         ;2636
00017a  8d20              LDRH     r0,[r4,#0x28]         ;2639
00017c  1e40              SUBS     r0,r0,#1              ;2639
00017e  8520              STRH     r0,[r4,#0x28]         ;2639
000180  8d60              LDRH     r0,[r4,#0x2a]         ;2640
000182  1e40              SUBS     r0,r0,#1              ;2640
000184  8560              STRH     r0,[r4,#0x2a]         ;2640
000186  e09e              B        |L30.710|
                  |L30.392|
000188  8d20              LDRH     r0,[r4,#0x28]         ;2643
00018a  2802              CMP      r0,#2                 ;2643
00018c  d12a              BNE      |L30.484|
00018e  4633              MOV      r3,r6                 ;2646
000190  2200              MOVS     r2,#0                 ;2646
000192  4957              LDR      r1,|L30.752|
000194  4620              MOV      r0,r4                 ;2646
000196  9500              STR      r5,[sp,#0]            ;2646
000198  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00019c  b108              CBZ      r0,|L30.418|
00019e  2001              MOVS     r0,#1                 ;2648
0001a0  e747              B        |L30.50|
                  |L30.418|
0001a2  6820              LDR      r0,[r4,#0]            ;2652
0001a4  6800              LDR      r0,[r0,#0]            ;2652
0001a6  f4407000          ORR      r0,r0,#0x200          ;2652
0001aa  6821              LDR      r1,[r4,#0]            ;2652
0001ac  6008              STR      r0,[r1,#0]            ;2652
0001ae  6820              LDR      r0,[r4,#0]            ;2655
0001b0  6900              LDR      r0,[r0,#0x10]         ;2655
0001b2  6a61              LDR      r1,[r4,#0x24]         ;2655
0001b4  7008              STRB     r0,[r1,#0]            ;2655
0001b6  6a60              LDR      r0,[r4,#0x24]         ;2658
0001b8  1c40              ADDS     r0,r0,#1              ;2658
0001ba  6260              STR      r0,[r4,#0x24]         ;2658
0001bc  8d20              LDRH     r0,[r4,#0x28]         ;2661
0001be  1e40              SUBS     r0,r0,#1              ;2661
0001c0  8520              STRH     r0,[r4,#0x28]         ;2661
0001c2  8d60              LDRH     r0,[r4,#0x2a]         ;2662
0001c4  1e40              SUBS     r0,r0,#1              ;2662
0001c6  8560              STRH     r0,[r4,#0x2a]         ;2662
0001c8  6820              LDR      r0,[r4,#0]            ;2665
0001ca  6900              LDR      r0,[r0,#0x10]         ;2665
0001cc  6a61              LDR      r1,[r4,#0x24]         ;2665
0001ce  7008              STRB     r0,[r1,#0]            ;2665
0001d0  6a60              LDR      r0,[r4,#0x24]         ;2668
0001d2  1c40              ADDS     r0,r0,#1              ;2668
0001d4  6260              STR      r0,[r4,#0x24]         ;2668
0001d6  8d20              LDRH     r0,[r4,#0x28]         ;2671
0001d8  1e40              SUBS     r0,r0,#1              ;2671
0001da  8520              STRH     r0,[r4,#0x28]         ;2671
0001dc  8d60              LDRH     r0,[r4,#0x2a]         ;2672
0001de  1e40              SUBS     r0,r0,#1              ;2672
0001e0  8560              STRH     r0,[r4,#0x2a]         ;2672
0001e2  e070              B        |L30.710|
                  |L30.484|
0001e4  4633              MOV      r3,r6                 ;2678
0001e6  2200              MOVS     r2,#0                 ;2678
0001e8  4941              LDR      r1,|L30.752|
0001ea  4620              MOV      r0,r4                 ;2678
0001ec  9500              STR      r5,[sp,#0]            ;2678
0001ee  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001f2  b108              CBZ      r0,|L30.504|
0001f4  2001              MOVS     r0,#1                 ;2680
0001f6  e71c              B        |L30.50|
                  |L30.504|
0001f8  6820              LDR      r0,[r4,#0]            ;2684
0001fa  6800              LDR      r0,[r0,#0]            ;2684
0001fc  f4206080          BIC      r0,r0,#0x400          ;2684
000200  6821              LDR      r1,[r4,#0]            ;2684
000202  6008              STR      r0,[r1,#0]            ;2684
000204  6820              LDR      r0,[r4,#0]            ;2687
000206  6900              LDR      r0,[r0,#0x10]         ;2687
000208  6a61              LDR      r1,[r4,#0x24]         ;2687
00020a  7008              STRB     r0,[r1,#0]            ;2687
00020c  6a60              LDR      r0,[r4,#0x24]         ;2690
00020e  1c40              ADDS     r0,r0,#1              ;2690
000210  6260              STR      r0,[r4,#0x24]         ;2690
000212  8d20              LDRH     r0,[r4,#0x28]         ;2693
000214  1e40              SUBS     r0,r0,#1              ;2693
000216  8520              STRH     r0,[r4,#0x28]         ;2693
000218  8d60              LDRH     r0,[r4,#0x2a]         ;2694
00021a  1e40              SUBS     r0,r0,#1              ;2694
00021c  8560              STRH     r0,[r4,#0x2a]         ;2694
00021e  4633              MOV      r3,r6                 ;2697
000220  2200              MOVS     r2,#0                 ;2697
000222  4933              LDR      r1,|L30.752|
000224  4620              MOV      r0,r4                 ;2697
000226  9500              STR      r5,[sp,#0]            ;2697
000228  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00022c  b108              CBZ      r0,|L30.562|
00022e  2001              MOVS     r0,#1                 ;2699
000230  e6ff              B        |L30.50|
                  |L30.562|
000232  6820              LDR      r0,[r4,#0]            ;2703
000234  6800              LDR      r0,[r0,#0]            ;2703
000236  f4407000          ORR      r0,r0,#0x200          ;2703
00023a  6821              LDR      r1,[r4,#0]            ;2703
00023c  6008              STR      r0,[r1,#0]            ;2703
00023e  6820              LDR      r0,[r4,#0]            ;2706
000240  6900              LDR      r0,[r0,#0x10]         ;2706
000242  6a61              LDR      r1,[r4,#0x24]         ;2706
000244  7008              STRB     r0,[r1,#0]            ;2706
000246  6a60              LDR      r0,[r4,#0x24]         ;2709
000248  1c40              ADDS     r0,r0,#1              ;2709
00024a  6260              STR      r0,[r4,#0x24]         ;2709
00024c  8d20              LDRH     r0,[r4,#0x28]         ;2712
00024e  1e40              SUBS     r0,r0,#1              ;2712
000250  8520              STRH     r0,[r4,#0x28]         ;2712
000252  e000              B        |L30.598|
                  |L30.596|
000254  e010              B        |L30.632|
                  |L30.598|
000256  8d60              LDRH     r0,[r4,#0x2a]         ;2713
000258  1e40              SUBS     r0,r0,#1              ;2713
00025a  8560              STRH     r0,[r4,#0x2a]         ;2713
00025c  6820              LDR      r0,[r4,#0]            ;2716
00025e  6900              LDR      r0,[r0,#0x10]         ;2716
000260  6a61              LDR      r1,[r4,#0x24]         ;2716
000262  7008              STRB     r0,[r1,#0]            ;2716
000264  6a60              LDR      r0,[r4,#0x24]         ;2719
000266  1c40              ADDS     r0,r0,#1              ;2719
000268  6260              STR      r0,[r4,#0x24]         ;2719
00026a  8d20              LDRH     r0,[r4,#0x28]         ;2722
00026c  1e40              SUBS     r0,r0,#1              ;2722
00026e  8520              STRH     r0,[r4,#0x28]         ;2722
000270  8d60              LDRH     r0,[r4,#0x2a]         ;2723
000272  1e40              SUBS     r0,r0,#1              ;2723
000274  8560              STRH     r0,[r4,#0x2a]         ;2723
000276  e026              B        |L30.710|
                  |L30.632|
000278  462a              MOV      r2,r5                 ;2729
00027a  4631              MOV      r1,r6                 ;2729
00027c  4620              MOV      r0,r4                 ;2729
00027e  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000282  b108              CBZ      r0,|L30.648|
000284  2001              MOVS     r0,#1                 ;2731
000286  e6d4              B        |L30.50|
                  |L30.648|
000288  6820              LDR      r0,[r4,#0]            ;2735
00028a  6900              LDR      r0,[r0,#0x10]         ;2735
00028c  6a61              LDR      r1,[r4,#0x24]         ;2735
00028e  7008              STRB     r0,[r1,#0]            ;2735
000290  6a60              LDR      r0,[r4,#0x24]         ;2738
000292  1c40              ADDS     r0,r0,#1              ;2738
000294  6260              STR      r0,[r4,#0x24]         ;2738
000296  8d20              LDRH     r0,[r4,#0x28]         ;2741
000298  1e40              SUBS     r0,r0,#1              ;2741
00029a  8520              STRH     r0,[r4,#0x28]         ;2741
00029c  8d60              LDRH     r0,[r4,#0x2a]         ;2742
00029e  1e40              SUBS     r0,r0,#1              ;2742
0002a0  8560              STRH     r0,[r4,#0x2a]         ;2742
0002a2  6820              LDR      r0,[r4,#0]            ;2744
0002a4  6940              LDR      r0,[r0,#0x14]         ;2744
0002a6  f3c00080          UBFX     r0,r0,#2,#1           ;2744
0002aa  b160              CBZ      r0,|L30.710|
0002ac  6820              LDR      r0,[r4,#0]            ;2747
0002ae  6900              LDR      r0,[r0,#0x10]         ;2747
0002b0  6a61              LDR      r1,[r4,#0x24]         ;2747
0002b2  7008              STRB     r0,[r1,#0]            ;2747
0002b4  6a60              LDR      r0,[r4,#0x24]         ;2750
0002b6  1c40              ADDS     r0,r0,#1              ;2750
0002b8  6260              STR      r0,[r4,#0x24]         ;2750
0002ba  8d20              LDRH     r0,[r4,#0x28]         ;2753
0002bc  1e40              SUBS     r0,r0,#1              ;2753
0002be  8520              STRH     r0,[r4,#0x28]         ;2753
0002c0  8d60              LDRH     r0,[r4,#0x2a]         ;2754
0002c2  1e40              SUBS     r0,r0,#1              ;2754
0002c4  8560              STRH     r0,[r4,#0x2a]         ;2754
                  |L30.710|
0002c6  8d20              LDRH     r0,[r4,#0x28]         ;2619
0002c8  2800              CMP      r0,#0                 ;2619
0002ca  f47faf41          BNE      |L30.336|
0002ce  2020              MOVS     r0,#0x20              ;2759
0002d0  f884003d          STRB     r0,[r4,#0x3d]         ;2759
0002d4  2000              MOVS     r0,#0                 ;2760
0002d6  f884003e          STRB     r0,[r4,#0x3e]         ;2760
0002da  bf00              NOP                            ;2763
0002dc  f884003c          STRB     r0,[r4,#0x3c]         ;2763
0002e0  bf00              NOP                            ;2763
0002e2  e6a6              B        |L30.50|
                  |L30.740|
0002e4  2002              MOVS     r0,#2                 ;2769
0002e6  e6a4              B        |L30.50|
;;;2772   
                          ENDP

                  |L30.744|
                          DCD      0x00100002
                  |L30.748|
                          DCD      0xffff0000
                  |L30.752|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Mem_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_DMA PROC
;;;3133     */
;;;3134   HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;3135   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;3136     /* Init tickstart for timeout management*/
;;;3137     uint32_t tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4606              MOV      r6,r0
;;;3138     __IO uint32_t count = 0U;
000016  2000              MOVS     r0,#0
000018  9002              STR      r0,[sp,#8]
;;;3139     HAL_StatusTypeDef dmaxferstatus;
;;;3140   
;;;3141     /* Check the parameters */
;;;3142     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;3143   
;;;3144     if (hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d17e              BNE      |L31.288|
;;;3145     {
;;;3146       /* Wait until BUSY flag is reset */
;;;3147       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000022  4883              LDR      r0,|L31.560|
000024  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000026  2119              MOVS     r1,#0x19
000028  fbb0f0f1          UDIV     r0,r0,r1
00002c  f44f717a          MOV      r1,#0x3e8
000030  fbb0f0f1          UDIV     r0,r0,r1
000034  eb0001c0          ADD      r1,r0,r0,LSL #3
000038  eb011000          ADD      r0,r1,r0,LSL #4
00003c  9002              STR      r0,[sp,#8]
;;;3148       do
00003e  bf00              NOP      
                  |L31.64|
;;;3149       {
;;;3150         count--;
000040  9802              LDR      r0,[sp,#8]
000042  1e40              SUBS     r0,r0,#1
000044  9002              STR      r0,[sp,#8]
;;;3151         if (count == 0U)
000046  9802              LDR      r0,[sp,#8]
000048  b998              CBNZ     r0,|L31.114|
;;;3152         {
;;;3153           hi2c->PreviousState       = I2C_STATE_NONE;
00004a  2000              MOVS     r0,#0
00004c  6320              STR      r0,[r4,#0x30]
;;;3154           hi2c->State               = HAL_I2C_STATE_READY;
00004e  2020              MOVS     r0,#0x20
000050  f884003d          STRB     r0,[r4,#0x3d]
;;;3155           hi2c->Mode                = HAL_I2C_MODE_NONE;
000054  2000              MOVS     r0,#0
000056  f884003e          STRB     r0,[r4,#0x3e]
;;;3156           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f0400020          ORR      r0,r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;3157   
;;;3158           /* Process Unlocked */
;;;3159           __HAL_UNLOCK(hi2c);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f884003c          STRB     r0,[r4,#0x3c]
00006a  bf00              NOP      
;;;3160   
;;;3161           return HAL_ERROR;
00006c  2001              MOVS     r0,#1
                  |L31.110|
;;;3162         }
;;;3163       }
;;;3164       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3165   
;;;3166       /* Process Locked */
;;;3167       __HAL_LOCK(hi2c);
;;;3168   
;;;3169       /* Check if the I2C is already enabled */
;;;3170       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3171       {
;;;3172         /* Enable I2C peripheral */
;;;3173         __HAL_I2C_ENABLE(hi2c);
;;;3174       }
;;;3175   
;;;3176       /* Disable Pos */
;;;3177       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3178   
;;;3179       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3180       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3181       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3182   
;;;3183       /* Prepare transfer parameters */
;;;3184       hi2c->pBuffPtr    = pData;
;;;3185       hi2c->XferCount   = Size;
;;;3186       hi2c->XferSize    = hi2c->XferCount;
;;;3187       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3188   
;;;3189       if (hi2c->XferSize > 0U)
;;;3190       {
;;;3191         /* Set the I2C DMA transfer complete callback */
;;;3192         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;3193   
;;;3194         /* Set the DMA error callback */
;;;3195         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;3196   
;;;3197         /* Set the unused DMA callbacks to NULL */
;;;3198         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;3199         hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;3200         hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;3201         hi2c->hdmarx->XferAbortCallback = NULL;
;;;3202   
;;;3203         /* Enable the DMA stream */
;;;3204         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;3205   
;;;3206         if (dmaxferstatus == HAL_OK)
;;;3207         {
;;;3208           /* Send Slave Address and Memory Address */
;;;3209           if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3210           {
;;;3211             /* Abort the ongoing DMA */
;;;3212             dmaxferstatus = HAL_DMA_Abort_IT(hi2c->hdmarx);
;;;3213   
;;;3214             /* Prevent unused argument(s) compilation and MISRA warning */
;;;3215             UNUSED(dmaxferstatus);
;;;3216   
;;;3217             /* Clear directly Complete callback as no XferAbortCallback is used to finalize Abort treatment */
;;;3218             if (hi2c->hdmarx != NULL)
;;;3219             {
;;;3220               hi2c->hdmarx->XferCpltCallback = NULL;
;;;3221             }
;;;3222   
;;;3223             /* Disable Acknowledge */
;;;3224             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3225   
;;;3226             hi2c->XferSize = 0U;
;;;3227             hi2c->XferCount = 0U;
;;;3228   
;;;3229             /* Disable I2C peripheral to prevent dummy data in buffer */
;;;3230             __HAL_I2C_DISABLE(hi2c);
;;;3231   
;;;3232             return HAL_ERROR;
;;;3233           }
;;;3234   
;;;3235           if (hi2c->XferSize == 1U)
;;;3236           {
;;;3237             /* Disable Acknowledge */
;;;3238             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3239           }
;;;3240           else
;;;3241           {
;;;3242             /* Enable Last DMA bit */
;;;3243             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3244           }
;;;3245   
;;;3246           /* Clear ADDR flag */
;;;3247           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3248   
;;;3249           /* Process Unlocked */
;;;3250           __HAL_UNLOCK(hi2c);
;;;3251   
;;;3252           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3253           to avoid the risk of I2C interrupt handle execution before current
;;;3254           process unlock */
;;;3255           /* Enable ERR interrupt */
;;;3256           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3257   
;;;3258           /* Enable DMA Request */
;;;3259           hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;3260         }
;;;3261         else
;;;3262         {
;;;3263           /* Update I2C state */
;;;3264           hi2c->State     = HAL_I2C_STATE_READY;
;;;3265           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3266   
;;;3267           /* Update I2C error code */
;;;3268           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3269   
;;;3270           /* Process Unlocked */
;;;3271           __HAL_UNLOCK(hi2c);
;;;3272   
;;;3273           return HAL_ERROR;
;;;3274         }
;;;3275       }
;;;3276       else
;;;3277       {
;;;3278         /* Send Slave Address and Memory Address */
;;;3279         if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3280         {
;;;3281           return HAL_ERROR;
;;;3282         }
;;;3283   
;;;3284         /* Clear ADDR flag */
;;;3285         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3286   
;;;3287         /* Generate Stop */
;;;3288         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3289   
;;;3290         hi2c->State = HAL_I2C_STATE_READY;
;;;3291   
;;;3292         /* Process Unlocked */
;;;3293         __HAL_UNLOCK(hi2c);
;;;3294       }
;;;3295   
;;;3296       return HAL_OK;
;;;3297     }
;;;3298     else
;;;3299     {
;;;3300       return HAL_BUSY;
;;;3301     }
;;;3302   }
00006e  e8bd8ffe          POP      {r1-r11,pc}
                  |L31.114|
000072  6820              LDR      r0,[r4,#0]            ;3164
000074  6980              LDR      r0,[r0,#0x18]         ;3164
000076  f3c00040          UBFX     r0,r0,#1,#1           ;3164
00007a  2800              CMP      r0,#0                 ;3164
00007c  d1e0              BNE      |L31.64|
00007e  bf00              NOP                            ;3167
000080  f894003c          LDRB     r0,[r4,#0x3c]         ;3167
000084  2801              CMP      r0,#1                 ;3167
000086  d101              BNE      |L31.140|
000088  2002              MOVS     r0,#2                 ;3167
00008a  e7f0              B        |L31.110|
                  |L31.140|
00008c  2001              MOVS     r0,#1                 ;3167
00008e  f884003c          STRB     r0,[r4,#0x3c]         ;3167
000092  bf00              NOP                            ;3167
000094  6820              LDR      r0,[r4,#0]            ;3170
000096  6800              LDR      r0,[r0,#0]            ;3170
000098  f0000001          AND      r0,r0,#1              ;3170
00009c  b928              CBNZ     r0,|L31.170|
00009e  6820              LDR      r0,[r4,#0]            ;3173
0000a0  6800              LDR      r0,[r0,#0]            ;3173
0000a2  f0400001          ORR      r0,r0,#1              ;3173
0000a6  6821              LDR      r1,[r4,#0]            ;3173
0000a8  6008              STR      r0,[r1,#0]            ;3173
                  |L31.170|
0000aa  6820              LDR      r0,[r4,#0]            ;3177
0000ac  6800              LDR      r0,[r0,#0]            ;3177
0000ae  f4206000          BIC      r0,r0,#0x800          ;3177
0000b2  6821              LDR      r1,[r4,#0]            ;3177
0000b4  6008              STR      r0,[r1,#0]            ;3177
0000b6  2022              MOVS     r0,#0x22              ;3179
0000b8  f884003d          STRB     r0,[r4,#0x3d]         ;3179
0000bc  2040              MOVS     r0,#0x40              ;3180
0000be  f884003e          STRB     r0,[r4,#0x3e]         ;3180
0000c2  2000              MOVS     r0,#0                 ;3181
0000c4  6420              STR      r0,[r4,#0x40]         ;3181
0000c6  f8c49024          STR      r9,[r4,#0x24]         ;3184
0000ca  f8a4a02a          STRH     r10,[r4,#0x2a]        ;3185
0000ce  8d60              LDRH     r0,[r4,#0x2a]         ;3186
0000d0  8520              STRH     r0,[r4,#0x28]         ;3186
0000d2  4858              LDR      r0,|L31.564|
0000d4  62e0              STR      r0,[r4,#0x2c]         ;3187
0000d6  8d20              LDRH     r0,[r4,#0x28]         ;3189
0000d8  2800              CMP      r0,#0                 ;3189
0000da  d07d              BEQ      |L31.472|
0000dc  4856              LDR      r0,|L31.568|
0000de  6ba1              LDR      r1,[r4,#0x38]         ;3192
0000e0  63c8              STR      r0,[r1,#0x3c]         ;3192
0000e2  4856              LDR      r0,|L31.572|
0000e4  6ba1              LDR      r1,[r4,#0x38]         ;3195
0000e6  64c8              STR      r0,[r1,#0x4c]         ;3195
0000e8  2000              MOVS     r0,#0                 ;3198
0000ea  6ba1              LDR      r1,[r4,#0x38]         ;3198
0000ec  6408              STR      r0,[r1,#0x40]         ;3198
0000ee  6ba1              LDR      r1,[r4,#0x38]         ;3199
0000f0  6448              STR      r0,[r1,#0x44]         ;3199
0000f2  6ba1              LDR      r1,[r4,#0x38]         ;3200
0000f4  6488              STR      r0,[r1,#0x48]         ;3200
0000f6  6ba1              LDR      r1,[r4,#0x38]         ;3201
0000f8  6508              STR      r0,[r1,#0x50]         ;3201
0000fa  8d23              LDRH     r3,[r4,#0x28]         ;3204
0000fc  f8d4c000          LDR      r12,[r4,#0]           ;3204
000100  f10c0110          ADD      r1,r12,#0x10          ;3204
000104  6a62              LDR      r2,[r4,#0x24]         ;3204
000106  6ba0              LDR      r0,[r4,#0x38]         ;3204
000108  f7fffffe          BL       HAL_DMA_Start_IT
00010c  4605              MOV      r5,r0                 ;3204
00010e  2d00              CMP      r5,#0                 ;3206
000110  d152              BNE      |L31.440|
000112  2023              MOVS     r0,#0x23              ;3209
000114  465b              MOV      r3,r11                ;3209
000116  4642              MOV      r2,r8                 ;3209
000118  4639              MOV      r1,r7                 ;3209
00011a  e9cd0600          STRD     r0,r6,[sp,#0]         ;3209
00011e  e000              B        |L31.290|
                  |L31.288|
000120  e084              B        |L31.556|
                  |L31.290|
000122  4620              MOV      r0,r4                 ;3209
000124  f7fffffe          BL       I2C_RequestMemoryRead
000128  b1c8              CBZ      r0,|L31.350|
00012a  6ba0              LDR      r0,[r4,#0x38]         ;3212
00012c  f7fffffe          BL       HAL_DMA_Abort_IT
000130  4605              MOV      r5,r0                 ;3212
000132  6ba0              LDR      r0,[r4,#0x38]         ;3218
000134  b110              CBZ      r0,|L31.316|
000136  2000              MOVS     r0,#0                 ;3220
000138  6ba1              LDR      r1,[r4,#0x38]         ;3220
00013a  63c8              STR      r0,[r1,#0x3c]         ;3220
                  |L31.316|
00013c  6820              LDR      r0,[r4,#0]            ;3224
00013e  6800              LDR      r0,[r0,#0]            ;3224
000140  f4206080          BIC      r0,r0,#0x400          ;3224
000144  6821              LDR      r1,[r4,#0]            ;3224
000146  6008              STR      r0,[r1,#0]            ;3224
000148  2000              MOVS     r0,#0                 ;3226
00014a  8520              STRH     r0,[r4,#0x28]         ;3226
00014c  8560              STRH     r0,[r4,#0x2a]         ;3227
00014e  6820              LDR      r0,[r4,#0]            ;3230
000150  6800              LDR      r0,[r0,#0]            ;3230
000152  f0200001          BIC      r0,r0,#1              ;3230
000156  6821              LDR      r1,[r4,#0]            ;3230
000158  6008              STR      r0,[r1,#0]            ;3230
00015a  2001              MOVS     r0,#1                 ;3232
00015c  e787              B        |L31.110|
                  |L31.350|
00015e  8d20              LDRH     r0,[r4,#0x28]         ;3235
000160  2801              CMP      r0,#1                 ;3235
000162  d106              BNE      |L31.370|
000164  6820              LDR      r0,[r4,#0]            ;3238
000166  6800              LDR      r0,[r0,#0]            ;3238
000168  f4206080          BIC      r0,r0,#0x400          ;3238
00016c  6821              LDR      r1,[r4,#0]            ;3238
00016e  6008              STR      r0,[r1,#0]            ;3238
000170  e005              B        |L31.382|
                  |L31.370|
000172  6820              LDR      r0,[r4,#0]            ;3243
000174  6840              LDR      r0,[r0,#4]            ;3243
000176  f4405080          ORR      r0,r0,#0x1000         ;3243
00017a  6821              LDR      r1,[r4,#0]            ;3243
00017c  6048              STR      r0,[r1,#4]            ;3243
                  |L31.382|
00017e  bf00              NOP                            ;3247
000180  2000              MOVS     r0,#0                 ;3247
000182  9001              STR      r0,[sp,#4]            ;3247
000184  6820              LDR      r0,[r4,#0]            ;3247
000186  6940              LDR      r0,[r0,#0x14]         ;3247
000188  9001              STR      r0,[sp,#4]            ;3247
00018a  6820              LDR      r0,[r4,#0]            ;3247
00018c  6980              LDR      r0,[r0,#0x18]         ;3247
00018e  9001              STR      r0,[sp,#4]            ;3247
000190  bf00              NOP                            ;3247
000192  bf00              NOP                            ;3247
000194  bf00              NOP                            ;3250
000196  2000              MOVS     r0,#0                 ;3250
000198  f884003c          STRB     r0,[r4,#0x3c]         ;3250
00019c  bf00              NOP                            ;3250
00019e  6820              LDR      r0,[r4,#0]            ;3256
0001a0  6840              LDR      r0,[r0,#4]            ;3256
0001a2  f4407080          ORR      r0,r0,#0x100          ;3256
0001a6  6821              LDR      r1,[r4,#0]            ;3256
0001a8  6048              STR      r0,[r1,#4]            ;3256
0001aa  6820              LDR      r0,[r4,#0]            ;3259
0001ac  6840              LDR      r0,[r0,#4]            ;3259
0001ae  f4406000          ORR      r0,r0,#0x800          ;3259
0001b2  6821              LDR      r1,[r4,#0]            ;3259
0001b4  6048              STR      r0,[r1,#4]            ;3259
0001b6  e037              B        |L31.552|
                  |L31.440|
0001b8  2020              MOVS     r0,#0x20              ;3264
0001ba  f884003d          STRB     r0,[r4,#0x3d]         ;3264
0001be  2000              MOVS     r0,#0                 ;3265
0001c0  f884003e          STRB     r0,[r4,#0x3e]         ;3265
0001c4  6c20              LDR      r0,[r4,#0x40]         ;3268
0001c6  f0400010          ORR      r0,r0,#0x10           ;3268
0001ca  6420              STR      r0,[r4,#0x40]         ;3268
0001cc  bf00              NOP                            ;3271
0001ce  2000              MOVS     r0,#0                 ;3271
0001d0  f884003c          STRB     r0,[r4,#0x3c]         ;3271
0001d4  bf00              NOP                            ;3271
0001d6  e000              B        |L31.474|
                  |L31.472|
0001d8  e001              B        |L31.478|
                  |L31.474|
0001da  2001              MOVS     r0,#1                 ;3273
0001dc  e747              B        |L31.110|
                  |L31.478|
0001de  2023              MOVS     r0,#0x23              ;3279
0001e0  465b              MOV      r3,r11                ;3279
0001e2  4642              MOV      r2,r8                 ;3279
0001e4  4639              MOV      r1,r7                 ;3279
0001e6  e9cd0600          STRD     r0,r6,[sp,#0]         ;3279
0001ea  4620              MOV      r0,r4                 ;3279
0001ec  f7fffffe          BL       I2C_RequestMemoryRead
0001f0  b108              CBZ      r0,|L31.502|
0001f2  2001              MOVS     r0,#1                 ;3281
0001f4  e73b              B        |L31.110|
                  |L31.502|
0001f6  bf00              NOP                            ;3285
0001f8  2000              MOVS     r0,#0                 ;3285
0001fa  9001              STR      r0,[sp,#4]            ;3285
0001fc  6820              LDR      r0,[r4,#0]            ;3285
0001fe  6940              LDR      r0,[r0,#0x14]         ;3285
000200  9001              STR      r0,[sp,#4]            ;3285
000202  6820              LDR      r0,[r4,#0]            ;3285
000204  6980              LDR      r0,[r0,#0x18]         ;3285
000206  9001              STR      r0,[sp,#4]            ;3285
000208  bf00              NOP                            ;3285
00020a  bf00              NOP                            ;3285
00020c  6820              LDR      r0,[r4,#0]            ;3288
00020e  6800              LDR      r0,[r0,#0]            ;3288
000210  f4407000          ORR      r0,r0,#0x200          ;3288
000214  6821              LDR      r1,[r4,#0]            ;3288
000216  6008              STR      r0,[r1,#0]            ;3288
000218  2020              MOVS     r0,#0x20              ;3290
00021a  f884003d          STRB     r0,[r4,#0x3d]         ;3290
00021e  bf00              NOP                            ;3293
000220  2000              MOVS     r0,#0                 ;3293
000222  f884003c          STRB     r0,[r4,#0x3c]         ;3293
000226  bf00              NOP                            ;3293
                  |L31.552|
000228  2000              MOVS     r0,#0                 ;3296
00022a  e720              B        |L31.110|
                  |L31.556|
00022c  2002              MOVS     r0,#2                 ;3300
00022e  e71e              B        |L31.110|
;;;3303   
                          ENDP

                  |L31.560|
                          DCD      SystemCoreClock
                  |L31.564|
                          DCD      0xffff0000
                  |L31.568|
                          DCD      I2C_DMAXferCplt
                  |L31.572|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Read_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_IT PROC
;;;2872     */
;;;2873   HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2874   {
000002  4604              MOV      r4,r0
000004  e9dd5606          LDRD     r5,r6,[sp,#0x18]
;;;2875     __IO uint32_t count = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2876   
;;;2877     /* Check the parameters */
;;;2878     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2879   
;;;2880     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d177              BNE      |L32.260|
;;;2881     {
;;;2882       /* Wait until BUSY flag is reset */
;;;2883       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000014  483c              LDR      r0,|L32.264|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  2719              MOVS     r7,#0x19
00001a  fbb0f0f7          UDIV     r0,r0,r7
00001e  f44f777a          MOV      r7,#0x3e8
000022  fbb0f0f7          UDIV     r0,r0,r7
000026  eb0007c0          ADD      r7,r0,r0,LSL #3
00002a  eb071000          ADD      r0,r7,r0,LSL #4
00002e  9000              STR      r0,[sp,#0]
;;;2884       do
000030  bf00              NOP      
                  |L32.50|
;;;2885       {
;;;2886         count--;
000032  9800              LDR      r0,[sp,#0]
000034  1e40              SUBS     r0,r0,#1
000036  9000              STR      r0,[sp,#0]
;;;2887         if (count == 0U)
000038  9800              LDR      r0,[sp,#0]
00003a  b990              CBNZ     r0,|L32.98|
;;;2888         {
;;;2889           hi2c->PreviousState       = I2C_STATE_NONE;
00003c  2000              MOVS     r0,#0
00003e  6320              STR      r0,[r4,#0x30]
;;;2890           hi2c->State               = HAL_I2C_STATE_READY;
000040  2020              MOVS     r0,#0x20
000042  f884003d          STRB     r0,[r4,#0x3d]
;;;2891           hi2c->Mode                = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;2892           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6420              STR      r0,[r4,#0x40]
;;;2893   
;;;2894           /* Process Unlocked */
;;;2895           __HAL_UNLOCK(hi2c);
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  f884003c          STRB     r0,[r4,#0x3c]
00005c  bf00              NOP      
;;;2896   
;;;2897           return HAL_ERROR;
00005e  2001              MOVS     r0,#1
                  |L32.96|
;;;2898         }
;;;2899       }
;;;2900       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2901   
;;;2902       /* Process Locked */
;;;2903       __HAL_LOCK(hi2c);
;;;2904   
;;;2905       /* Check if the I2C is already enabled */
;;;2906       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2907       {
;;;2908         /* Enable I2C peripheral */
;;;2909         __HAL_I2C_ENABLE(hi2c);
;;;2910       }
;;;2911   
;;;2912       /* Disable Pos */
;;;2913       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2914   
;;;2915       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2916       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2917       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2918   
;;;2919       /* Prepare transfer parameters */
;;;2920       hi2c->pBuffPtr    = pData;
;;;2921       hi2c->XferCount   = Size;
;;;2922       hi2c->XferSize    = hi2c->XferCount;
;;;2923       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2924       hi2c->Devaddress  = DevAddress;
;;;2925       hi2c->Memaddress  = MemAddress;
;;;2926       hi2c->MemaddSize  = MemAddSize;
;;;2927       hi2c->EventCount  = 0U;
;;;2928   
;;;2929       /* Enable Acknowledge */
;;;2930       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2931   
;;;2932       /* Generate Start */
;;;2933       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2934   
;;;2935       /* Process Unlocked */
;;;2936       __HAL_UNLOCK(hi2c);
;;;2937   
;;;2938       if (hi2c->XferSize > 0U)
;;;2939       {
;;;2940         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2941         to avoid the risk of I2C interrupt handle execution before current
;;;2942         process unlock */
;;;2943   
;;;2944         /* Enable EVT, BUF and ERR interrupt */
;;;2945         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2946       }
;;;2947       return HAL_OK;
;;;2948     }
;;;2949     else
;;;2950     {
;;;2951       return HAL_BUSY;
;;;2952     }
;;;2953   }
000060  bdf8              POP      {r3-r7,pc}
                  |L32.98|
000062  6820              LDR      r0,[r4,#0]            ;2900
000064  6980              LDR      r0,[r0,#0x18]         ;2900
000066  f3c00040          UBFX     r0,r0,#1,#1           ;2900
00006a  2800              CMP      r0,#0                 ;2900
00006c  d1e1              BNE      |L32.50|
00006e  bf00              NOP                            ;2903
000070  f894003c          LDRB     r0,[r4,#0x3c]         ;2903
000074  2801              CMP      r0,#1                 ;2903
000076  d101              BNE      |L32.124|
000078  2002              MOVS     r0,#2                 ;2903
00007a  e7f1              B        |L32.96|
                  |L32.124|
00007c  2001              MOVS     r0,#1                 ;2903
00007e  f884003c          STRB     r0,[r4,#0x3c]         ;2903
000082  bf00              NOP                            ;2903
000084  6820              LDR      r0,[r4,#0]            ;2906
000086  6800              LDR      r0,[r0,#0]            ;2906
000088  f0000001          AND      r0,r0,#1              ;2906
00008c  b928              CBNZ     r0,|L32.154|
00008e  6820              LDR      r0,[r4,#0]            ;2909
000090  6800              LDR      r0,[r0,#0]            ;2909
000092  f0400001          ORR      r0,r0,#1              ;2909
000096  6827              LDR      r7,[r4,#0]            ;2909
000098  6038              STR      r0,[r7,#0]            ;2909
                  |L32.154|
00009a  6820              LDR      r0,[r4,#0]            ;2913
00009c  6800              LDR      r0,[r0,#0]            ;2913
00009e  f4206000          BIC      r0,r0,#0x800          ;2913
0000a2  6827              LDR      r7,[r4,#0]            ;2913
0000a4  6038              STR      r0,[r7,#0]            ;2913
0000a6  2022              MOVS     r0,#0x22              ;2915
0000a8  f884003d          STRB     r0,[r4,#0x3d]         ;2915
0000ac  2040              MOVS     r0,#0x40              ;2916
0000ae  f884003e          STRB     r0,[r4,#0x3e]         ;2916
0000b2  2000              MOVS     r0,#0                 ;2917
0000b4  6420              STR      r0,[r4,#0x40]         ;2917
0000b6  6265              STR      r5,[r4,#0x24]         ;2920
0000b8  8566              STRH     r6,[r4,#0x2a]         ;2921
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;2922
0000bc  8520              STRH     r0,[r4,#0x28]         ;2922
0000be  4813              LDR      r0,|L32.268|
0000c0  62e0              STR      r0,[r4,#0x2c]         ;2923
0000c2  6461              STR      r1,[r4,#0x44]         ;2924
0000c4  64a2              STR      r2,[r4,#0x48]         ;2925
0000c6  64e3              STR      r3,[r4,#0x4c]         ;2926
0000c8  2000              MOVS     r0,#0                 ;2927
0000ca  6520              STR      r0,[r4,#0x50]         ;2927
0000cc  6820              LDR      r0,[r4,#0]            ;2930
0000ce  6800              LDR      r0,[r0,#0]            ;2930
0000d0  f4406080          ORR      r0,r0,#0x400          ;2930
0000d4  6827              LDR      r7,[r4,#0]            ;2930
0000d6  6038              STR      r0,[r7,#0]            ;2930
0000d8  6820              LDR      r0,[r4,#0]            ;2933
0000da  6800              LDR      r0,[r0,#0]            ;2933
0000dc  f4407080          ORR      r0,r0,#0x100          ;2933
0000e0  6827              LDR      r7,[r4,#0]            ;2933
0000e2  6038              STR      r0,[r7,#0]            ;2933
0000e4  bf00              NOP                            ;2936
0000e6  2000              MOVS     r0,#0                 ;2936
0000e8  f884003c          STRB     r0,[r4,#0x3c]         ;2936
0000ec  bf00              NOP                            ;2936
0000ee  8d20              LDRH     r0,[r4,#0x28]         ;2938
0000f0  b128              CBZ      r0,|L32.254|
0000f2  6820              LDR      r0,[r4,#0]            ;2945
0000f4  6840              LDR      r0,[r0,#4]            ;2945
0000f6  f44060e0          ORR      r0,r0,#0x700          ;2945
0000fa  6827              LDR      r7,[r4,#0]            ;2945
0000fc  6078              STR      r0,[r7,#4]            ;2945
                  |L32.254|
0000fe  2000              MOVS     r0,#0                 ;2947
000100  e7ae              B        |L32.96|
000102  e7ff              B        |L32.260|
                  |L32.260|
000104  2002              MOVS     r0,#2                 ;2951
000106  e7ab              B        |L32.96|
;;;2954   
                          ENDP

                  |L32.264|
                          DCD      SystemCoreClock
                  |L32.268|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write PROC
;;;2414     */
;;;2415   HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2416   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  9e0e              LDR      r6,[sp,#0x38]
;;;2417     /* Init tickstart for timeout management*/
;;;2418     uint32_t tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2419   
;;;2420     /* Check the parameters */
;;;2421     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2422   
;;;2423     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d17d              BNE      |L33.284|
;;;2424     {
;;;2425       /* Wait until BUSY flag is reset */
;;;2426       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
000020  2319              MOVS     r3,#0x19
000022  2201              MOVS     r2,#1
000024  494d              LDR      r1,|L33.348|
000026  4620              MOV      r0,r4
000028  9500              STR      r5,[sp,#0]
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  b110              CBZ      r0,|L33.54|
;;;2427       {
;;;2428         return HAL_BUSY;
000030  2002              MOVS     r0,#2
                  |L33.50|
;;;2429       }
;;;2430   
;;;2431       /* Process Locked */
;;;2432       __HAL_LOCK(hi2c);
;;;2433   
;;;2434       /* Check if the I2C is already enabled */
;;;2435       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2436       {
;;;2437         /* Enable I2C peripheral */
;;;2438         __HAL_I2C_ENABLE(hi2c);
;;;2439       }
;;;2440   
;;;2441       /* Disable Pos */
;;;2442       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2443   
;;;2444       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2445       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2446       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2447   
;;;2448       /* Prepare transfer parameters */
;;;2449       hi2c->pBuffPtr    = pData;
;;;2450       hi2c->XferCount   = Size;
;;;2451       hi2c->XferSize    = hi2c->XferCount;
;;;2452       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2453   
;;;2454       /* Send Slave Address and Memory Address */
;;;2455       if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2456       {
;;;2457         return HAL_ERROR;
;;;2458       }
;;;2459   
;;;2460       while (hi2c->XferSize > 0U)
;;;2461       {
;;;2462         /* Wait until TXE flag is set */
;;;2463         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2464         {
;;;2465           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2466           {
;;;2467             /* Generate Stop */
;;;2468             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2469           }
;;;2470           return HAL_ERROR;
;;;2471         }
;;;2472   
;;;2473         /* Write data to DR */
;;;2474         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;2475   
;;;2476         /* Increment Buffer pointer */
;;;2477         hi2c->pBuffPtr++;
;;;2478   
;;;2479         /* Update counter */
;;;2480         hi2c->XferSize--;
;;;2481         hi2c->XferCount--;
;;;2482   
;;;2483         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;2484         {
;;;2485           /* Write data to DR */
;;;2486           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;2487   
;;;2488           /* Increment Buffer pointer */
;;;2489           hi2c->pBuffPtr++;
;;;2490   
;;;2491           /* Update counter */
;;;2492           hi2c->XferSize--;
;;;2493           hi2c->XferCount--;
;;;2494         }
;;;2495       }
;;;2496   
;;;2497       /* Wait until BTF flag is set */
;;;2498       if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2499       {
;;;2500         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2501         {
;;;2502           /* Generate Stop */
;;;2503           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2504         }
;;;2505         return HAL_ERROR;
;;;2506       }
;;;2507   
;;;2508       /* Generate Stop */
;;;2509       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2510   
;;;2511       hi2c->State = HAL_I2C_STATE_READY;
;;;2512       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2513   
;;;2514       /* Process Unlocked */
;;;2515       __HAL_UNLOCK(hi2c);
;;;2516   
;;;2517       return HAL_OK;
;;;2518     }
;;;2519     else
;;;2520     {
;;;2521       return HAL_BUSY;
;;;2522     }
;;;2523   }
000032  e8bd9ffc          POP      {r2-r12,pc}
                  |L33.54|
000036  bf00              NOP                            ;2432
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;2432
00003c  2801              CMP      r0,#1                 ;2432
00003e  d101              BNE      |L33.68|
000040  2002              MOVS     r0,#2                 ;2432
000042  e7f6              B        |L33.50|
                  |L33.68|
000044  2001              MOVS     r0,#1                 ;2432
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2432
00004a  bf00              NOP                            ;2432
00004c  6820              LDR      r0,[r4,#0]            ;2435
00004e  6800              LDR      r0,[r0,#0]            ;2435
000050  f0000001          AND      r0,r0,#1              ;2435
000054  b928              CBNZ     r0,|L33.98|
000056  6820              LDR      r0,[r4,#0]            ;2438
000058  6800              LDR      r0,[r0,#0]            ;2438
00005a  f0400001          ORR      r0,r0,#1              ;2438
00005e  6821              LDR      r1,[r4,#0]            ;2438
000060  6008              STR      r0,[r1,#0]            ;2438
                  |L33.98|
000062  6820              LDR      r0,[r4,#0]            ;2442
000064  6800              LDR      r0,[r0,#0]            ;2442
000066  f4206000          BIC      r0,r0,#0x800          ;2442
00006a  6821              LDR      r1,[r4,#0]            ;2442
00006c  6008              STR      r0,[r1,#0]            ;2442
00006e  2021              MOVS     r0,#0x21              ;2444
000070  f884003d          STRB     r0,[r4,#0x3d]         ;2444
000074  2040              MOVS     r0,#0x40              ;2445
000076  f884003e          STRB     r0,[r4,#0x3e]         ;2445
00007a  2000              MOVS     r0,#0                 ;2446
00007c  6420              STR      r0,[r4,#0x40]         ;2446
00007e  f8c4a024          STR      r10,[r4,#0x24]        ;2449
000082  f8a4b02a          STRH     r11,[r4,#0x2a]        ;2450
000086  8d60              LDRH     r0,[r4,#0x2a]         ;2451
000088  8520              STRH     r0,[r4,#0x28]         ;2451
00008a  4835              LDR      r0,|L33.352|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2452
00008e  464b              MOV      r3,r9                 ;2455
000090  4642              MOV      r2,r8                 ;2455
000092  4639              MOV      r1,r7                 ;2455
000094  4620              MOV      r0,r4                 ;2455
000096  e9cd6500          STRD     r6,r5,[sp,#0]         ;2455
00009a  f7fffffe          BL       I2C_RequestMemoryWrite
00009e  b108              CBZ      r0,|L33.164|
0000a0  2001              MOVS     r0,#1                 ;2457
0000a2  e7c6              B        |L33.50|
                  |L33.164|
0000a4  e031              B        |L33.266|
                  |L33.166|
0000a6  462a              MOV      r2,r5                 ;2463
0000a8  4631              MOV      r1,r6                 ;2463
0000aa  4620              MOV      r0,r4                 ;2463
0000ac  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000b0  b150              CBZ      r0,|L33.200|
0000b2  6c20              LDR      r0,[r4,#0x40]         ;2465
0000b4  2804              CMP      r0,#4                 ;2465
0000b6  d105              BNE      |L33.196|
0000b8  6820              LDR      r0,[r4,#0]            ;2468
0000ba  6800              LDR      r0,[r0,#0]            ;2468
0000bc  f4407000          ORR      r0,r0,#0x200          ;2468
0000c0  6821              LDR      r1,[r4,#0]            ;2468
0000c2  6008              STR      r0,[r1,#0]            ;2468
                  |L33.196|
0000c4  2001              MOVS     r0,#1                 ;2470
0000c6  e7b4              B        |L33.50|
                  |L33.200|
0000c8  6a60              LDR      r0,[r4,#0x24]         ;2474
0000ca  7800              LDRB     r0,[r0,#0]            ;2474
0000cc  6821              LDR      r1,[r4,#0]            ;2474
0000ce  6108              STR      r0,[r1,#0x10]         ;2474
0000d0  6a60              LDR      r0,[r4,#0x24]         ;2477
0000d2  1c40              ADDS     r0,r0,#1              ;2477
0000d4  6260              STR      r0,[r4,#0x24]         ;2477
0000d6  8d20              LDRH     r0,[r4,#0x28]         ;2480
0000d8  1e40              SUBS     r0,r0,#1              ;2480
0000da  8520              STRH     r0,[r4,#0x28]         ;2480
0000dc  8d60              LDRH     r0,[r4,#0x2a]         ;2481
0000de  1e40              SUBS     r0,r0,#1              ;2481
0000e0  8560              STRH     r0,[r4,#0x2a]         ;2481
0000e2  6820              LDR      r0,[r4,#0]            ;2483
0000e4  6940              LDR      r0,[r0,#0x14]         ;2483
0000e6  f3c00080          UBFX     r0,r0,#2,#1           ;2483
0000ea  b170              CBZ      r0,|L33.266|
0000ec  8d20              LDRH     r0,[r4,#0x28]         ;2483
0000ee  b160              CBZ      r0,|L33.266|
0000f0  6a60              LDR      r0,[r4,#0x24]         ;2486
0000f2  7800              LDRB     r0,[r0,#0]            ;2486
0000f4  6821              LDR      r1,[r4,#0]            ;2486
0000f6  6108              STR      r0,[r1,#0x10]         ;2486
0000f8  6a60              LDR      r0,[r4,#0x24]         ;2489
0000fa  1c40              ADDS     r0,r0,#1              ;2489
0000fc  6260              STR      r0,[r4,#0x24]         ;2489
0000fe  8d20              LDRH     r0,[r4,#0x28]         ;2492
000100  1e40              SUBS     r0,r0,#1              ;2492
000102  8520              STRH     r0,[r4,#0x28]         ;2492
000104  8d60              LDRH     r0,[r4,#0x2a]         ;2493
000106  1e40              SUBS     r0,r0,#1              ;2493
000108  8560              STRH     r0,[r4,#0x2a]         ;2493
                  |L33.266|
00010a  8d20              LDRH     r0,[r4,#0x28]         ;2460
00010c  2800              CMP      r0,#0                 ;2460
00010e  d1ca              BNE      |L33.166|
000110  462a              MOV      r2,r5                 ;2498
000112  4631              MOV      r1,r6                 ;2498
000114  4620              MOV      r0,r4                 ;2498
000116  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
00011a  e000              B        |L33.286|
                  |L33.284|
00011c  e01c              B        |L33.344|
                  |L33.286|
00011e  b150              CBZ      r0,|L33.310|
000120  6c20              LDR      r0,[r4,#0x40]         ;2500
000122  2804              CMP      r0,#4                 ;2500
000124  d105              BNE      |L33.306|
000126  6820              LDR      r0,[r4,#0]            ;2503
000128  6800              LDR      r0,[r0,#0]            ;2503
00012a  f4407000          ORR      r0,r0,#0x200          ;2503
00012e  6821              LDR      r1,[r4,#0]            ;2503
000130  6008              STR      r0,[r1,#0]            ;2503
                  |L33.306|
000132  2001              MOVS     r0,#1                 ;2505
000134  e77d              B        |L33.50|
                  |L33.310|
000136  6820              LDR      r0,[r4,#0]            ;2509
000138  6800              LDR      r0,[r0,#0]            ;2509
00013a  f4407000          ORR      r0,r0,#0x200          ;2509
00013e  6821              LDR      r1,[r4,#0]            ;2509
000140  6008              STR      r0,[r1,#0]            ;2509
000142  2020              MOVS     r0,#0x20              ;2511
000144  f884003d          STRB     r0,[r4,#0x3d]         ;2511
000148  2000              MOVS     r0,#0                 ;2512
00014a  f884003e          STRB     r0,[r4,#0x3e]         ;2512
00014e  bf00              NOP                            ;2515
000150  f884003c          STRB     r0,[r4,#0x3c]         ;2515
000154  bf00              NOP                            ;2515
000156  e76c              B        |L33.50|
                  |L33.344|
000158  2002              MOVS     r0,#2                 ;2521
00015a  e76a              B        |L33.50|
;;;2524   
                          ENDP

                  |L33.348|
                          DCD      0x00100002
                  |L33.352|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_DMA PROC
;;;2966     */
;;;2967   HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;2968   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  469b              MOV      r11,r3
00000c  e9dd890c          LDRD     r8,r9,[sp,#0x30]
;;;2969     __IO uint32_t count = 0U;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;2970     HAL_StatusTypeDef dmaxferstatus;
;;;2971   
;;;2972     /* Init tickstart for timeout management*/
;;;2973     uint32_t tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4682              MOV      r10,r0
;;;2974   
;;;2975     /* Check the parameters */
;;;2976     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2977   
;;;2978     if (hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d17e              BNE      |L34.288|
;;;2979     {
;;;2980       /* Wait until BUSY flag is reset */
;;;2981       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000022  4870              LDR      r0,|L34.484|
000024  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000026  2119              MOVS     r1,#0x19
000028  fbb0f0f1          UDIV     r0,r0,r1
00002c  f44f717a          MOV      r1,#0x3e8
000030  fbb0f0f1          UDIV     r0,r0,r1
000034  eb0001c0          ADD      r1,r0,r0,LSL #3
000038  eb011000          ADD      r0,r1,r0,LSL #4
00003c  9002              STR      r0,[sp,#8]
;;;2982       do
00003e  bf00              NOP      
                  |L34.64|
;;;2983       {
;;;2984         count--;
000040  9802              LDR      r0,[sp,#8]
000042  1e40              SUBS     r0,r0,#1
000044  9002              STR      r0,[sp,#8]
;;;2985         if (count == 0U)
000046  9802              LDR      r0,[sp,#8]
000048  b998              CBNZ     r0,|L34.114|
;;;2986         {
;;;2987           hi2c->PreviousState       = I2C_STATE_NONE;
00004a  2000              MOVS     r0,#0
00004c  6320              STR      r0,[r4,#0x30]
;;;2988           hi2c->State               = HAL_I2C_STATE_READY;
00004e  2020              MOVS     r0,#0x20
000050  f884003d          STRB     r0,[r4,#0x3d]
;;;2989           hi2c->Mode                = HAL_I2C_MODE_NONE;
000054  2000              MOVS     r0,#0
000056  f884003e          STRB     r0,[r4,#0x3e]
;;;2990           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f0400020          ORR      r0,r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;2991   
;;;2992           /* Process Unlocked */
;;;2993           __HAL_UNLOCK(hi2c);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f884003c          STRB     r0,[r4,#0x3c]
00006a  bf00              NOP      
;;;2994   
;;;2995           return HAL_ERROR;
00006c  2001              MOVS     r0,#1
                  |L34.110|
;;;2996         }
;;;2997       }
;;;2998       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2999   
;;;3000       /* Process Locked */
;;;3001       __HAL_LOCK(hi2c);
;;;3002   
;;;3003       /* Check if the I2C is already enabled */
;;;3004       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3005       {
;;;3006         /* Enable I2C peripheral */
;;;3007         __HAL_I2C_ENABLE(hi2c);
;;;3008       }
;;;3009   
;;;3010       /* Disable Pos */
;;;3011       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3012   
;;;3013       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3014       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3015       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3016   
;;;3017       /* Prepare transfer parameters */
;;;3018       hi2c->pBuffPtr    = pData;
;;;3019       hi2c->XferCount   = Size;
;;;3020       hi2c->XferSize    = hi2c->XferCount;
;;;3021       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3022   
;;;3023       if (hi2c->XferSize > 0U)
;;;3024       {
;;;3025         /* Set the I2C DMA transfer complete callback */
;;;3026         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;3027   
;;;3028         /* Set the DMA error callback */
;;;3029         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3030   
;;;3031         /* Set the unused DMA callbacks to NULL */
;;;3032         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3033         hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;3034         hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;3035         hi2c->hdmatx->XferAbortCallback = NULL;
;;;3036   
;;;3037         /* Enable the DMA stream */
;;;3038         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;3039   
;;;3040         if (dmaxferstatus == HAL_OK)
;;;3041         {
;;;3042           /* Send Slave Address and Memory Address */
;;;3043           if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3044           {
;;;3045             /* Abort the ongoing DMA */
;;;3046             dmaxferstatus = HAL_DMA_Abort_IT(hi2c->hdmatx);
;;;3047   
;;;3048             /* Prevent unused argument(s) compilation and MISRA warning */
;;;3049             UNUSED(dmaxferstatus);
;;;3050   
;;;3051             /* Clear directly Complete callback as no XferAbortCallback is used to finalize Abort treatment */
;;;3052             if (hi2c->hdmatx != NULL)
;;;3053             {
;;;3054               hi2c->hdmatx->XferCpltCallback = NULL;
;;;3055             }
;;;3056   
;;;3057             /* Disable Acknowledge */
;;;3058             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3059   
;;;3060             hi2c->XferSize = 0U;
;;;3061             hi2c->XferCount = 0U;
;;;3062   
;;;3063             /* Disable I2C peripheral to prevent dummy data in buffer */
;;;3064             __HAL_I2C_DISABLE(hi2c);
;;;3065   
;;;3066             return HAL_ERROR;
;;;3067           }
;;;3068   
;;;3069           /* Clear ADDR flag */
;;;3070           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3071   
;;;3072           /* Process Unlocked */
;;;3073           __HAL_UNLOCK(hi2c);
;;;3074   
;;;3075           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3076           to avoid the risk of I2C interrupt handle execution before current
;;;3077           process unlock */
;;;3078           /* Enable ERR interrupt */
;;;3079           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3080   
;;;3081           /* Enable DMA Request */
;;;3082           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3083   
;;;3084           return HAL_OK;
;;;3085         }
;;;3086         else
;;;3087         {
;;;3088           /* Update I2C state */
;;;3089           hi2c->State     = HAL_I2C_STATE_READY;
;;;3090           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3091   
;;;3092           /* Update I2C error code */
;;;3093           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3094   
;;;3095           /* Process Unlocked */
;;;3096           __HAL_UNLOCK(hi2c);
;;;3097   
;;;3098           return HAL_ERROR;
;;;3099         }
;;;3100       }
;;;3101       else
;;;3102       {
;;;3103         /* Update I2C state */
;;;3104         hi2c->State     = HAL_I2C_STATE_READY;
;;;3105         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3106   
;;;3107         /* Update I2C error code */
;;;3108         hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
;;;3109   
;;;3110         /* Process Unlocked */
;;;3111         __HAL_UNLOCK(hi2c);
;;;3112   
;;;3113         return HAL_ERROR;
;;;3114       }
;;;3115     }
;;;3116     else
;;;3117     {
;;;3118       return HAL_BUSY;
;;;3119     }
;;;3120   }
00006e  e8bd8ffe          POP      {r1-r11,pc}
                  |L34.114|
000072  6820              LDR      r0,[r4,#0]            ;2998
000074  6980              LDR      r0,[r0,#0x18]         ;2998
000076  f3c00040          UBFX     r0,r0,#1,#1           ;2998
00007a  2800              CMP      r0,#0                 ;2998
00007c  d1e0              BNE      |L34.64|
00007e  bf00              NOP                            ;3001
000080  f894003c          LDRB     r0,[r4,#0x3c]         ;3001
000084  2801              CMP      r0,#1                 ;3001
000086  d101              BNE      |L34.140|
000088  2002              MOVS     r0,#2                 ;3001
00008a  e7f0              B        |L34.110|
                  |L34.140|
00008c  2001              MOVS     r0,#1                 ;3001
00008e  f884003c          STRB     r0,[r4,#0x3c]         ;3001
000092  bf00              NOP                            ;3001
000094  6820              LDR      r0,[r4,#0]            ;3004
000096  6800              LDR      r0,[r0,#0]            ;3004
000098  f0000001          AND      r0,r0,#1              ;3004
00009c  b928              CBNZ     r0,|L34.170|
00009e  6820              LDR      r0,[r4,#0]            ;3007
0000a0  6800              LDR      r0,[r0,#0]            ;3007
0000a2  f0400001          ORR      r0,r0,#1              ;3007
0000a6  6821              LDR      r1,[r4,#0]            ;3007
0000a8  6008              STR      r0,[r1,#0]            ;3007
                  |L34.170|
0000aa  6820              LDR      r0,[r4,#0]            ;3011
0000ac  6800              LDR      r0,[r0,#0]            ;3011
0000ae  f4206000          BIC      r0,r0,#0x800          ;3011
0000b2  6821              LDR      r1,[r4,#0]            ;3011
0000b4  6008              STR      r0,[r1,#0]            ;3011
0000b6  2021              MOVS     r0,#0x21              ;3013
0000b8  f884003d          STRB     r0,[r4,#0x3d]         ;3013
0000bc  2040              MOVS     r0,#0x40              ;3014
0000be  f884003e          STRB     r0,[r4,#0x3e]         ;3014
0000c2  2000              MOVS     r0,#0                 ;3015
0000c4  6420              STR      r0,[r4,#0x40]         ;3015
0000c6  f8c48024          STR      r8,[r4,#0x24]         ;3018
0000ca  f8a4902a          STRH     r9,[r4,#0x2a]         ;3019
0000ce  8d60              LDRH     r0,[r4,#0x2a]         ;3020
0000d0  8520              STRH     r0,[r4,#0x28]         ;3020
0000d2  4845              LDR      r0,|L34.488|
0000d4  62e0              STR      r0,[r4,#0x2c]         ;3021
0000d6  8d20              LDRH     r0,[r4,#0x28]         ;3023
0000d8  2800              CMP      r0,#0                 ;3023
0000da  d070              BEQ      |L34.446|
0000dc  4843              LDR      r0,|L34.492|
0000de  6b61              LDR      r1,[r4,#0x34]         ;3026
0000e0  63c8              STR      r0,[r1,#0x3c]         ;3026
0000e2  4843              LDR      r0,|L34.496|
0000e4  6b61              LDR      r1,[r4,#0x34]         ;3029
0000e6  64c8              STR      r0,[r1,#0x4c]         ;3029
0000e8  2000              MOVS     r0,#0                 ;3032
0000ea  6b61              LDR      r1,[r4,#0x34]         ;3032
0000ec  6408              STR      r0,[r1,#0x40]         ;3032
0000ee  6b61              LDR      r1,[r4,#0x34]         ;3033
0000f0  6448              STR      r0,[r1,#0x44]         ;3033
0000f2  6b61              LDR      r1,[r4,#0x34]         ;3034
0000f4  6488              STR      r0,[r1,#0x48]         ;3034
0000f6  6b61              LDR      r1,[r4,#0x34]         ;3035
0000f8  6508              STR      r0,[r1,#0x50]         ;3035
0000fa  8d23              LDRH     r3,[r4,#0x28]         ;3038
0000fc  f8d4c000          LDR      r12,[r4,#0]           ;3038
000100  f10c0210          ADD      r2,r12,#0x10          ;3038
000104  6a61              LDR      r1,[r4,#0x24]         ;3038
000106  6b60              LDR      r0,[r4,#0x34]         ;3038
000108  f7fffffe          BL       HAL_DMA_Start_IT
00010c  4605              MOV      r5,r0                 ;3038
00010e  2d00              CMP      r5,#0                 ;3040
000110  d143              BNE      |L34.410|
000112  2023              MOVS     r0,#0x23              ;3043
000114  465b              MOV      r3,r11                ;3043
000116  463a              MOV      r2,r7                 ;3043
000118  4631              MOV      r1,r6                 ;3043
00011a  e9cd0a00          STRD     r0,r10,[sp,#0]        ;3043
00011e  e000              B        |L34.290|
                  |L34.288|
000120  e05e              B        |L34.480|
                  |L34.290|
000122  4620              MOV      r0,r4                 ;3043
000124  f7fffffe          BL       I2C_RequestMemoryWrite
000128  b1c8              CBZ      r0,|L34.350|
00012a  6b60              LDR      r0,[r4,#0x34]         ;3046
00012c  f7fffffe          BL       HAL_DMA_Abort_IT
000130  4605              MOV      r5,r0                 ;3046
000132  6b60              LDR      r0,[r4,#0x34]         ;3052
000134  b110              CBZ      r0,|L34.316|
000136  2000              MOVS     r0,#0                 ;3054
000138  6b61              LDR      r1,[r4,#0x34]         ;3054
00013a  63c8              STR      r0,[r1,#0x3c]         ;3054
                  |L34.316|
00013c  6820              LDR      r0,[r4,#0]            ;3058
00013e  6800              LDR      r0,[r0,#0]            ;3058
000140  f4206080          BIC      r0,r0,#0x400          ;3058
000144  6821              LDR      r1,[r4,#0]            ;3058
000146  6008              STR      r0,[r1,#0]            ;3058
000148  2000              MOVS     r0,#0                 ;3060
00014a  8520              STRH     r0,[r4,#0x28]         ;3060
00014c  8560              STRH     r0,[r4,#0x2a]         ;3061
00014e  6820              LDR      r0,[r4,#0]            ;3064
000150  6800              LDR      r0,[r0,#0]            ;3064
000152  f0200001          BIC      r0,r0,#1              ;3064
000156  6821              LDR      r1,[r4,#0]            ;3064
000158  6008              STR      r0,[r1,#0]            ;3064
00015a  2001              MOVS     r0,#1                 ;3066
00015c  e787              B        |L34.110|
                  |L34.350|
00015e  bf00              NOP                            ;3070
000160  2000              MOVS     r0,#0                 ;3070
000162  9001              STR      r0,[sp,#4]            ;3070
000164  6820              LDR      r0,[r4,#0]            ;3070
000166  6940              LDR      r0,[r0,#0x14]         ;3070
000168  9001              STR      r0,[sp,#4]            ;3070
00016a  6820              LDR      r0,[r4,#0]            ;3070
00016c  6980              LDR      r0,[r0,#0x18]         ;3070
00016e  9001              STR      r0,[sp,#4]            ;3070
000170  bf00              NOP                            ;3070
000172  bf00              NOP                            ;3070
000174  bf00              NOP                            ;3073
000176  2000              MOVS     r0,#0                 ;3073
000178  f884003c          STRB     r0,[r4,#0x3c]         ;3073
00017c  bf00              NOP                            ;3073
00017e  6820              LDR      r0,[r4,#0]            ;3079
000180  6840              LDR      r0,[r0,#4]            ;3079
000182  f4407080          ORR      r0,r0,#0x100          ;3079
000186  6821              LDR      r1,[r4,#0]            ;3079
000188  6048              STR      r0,[r1,#4]            ;3079
00018a  6820              LDR      r0,[r4,#0]            ;3082
00018c  6840              LDR      r0,[r0,#4]            ;3082
00018e  f4406000          ORR      r0,r0,#0x800          ;3082
000192  6821              LDR      r1,[r4,#0]            ;3082
000194  6048              STR      r0,[r1,#4]            ;3082
000196  2000              MOVS     r0,#0                 ;3084
000198  e769              B        |L34.110|
                  |L34.410|
00019a  2020              MOVS     r0,#0x20              ;3089
00019c  f884003d          STRB     r0,[r4,#0x3d]         ;3089
0001a0  2000              MOVS     r0,#0                 ;3090
0001a2  f884003e          STRB     r0,[r4,#0x3e]         ;3090
0001a6  6c20              LDR      r0,[r4,#0x40]         ;3093
0001a8  f0400010          ORR      r0,r0,#0x10           ;3093
0001ac  6420              STR      r0,[r4,#0x40]         ;3093
0001ae  bf00              NOP                            ;3096
0001b0  2000              MOVS     r0,#0                 ;3096
0001b2  f884003c          STRB     r0,[r4,#0x3c]         ;3096
0001b6  bf00              NOP                            ;3096
0001b8  2001              MOVS     r0,#1                 ;3098
0001ba  e758              B        |L34.110|
0001bc  e7ff              B        |L34.446|
                  |L34.446|
0001be  2020              MOVS     r0,#0x20              ;3104
0001c0  f884003d          STRB     r0,[r4,#0x3d]         ;3104
0001c4  2000              MOVS     r0,#0                 ;3105
0001c6  f884003e          STRB     r0,[r4,#0x3e]         ;3105
0001ca  6c20              LDR      r0,[r4,#0x40]         ;3108
0001cc  f0400040          ORR      r0,r0,#0x40           ;3108
0001d0  6420              STR      r0,[r4,#0x40]         ;3108
0001d2  bf00              NOP                            ;3111
0001d4  2000              MOVS     r0,#0                 ;3111
0001d6  f884003c          STRB     r0,[r4,#0x3c]         ;3111
0001da  bf00              NOP                            ;3111
0001dc  2001              MOVS     r0,#1                 ;3113
0001de  e746              B        |L34.110|
                  |L34.480|
0001e0  2002              MOVS     r0,#2                 ;3118
0001e2  e744              B        |L34.110|
;;;3121   
                          ENDP

                  |L34.484|
                          DCD      SystemCoreClock
                  |L34.488|
                          DCD      0xffff0000
                  |L34.492|
                          DCD      I2C_DMAXferCplt
                  |L34.496|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Write_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_IT PROC
;;;2784     */
;;;2785   HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2786   {
000002  4604              MOV      r4,r0
000004  e9dd5606          LDRD     r5,r6,[sp,#0x18]
;;;2787     __IO uint32_t count = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2788   
;;;2789     /* Check the parameters */
;;;2790     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2791   
;;;2792     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d16f              BNE      |L35.244|
;;;2793     {
;;;2794       /* Wait until BUSY flag is reset */
;;;2795       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000014  4838              LDR      r0,|L35.248|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  2719              MOVS     r7,#0x19
00001a  fbb0f0f7          UDIV     r0,r0,r7
00001e  f44f777a          MOV      r7,#0x3e8
000022  fbb0f0f7          UDIV     r0,r0,r7
000026  eb0007c0          ADD      r7,r0,r0,LSL #3
00002a  eb071000          ADD      r0,r7,r0,LSL #4
00002e  9000              STR      r0,[sp,#0]
;;;2796       do
000030  bf00              NOP      
                  |L35.50|
;;;2797       {
;;;2798         count--;
000032  9800              LDR      r0,[sp,#0]
000034  1e40              SUBS     r0,r0,#1
000036  9000              STR      r0,[sp,#0]
;;;2799         if (count == 0U)
000038  9800              LDR      r0,[sp,#0]
00003a  b990              CBNZ     r0,|L35.98|
;;;2800         {
;;;2801           hi2c->PreviousState       = I2C_STATE_NONE;
00003c  2000              MOVS     r0,#0
00003e  6320              STR      r0,[r4,#0x30]
;;;2802           hi2c->State               = HAL_I2C_STATE_READY;
000040  2020              MOVS     r0,#0x20
000042  f884003d          STRB     r0,[r4,#0x3d]
;;;2803           hi2c->Mode                = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;2804           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6420              STR      r0,[r4,#0x40]
;;;2805   
;;;2806           /* Process Unlocked */
;;;2807           __HAL_UNLOCK(hi2c);
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  f884003c          STRB     r0,[r4,#0x3c]
00005c  bf00              NOP      
;;;2808   
;;;2809           return HAL_ERROR;
00005e  2001              MOVS     r0,#1
                  |L35.96|
;;;2810         }
;;;2811       }
;;;2812       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2813   
;;;2814       /* Process Locked */
;;;2815       __HAL_LOCK(hi2c);
;;;2816   
;;;2817       /* Check if the I2C is already enabled */
;;;2818       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2819       {
;;;2820         /* Enable I2C peripheral */
;;;2821         __HAL_I2C_ENABLE(hi2c);
;;;2822       }
;;;2823   
;;;2824       /* Disable Pos */
;;;2825       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2826   
;;;2827       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2828       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2829       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2830   
;;;2831       /* Prepare transfer parameters */
;;;2832       hi2c->pBuffPtr    = pData;
;;;2833       hi2c->XferCount   = Size;
;;;2834       hi2c->XferSize    = hi2c->XferCount;
;;;2835       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2836       hi2c->Devaddress  = DevAddress;
;;;2837       hi2c->Memaddress  = MemAddress;
;;;2838       hi2c->MemaddSize  = MemAddSize;
;;;2839       hi2c->EventCount  = 0U;
;;;2840   
;;;2841       /* Generate Start */
;;;2842       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2843   
;;;2844       /* Process Unlocked */
;;;2845       __HAL_UNLOCK(hi2c);
;;;2846   
;;;2847       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2848       to avoid the risk of I2C interrupt handle execution before current
;;;2849       process unlock */
;;;2850   
;;;2851       /* Enable EVT, BUF and ERR interrupt */
;;;2852       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2853   
;;;2854       return HAL_OK;
;;;2855     }
;;;2856     else
;;;2857     {
;;;2858       return HAL_BUSY;
;;;2859     }
;;;2860   }
000060  bdf8              POP      {r3-r7,pc}
                  |L35.98|
000062  6820              LDR      r0,[r4,#0]            ;2812
000064  6980              LDR      r0,[r0,#0x18]         ;2812
000066  f3c00040          UBFX     r0,r0,#1,#1           ;2812
00006a  2800              CMP      r0,#0                 ;2812
00006c  d1e1              BNE      |L35.50|
00006e  bf00              NOP                            ;2815
000070  f894003c          LDRB     r0,[r4,#0x3c]         ;2815
000074  2801              CMP      r0,#1                 ;2815
000076  d101              BNE      |L35.124|
000078  2002              MOVS     r0,#2                 ;2815
00007a  e7f1              B        |L35.96|
                  |L35.124|
00007c  2001              MOVS     r0,#1                 ;2815
00007e  f884003c          STRB     r0,[r4,#0x3c]         ;2815
000082  bf00              NOP                            ;2815
000084  6820              LDR      r0,[r4,#0]            ;2818
000086  6800              LDR      r0,[r0,#0]            ;2818
000088  f0000001          AND      r0,r0,#1              ;2818
00008c  b928              CBNZ     r0,|L35.154|
00008e  6820              LDR      r0,[r4,#0]            ;2821
000090  6800              LDR      r0,[r0,#0]            ;2821
000092  f0400001          ORR      r0,r0,#1              ;2821
000096  6827              LDR      r7,[r4,#0]            ;2821
000098  6038              STR      r0,[r7,#0]            ;2821
                  |L35.154|
00009a  6820              LDR      r0,[r4,#0]            ;2825
00009c  6800              LDR      r0,[r0,#0]            ;2825
00009e  f4206000          BIC      r0,r0,#0x800          ;2825
0000a2  6827              LDR      r7,[r4,#0]            ;2825
0000a4  6038              STR      r0,[r7,#0]            ;2825
0000a6  2021              MOVS     r0,#0x21              ;2827
0000a8  f884003d          STRB     r0,[r4,#0x3d]         ;2827
0000ac  2040              MOVS     r0,#0x40              ;2828
0000ae  f884003e          STRB     r0,[r4,#0x3e]         ;2828
0000b2  2000              MOVS     r0,#0                 ;2829
0000b4  6420              STR      r0,[r4,#0x40]         ;2829
0000b6  6265              STR      r5,[r4,#0x24]         ;2832
0000b8  8566              STRH     r6,[r4,#0x2a]         ;2833
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;2834
0000bc  8520              STRH     r0,[r4,#0x28]         ;2834
0000be  480f              LDR      r0,|L35.252|
0000c0  62e0              STR      r0,[r4,#0x2c]         ;2835
0000c2  6461              STR      r1,[r4,#0x44]         ;2836
0000c4  64a2              STR      r2,[r4,#0x48]         ;2837
0000c6  64e3              STR      r3,[r4,#0x4c]         ;2838
0000c8  2000              MOVS     r0,#0                 ;2839
0000ca  6520              STR      r0,[r4,#0x50]         ;2839
0000cc  6820              LDR      r0,[r4,#0]            ;2842
0000ce  6800              LDR      r0,[r0,#0]            ;2842
0000d0  f4407080          ORR      r0,r0,#0x100          ;2842
0000d4  6827              LDR      r7,[r4,#0]            ;2842
0000d6  6038              STR      r0,[r7,#0]            ;2842
0000d8  bf00              NOP                            ;2845
0000da  2000              MOVS     r0,#0                 ;2845
0000dc  f884003c          STRB     r0,[r4,#0x3c]         ;2845
0000e0  bf00              NOP                            ;2845
0000e2  6820              LDR      r0,[r4,#0]            ;2852
0000e4  6840              LDR      r0,[r0,#4]            ;2852
0000e6  f44060e0          ORR      r0,r0,#0x700          ;2852
0000ea  6827              LDR      r7,[r4,#0]            ;2852
0000ec  6078              STR      r0,[r7,#4]            ;2852
0000ee  2000              MOVS     r0,#0                 ;2854
0000f0  e7b6              B        |L35.96|
0000f2  e7ff              B        |L35.244|
                  |L35.244|
0000f4  2002              MOVS     r0,#2                 ;2858
0000f6  e7b3              B        |L35.96|
;;;2861   
                          ENDP

                  |L35.248|
                          DCD      SystemCoreClock
                  |L35.252|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspDeInit PROC
;;;611      */
;;;612    __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;613    {
;;;614      /* Prevent unused argument(s) compilation warning */
;;;615      UNUSED(hi2c);
;;;616    
;;;617      /* NOTE : This function should not be modified, when the callback is needed,
;;;618                the HAL_I2C_MspDeInit could be implemented in the user file
;;;619       */
;;;620    }
;;;621    
                          ENDP


                          AREA ||i.HAL_I2C_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspInit PROC
;;;595      */
;;;596    __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;597    {
;;;598      /* Prevent unused argument(s) compilation warning */
;;;599      UNUSED(hi2c);
;;;600    
;;;601      /* NOTE : This function should not be modified, when the callback is needed,
;;;602                the HAL_I2C_MspInit could be implemented in the user file
;;;603       */
;;;604    }
;;;605    
                          ENDP


                          AREA ||i.HAL_I2C_SlaveRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveRxCpltCallback PROC
;;;4903     */
;;;4904   __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4905   {
;;;4906     /* Prevent unused argument(s) compilation warning */
;;;4907     UNUSED(hi2c);
;;;4908   
;;;4909     /* NOTE : This function should not be modified, when the callback is needed,
;;;4910               the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
;;;4911      */
;;;4912   }
;;;4913   
                          ENDP


                          AREA ||i.HAL_I2C_SlaveTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveTxCpltCallback PROC
;;;4887     */
;;;4888   __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4889   {
;;;4890     /* Prevent unused argument(s) compilation warning */
;;;4891     UNUSED(hi2c);
;;;4892   
;;;4893     /* NOTE : This function should not be modified, when the callback is needed,
;;;4894               the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
;;;4895      */
;;;4896   }
;;;4897   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive PROC
;;;1526     */
;;;1527   HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1528   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1529     /* Init tickstart for timeout management*/
;;;1530     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;1531   
;;;1532     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d17e              BNE      |L40.280|
;;;1533     {
;;;1534       if ((pData == NULL) || (Size == (uint16_t)0))
00001a  b105              CBZ      r5,|L40.30|
00001c  b916              CBNZ     r6,|L40.36|
                  |L40.30|
;;;1535       {
;;;1536         return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L40.32|
;;;1537       }
;;;1538   
;;;1539       /* Process Locked */
;;;1540       __HAL_LOCK(hi2c);
;;;1541   
;;;1542       /* Check if the I2C is already enabled */
;;;1543       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1544       {
;;;1545         /* Enable I2C peripheral */
;;;1546         __HAL_I2C_ENABLE(hi2c);
;;;1547       }
;;;1548   
;;;1549       /* Disable Pos */
;;;1550       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1551   
;;;1552       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1553       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1554       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1555   
;;;1556       /* Prepare transfer parameters */
;;;1557       hi2c->pBuffPtr    = pData;
;;;1558       hi2c->XferCount   = Size;
;;;1559       hi2c->XferSize    = hi2c->XferCount;
;;;1560       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1561   
;;;1562       /* Enable Address Acknowledge */
;;;1563       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1564   
;;;1565       /* Wait until ADDR flag is set */
;;;1566       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1567       {
;;;1568         return HAL_ERROR;
;;;1569       }
;;;1570   
;;;1571       /* Clear ADDR flag */
;;;1572       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1573   
;;;1574       while (hi2c->XferSize > 0U)
;;;1575       {
;;;1576         /* Wait until RXNE flag is set */
;;;1577         if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1578         {
;;;1579           /* Disable Address Acknowledge */
;;;1580           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1581   
;;;1582           return HAL_ERROR;
;;;1583         }
;;;1584   
;;;1585         /* Read data from DR */
;;;1586         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1587   
;;;1588         /* Increment Buffer pointer */
;;;1589         hi2c->pBuffPtr++;
;;;1590   
;;;1591         /* Update counter */
;;;1592         hi2c->XferSize--;
;;;1593         hi2c->XferCount--;
;;;1594   
;;;1595         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1596         {
;;;1597           /* Read data from DR */
;;;1598           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1599   
;;;1600           /* Increment Buffer pointer */
;;;1601           hi2c->pBuffPtr++;
;;;1602   
;;;1603           /* Update counter */
;;;1604           hi2c->XferSize--;
;;;1605           hi2c->XferCount--;
;;;1606         }
;;;1607       }
;;;1608   
;;;1609       /* Wait until STOP flag is set */
;;;1610       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1611       {
;;;1612         /* Disable Address Acknowledge */
;;;1613         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1614   
;;;1615         return HAL_ERROR;
;;;1616       }
;;;1617   
;;;1618       /* Clear STOP flag */
;;;1619       __HAL_I2C_CLEAR_STOPFLAG(hi2c);
;;;1620   
;;;1621       /* Disable Address Acknowledge */
;;;1622       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1623   
;;;1624       hi2c->State = HAL_I2C_STATE_READY;
;;;1625       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1626   
;;;1627       /* Process Unlocked */
;;;1628       __HAL_UNLOCK(hi2c);
;;;1629   
;;;1630       return HAL_OK;
;;;1631     }
;;;1632     else
;;;1633     {
;;;1634       return HAL_BUSY;
;;;1635     }
;;;1636   }
000020  e8bd83f8          POP      {r3-r9,pc}
                  |L40.36|
000024  bf00              NOP                            ;1540
000026  f894003c          LDRB     r0,[r4,#0x3c]         ;1540
00002a  2801              CMP      r0,#1                 ;1540
00002c  d101              BNE      |L40.50|
00002e  2002              MOVS     r0,#2                 ;1540
000030  e7f6              B        |L40.32|
                  |L40.50|
000032  2001              MOVS     r0,#1                 ;1540
000034  f884003c          STRB     r0,[r4,#0x3c]         ;1540
000038  bf00              NOP                            ;1540
00003a  6820              LDR      r0,[r4,#0]            ;1543
00003c  6800              LDR      r0,[r0,#0]            ;1543
00003e  f0000001          AND      r0,r0,#1              ;1543
000042  b928              CBNZ     r0,|L40.80|
000044  6820              LDR      r0,[r4,#0]            ;1546
000046  6800              LDR      r0,[r0,#0]            ;1546
000048  f0400001          ORR      r0,r0,#1              ;1546
00004c  6821              LDR      r1,[r4,#0]            ;1546
00004e  6008              STR      r0,[r1,#0]            ;1546
                  |L40.80|
000050  6820              LDR      r0,[r4,#0]            ;1550
000052  6800              LDR      r0,[r0,#0]            ;1550
000054  f4206000          BIC      r0,r0,#0x800          ;1550
000058  6821              LDR      r1,[r4,#0]            ;1550
00005a  6008              STR      r0,[r1,#0]            ;1550
00005c  2022              MOVS     r0,#0x22              ;1552
00005e  f884003d          STRB     r0,[r4,#0x3d]         ;1552
000062  2020              MOVS     r0,#0x20              ;1553
000064  f884003e          STRB     r0,[r4,#0x3e]         ;1553
000068  2000              MOVS     r0,#0                 ;1554
00006a  6420              STR      r0,[r4,#0x40]         ;1554
00006c  6265              STR      r5,[r4,#0x24]         ;1557
00006e  8566              STRH     r6,[r4,#0x2a]         ;1558
000070  8d60              LDRH     r0,[r4,#0x2a]         ;1559
000072  8520              STRH     r0,[r4,#0x28]         ;1559
000074  4840              LDR      r0,|L40.376|
000076  62e0              STR      r0,[r4,#0x2c]         ;1560
000078  6820              LDR      r0,[r4,#0]            ;1563
00007a  6800              LDR      r0,[r0,#0]            ;1563
00007c  f4406080          ORR      r0,r0,#0x400          ;1563
000080  6821              LDR      r1,[r4,#0]            ;1563
000082  6008              STR      r0,[r1,#0]            ;1563
000084  463b              MOV      r3,r7                 ;1566
000086  2200              MOVS     r2,#0                 ;1566
000088  493c              LDR      r1,|L40.380|
00008a  4620              MOV      r0,r4                 ;1566
00008c  f8cd8000          STR      r8,[sp,#0]            ;1566
000090  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000094  b108              CBZ      r0,|L40.154|
000096  2001              MOVS     r0,#1                 ;1568
000098  e7c2              B        |L40.32|
                  |L40.154|
00009a  bf00              NOP                            ;1572
00009c  2000              MOVS     r0,#0                 ;1572
00009e  9000              STR      r0,[sp,#0]            ;1572
0000a0  6820              LDR      r0,[r4,#0]            ;1572
0000a2  6940              LDR      r0,[r0,#0x14]         ;1572
0000a4  9000              STR      r0,[sp,#0]            ;1572
0000a6  6820              LDR      r0,[r4,#0]            ;1572
0000a8  6980              LDR      r0,[r0,#0x18]         ;1572
0000aa  9000              STR      r0,[sp,#0]            ;1572
0000ac  bf00              NOP                            ;1572
0000ae  bf00              NOP                            ;1572
0000b0  e02e              B        |L40.272|
                  |L40.178|
0000b2  4642              MOV      r2,r8                 ;1577
0000b4  4639              MOV      r1,r7                 ;1577
0000b6  4620              MOV      r0,r4                 ;1577
0000b8  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000bc  b138              CBZ      r0,|L40.206|
0000be  6820              LDR      r0,[r4,#0]            ;1580
0000c0  6800              LDR      r0,[r0,#0]            ;1580
0000c2  f4206080          BIC      r0,r0,#0x400          ;1580
0000c6  6821              LDR      r1,[r4,#0]            ;1580
0000c8  6008              STR      r0,[r1,#0]            ;1580
0000ca  2001              MOVS     r0,#1                 ;1582
0000cc  e7a8              B        |L40.32|
                  |L40.206|
0000ce  6820              LDR      r0,[r4,#0]            ;1586
0000d0  6900              LDR      r0,[r0,#0x10]         ;1586
0000d2  6a61              LDR      r1,[r4,#0x24]         ;1586
0000d4  7008              STRB     r0,[r1,#0]            ;1586
0000d6  6a60              LDR      r0,[r4,#0x24]         ;1589
0000d8  1c40              ADDS     r0,r0,#1              ;1589
0000da  6260              STR      r0,[r4,#0x24]         ;1589
0000dc  8d20              LDRH     r0,[r4,#0x28]         ;1592
0000de  1e40              SUBS     r0,r0,#1              ;1592
0000e0  8520              STRH     r0,[r4,#0x28]         ;1592
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1593
0000e4  1e40              SUBS     r0,r0,#1              ;1593
0000e6  8560              STRH     r0,[r4,#0x2a]         ;1593
0000e8  6820              LDR      r0,[r4,#0]            ;1595
0000ea  6940              LDR      r0,[r0,#0x14]         ;1595
0000ec  f3c00080          UBFX     r0,r0,#2,#1           ;1595
0000f0  b170              CBZ      r0,|L40.272|
0000f2  8d20              LDRH     r0,[r4,#0x28]         ;1595
0000f4  b160              CBZ      r0,|L40.272|
0000f6  6820              LDR      r0,[r4,#0]            ;1598
0000f8  6900              LDR      r0,[r0,#0x10]         ;1598
0000fa  6a61              LDR      r1,[r4,#0x24]         ;1598
0000fc  7008              STRB     r0,[r1,#0]            ;1598
0000fe  6a60              LDR      r0,[r4,#0x24]         ;1601
000100  1c40              ADDS     r0,r0,#1              ;1601
000102  6260              STR      r0,[r4,#0x24]         ;1601
000104  8d20              LDRH     r0,[r4,#0x28]         ;1604
000106  1e40              SUBS     r0,r0,#1              ;1604
000108  8520              STRH     r0,[r4,#0x28]         ;1604
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;1605
00010c  1e40              SUBS     r0,r0,#1              ;1605
00010e  8560              STRH     r0,[r4,#0x2a]         ;1605
                  |L40.272|
000110  8d20              LDRH     r0,[r4,#0x28]         ;1574
000112  2800              CMP      r0,#0                 ;1574
000114  d1cd              BNE      |L40.178|
000116  e000              B        |L40.282|
                  |L40.280|
000118  e02c              B        |L40.372|
                  |L40.282|
00011a  4642              MOV      r2,r8                 ;1610
00011c  4639              MOV      r1,r7                 ;1610
00011e  4620              MOV      r0,r4                 ;1610
000120  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000124  b138              CBZ      r0,|L40.310|
000126  6820              LDR      r0,[r4,#0]            ;1613
000128  6800              LDR      r0,[r0,#0]            ;1613
00012a  f4206080          BIC      r0,r0,#0x400          ;1613
00012e  6821              LDR      r1,[r4,#0]            ;1613
000130  6008              STR      r0,[r1,#0]            ;1613
000132  2001              MOVS     r0,#1                 ;1615
000134  e774              B        |L40.32|
                  |L40.310|
000136  bf00              NOP                            ;1619
000138  2000              MOVS     r0,#0                 ;1619
00013a  9000              STR      r0,[sp,#0]            ;1619
00013c  6820              LDR      r0,[r4,#0]            ;1619
00013e  6940              LDR      r0,[r0,#0x14]         ;1619
000140  9000              STR      r0,[sp,#0]            ;1619
000142  6820              LDR      r0,[r4,#0]            ;1619
000144  6800              LDR      r0,[r0,#0]            ;1619
000146  f0400001          ORR      r0,r0,#1              ;1619
00014a  6821              LDR      r1,[r4,#0]            ;1619
00014c  6008              STR      r0,[r1,#0]            ;1619
00014e  bf00              NOP                            ;1619
000150  bf00              NOP                            ;1619
000152  6820              LDR      r0,[r4,#0]            ;1622
000154  6800              LDR      r0,[r0,#0]            ;1622
000156  f4206080          BIC      r0,r0,#0x400          ;1622
00015a  6821              LDR      r1,[r4,#0]            ;1622
00015c  6008              STR      r0,[r1,#0]            ;1622
00015e  2020              MOVS     r0,#0x20              ;1624
000160  f884003d          STRB     r0,[r4,#0x3d]         ;1624
000164  2000              MOVS     r0,#0                 ;1625
000166  f884003e          STRB     r0,[r4,#0x3e]         ;1625
00016a  bf00              NOP                            ;1628
00016c  f884003c          STRB     r0,[r4,#0x3c]         ;1628
000170  bf00              NOP                            ;1628
000172  e755              B        |L40.32|
                  |L40.372|
000174  2002              MOVS     r0,#2                 ;1634
000176  e753              B        |L40.32|
;;;1637   
                          ENDP

                  |L40.376|
                          DCD      0xffff0000
                  |L40.380|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_DMA PROC
;;;2312     */
;;;2313   HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2314   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2315     HAL_StatusTypeDef dmaxferstatus;
;;;2316   
;;;2317     if (hi2c->State == HAL_I2C_STATE_READY)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2820              CMP      r0,#0x20
000010  d173              BNE      |L41.250|
;;;2318     {
;;;2319       if ((pData == NULL) || (Size == 0U))
000012  b105              CBZ      r5,|L41.22|
000014  b916              CBNZ     r6,|L41.28|
                  |L41.22|
;;;2320       {
;;;2321         return  HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L41.24|
;;;2322       }
;;;2323   
;;;2324       /* Process Locked */
;;;2325       __HAL_LOCK(hi2c);
;;;2326   
;;;2327       /* Check if the I2C is already enabled */
;;;2328       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2329       {
;;;2330         /* Enable I2C peripheral */
;;;2331         __HAL_I2C_ENABLE(hi2c);
;;;2332       }
;;;2333   
;;;2334       /* Disable Pos */
;;;2335       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2336   
;;;2337       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2338       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2339       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2340   
;;;2341       /* Prepare transfer parameters */
;;;2342       hi2c->pBuffPtr    = pData;
;;;2343       hi2c->XferCount   = Size;
;;;2344       hi2c->XferSize    = hi2c->XferCount;
;;;2345       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2346   
;;;2347       /* Set the I2C DMA transfer complete callback */
;;;2348       hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2349   
;;;2350       /* Set the DMA error callback */
;;;2351       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2352   
;;;2353       /* Set the unused DMA callbacks to NULL */
;;;2354       hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2355       hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;2356       hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;2357       hi2c->hdmarx->XferAbortCallback = NULL;
;;;2358   
;;;2359       /* Enable the DMA stream */
;;;2360       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2361   
;;;2362       if (dmaxferstatus == HAL_OK)
;;;2363       {
;;;2364         /* Enable Address Acknowledge */
;;;2365         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2366   
;;;2367         /* Process Unlocked */
;;;2368         __HAL_UNLOCK(hi2c);
;;;2369   
;;;2370         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2371         to avoid the risk of I2C interrupt handle execution before current
;;;2372         process unlock */
;;;2373         /* Enable EVT and ERR interrupt */
;;;2374         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2375   
;;;2376         /* Enable DMA Request */
;;;2377         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2378   
;;;2379         return HAL_OK;
;;;2380       }
;;;2381       else
;;;2382       {
;;;2383         /* Update I2C state */
;;;2384         hi2c->State     = HAL_I2C_STATE_READY;
;;;2385         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2386   
;;;2387         /* Update I2C error code */
;;;2388         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2389   
;;;2390         /* Process Unlocked */
;;;2391         __HAL_UNLOCK(hi2c);
;;;2392   
;;;2393         return HAL_ERROR;
;;;2394       }
;;;2395     }
;;;2396     else
;;;2397     {
;;;2398       return HAL_BUSY;
;;;2399     }
;;;2400   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L41.28|
00001c  bf00              NOP                            ;2325
00001e  f894003c          LDRB     r0,[r4,#0x3c]         ;2325
000022  2801              CMP      r0,#1                 ;2325
000024  d101              BNE      |L41.42|
000026  2002              MOVS     r0,#2                 ;2325
000028  e7f6              B        |L41.24|
                  |L41.42|
00002a  2001              MOVS     r0,#1                 ;2325
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;2325
000030  bf00              NOP                            ;2325
000032  6820              LDR      r0,[r4,#0]            ;2328
000034  6800              LDR      r0,[r0,#0]            ;2328
000036  f0000001          AND      r0,r0,#1              ;2328
00003a  b928              CBNZ     r0,|L41.72|
00003c  6820              LDR      r0,[r4,#0]            ;2331
00003e  6800              LDR      r0,[r0,#0]            ;2331
000040  f0400001          ORR      r0,r0,#1              ;2331
000044  6821              LDR      r1,[r4,#0]            ;2331
000046  6008              STR      r0,[r1,#0]            ;2331
                  |L41.72|
000048  6820              LDR      r0,[r4,#0]            ;2335
00004a  6800              LDR      r0,[r0,#0]            ;2335
00004c  f4206000          BIC      r0,r0,#0x800          ;2335
000050  6821              LDR      r1,[r4,#0]            ;2335
000052  6008              STR      r0,[r1,#0]            ;2335
000054  2022              MOVS     r0,#0x22              ;2337
000056  f884003d          STRB     r0,[r4,#0x3d]         ;2337
00005a  2020              MOVS     r0,#0x20              ;2338
00005c  f884003e          STRB     r0,[r4,#0x3e]         ;2338
000060  2000              MOVS     r0,#0                 ;2339
000062  6420              STR      r0,[r4,#0x40]         ;2339
000064  6265              STR      r5,[r4,#0x24]         ;2342
000066  8566              STRH     r6,[r4,#0x2a]         ;2343
000068  8d60              LDRH     r0,[r4,#0x2a]         ;2344
00006a  8520              STRH     r0,[r4,#0x28]         ;2344
00006c  4824              LDR      r0,|L41.256|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2345
000070  4824              LDR      r0,|L41.260|
000072  6ba1              LDR      r1,[r4,#0x38]         ;2348
000074  63c8              STR      r0,[r1,#0x3c]         ;2348
000076  4824              LDR      r0,|L41.264|
000078  6ba1              LDR      r1,[r4,#0x38]         ;2351
00007a  64c8              STR      r0,[r1,#0x4c]         ;2351
00007c  2000              MOVS     r0,#0                 ;2354
00007e  6ba1              LDR      r1,[r4,#0x38]         ;2354
000080  6408              STR      r0,[r1,#0x40]         ;2354
000082  6ba1              LDR      r1,[r4,#0x38]         ;2355
000084  6448              STR      r0,[r1,#0x44]         ;2355
000086  6ba1              LDR      r1,[r4,#0x38]         ;2356
000088  6488              STR      r0,[r1,#0x48]         ;2356
00008a  6ba1              LDR      r1,[r4,#0x38]         ;2357
00008c  6508              STR      r0,[r1,#0x50]         ;2357
00008e  8d23              LDRH     r3,[r4,#0x28]         ;2360
000090  f8d4c000          LDR      r12,[r4,#0]           ;2360
000094  f10c0110          ADD      r1,r12,#0x10          ;2360
000098  6a62              LDR      r2,[r4,#0x24]         ;2360
00009a  6ba0              LDR      r0,[r4,#0x38]         ;2360
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  4607              MOV      r7,r0                 ;2360
0000a2  b9c7              CBNZ     r7,|L41.214|
0000a4  6820              LDR      r0,[r4,#0]            ;2365
0000a6  6800              LDR      r0,[r0,#0]            ;2365
0000a8  f4406080          ORR      r0,r0,#0x400          ;2365
0000ac  6821              LDR      r1,[r4,#0]            ;2365
0000ae  6008              STR      r0,[r1,#0]            ;2365
0000b0  bf00              NOP                            ;2368
0000b2  2000              MOVS     r0,#0                 ;2368
0000b4  f884003c          STRB     r0,[r4,#0x3c]         ;2368
0000b8  bf00              NOP                            ;2368
0000ba  6820              LDR      r0,[r4,#0]            ;2374
0000bc  6840              LDR      r0,[r0,#4]            ;2374
0000be  f4407040          ORR      r0,r0,#0x300          ;2374
0000c2  6821              LDR      r1,[r4,#0]            ;2374
0000c4  6048              STR      r0,[r1,#4]            ;2374
0000c6  6820              LDR      r0,[r4,#0]            ;2377
0000c8  6840              LDR      r0,[r0,#4]            ;2377
0000ca  f4406000          ORR      r0,r0,#0x800          ;2377
0000ce  6821              LDR      r1,[r4,#0]            ;2377
0000d0  6048              STR      r0,[r1,#4]            ;2377
0000d2  2000              MOVS     r0,#0                 ;2379
0000d4  e7a0              B        |L41.24|
                  |L41.214|
0000d6  2020              MOVS     r0,#0x20              ;2384
0000d8  f884003d          STRB     r0,[r4,#0x3d]         ;2384
0000dc  2000              MOVS     r0,#0                 ;2385
0000de  f884003e          STRB     r0,[r4,#0x3e]         ;2385
0000e2  6c20              LDR      r0,[r4,#0x40]         ;2388
0000e4  f0400010          ORR      r0,r0,#0x10           ;2388
0000e8  6420              STR      r0,[r4,#0x40]         ;2388
0000ea  bf00              NOP                            ;2391
0000ec  2000              MOVS     r0,#0                 ;2391
0000ee  f884003c          STRB     r0,[r4,#0x3c]         ;2391
0000f2  bf00              NOP                            ;2391
0000f4  2001              MOVS     r0,#1                 ;2393
0000f6  e78f              B        |L41.24|
0000f8  e7ff              B        |L41.250|
                  |L41.250|
0000fa  2002              MOVS     r0,#2                 ;2398
0000fc  e78c              B        |L41.24|
;;;2401   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L41.256|
                          DCD      0xffff0000
                  |L41.260|
                          DCD      I2C_DMAXferCplt
                  |L41.264|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_IT PROC
;;;1871     */
;;;1872   HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1873   {
000002  4603              MOV      r3,r0
;;;1874   
;;;1875     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d140              BNE      |L42.142|
;;;1876     {
;;;1877       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L42.16|
00000e  b90a              CBNZ     r2,|L42.20|
                  |L42.16|
;;;1878       {
;;;1879         return  HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L42.18|
;;;1880       }
;;;1881   
;;;1882       /* Process Locked */
;;;1883       __HAL_LOCK(hi2c);
;;;1884   
;;;1885       /* Check if the I2C is already enabled */
;;;1886       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1887       {
;;;1888         /* Enable I2C peripheral */
;;;1889         __HAL_I2C_ENABLE(hi2c);
;;;1890       }
;;;1891   
;;;1892       /* Disable Pos */
;;;1893       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1894   
;;;1895       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1896       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1897       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1898   
;;;1899       /* Prepare transfer parameters */
;;;1900       hi2c->pBuffPtr    = pData;
;;;1901       hi2c->XferCount   = Size;
;;;1902       hi2c->XferSize    = hi2c->XferCount;
;;;1903       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1904   
;;;1905       /* Enable Address Acknowledge */
;;;1906       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1907   
;;;1908       /* Process Unlocked */
;;;1909       __HAL_UNLOCK(hi2c);
;;;1910   
;;;1911       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1912                 to avoid the risk of I2C interrupt handle execution before current
;;;1913                 process unlock */
;;;1914   
;;;1915       /* Enable EVT, BUF and ERR interrupt */
;;;1916       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1917   
;;;1918       return HAL_OK;
;;;1919     }
;;;1920     else
;;;1921     {
;;;1922       return HAL_BUSY;
;;;1923     }
;;;1924   }
000012  bd10              POP      {r4,pc}
                  |L42.20|
000014  bf00              NOP                            ;1883
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1883
00001a  2801              CMP      r0,#1                 ;1883
00001c  d101              BNE      |L42.34|
00001e  2002              MOVS     r0,#2                 ;1883
000020  e7f7              B        |L42.18|
                  |L42.34|
000022  2001              MOVS     r0,#1                 ;1883
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1883
000028  bf00              NOP                            ;1883
00002a  6818              LDR      r0,[r3,#0]            ;1886
00002c  6800              LDR      r0,[r0,#0]            ;1886
00002e  f0000001          AND      r0,r0,#1              ;1886
000032  b928              CBNZ     r0,|L42.64|
000034  6818              LDR      r0,[r3,#0]            ;1889
000036  6800              LDR      r0,[r0,#0]            ;1889
000038  f0400001          ORR      r0,r0,#1              ;1889
00003c  681c              LDR      r4,[r3,#0]            ;1889
00003e  6020              STR      r0,[r4,#0]            ;1889
                  |L42.64|
000040  6818              LDR      r0,[r3,#0]            ;1893
000042  6800              LDR      r0,[r0,#0]            ;1893
000044  f4206000          BIC      r0,r0,#0x800          ;1893
000048  681c              LDR      r4,[r3,#0]            ;1893
00004a  6020              STR      r0,[r4,#0]            ;1893
00004c  2022              MOVS     r0,#0x22              ;1895
00004e  f883003d          STRB     r0,[r3,#0x3d]         ;1895
000052  2020              MOVS     r0,#0x20              ;1896
000054  f883003e          STRB     r0,[r3,#0x3e]         ;1896
000058  2000              MOVS     r0,#0                 ;1897
00005a  6418              STR      r0,[r3,#0x40]         ;1897
00005c  6259              STR      r1,[r3,#0x24]         ;1900
00005e  855a              STRH     r2,[r3,#0x2a]         ;1901
000060  8d58              LDRH     r0,[r3,#0x2a]         ;1902
000062  8518              STRH     r0,[r3,#0x28]         ;1902
000064  480b              LDR      r0,|L42.148|
000066  62d8              STR      r0,[r3,#0x2c]         ;1903
000068  6818              LDR      r0,[r3,#0]            ;1906
00006a  6800              LDR      r0,[r0,#0]            ;1906
00006c  f4406080          ORR      r0,r0,#0x400          ;1906
000070  681c              LDR      r4,[r3,#0]            ;1906
000072  6020              STR      r0,[r4,#0]            ;1906
000074  bf00              NOP                            ;1909
000076  2000              MOVS     r0,#0                 ;1909
000078  f883003c          STRB     r0,[r3,#0x3c]         ;1909
00007c  bf00              NOP                            ;1909
00007e  6818              LDR      r0,[r3,#0]            ;1916
000080  6840              LDR      r0,[r0,#4]            ;1916
000082  f44060e0          ORR      r0,r0,#0x700          ;1916
000086  681c              LDR      r4,[r3,#0]            ;1916
000088  6060              STR      r0,[r4,#4]            ;1916
00008a  2000              MOVS     r0,#0                 ;1918
00008c  e7c1              B        |L42.18|
                  |L42.142|
00008e  2002              MOVS     r0,#2                 ;1922
000090  e7bf              B        |L42.18|
;;;1925   
                          ENDP

000092  0000              DCW      0x0000
                  |L42.148|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Receive_DMA PROC
;;;4330     */
;;;4331   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4332   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;4333     HAL_StatusTypeDef dmaxferstatus;
;;;4334   
;;;4335     /* Check the parameters */
;;;4336     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4337   
;;;4338     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  f0000028          AND      r0,r0,#0x28
000014  2828              CMP      r0,#0x28
000016  d17c              BNE      |L43.274|
;;;4339     {
;;;4340       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L43.28|
00001a  b916              CBNZ     r6,|L43.34|
                  |L43.28|
;;;4341       {
;;;4342         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L43.30|
;;;4343       }
;;;4344   
;;;4345       /* Process Locked */
;;;4346       __HAL_LOCK(hi2c);
;;;4347   
;;;4348       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;4349       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4350   
;;;4351       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;4352       /* and then toggle the HAL slave RX state to TX state */
;;;4353       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;4354       {
;;;4355         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4356         {
;;;4357           /* Abort DMA Xfer if any */
;;;4358           if (hi2c->hdmarx != NULL)
;;;4359           {
;;;4360             CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4361   
;;;4362             /* Set the I2C DMA Abort callback :
;;;4363              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4364             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;4365   
;;;4366             /* Abort DMA RX */
;;;4367             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;4368             {
;;;4369               /* Call Directly XferAbortCallback function in case of error */
;;;4370               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;4371             }
;;;4372           }
;;;4373         }
;;;4374       }
;;;4375       else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;4376       {
;;;4377         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4378         {
;;;4379           CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4380   
;;;4381           /* Abort DMA Xfer if any */
;;;4382           if (hi2c->hdmatx != NULL)
;;;4383           {
;;;4384             /* Set the I2C DMA Abort callback :
;;;4385              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4386             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;4387   
;;;4388             /* Abort DMA TX */
;;;4389             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;4390             {
;;;4391               /* Call Directly XferAbortCallback function in case of error */
;;;4392               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;4393             }
;;;4394           }
;;;4395         }
;;;4396       }
;;;4397       else
;;;4398       {
;;;4399         /* Nothing to do */
;;;4400       }
;;;4401   
;;;4402       /* Check if the I2C is already enabled */
;;;4403       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4404       {
;;;4405         /* Enable I2C peripheral */
;;;4406         __HAL_I2C_ENABLE(hi2c);
;;;4407       }
;;;4408   
;;;4409       /* Disable Pos */
;;;4410       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4411   
;;;4412       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;4413       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4414       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4415   
;;;4416       /* Prepare transfer parameters */
;;;4417       hi2c->pBuffPtr    = pData;
;;;4418       hi2c->XferCount   = Size;
;;;4419       hi2c->XferSize    = hi2c->XferCount;
;;;4420       hi2c->XferOptions = XferOptions;
;;;4421   
;;;4422       /* Set the I2C DMA transfer complete callback */
;;;4423       hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;4424   
;;;4425       /* Set the DMA error callback */
;;;4426       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;4427   
;;;4428       /* Set the unused DMA callbacks to NULL */
;;;4429       hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;4430       hi2c->hdmarx->XferAbortCallback = NULL;
;;;4431   
;;;4432       /* Enable the DMA stream */
;;;4433       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;4434   
;;;4435       if (dmaxferstatus == HAL_OK)
;;;4436       {
;;;4437         /* Enable Address Acknowledge */
;;;4438         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4439   
;;;4440         /* Clear ADDR flag */
;;;4441         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4442   
;;;4443         /* Process Unlocked */
;;;4444         __HAL_UNLOCK(hi2c);
;;;4445   
;;;4446         /* Enable DMA Request */
;;;4447         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4448   
;;;4449         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4450         to avoid the risk of I2C interrupt handle execution before current
;;;4451         process unlock */
;;;4452         /* Enable EVT and ERR interrupt */
;;;4453         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4454   
;;;4455         return HAL_OK;
;;;4456       }
;;;4457       else
;;;4458       {
;;;4459         /* Update I2C state */
;;;4460         hi2c->State     = HAL_I2C_STATE_READY;
;;;4461         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4462   
;;;4463         /* Update I2C error code */
;;;4464         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4465   
;;;4466         /* Process Unlocked */
;;;4467         __HAL_UNLOCK(hi2c);
;;;4468   
;;;4469         return HAL_ERROR;
;;;4470       }
;;;4471     }
;;;4472     else
;;;4473     {
;;;4474       return HAL_BUSY;
;;;4475     }
;;;4476   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L43.34|
000022  bf00              NOP                            ;4346
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;4346
000028  2801              CMP      r0,#1                 ;4346
00002a  d101              BNE      |L43.48|
00002c  2002              MOVS     r0,#2                 ;4346
00002e  e7f6              B        |L43.30|
                  |L43.48|
000030  2001              MOVS     r0,#1                 ;4346
000032  f884003c          STRB     r0,[r4,#0x3c]         ;4346
000036  bf00              NOP                            ;4346
000038  6820              LDR      r0,[r4,#0]            ;4349
00003a  6840              LDR      r0,[r0,#4]            ;4349
00003c  f4207040          BIC      r0,r0,#0x300          ;4349
000040  6821              LDR      r1,[r4,#0]            ;4349
000042  6048              STR      r0,[r1,#4]            ;4349
000044  f894003d          LDRB     r0,[r4,#0x3d]         ;4353
000048  282a              CMP      r0,#0x2a              ;4353
00004a  d119              BNE      |L43.128|
00004c  6820              LDR      r0,[r4,#0]            ;4355
00004e  6840              LDR      r0,[r0,#4]            ;4355
000050  f4006000          AND      r0,r0,#0x800          ;4355
000054  f5b06f00          CMP      r0,#0x800             ;4355
000058  d12f              BNE      |L43.186|
00005a  6ba0              LDR      r0,[r4,#0x38]         ;4358
00005c  b368              CBZ      r0,|L43.186|
00005e  6820              LDR      r0,[r4,#0]            ;4360
000060  6840              LDR      r0,[r0,#4]            ;4360
000062  f4206000          BIC      r0,r0,#0x800          ;4360
000066  6821              LDR      r1,[r4,#0]            ;4360
000068  6048              STR      r0,[r1,#4]            ;4360
00006a  484b              LDR      r0,|L43.408|
00006c  6ba1              LDR      r1,[r4,#0x38]         ;4364
00006e  6508              STR      r0,[r1,#0x50]         ;4364
000070  6ba0              LDR      r0,[r4,#0x38]         ;4367
000072  f7fffffe          BL       HAL_DMA_Abort_IT
000076  b300              CBZ      r0,|L43.186|
000078  6ba0              LDR      r0,[r4,#0x38]         ;4370
00007a  6d01              LDR      r1,[r0,#0x50]         ;4370
00007c  4788              BLX      r1                    ;4370
00007e  e01c              B        |L43.186|
                  |L43.128|
000080  f894003d          LDRB     r0,[r4,#0x3d]         ;4375
000084  2829              CMP      r0,#0x29              ;4375
000086  d118              BNE      |L43.186|
000088  6820              LDR      r0,[r4,#0]            ;4377
00008a  6840              LDR      r0,[r0,#4]            ;4377
00008c  f4006000          AND      r0,r0,#0x800          ;4377
000090  f5b06f00          CMP      r0,#0x800             ;4377
000094  d111              BNE      |L43.186|
000096  6820              LDR      r0,[r4,#0]            ;4379
000098  6840              LDR      r0,[r0,#4]            ;4379
00009a  f4206000          BIC      r0,r0,#0x800          ;4379
00009e  6821              LDR      r1,[r4,#0]            ;4379
0000a0  6048              STR      r0,[r1,#4]            ;4379
0000a2  6b60              LDR      r0,[r4,#0x34]         ;4382
0000a4  b148              CBZ      r0,|L43.186|
0000a6  483c              LDR      r0,|L43.408|
0000a8  6b61              LDR      r1,[r4,#0x34]         ;4386
0000aa  6508              STR      r0,[r1,#0x50]         ;4386
0000ac  6b60              LDR      r0,[r4,#0x34]         ;4389
0000ae  f7fffffe          BL       HAL_DMA_Abort_IT
0000b2  b110              CBZ      r0,|L43.186|
0000b4  6b60              LDR      r0,[r4,#0x34]         ;4392
0000b6  6d01              LDR      r1,[r0,#0x50]         ;4392
0000b8  4788              BLX      r1                    ;4392
                  |L43.186|
0000ba  6820              LDR      r0,[r4,#0]            ;4403
0000bc  6800              LDR      r0,[r0,#0]            ;4403
0000be  f0000001          AND      r0,r0,#1              ;4403
0000c2  b928              CBNZ     r0,|L43.208|
0000c4  6820              LDR      r0,[r4,#0]            ;4406
0000c6  6800              LDR      r0,[r0,#0]            ;4406
0000c8  f0400001          ORR      r0,r0,#1              ;4406
0000cc  6821              LDR      r1,[r4,#0]            ;4406
0000ce  6008              STR      r0,[r1,#0]            ;4406
                  |L43.208|
0000d0  6820              LDR      r0,[r4,#0]            ;4410
0000d2  6800              LDR      r0,[r0,#0]            ;4410
0000d4  f4206000          BIC      r0,r0,#0x800          ;4410
0000d8  6821              LDR      r1,[r4,#0]            ;4410
0000da  6008              STR      r0,[r1,#0]            ;4410
0000dc  202a              MOVS     r0,#0x2a              ;4412
0000de  f884003d          STRB     r0,[r4,#0x3d]         ;4412
0000e2  2020              MOVS     r0,#0x20              ;4413
0000e4  f884003e          STRB     r0,[r4,#0x3e]         ;4413
0000e8  2000              MOVS     r0,#0                 ;4414
0000ea  6420              STR      r0,[r4,#0x40]         ;4414
0000ec  6265              STR      r5,[r4,#0x24]         ;4417
0000ee  8566              STRH     r6,[r4,#0x2a]         ;4418
0000f0  8d60              LDRH     r0,[r4,#0x2a]         ;4419
0000f2  8520              STRH     r0,[r4,#0x28]         ;4419
0000f4  f8c4802c          STR      r8,[r4,#0x2c]         ;4420
0000f8  4828              LDR      r0,|L43.412|
0000fa  6ba1              LDR      r1,[r4,#0x38]         ;4423
0000fc  63c8              STR      r0,[r1,#0x3c]         ;4423
0000fe  4828              LDR      r0,|L43.416|
000100  6ba1              LDR      r1,[r4,#0x38]         ;4426
000102  64c8              STR      r0,[r1,#0x4c]         ;4426
000104  2000              MOVS     r0,#0                 ;4429
000106  6ba1              LDR      r1,[r4,#0x38]         ;4429
000108  6408              STR      r0,[r1,#0x40]         ;4429
00010a  6ba1              LDR      r1,[r4,#0x38]         ;4430
00010c  6508              STR      r0,[r1,#0x50]         ;4430
00010e  8d23              LDRH     r3,[r4,#0x28]         ;4433
000110  e000              B        |L43.276|
                  |L43.274|
000112  e03e              B        |L43.402|
                  |L43.276|
000114  f8d4c000          LDR      r12,[r4,#0]           ;4433
000118  f10c0110          ADD      r1,r12,#0x10          ;4433
00011c  6a62              LDR      r2,[r4,#0x24]         ;4433
00011e  6ba0              LDR      r0,[r4,#0x38]         ;4433
000120  f7fffffe          BL       HAL_DMA_Start_IT
000124  4607              MOV      r7,r0                 ;4433
000126  bb1f              CBNZ     r7,|L43.368|
000128  6820              LDR      r0,[r4,#0]            ;4438
00012a  6800              LDR      r0,[r0,#0]            ;4438
00012c  f4406080          ORR      r0,r0,#0x400          ;4438
000130  6821              LDR      r1,[r4,#0]            ;4438
000132  6008              STR      r0,[r1,#0]            ;4438
000134  bf00              NOP                            ;4441
000136  2000              MOVS     r0,#0                 ;4441
000138  9000              STR      r0,[sp,#0]            ;4441
00013a  6820              LDR      r0,[r4,#0]            ;4441
00013c  6940              LDR      r0,[r0,#0x14]         ;4441
00013e  9000              STR      r0,[sp,#0]            ;4441
000140  6820              LDR      r0,[r4,#0]            ;4441
000142  6980              LDR      r0,[r0,#0x18]         ;4441
000144  9000              STR      r0,[sp,#0]            ;4441
000146  bf00              NOP                            ;4441
000148  bf00              NOP                            ;4441
00014a  bf00              NOP                            ;4444
00014c  2000              MOVS     r0,#0                 ;4444
00014e  f884003c          STRB     r0,[r4,#0x3c]         ;4444
000152  bf00              NOP                            ;4444
000154  6820              LDR      r0,[r4,#0]            ;4447
000156  6840              LDR      r0,[r0,#4]            ;4447
000158  f4406000          ORR      r0,r0,#0x800          ;4447
00015c  6821              LDR      r1,[r4,#0]            ;4447
00015e  6048              STR      r0,[r1,#4]            ;4447
000160  6820              LDR      r0,[r4,#0]            ;4453
000162  6840              LDR      r0,[r0,#4]            ;4453
000164  f4407040          ORR      r0,r0,#0x300          ;4453
000168  6821              LDR      r1,[r4,#0]            ;4453
00016a  6048              STR      r0,[r1,#4]            ;4453
00016c  2000              MOVS     r0,#0                 ;4455
00016e  e756              B        |L43.30|
                  |L43.368|
000170  2020              MOVS     r0,#0x20              ;4460
000172  f884003d          STRB     r0,[r4,#0x3d]         ;4460
000176  2000              MOVS     r0,#0                 ;4461
000178  f884003e          STRB     r0,[r4,#0x3e]         ;4461
00017c  6c20              LDR      r0,[r4,#0x40]         ;4464
00017e  f0400010          ORR      r0,r0,#0x10           ;4464
000182  6420              STR      r0,[r4,#0x40]         ;4464
000184  bf00              NOP                            ;4467
000186  2000              MOVS     r0,#0                 ;4467
000188  f884003c          STRB     r0,[r4,#0x3c]         ;4467
00018c  bf00              NOP                            ;4467
00018e  2001              MOVS     r0,#1                 ;4469
000190  e745              B        |L43.30|
                  |L43.402|
000192  2002              MOVS     r0,#2                 ;4474
000194  e743              B        |L43.30|
;;;4477   
                          ENDP

000196  0000              DCW      0x0000
                  |L43.408|
                          DCD      I2C_DMAAbort
                  |L43.412|
                          DCD      I2C_DMAXferCplt
                  |L43.416|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Seq_Receive_IT PROC
;;;4264     */
;;;4265   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;4266   {
000002  4604              MOV      r4,r0
;;;4267     /* Check the parameters */
;;;4268     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4269   
;;;4270     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  f0000028          AND      r0,r0,#0x28
00000c  2828              CMP      r0,#0x28
00000e  d144              BNE      |L44.154|
;;;4271     {
;;;4272       if ((pData == NULL) || (Size == 0U))
000010  b101              CBZ      r1,|L44.20|
000012  b90a              CBNZ     r2,|L44.24|
                  |L44.20|
;;;4273       {
;;;4274         return  HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L44.22|
;;;4275       }
;;;4276   
;;;4277       /* Process Locked */
;;;4278       __HAL_LOCK(hi2c);
;;;4279   
;;;4280       /* Check if the I2C is already enabled */
;;;4281       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4282       {
;;;4283         /* Enable I2C peripheral */
;;;4284         __HAL_I2C_ENABLE(hi2c);
;;;4285       }
;;;4286   
;;;4287       /* Disable Pos */
;;;4288       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4289   
;;;4290       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;4291       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4292       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4293   
;;;4294       /* Prepare transfer parameters */
;;;4295       hi2c->pBuffPtr    = pData;
;;;4296       hi2c->XferCount   = Size;
;;;4297       hi2c->XferSize    = hi2c->XferCount;
;;;4298       hi2c->XferOptions = XferOptions;
;;;4299   
;;;4300       /* Clear ADDR flag */
;;;4301       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4302   
;;;4303       /* Process Unlocked */
;;;4304       __HAL_UNLOCK(hi2c);
;;;4305   
;;;4306       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4307                 to avoid the risk of I2C interrupt handle execution before current
;;;4308                 process unlock */
;;;4309   
;;;4310       /* Enable EVT, BUF and ERR interrupt */
;;;4311       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4312   
;;;4313       return HAL_OK;
;;;4314     }
;;;4315     else
;;;4316     {
;;;4317       return HAL_BUSY;
;;;4318     }
;;;4319   }
000016  bd38              POP      {r3-r5,pc}
                  |L44.24|
000018  bf00              NOP                            ;4278
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;4278
00001e  2801              CMP      r0,#1                 ;4278
000020  d101              BNE      |L44.38|
000022  2002              MOVS     r0,#2                 ;4278
000024  e7f7              B        |L44.22|
                  |L44.38|
000026  2001              MOVS     r0,#1                 ;4278
000028  f884003c          STRB     r0,[r4,#0x3c]         ;4278
00002c  bf00              NOP                            ;4278
00002e  6820              LDR      r0,[r4,#0]            ;4281
000030  6800              LDR      r0,[r0,#0]            ;4281
000032  f0000001          AND      r0,r0,#1              ;4281
000036  b928              CBNZ     r0,|L44.68|
000038  6820              LDR      r0,[r4,#0]            ;4284
00003a  6800              LDR      r0,[r0,#0]            ;4284
00003c  f0400001          ORR      r0,r0,#1              ;4284
000040  6825              LDR      r5,[r4,#0]            ;4284
000042  6028              STR      r0,[r5,#0]            ;4284
                  |L44.68|
000044  6820              LDR      r0,[r4,#0]            ;4288
000046  6800              LDR      r0,[r0,#0]            ;4288
000048  f4206000          BIC      r0,r0,#0x800          ;4288
00004c  6825              LDR      r5,[r4,#0]            ;4288
00004e  6028              STR      r0,[r5,#0]            ;4288
000050  202a              MOVS     r0,#0x2a              ;4290
000052  f884003d          STRB     r0,[r4,#0x3d]         ;4290
000056  2020              MOVS     r0,#0x20              ;4291
000058  f884003e          STRB     r0,[r4,#0x3e]         ;4291
00005c  2000              MOVS     r0,#0                 ;4292
00005e  6420              STR      r0,[r4,#0x40]         ;4292
000060  6261              STR      r1,[r4,#0x24]         ;4295
000062  8562              STRH     r2,[r4,#0x2a]         ;4296
000064  8d60              LDRH     r0,[r4,#0x2a]         ;4297
000066  8520              STRH     r0,[r4,#0x28]         ;4297
000068  62e3              STR      r3,[r4,#0x2c]         ;4298
00006a  bf00              NOP                            ;4301
00006c  2000              MOVS     r0,#0                 ;4301
00006e  9000              STR      r0,[sp,#0]            ;4301
000070  6820              LDR      r0,[r4,#0]            ;4301
000072  6940              LDR      r0,[r0,#0x14]         ;4301
000074  9000              STR      r0,[sp,#0]            ;4301
000076  6820              LDR      r0,[r4,#0]            ;4301
000078  6980              LDR      r0,[r0,#0x18]         ;4301
00007a  9000              STR      r0,[sp,#0]            ;4301
00007c  bf00              NOP                            ;4301
00007e  bf00              NOP                            ;4301
000080  bf00              NOP                            ;4304
000082  2000              MOVS     r0,#0                 ;4304
000084  f884003c          STRB     r0,[r4,#0x3c]         ;4304
000088  bf00              NOP                            ;4304
00008a  6820              LDR      r0,[r4,#0]            ;4311
00008c  6840              LDR      r0,[r0,#4]            ;4311
00008e  f44060e0          ORR      r0,r0,#0x700          ;4311
000092  6825              LDR      r5,[r4,#0]            ;4311
000094  6068              STR      r0,[r5,#4]            ;4311
000096  2000              MOVS     r0,#0                 ;4313
000098  e7bd              B        |L44.22|
                  |L44.154|
00009a  2002              MOVS     r0,#2                 ;4317
00009c  e7bb              B        |L44.22|
;;;4320   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Transmit_DMA PROC
;;;4107     */
;;;4108   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4109   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;4110     HAL_StatusTypeDef dmaxferstatus;
;;;4111   
;;;4112     /* Check the parameters */
;;;4113     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4114   
;;;4115     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  f0000028          AND      r0,r0,#0x28
000014  2828              CMP      r0,#0x28
000016  d17c              BNE      |L45.274|
;;;4116     {
;;;4117       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L45.28|
00001a  b916              CBNZ     r6,|L45.34|
                  |L45.28|
;;;4118       {
;;;4119         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L45.30|
;;;4120       }
;;;4121   
;;;4122       /* Process Locked */
;;;4123       __HAL_LOCK(hi2c);
;;;4124   
;;;4125       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;4126       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4127   
;;;4128       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;4129       /* and then toggle the HAL slave RX state to TX state */
;;;4130       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;4131       {
;;;4132         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4133         {
;;;4134           /* Abort DMA Xfer if any */
;;;4135           if (hi2c->hdmarx != NULL)
;;;4136           {
;;;4137             CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4138   
;;;4139             /* Set the I2C DMA Abort callback :
;;;4140              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4141             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;4142   
;;;4143             /* Abort DMA RX */
;;;4144             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;4145             {
;;;4146               /* Call Directly XferAbortCallback function in case of error */
;;;4147               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;4148             }
;;;4149           }
;;;4150         }
;;;4151       }
;;;4152       else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;4153       {
;;;4154         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4155         {
;;;4156           CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4157   
;;;4158           /* Abort DMA Xfer if any */
;;;4159           if (hi2c->hdmatx != NULL)
;;;4160           {
;;;4161             /* Set the I2C DMA Abort callback :
;;;4162              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4163             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;4164   
;;;4165             /* Abort DMA TX */
;;;4166             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;4167             {
;;;4168               /* Call Directly XferAbortCallback function in case of error */
;;;4169               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;4170             }
;;;4171           }
;;;4172         }
;;;4173       }
;;;4174       else
;;;4175       {
;;;4176         /* Nothing to do */
;;;4177       }
;;;4178   
;;;4179       /* Check if the I2C is already enabled */
;;;4180       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4181       {
;;;4182         /* Enable I2C peripheral */
;;;4183         __HAL_I2C_ENABLE(hi2c);
;;;4184       }
;;;4185   
;;;4186       /* Disable Pos */
;;;4187       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4188   
;;;4189       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;4190       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4191       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4192   
;;;4193       /* Prepare transfer parameters */
;;;4194       hi2c->pBuffPtr    = pData;
;;;4195       hi2c->XferCount   = Size;
;;;4196       hi2c->XferSize    = hi2c->XferCount;
;;;4197       hi2c->XferOptions = XferOptions;
;;;4198   
;;;4199       /* Set the I2C DMA transfer complete callback */
;;;4200       hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;4201   
;;;4202       /* Set the DMA error callback */
;;;4203       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;4204   
;;;4205       /* Set the unused DMA callbacks to NULL */
;;;4206       hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;4207       hi2c->hdmatx->XferAbortCallback = NULL;
;;;4208   
;;;4209       /* Enable the DMA stream */
;;;4210       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;4211   
;;;4212       if (dmaxferstatus == HAL_OK)
;;;4213       {
;;;4214         /* Enable Address Acknowledge */
;;;4215         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4216   
;;;4217         /* Clear ADDR flag */
;;;4218         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4219   
;;;4220         /* Process Unlocked */
;;;4221         __HAL_UNLOCK(hi2c);
;;;4222   
;;;4223         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4224         to avoid the risk of I2C interrupt handle execution before current
;;;4225         process unlock */
;;;4226         /* Enable EVT and ERR interrupt */
;;;4227         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4228   
;;;4229         /* Enable DMA Request */
;;;4230         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;4231   
;;;4232         return HAL_OK;
;;;4233       }
;;;4234       else
;;;4235       {
;;;4236         /* Update I2C state */
;;;4237         hi2c->State     = HAL_I2C_STATE_READY;
;;;4238         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4239   
;;;4240         /* Update I2C error code */
;;;4241         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4242   
;;;4243         /* Process Unlocked */
;;;4244         __HAL_UNLOCK(hi2c);
;;;4245   
;;;4246         return HAL_ERROR;
;;;4247       }
;;;4248     }
;;;4249     else
;;;4250     {
;;;4251       return HAL_BUSY;
;;;4252     }
;;;4253   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L45.34|
000022  bf00              NOP                            ;4123
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;4123
000028  2801              CMP      r0,#1                 ;4123
00002a  d101              BNE      |L45.48|
00002c  2002              MOVS     r0,#2                 ;4123
00002e  e7f6              B        |L45.30|
                  |L45.48|
000030  2001              MOVS     r0,#1                 ;4123
000032  f884003c          STRB     r0,[r4,#0x3c]         ;4123
000036  bf00              NOP                            ;4123
000038  6820              LDR      r0,[r4,#0]            ;4126
00003a  6840              LDR      r0,[r0,#4]            ;4126
00003c  f4207040          BIC      r0,r0,#0x300          ;4126
000040  6821              LDR      r1,[r4,#0]            ;4126
000042  6048              STR      r0,[r1,#4]            ;4126
000044  f894003d          LDRB     r0,[r4,#0x3d]         ;4130
000048  282a              CMP      r0,#0x2a              ;4130
00004a  d119              BNE      |L45.128|
00004c  6820              LDR      r0,[r4,#0]            ;4132
00004e  6840              LDR      r0,[r0,#4]            ;4132
000050  f4006000          AND      r0,r0,#0x800          ;4132
000054  f5b06f00          CMP      r0,#0x800             ;4132
000058  d12f              BNE      |L45.186|
00005a  6ba0              LDR      r0,[r4,#0x38]         ;4135
00005c  b368              CBZ      r0,|L45.186|
00005e  6820              LDR      r0,[r4,#0]            ;4137
000060  6840              LDR      r0,[r0,#4]            ;4137
000062  f4206000          BIC      r0,r0,#0x800          ;4137
000066  6821              LDR      r1,[r4,#0]            ;4137
000068  6048              STR      r0,[r1,#4]            ;4137
00006a  484b              LDR      r0,|L45.408|
00006c  6ba1              LDR      r1,[r4,#0x38]         ;4141
00006e  6508              STR      r0,[r1,#0x50]         ;4141
000070  6ba0              LDR      r0,[r4,#0x38]         ;4144
000072  f7fffffe          BL       HAL_DMA_Abort_IT
000076  b300              CBZ      r0,|L45.186|
000078  6ba0              LDR      r0,[r4,#0x38]         ;4147
00007a  6d01              LDR      r1,[r0,#0x50]         ;4147
00007c  4788              BLX      r1                    ;4147
00007e  e01c              B        |L45.186|
                  |L45.128|
000080  f894003d          LDRB     r0,[r4,#0x3d]         ;4152
000084  2829              CMP      r0,#0x29              ;4152
000086  d118              BNE      |L45.186|
000088  6820              LDR      r0,[r4,#0]            ;4154
00008a  6840              LDR      r0,[r0,#4]            ;4154
00008c  f4006000          AND      r0,r0,#0x800          ;4154
000090  f5b06f00          CMP      r0,#0x800             ;4154
000094  d111              BNE      |L45.186|
000096  6820              LDR      r0,[r4,#0]            ;4156
000098  6840              LDR      r0,[r0,#4]            ;4156
00009a  f4206000          BIC      r0,r0,#0x800          ;4156
00009e  6821              LDR      r1,[r4,#0]            ;4156
0000a0  6048              STR      r0,[r1,#4]            ;4156
0000a2  6b60              LDR      r0,[r4,#0x34]         ;4159
0000a4  b148              CBZ      r0,|L45.186|
0000a6  483c              LDR      r0,|L45.408|
0000a8  6b61              LDR      r1,[r4,#0x34]         ;4163
0000aa  6508              STR      r0,[r1,#0x50]         ;4163
0000ac  6b60              LDR      r0,[r4,#0x34]         ;4166
0000ae  f7fffffe          BL       HAL_DMA_Abort_IT
0000b2  b110              CBZ      r0,|L45.186|
0000b4  6b60              LDR      r0,[r4,#0x34]         ;4169
0000b6  6d01              LDR      r1,[r0,#0x50]         ;4169
0000b8  4788              BLX      r1                    ;4169
                  |L45.186|
0000ba  6820              LDR      r0,[r4,#0]            ;4180
0000bc  6800              LDR      r0,[r0,#0]            ;4180
0000be  f0000001          AND      r0,r0,#1              ;4180
0000c2  b928              CBNZ     r0,|L45.208|
0000c4  6820              LDR      r0,[r4,#0]            ;4183
0000c6  6800              LDR      r0,[r0,#0]            ;4183
0000c8  f0400001          ORR      r0,r0,#1              ;4183
0000cc  6821              LDR      r1,[r4,#0]            ;4183
0000ce  6008              STR      r0,[r1,#0]            ;4183
                  |L45.208|
0000d0  6820              LDR      r0,[r4,#0]            ;4187
0000d2  6800              LDR      r0,[r0,#0]            ;4187
0000d4  f4206000          BIC      r0,r0,#0x800          ;4187
0000d8  6821              LDR      r1,[r4,#0]            ;4187
0000da  6008              STR      r0,[r1,#0]            ;4187
0000dc  2029              MOVS     r0,#0x29              ;4189
0000de  f884003d          STRB     r0,[r4,#0x3d]         ;4189
0000e2  2020              MOVS     r0,#0x20              ;4190
0000e4  f884003e          STRB     r0,[r4,#0x3e]         ;4190
0000e8  2000              MOVS     r0,#0                 ;4191
0000ea  6420              STR      r0,[r4,#0x40]         ;4191
0000ec  6265              STR      r5,[r4,#0x24]         ;4194
0000ee  8566              STRH     r6,[r4,#0x2a]         ;4195
0000f0  8d60              LDRH     r0,[r4,#0x2a]         ;4196
0000f2  8520              STRH     r0,[r4,#0x28]         ;4196
0000f4  f8c4802c          STR      r8,[r4,#0x2c]         ;4197
0000f8  4828              LDR      r0,|L45.412|
0000fa  6b61              LDR      r1,[r4,#0x34]         ;4200
0000fc  63c8              STR      r0,[r1,#0x3c]         ;4200
0000fe  4828              LDR      r0,|L45.416|
000100  6b61              LDR      r1,[r4,#0x34]         ;4203
000102  64c8              STR      r0,[r1,#0x4c]         ;4203
000104  2000              MOVS     r0,#0                 ;4206
000106  6b61              LDR      r1,[r4,#0x34]         ;4206
000108  6408              STR      r0,[r1,#0x40]         ;4206
00010a  6b61              LDR      r1,[r4,#0x34]         ;4207
00010c  6508              STR      r0,[r1,#0x50]         ;4207
00010e  8d23              LDRH     r3,[r4,#0x28]         ;4210
000110  e000              B        |L45.276|
                  |L45.274|
000112  e03e              B        |L45.402|
                  |L45.276|
000114  f8d4c000          LDR      r12,[r4,#0]           ;4210
000118  f10c0210          ADD      r2,r12,#0x10          ;4210
00011c  6a61              LDR      r1,[r4,#0x24]         ;4210
00011e  6b60              LDR      r0,[r4,#0x34]         ;4210
000120  f7fffffe          BL       HAL_DMA_Start_IT
000124  4607              MOV      r7,r0                 ;4210
000126  bb1f              CBNZ     r7,|L45.368|
000128  6820              LDR      r0,[r4,#0]            ;4215
00012a  6800              LDR      r0,[r0,#0]            ;4215
00012c  f4406080          ORR      r0,r0,#0x400          ;4215
000130  6821              LDR      r1,[r4,#0]            ;4215
000132  6008              STR      r0,[r1,#0]            ;4215
000134  bf00              NOP                            ;4218
000136  2000              MOVS     r0,#0                 ;4218
000138  9000              STR      r0,[sp,#0]            ;4218
00013a  6820              LDR      r0,[r4,#0]            ;4218
00013c  6940              LDR      r0,[r0,#0x14]         ;4218
00013e  9000              STR      r0,[sp,#0]            ;4218
000140  6820              LDR      r0,[r4,#0]            ;4218
000142  6980              LDR      r0,[r0,#0x18]         ;4218
000144  9000              STR      r0,[sp,#0]            ;4218
000146  bf00              NOP                            ;4218
000148  bf00              NOP                            ;4218
00014a  bf00              NOP                            ;4221
00014c  2000              MOVS     r0,#0                 ;4221
00014e  f884003c          STRB     r0,[r4,#0x3c]         ;4221
000152  bf00              NOP                            ;4221
000154  6820              LDR      r0,[r4,#0]            ;4227
000156  6840              LDR      r0,[r0,#4]            ;4227
000158  f4407040          ORR      r0,r0,#0x300          ;4227
00015c  6821              LDR      r1,[r4,#0]            ;4227
00015e  6048              STR      r0,[r1,#4]            ;4227
000160  6820              LDR      r0,[r4,#0]            ;4230
000162  6840              LDR      r0,[r0,#4]            ;4230
000164  f4406000          ORR      r0,r0,#0x800          ;4230
000168  6821              LDR      r1,[r4,#0]            ;4230
00016a  6048              STR      r0,[r1,#4]            ;4230
00016c  2000              MOVS     r0,#0                 ;4232
00016e  e756              B        |L45.30|
                  |L45.368|
000170  2020              MOVS     r0,#0x20              ;4237
000172  f884003d          STRB     r0,[r4,#0x3d]         ;4237
000176  2000              MOVS     r0,#0                 ;4238
000178  f884003e          STRB     r0,[r4,#0x3e]         ;4238
00017c  6c20              LDR      r0,[r4,#0x40]         ;4241
00017e  f0400010          ORR      r0,r0,#0x10           ;4241
000182  6420              STR      r0,[r4,#0x40]         ;4241
000184  bf00              NOP                            ;4244
000186  2000              MOVS     r0,#0                 ;4244
000188  f884003c          STRB     r0,[r4,#0x3c]         ;4244
00018c  bf00              NOP                            ;4244
00018e  2001              MOVS     r0,#1                 ;4246
000190  e745              B        |L45.30|
                  |L45.402|
000192  2002              MOVS     r0,#2                 ;4251
000194  e743              B        |L45.30|
;;;4254   
                          ENDP

000196  0000              DCW      0x0000
                  |L45.408|
                          DCD      I2C_DMAAbort
                  |L45.412|
                          DCD      I2C_DMAXferCplt
                  |L45.416|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Seq_Transmit_IT PROC
;;;4041     */
;;;4042   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;4043   {
000002  4604              MOV      r4,r0
;;;4044     /* Check the parameters */
;;;4045     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4046   
;;;4047     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  f0000028          AND      r0,r0,#0x28
00000c  2828              CMP      r0,#0x28
00000e  d144              BNE      |L46.154|
;;;4048     {
;;;4049       if ((pData == NULL) || (Size == 0U))
000010  b101              CBZ      r1,|L46.20|
000012  b90a              CBNZ     r2,|L46.24|
                  |L46.20|
;;;4050       {
;;;4051         return  HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L46.22|
;;;4052       }
;;;4053   
;;;4054       /* Process Locked */
;;;4055       __HAL_LOCK(hi2c);
;;;4056   
;;;4057       /* Check if the I2C is already enabled */
;;;4058       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4059       {
;;;4060         /* Enable I2C peripheral */
;;;4061         __HAL_I2C_ENABLE(hi2c);
;;;4062       }
;;;4063   
;;;4064       /* Disable Pos */
;;;4065       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4066   
;;;4067       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;4068       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4069       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4070   
;;;4071       /* Prepare transfer parameters */
;;;4072       hi2c->pBuffPtr    = pData;
;;;4073       hi2c->XferCount   = Size;
;;;4074       hi2c->XferSize    = hi2c->XferCount;
;;;4075       hi2c->XferOptions = XferOptions;
;;;4076   
;;;4077       /* Clear ADDR flag */
;;;4078       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4079   
;;;4080       /* Process Unlocked */
;;;4081       __HAL_UNLOCK(hi2c);
;;;4082   
;;;4083       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4084                 to avoid the risk of I2C interrupt handle execution before current
;;;4085                 process unlock */
;;;4086   
;;;4087       /* Enable EVT, BUF and ERR interrupt */
;;;4088       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4089   
;;;4090       return HAL_OK;
;;;4091     }
;;;4092     else
;;;4093     {
;;;4094       return HAL_BUSY;
;;;4095     }
;;;4096   }
000016  bd38              POP      {r3-r5,pc}
                  |L46.24|
000018  bf00              NOP                            ;4055
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;4055
00001e  2801              CMP      r0,#1                 ;4055
000020  d101              BNE      |L46.38|
000022  2002              MOVS     r0,#2                 ;4055
000024  e7f7              B        |L46.22|
                  |L46.38|
000026  2001              MOVS     r0,#1                 ;4055
000028  f884003c          STRB     r0,[r4,#0x3c]         ;4055
00002c  bf00              NOP                            ;4055
00002e  6820              LDR      r0,[r4,#0]            ;4058
000030  6800              LDR      r0,[r0,#0]            ;4058
000032  f0000001          AND      r0,r0,#1              ;4058
000036  b928              CBNZ     r0,|L46.68|
000038  6820              LDR      r0,[r4,#0]            ;4061
00003a  6800              LDR      r0,[r0,#0]            ;4061
00003c  f0400001          ORR      r0,r0,#1              ;4061
000040  6825              LDR      r5,[r4,#0]            ;4061
000042  6028              STR      r0,[r5,#0]            ;4061
                  |L46.68|
000044  6820              LDR      r0,[r4,#0]            ;4065
000046  6800              LDR      r0,[r0,#0]            ;4065
000048  f4206000          BIC      r0,r0,#0x800          ;4065
00004c  6825              LDR      r5,[r4,#0]            ;4065
00004e  6028              STR      r0,[r5,#0]            ;4065
000050  2029              MOVS     r0,#0x29              ;4067
000052  f884003d          STRB     r0,[r4,#0x3d]         ;4067
000056  2020              MOVS     r0,#0x20              ;4068
000058  f884003e          STRB     r0,[r4,#0x3e]         ;4068
00005c  2000              MOVS     r0,#0                 ;4069
00005e  6420              STR      r0,[r4,#0x40]         ;4069
000060  6261              STR      r1,[r4,#0x24]         ;4072
000062  8562              STRH     r2,[r4,#0x2a]         ;4073
000064  8d60              LDRH     r0,[r4,#0x2a]         ;4074
000066  8520              STRH     r0,[r4,#0x28]         ;4074
000068  62e3              STR      r3,[r4,#0x2c]         ;4075
00006a  bf00              NOP                            ;4078
00006c  2000              MOVS     r0,#0                 ;4078
00006e  9000              STR      r0,[sp,#0]            ;4078
000070  6820              LDR      r0,[r4,#0]            ;4078
000072  6940              LDR      r0,[r0,#0x14]         ;4078
000074  9000              STR      r0,[sp,#0]            ;4078
000076  6820              LDR      r0,[r4,#0]            ;4078
000078  6980              LDR      r0,[r0,#0x18]         ;4078
00007a  9000              STR      r0,[sp,#0]            ;4078
00007c  bf00              NOP                            ;4078
00007e  bf00              NOP                            ;4078
000080  bf00              NOP                            ;4081
000082  2000              MOVS     r0,#0                 ;4081
000084  f884003c          STRB     r0,[r4,#0x3c]         ;4081
000088  bf00              NOP                            ;4081
00008a  6820              LDR      r0,[r4,#0]            ;4088
00008c  6840              LDR      r0,[r0,#4]            ;4088
00008e  f44060e0          ORR      r0,r0,#0x700          ;4088
000092  6825              LDR      r5,[r4,#0]            ;4088
000094  6068              STR      r0,[r5,#4]            ;4088
000096  2000              MOVS     r0,#0                 ;4090
000098  e7bd              B        |L46.22|
                  |L46.154|
00009a  2002              MOVS     r0,#2                 ;4094
00009c  e7bb              B        |L46.22|
;;;4097   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit PROC
;;;1396     */
;;;1397   HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1398   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1399     /* Init tickstart for timeout management*/
;;;1400     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;1401   
;;;1402     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d171              BNE      |L47.254|
;;;1403     {
;;;1404       if ((pData == NULL) || (Size == 0U))
00001a  b106              CBZ      r6,|L47.30|
00001c  b917              CBNZ     r7,|L47.36|
                  |L47.30|
;;;1405       {
;;;1406         return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L47.32|
;;;1407       }
;;;1408   
;;;1409       /* Process Locked */
;;;1410       __HAL_LOCK(hi2c);
;;;1411   
;;;1412       /* Check if the I2C is already enabled */
;;;1413       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1414       {
;;;1415         /* Enable I2C peripheral */
;;;1416         __HAL_I2C_ENABLE(hi2c);
;;;1417       }
;;;1418   
;;;1419       /* Disable Pos */
;;;1420       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1421   
;;;1422       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1423       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1424       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1425   
;;;1426       /* Prepare transfer parameters */
;;;1427       hi2c->pBuffPtr    = pData;
;;;1428       hi2c->XferCount   = Size;
;;;1429       hi2c->XferSize    = hi2c->XferCount;
;;;1430       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1431   
;;;1432       /* Enable Address Acknowledge */
;;;1433       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1434   
;;;1435       /* Wait until ADDR flag is set */
;;;1436       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1437       {
;;;1438         return HAL_ERROR;
;;;1439       }
;;;1440   
;;;1441       /* Clear ADDR flag */
;;;1442       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1443   
;;;1444       /* If 10bit addressing mode is selected */
;;;1445       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;1446       {
;;;1447         /* Wait until ADDR flag is set */
;;;1448         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1449         {
;;;1450           return HAL_ERROR;
;;;1451         }
;;;1452   
;;;1453         /* Clear ADDR flag */
;;;1454         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1455       }
;;;1456   
;;;1457       while (hi2c->XferSize > 0U)
;;;1458       {
;;;1459         /* Wait until TXE flag is set */
;;;1460         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1461         {
;;;1462           /* Disable Address Acknowledge */
;;;1463           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1464   
;;;1465           return HAL_ERROR;
;;;1466         }
;;;1467   
;;;1468         /* Write data to DR */
;;;1469         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1470   
;;;1471         /* Increment Buffer pointer */
;;;1472         hi2c->pBuffPtr++;
;;;1473   
;;;1474         /* Update counter */
;;;1475         hi2c->XferCount--;
;;;1476         hi2c->XferSize--;
;;;1477   
;;;1478         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1479         {
;;;1480           /* Write data to DR */
;;;1481           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1482   
;;;1483           /* Increment Buffer pointer */
;;;1484           hi2c->pBuffPtr++;
;;;1485   
;;;1486           /* Update counter */
;;;1487           hi2c->XferCount--;
;;;1488           hi2c->XferSize--;
;;;1489         }
;;;1490       }
;;;1491   
;;;1492       /* Wait until AF flag is set */
;;;1493       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
;;;1494       {
;;;1495         return HAL_ERROR;
;;;1496       }
;;;1497   
;;;1498       /* Clear AF flag */
;;;1499       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;1500   
;;;1501       /* Disable Address Acknowledge */
;;;1502       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1503   
;;;1504       hi2c->State = HAL_I2C_STATE_READY;
;;;1505       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1506   
;;;1507       /* Process Unlocked */
;;;1508       __HAL_UNLOCK(hi2c);
;;;1509   
;;;1510       return HAL_OK;
;;;1511     }
;;;1512     else
;;;1513     {
;;;1514       return HAL_BUSY;
;;;1515     }
;;;1516   }
000020  e8bd83f8          POP      {r3-r9,pc}
                  |L47.36|
000024  bf00              NOP                            ;1410
000026  f894003c          LDRB     r0,[r4,#0x3c]         ;1410
00002a  2801              CMP      r0,#1                 ;1410
00002c  d101              BNE      |L47.50|
00002e  2002              MOVS     r0,#2                 ;1410
000030  e7f6              B        |L47.32|
                  |L47.50|
000032  2001              MOVS     r0,#1                 ;1410
000034  f884003c          STRB     r0,[r4,#0x3c]         ;1410
000038  bf00              NOP                            ;1410
00003a  6820              LDR      r0,[r4,#0]            ;1413
00003c  6800              LDR      r0,[r0,#0]            ;1413
00003e  f0000001          AND      r0,r0,#1              ;1413
000042  b928              CBNZ     r0,|L47.80|
000044  6820              LDR      r0,[r4,#0]            ;1416
000046  6800              LDR      r0,[r0,#0]            ;1416
000048  f0400001          ORR      r0,r0,#1              ;1416
00004c  6821              LDR      r1,[r4,#0]            ;1416
00004e  6008              STR      r0,[r1,#0]            ;1416
                  |L47.80|
000050  6820              LDR      r0,[r4,#0]            ;1420
000052  6800              LDR      r0,[r0,#0]            ;1420
000054  f4206000          BIC      r0,r0,#0x800          ;1420
000058  6821              LDR      r1,[r4,#0]            ;1420
00005a  6008              STR      r0,[r1,#0]            ;1420
00005c  2021              MOVS     r0,#0x21              ;1422
00005e  f884003d          STRB     r0,[r4,#0x3d]         ;1422
000062  2020              MOVS     r0,#0x20              ;1423
000064  f884003e          STRB     r0,[r4,#0x3e]         ;1423
000068  2000              MOVS     r0,#0                 ;1424
00006a  6420              STR      r0,[r4,#0x40]         ;1424
00006c  6266              STR      r6,[r4,#0x24]         ;1427
00006e  8567              STRH     r7,[r4,#0x2a]         ;1428
000070  8d60              LDRH     r0,[r4,#0x2a]         ;1429
000072  8520              STRH     r0,[r4,#0x28]         ;1429
000074  4845              LDR      r0,|L47.396|
000076  62e0              STR      r0,[r4,#0x2c]         ;1430
000078  6820              LDR      r0,[r4,#0]            ;1433
00007a  6800              LDR      r0,[r0,#0]            ;1433
00007c  f4406080          ORR      r0,r0,#0x400          ;1433
000080  6821              LDR      r1,[r4,#0]            ;1433
000082  6008              STR      r0,[r1,#0]            ;1433
000084  4643              MOV      r3,r8                 ;1436
000086  2200              MOVS     r2,#0                 ;1436
000088  4941              LDR      r1,|L47.400|
00008a  4620              MOV      r0,r4                 ;1436
00008c  9500              STR      r5,[sp,#0]            ;1436
00008e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000092  b108              CBZ      r0,|L47.152|
000094  2001              MOVS     r0,#1                 ;1438
000096  e7c3              B        |L47.32|
                  |L47.152|
000098  bf00              NOP                            ;1442
00009a  2000              MOVS     r0,#0                 ;1442
00009c  9000              STR      r0,[sp,#0]            ;1442
00009e  6820              LDR      r0,[r4,#0]            ;1442
0000a0  6940              LDR      r0,[r0,#0x14]         ;1442
0000a2  9000              STR      r0,[sp,#0]            ;1442
0000a4  6820              LDR      r0,[r4,#0]            ;1442
0000a6  6980              LDR      r0,[r0,#0x18]         ;1442
0000a8  9000              STR      r0,[sp,#0]            ;1442
0000aa  bf00              NOP                            ;1442
0000ac  bf00              NOP                            ;1442
0000ae  6920              LDR      r0,[r4,#0x10]         ;1445
0000b0  f5b04f40          CMP      r0,#0xc000            ;1445
0000b4  d114              BNE      |L47.224|
0000b6  4643              MOV      r3,r8                 ;1448
0000b8  2200              MOVS     r2,#0                 ;1448
0000ba  4935              LDR      r1,|L47.400|
0000bc  4620              MOV      r0,r4                 ;1448
0000be  9500              STR      r5,[sp,#0]            ;1448
0000c0  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000c4  b108              CBZ      r0,|L47.202|
0000c6  2001              MOVS     r0,#1                 ;1450
0000c8  e7aa              B        |L47.32|
                  |L47.202|
0000ca  bf00              NOP                            ;1454
0000cc  2000              MOVS     r0,#0                 ;1454
0000ce  9000              STR      r0,[sp,#0]            ;1454
0000d0  6820              LDR      r0,[r4,#0]            ;1454
0000d2  6940              LDR      r0,[r0,#0x14]         ;1454
0000d4  9000              STR      r0,[sp,#0]            ;1454
0000d6  6820              LDR      r0,[r4,#0]            ;1454
0000d8  6980              LDR      r0,[r0,#0x18]         ;1454
0000da  9000              STR      r0,[sp,#0]            ;1454
0000dc  bf00              NOP                            ;1454
0000de  bf00              NOP                            ;1454
                  |L47.224|
0000e0  e02f              B        |L47.322|
                  |L47.226|
0000e2  462a              MOV      r2,r5                 ;1460
0000e4  4641              MOV      r1,r8                 ;1460
0000e6  4620              MOV      r0,r4                 ;1460
0000e8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ec  b140              CBZ      r0,|L47.256|
0000ee  6820              LDR      r0,[r4,#0]            ;1463
0000f0  6800              LDR      r0,[r0,#0]            ;1463
0000f2  f4206080          BIC      r0,r0,#0x400          ;1463
0000f6  6821              LDR      r1,[r4,#0]            ;1463
0000f8  6008              STR      r0,[r1,#0]            ;1463
0000fa  2001              MOVS     r0,#1                 ;1465
0000fc  e790              B        |L47.32|
                  |L47.254|
0000fe  e043              B        |L47.392|
                  |L47.256|
000100  6a60              LDR      r0,[r4,#0x24]         ;1469
000102  7800              LDRB     r0,[r0,#0]            ;1469
000104  6821              LDR      r1,[r4,#0]            ;1469
000106  6108              STR      r0,[r1,#0x10]         ;1469
000108  6a60              LDR      r0,[r4,#0x24]         ;1472
00010a  1c40              ADDS     r0,r0,#1              ;1472
00010c  6260              STR      r0,[r4,#0x24]         ;1472
00010e  8d60              LDRH     r0,[r4,#0x2a]         ;1475
000110  1e40              SUBS     r0,r0,#1              ;1475
000112  8560              STRH     r0,[r4,#0x2a]         ;1475
000114  8d20              LDRH     r0,[r4,#0x28]         ;1476
000116  1e40              SUBS     r0,r0,#1              ;1476
000118  8520              STRH     r0,[r4,#0x28]         ;1476
00011a  6820              LDR      r0,[r4,#0]            ;1478
00011c  6940              LDR      r0,[r0,#0x14]         ;1478
00011e  f3c00080          UBFX     r0,r0,#2,#1           ;1478
000122  b170              CBZ      r0,|L47.322|
000124  8d20              LDRH     r0,[r4,#0x28]         ;1478
000126  b160              CBZ      r0,|L47.322|
000128  6a60              LDR      r0,[r4,#0x24]         ;1481
00012a  7800              LDRB     r0,[r0,#0]            ;1481
00012c  6821              LDR      r1,[r4,#0]            ;1481
00012e  6108              STR      r0,[r1,#0x10]         ;1481
000130  6a60              LDR      r0,[r4,#0x24]         ;1484
000132  1c40              ADDS     r0,r0,#1              ;1484
000134  6260              STR      r0,[r4,#0x24]         ;1484
000136  8d60              LDRH     r0,[r4,#0x2a]         ;1487
000138  1e40              SUBS     r0,r0,#1              ;1487
00013a  8560              STRH     r0,[r4,#0x2a]         ;1487
00013c  8d20              LDRH     r0,[r4,#0x28]         ;1488
00013e  1e40              SUBS     r0,r0,#1              ;1488
000140  8520              STRH     r0,[r4,#0x28]         ;1488
                  |L47.322|
000142  8d20              LDRH     r0,[r4,#0x28]         ;1457
000144  2800              CMP      r0,#0                 ;1457
000146  d1cc              BNE      |L47.226|
000148  4643              MOV      r3,r8                 ;1493
00014a  2200              MOVS     r2,#0                 ;1493
00014c  f44f3182          MOV      r1,#0x10400           ;1493
000150  4620              MOV      r0,r4                 ;1493
000152  9500              STR      r5,[sp,#0]            ;1493
000154  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000158  b108              CBZ      r0,|L47.350|
00015a  2001              MOVS     r0,#1                 ;1495
00015c  e760              B        |L47.32|
                  |L47.350|
00015e  f46f6080          MVN      r0,#0x400             ;1499
000162  6821              LDR      r1,[r4,#0]            ;1499
000164  6148              STR      r0,[r1,#0x14]         ;1499
000166  6820              LDR      r0,[r4,#0]            ;1502
000168  6800              LDR      r0,[r0,#0]            ;1502
00016a  f4206080          BIC      r0,r0,#0x400          ;1502
00016e  6821              LDR      r1,[r4,#0]            ;1502
000170  6008              STR      r0,[r1,#0]            ;1502
000172  2020              MOVS     r0,#0x20              ;1504
000174  f884003d          STRB     r0,[r4,#0x3d]         ;1504
000178  2000              MOVS     r0,#0                 ;1505
00017a  f884003e          STRB     r0,[r4,#0x3e]         ;1505
00017e  bf00              NOP                            ;1508
000180  f884003c          STRB     r0,[r4,#0x3c]         ;1508
000184  bf00              NOP                            ;1508
000186  e74b              B        |L47.32|
                  |L47.392|
000188  2002              MOVS     r0,#2                 ;1514
00018a  e749              B        |L47.32|
;;;1517   
                          ENDP

                  |L47.396|
                          DCD      0xffff0000
                  |L47.400|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_DMA PROC
;;;2215     */
;;;2216   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2217   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2218     HAL_StatusTypeDef dmaxferstatus;
;;;2219   
;;;2220     if (hi2c->State == HAL_I2C_STATE_READY)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2820              CMP      r0,#0x20
000010  d173              BNE      |L48.250|
;;;2221     {
;;;2222       if ((pData == NULL) || (Size == 0U))
000012  b105              CBZ      r5,|L48.22|
000014  b916              CBNZ     r6,|L48.28|
                  |L48.22|
;;;2223       {
;;;2224         return  HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L48.24|
;;;2225       }
;;;2226   
;;;2227       /* Process Locked */
;;;2228       __HAL_LOCK(hi2c);
;;;2229   
;;;2230       /* Check if the I2C is already enabled */
;;;2231       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2232       {
;;;2233         /* Enable I2C peripheral */
;;;2234         __HAL_I2C_ENABLE(hi2c);
;;;2235       }
;;;2236   
;;;2237       /* Disable Pos */
;;;2238       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2239   
;;;2240       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2241       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2242       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2243   
;;;2244       /* Prepare transfer parameters */
;;;2245       hi2c->pBuffPtr    = pData;
;;;2246       hi2c->XferCount   = Size;
;;;2247       hi2c->XferSize    = hi2c->XferCount;
;;;2248       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2249   
;;;2250       /* Set the I2C DMA transfer complete callback */
;;;2251       hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;2252   
;;;2253       /* Set the DMA error callback */
;;;2254       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2255   
;;;2256       /* Set the unused DMA callbacks to NULL */
;;;2257       hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2258       hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;2259       hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;2260       hi2c->hdmatx->XferAbortCallback = NULL;
;;;2261   
;;;2262       /* Enable the DMA stream */
;;;2263       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;2264   
;;;2265       if (dmaxferstatus == HAL_OK)
;;;2266       {
;;;2267         /* Enable Address Acknowledge */
;;;2268         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2269   
;;;2270         /* Process Unlocked */
;;;2271         __HAL_UNLOCK(hi2c);
;;;2272   
;;;2273         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2274         to avoid the risk of I2C interrupt handle execution before current
;;;2275         process unlock */
;;;2276         /* Enable EVT and ERR interrupt */
;;;2277         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2278   
;;;2279         /* Enable DMA Request */
;;;2280         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;2281   
;;;2282         return HAL_OK;
;;;2283       }
;;;2284       else
;;;2285       {
;;;2286         /* Update I2C state */
;;;2287         hi2c->State     = HAL_I2C_STATE_READY;
;;;2288         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2289   
;;;2290         /* Update I2C error code */
;;;2291         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2292   
;;;2293         /* Process Unlocked */
;;;2294         __HAL_UNLOCK(hi2c);
;;;2295   
;;;2296         return HAL_ERROR;
;;;2297       }
;;;2298     }
;;;2299     else
;;;2300     {
;;;2301       return HAL_BUSY;
;;;2302     }
;;;2303   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L48.28|
00001c  bf00              NOP                            ;2228
00001e  f894003c          LDRB     r0,[r4,#0x3c]         ;2228
000022  2801              CMP      r0,#1                 ;2228
000024  d101              BNE      |L48.42|
000026  2002              MOVS     r0,#2                 ;2228
000028  e7f6              B        |L48.24|
                  |L48.42|
00002a  2001              MOVS     r0,#1                 ;2228
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;2228
000030  bf00              NOP                            ;2228
000032  6820              LDR      r0,[r4,#0]            ;2231
000034  6800              LDR      r0,[r0,#0]            ;2231
000036  f0000001          AND      r0,r0,#1              ;2231
00003a  b928              CBNZ     r0,|L48.72|
00003c  6820              LDR      r0,[r4,#0]            ;2234
00003e  6800              LDR      r0,[r0,#0]            ;2234
000040  f0400001          ORR      r0,r0,#1              ;2234
000044  6821              LDR      r1,[r4,#0]            ;2234
000046  6008              STR      r0,[r1,#0]            ;2234
                  |L48.72|
000048  6820              LDR      r0,[r4,#0]            ;2238
00004a  6800              LDR      r0,[r0,#0]            ;2238
00004c  f4206000          BIC      r0,r0,#0x800          ;2238
000050  6821              LDR      r1,[r4,#0]            ;2238
000052  6008              STR      r0,[r1,#0]            ;2238
000054  2021              MOVS     r0,#0x21              ;2240
000056  f884003d          STRB     r0,[r4,#0x3d]         ;2240
00005a  2020              MOVS     r0,#0x20              ;2241
00005c  f884003e          STRB     r0,[r4,#0x3e]         ;2241
000060  2000              MOVS     r0,#0                 ;2242
000062  6420              STR      r0,[r4,#0x40]         ;2242
000064  6265              STR      r5,[r4,#0x24]         ;2245
000066  8566              STRH     r6,[r4,#0x2a]         ;2246
000068  8d60              LDRH     r0,[r4,#0x2a]         ;2247
00006a  8520              STRH     r0,[r4,#0x28]         ;2247
00006c  4824              LDR      r0,|L48.256|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2248
000070  4824              LDR      r0,|L48.260|
000072  6b61              LDR      r1,[r4,#0x34]         ;2251
000074  63c8              STR      r0,[r1,#0x3c]         ;2251
000076  4824              LDR      r0,|L48.264|
000078  6b61              LDR      r1,[r4,#0x34]         ;2254
00007a  64c8              STR      r0,[r1,#0x4c]         ;2254
00007c  2000              MOVS     r0,#0                 ;2257
00007e  6b61              LDR      r1,[r4,#0x34]         ;2257
000080  6408              STR      r0,[r1,#0x40]         ;2257
000082  6b61              LDR      r1,[r4,#0x34]         ;2258
000084  6448              STR      r0,[r1,#0x44]         ;2258
000086  6b61              LDR      r1,[r4,#0x34]         ;2259
000088  6488              STR      r0,[r1,#0x48]         ;2259
00008a  6b61              LDR      r1,[r4,#0x34]         ;2260
00008c  6508              STR      r0,[r1,#0x50]         ;2260
00008e  8d23              LDRH     r3,[r4,#0x28]         ;2263
000090  f8d4c000          LDR      r12,[r4,#0]           ;2263
000094  f10c0210          ADD      r2,r12,#0x10          ;2263
000098  6a61              LDR      r1,[r4,#0x24]         ;2263
00009a  6b60              LDR      r0,[r4,#0x34]         ;2263
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  4607              MOV      r7,r0                 ;2263
0000a2  b9c7              CBNZ     r7,|L48.214|
0000a4  6820              LDR      r0,[r4,#0]            ;2268
0000a6  6800              LDR      r0,[r0,#0]            ;2268
0000a8  f4406080          ORR      r0,r0,#0x400          ;2268
0000ac  6821              LDR      r1,[r4,#0]            ;2268
0000ae  6008              STR      r0,[r1,#0]            ;2268
0000b0  bf00              NOP                            ;2271
0000b2  2000              MOVS     r0,#0                 ;2271
0000b4  f884003c          STRB     r0,[r4,#0x3c]         ;2271
0000b8  bf00              NOP                            ;2271
0000ba  6820              LDR      r0,[r4,#0]            ;2277
0000bc  6840              LDR      r0,[r0,#4]            ;2277
0000be  f4407040          ORR      r0,r0,#0x300          ;2277
0000c2  6821              LDR      r1,[r4,#0]            ;2277
0000c4  6048              STR      r0,[r1,#4]            ;2277
0000c6  6820              LDR      r0,[r4,#0]            ;2280
0000c8  6840              LDR      r0,[r0,#4]            ;2280
0000ca  f4406000          ORR      r0,r0,#0x800          ;2280
0000ce  6821              LDR      r1,[r4,#0]            ;2280
0000d0  6048              STR      r0,[r1,#4]            ;2280
0000d2  2000              MOVS     r0,#0                 ;2282
0000d4  e7a0              B        |L48.24|
                  |L48.214|
0000d6  2020              MOVS     r0,#0x20              ;2287
0000d8  f884003d          STRB     r0,[r4,#0x3d]         ;2287
0000dc  2000              MOVS     r0,#0                 ;2288
0000de  f884003e          STRB     r0,[r4,#0x3e]         ;2288
0000e2  6c20              LDR      r0,[r4,#0x40]         ;2291
0000e4  f0400010          ORR      r0,r0,#0x10           ;2291
0000e8  6420              STR      r0,[r4,#0x40]         ;2291
0000ea  bf00              NOP                            ;2294
0000ec  2000              MOVS     r0,#0                 ;2294
0000ee  f884003c          STRB     r0,[r4,#0x3c]         ;2294
0000f2  bf00              NOP                            ;2294
0000f4  2001              MOVS     r0,#1                 ;2296
0000f6  e78f              B        |L48.24|
0000f8  e7ff              B        |L48.250|
                  |L48.250|
0000fa  2002              MOVS     r0,#2                 ;2301
0000fc  e78c              B        |L48.24|
;;;2304   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L48.256|
                          DCD      0xffff0000
                  |L48.260|
                          DCD      I2C_DMAXferCplt
                  |L48.264|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_IT PROC
;;;1809     */
;;;1810   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1811   {
000002  4603              MOV      r3,r0
;;;1812   
;;;1813     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d140              BNE      |L49.142|
;;;1814     {
;;;1815       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L49.16|
00000e  b90a              CBNZ     r2,|L49.20|
                  |L49.16|
;;;1816       {
;;;1817         return  HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L49.18|
;;;1818       }
;;;1819   
;;;1820       /* Process Locked */
;;;1821       __HAL_LOCK(hi2c);
;;;1822   
;;;1823       /* Check if the I2C is already enabled */
;;;1824       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1825       {
;;;1826         /* Enable I2C peripheral */
;;;1827         __HAL_I2C_ENABLE(hi2c);
;;;1828       }
;;;1829   
;;;1830       /* Disable Pos */
;;;1831       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1832   
;;;1833       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1834       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1835       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1836   
;;;1837       /* Prepare transfer parameters */
;;;1838       hi2c->pBuffPtr    = pData;
;;;1839       hi2c->XferCount   = Size;
;;;1840       hi2c->XferSize    = hi2c->XferCount;
;;;1841       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1842   
;;;1843       /* Enable Address Acknowledge */
;;;1844       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1845   
;;;1846       /* Process Unlocked */
;;;1847       __HAL_UNLOCK(hi2c);
;;;1848   
;;;1849       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1850                 to avoid the risk of I2C interrupt handle execution before current
;;;1851                 process unlock */
;;;1852   
;;;1853       /* Enable EVT, BUF and ERR interrupt */
;;;1854       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1855   
;;;1856       return HAL_OK;
;;;1857     }
;;;1858     else
;;;1859     {
;;;1860       return HAL_BUSY;
;;;1861     }
;;;1862   }
000012  bd10              POP      {r4,pc}
                  |L49.20|
000014  bf00              NOP                            ;1821
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1821
00001a  2801              CMP      r0,#1                 ;1821
00001c  d101              BNE      |L49.34|
00001e  2002              MOVS     r0,#2                 ;1821
000020  e7f7              B        |L49.18|
                  |L49.34|
000022  2001              MOVS     r0,#1                 ;1821
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1821
000028  bf00              NOP                            ;1821
00002a  6818              LDR      r0,[r3,#0]            ;1824
00002c  6800              LDR      r0,[r0,#0]            ;1824
00002e  f0000001          AND      r0,r0,#1              ;1824
000032  b928              CBNZ     r0,|L49.64|
000034  6818              LDR      r0,[r3,#0]            ;1827
000036  6800              LDR      r0,[r0,#0]            ;1827
000038  f0400001          ORR      r0,r0,#1              ;1827
00003c  681c              LDR      r4,[r3,#0]            ;1827
00003e  6020              STR      r0,[r4,#0]            ;1827
                  |L49.64|
000040  6818              LDR      r0,[r3,#0]            ;1831
000042  6800              LDR      r0,[r0,#0]            ;1831
000044  f4206000          BIC      r0,r0,#0x800          ;1831
000048  681c              LDR      r4,[r3,#0]            ;1831
00004a  6020              STR      r0,[r4,#0]            ;1831
00004c  2021              MOVS     r0,#0x21              ;1833
00004e  f883003d          STRB     r0,[r3,#0x3d]         ;1833
000052  2020              MOVS     r0,#0x20              ;1834
000054  f883003e          STRB     r0,[r3,#0x3e]         ;1834
000058  2000              MOVS     r0,#0                 ;1835
00005a  6418              STR      r0,[r3,#0x40]         ;1835
00005c  6259              STR      r1,[r3,#0x24]         ;1838
00005e  855a              STRH     r2,[r3,#0x2a]         ;1839
000060  8d58              LDRH     r0,[r3,#0x2a]         ;1840
000062  8518              STRH     r0,[r3,#0x28]         ;1840
000064  480b              LDR      r0,|L49.148|
000066  62d8              STR      r0,[r3,#0x2c]         ;1841
000068  6818              LDR      r0,[r3,#0]            ;1844
00006a  6800              LDR      r0,[r0,#0]            ;1844
00006c  f4406080          ORR      r0,r0,#0x400          ;1844
000070  681c              LDR      r4,[r3,#0]            ;1844
000072  6020              STR      r0,[r4,#0]            ;1844
000074  bf00              NOP                            ;1847
000076  2000              MOVS     r0,#0                 ;1847
000078  f883003c          STRB     r0,[r3,#0x3c]         ;1847
00007c  bf00              NOP                            ;1847
00007e  6818              LDR      r0,[r3,#0]            ;1854
000080  6840              LDR      r0,[r0,#4]            ;1854
000082  f44060e0          ORR      r0,r0,#0x700          ;1854
000086  681c              LDR      r4,[r3,#0]            ;1854
000088  6060              STR      r0,[r4,#4]            ;1854
00008a  2000              MOVS     r0,#0                 ;1856
00008c  e7c1              B        |L49.18|
                  |L49.142|
00008e  2002              MOVS     r0,#2                 ;1860
000090  e7bf              B        |L49.18|
;;;1863   
                          ENDP

000092  0000              DCW      0x0000
                  |L49.148|
                          DCD      0xffff0000

                          AREA ||i.I2C_ConvertOtherXferOptions||, CODE, READONLY, ALIGN=1

                  I2C_ConvertOtherXferOptions PROC
;;;7301     */
;;;7302   static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;7303   {
;;;7304     /* if user set XferOptions to I2C_OTHER_FRAME            */
;;;7305     /* it request implicitly to generate a restart condition */
;;;7306     /* set XferOptions to I2C_FIRST_FRAME                    */
;;;7307     if (hi2c->XferOptions == I2C_OTHER_FRAME)
000002  f5b10f2a          CMP      r1,#0xaa0000
000006  d102              BNE      |L50.14|
;;;7308     {
;;;7309       hi2c->XferOptions = I2C_FIRST_FRAME;
000008  2101              MOVS     r1,#1
00000a  62c1              STR      r1,[r0,#0x2c]
00000c  e005              B        |L50.26|
                  |L50.14|
;;;7310     }
;;;7311     /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
;;;7312     /* it request implicitly to generate a restart condition    */
;;;7313     /* then generate a stop condition at the end of transfer    */
;;;7314     /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
;;;7315     else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
00000e  6ac1              LDR      r1,[r0,#0x2c]
000010  f1b14f2a          CMP      r1,#0xaa000000
000014  d101              BNE      |L50.26|
;;;7316     {
;;;7317       hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
000016  2108              MOVS     r1,#8
000018  62c1              STR      r1,[r0,#0x2c]
                  |L50.26|
;;;7318     }
;;;7319     else
;;;7320     {
;;;7321       /* Nothing to do */
;;;7322     }
;;;7323   }
00001a  4770              BX       lr
;;;7324   
                          ENDP


                          AREA ||i.I2C_DMAAbort||, CODE, READONLY, ALIGN=2

                  I2C_DMAAbort PROC
;;;6905     */
;;;6906   static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;6907   {
000002  4605              MOV      r5,r0
;;;6908     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;6909     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000008  6bac              LDR      r4,[r5,#0x38]
;;;6910   
;;;6911     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6912     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
00000a  f894603d          LDRB     r6,[r4,#0x3d]
;;;6913   
;;;6914     /* During abort treatment, check that there is no pending STOP request */
;;;6915     /* Wait until STOP flag is reset */
;;;6916     count = I2C_TIMEOUT_FLAG * (SystemCoreClock / 25U / 1000U);
00000e  4839              LDR      r0,|L51.244|
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  2119              MOVS     r1,#0x19
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  f44f717a          MOV      r1,#0x3e8
00001c  fbb0f0f1          UDIV     r0,r0,r1
000020  ebc000c0          RSB      r0,r0,r0,LSL #3
000024  eb000080          ADD      r0,r0,r0,LSL #2
000028  9000              STR      r0,[sp,#0]
;;;6917     do
00002a  bf00              NOP      
                  |L51.44|
;;;6918     {
;;;6919       if (count == 0U)
00002c  9800              LDR      r0,[sp,#0]
00002e  b920              CBNZ     r0,|L51.58|
;;;6920       {
;;;6921         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
000030  6c20              LDR      r0,[r4,#0x40]
000032  f0400020          ORR      r0,r0,#0x20
000036  6420              STR      r0,[r4,#0x40]
;;;6922         break;
000038  e009              B        |L51.78|
                  |L51.58|
;;;6923       }
;;;6924       count--;
00003a  9800              LDR      r0,[sp,#0]
00003c  1e40              SUBS     r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
;;;6925     }
;;;6926     while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
000040  6820              LDR      r0,[r4,#0]
000042  6800              LDR      r0,[r0,#0]
000044  f4007000          AND      r0,r0,#0x200
000048  f5b07f00          CMP      r0,#0x200
00004c  d0ee              BEQ      |L51.44|
                  |L51.78|
00004e  bf00              NOP                            ;6922
;;;6927   
;;;6928     /* Clear Complete callback */
;;;6929     if (hi2c->hdmatx != NULL)
000050  6b60              LDR      r0,[r4,#0x34]
000052  b110              CBZ      r0,|L51.90|
;;;6930     {
;;;6931       hi2c->hdmatx->XferCpltCallback = NULL;
000054  2000              MOVS     r0,#0
000056  6b61              LDR      r1,[r4,#0x34]
000058  63c8              STR      r0,[r1,#0x3c]
                  |L51.90|
;;;6932     }
;;;6933     if (hi2c->hdmarx != NULL)
00005a  6ba0              LDR      r0,[r4,#0x38]
00005c  b110              CBZ      r0,|L51.100|
;;;6934     {
;;;6935       hi2c->hdmarx->XferCpltCallback = NULL;
00005e  2000              MOVS     r0,#0
000060  6ba1              LDR      r1,[r4,#0x38]
000062  63c8              STR      r0,[r1,#0x3c]
                  |L51.100|
;;;6936     }
;;;6937   
;;;6938     /* Disable Acknowledge */
;;;6939     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000064  6820              LDR      r0,[r4,#0]
000066  6800              LDR      r0,[r0,#0]
000068  f4206080          BIC      r0,r0,#0x400
00006c  6821              LDR      r1,[r4,#0]
00006e  6008              STR      r0,[r1,#0]
;;;6940   
;;;6941     hi2c->XferCount = 0U;
000070  2000              MOVS     r0,#0
000072  8560              STRH     r0,[r4,#0x2a]
;;;6942   
;;;6943     /* Reset XferAbortCallback */
;;;6944     if (hi2c->hdmatx != NULL)
000074  6b60              LDR      r0,[r4,#0x34]
000076  b110              CBZ      r0,|L51.126|
;;;6945     {
;;;6946       hi2c->hdmatx->XferAbortCallback = NULL;
000078  2000              MOVS     r0,#0
00007a  6b61              LDR      r1,[r4,#0x34]
00007c  6508              STR      r0,[r1,#0x50]
                  |L51.126|
;;;6947     }
;;;6948     if (hi2c->hdmarx != NULL)
00007e  6ba0              LDR      r0,[r4,#0x38]
000080  b110              CBZ      r0,|L51.136|
;;;6949     {
;;;6950       hi2c->hdmarx->XferAbortCallback = NULL;
000082  2000              MOVS     r0,#0
000084  6ba1              LDR      r1,[r4,#0x38]
000086  6508              STR      r0,[r1,#0x50]
                  |L51.136|
;;;6951     }
;;;6952   
;;;6953     /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6954     __HAL_I2C_DISABLE(hi2c);
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f0200001          BIC      r0,r0,#1
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
;;;6955   
;;;6956     /* Check if come from abort from user */
;;;6957     if (hi2c->State == HAL_I2C_STATE_ABORT)
000094  f894003d          LDRB     r0,[r4,#0x3d]
000098  2860              CMP      r0,#0x60
00009a  d10a              BNE      |L51.178|
;;;6958     {
;;;6959       hi2c->State         = HAL_I2C_STATE_READY;
00009c  2020              MOVS     r0,#0x20
00009e  f884003d          STRB     r0,[r4,#0x3d]
;;;6960       hi2c->Mode          = HAL_I2C_MODE_NONE;
0000a2  2000              MOVS     r0,#0
0000a4  f884003e          STRB     r0,[r4,#0x3e]
;;;6961       hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
0000a8  6420              STR      r0,[r4,#0x40]
;;;6962   
;;;6963       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6964   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6965       hi2c->AbortCpltCallback(hi2c);
;;;6966   #else
;;;6967       HAL_I2C_AbortCpltCallback(hi2c);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       HAL_I2C_AbortCpltCallback
0000b0  e01e              B        |L51.240|
                  |L51.178|
;;;6968   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6969     }
;;;6970     else
;;;6971     {
;;;6972       if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
0000b2  f0060028          AND      r0,r6,#0x28
0000b6  2828              CMP      r0,#0x28
0000b8  d111              BNE      |L51.222|
;;;6973       {
;;;6974         /* Renable I2C peripheral */
;;;6975         __HAL_I2C_ENABLE(hi2c);
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6800              LDR      r0,[r0,#0]
0000be  f0400001          ORR      r0,r0,#1
0000c2  6821              LDR      r1,[r4,#0]
0000c4  6008              STR      r0,[r1,#0]
;;;6976   
;;;6977         /* Enable Acknowledge */
;;;6978         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f4406080          ORR      r0,r0,#0x400
0000ce  6821              LDR      r1,[r4,#0]
0000d0  6008              STR      r0,[r1,#0]
;;;6979   
;;;6980         /* keep HAL_I2C_STATE_LISTEN */
;;;6981         hi2c->PreviousState = I2C_STATE_NONE;
0000d2  2000              MOVS     r0,#0
0000d4  6320              STR      r0,[r4,#0x30]
;;;6982         hi2c->State = HAL_I2C_STATE_LISTEN;
0000d6  2028              MOVS     r0,#0x28
0000d8  f884003d          STRB     r0,[r4,#0x3d]
0000dc  e005              B        |L51.234|
                  |L51.222|
;;;6983       }
;;;6984       else
;;;6985       {
;;;6986         hi2c->State = HAL_I2C_STATE_READY;
0000de  2020              MOVS     r0,#0x20
0000e0  f884003d          STRB     r0,[r4,#0x3d]
;;;6987         hi2c->Mode = HAL_I2C_MODE_NONE;
0000e4  2000              MOVS     r0,#0
0000e6  f884003e          STRB     r0,[r4,#0x3e]
                  |L51.234|
;;;6988       }
;;;6989   
;;;6990       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6991   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6992       hi2c->ErrorCallback(hi2c);
;;;6993   #else
;;;6994       HAL_I2C_ErrorCallback(hi2c);
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L51.240|
;;;6995   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6996     }
;;;6997   }
0000f0  bdf8              POP      {r3-r7,pc}
;;;6998   
                          ENDP

0000f2  0000              DCW      0x0000
                  |L51.244|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_DMAError||, CODE, READONLY, ALIGN=1

                  I2C_DMAError PROC
;;;6864     */
;;;6865   static void I2C_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;6866   {
000002  4605              MOV      r5,r0
;;;6867     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;6868   
;;;6869     /* Clear Complete callback */
;;;6870     if (hi2c->hdmatx != NULL)
000006  6b60              LDR      r0,[r4,#0x34]
000008  b110              CBZ      r0,|L52.16|
;;;6871     {
;;;6872       hi2c->hdmatx->XferCpltCallback = NULL;
00000a  2000              MOVS     r0,#0
00000c  6b61              LDR      r1,[r4,#0x34]
00000e  63c8              STR      r0,[r1,#0x3c]
                  |L52.16|
;;;6873     }
;;;6874     if (hi2c->hdmarx != NULL)
000010  6ba0              LDR      r0,[r4,#0x38]
000012  b110              CBZ      r0,|L52.26|
;;;6875     {
;;;6876       hi2c->hdmarx->XferCpltCallback = NULL;
000014  2000              MOVS     r0,#0
000016  6ba1              LDR      r1,[r4,#0x38]
000018  63c8              STR      r0,[r1,#0x3c]
                  |L52.26|
;;;6877     }
;;;6878   
;;;6879     /* Ignore DMA FIFO error */
;;;6880     if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       HAL_DMA_GetError
000020  2802              CMP      r0,#2
000022  d014              BEQ      |L52.78|
;;;6881     {
;;;6882       /* Disable Acknowledge */
;;;6883       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
;;;6884   
;;;6885       hi2c->XferCount = 0U;
000030  2000              MOVS     r0,#0
000032  8560              STRH     r0,[r4,#0x2a]
;;;6886   
;;;6887       hi2c->State = HAL_I2C_STATE_READY;
000034  2020              MOVS     r0,#0x20
000036  f884003d          STRB     r0,[r4,#0x3d]
;;;6888       hi2c->Mode = HAL_I2C_MODE_NONE;
00003a  2000              MOVS     r0,#0
00003c  f884003e          STRB     r0,[r4,#0x3e]
;;;6889   
;;;6890       hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
000040  6c20              LDR      r0,[r4,#0x40]
000042  f0400010          ORR      r0,r0,#0x10
000046  6420              STR      r0,[r4,#0x40]
;;;6891   
;;;6892   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6893       hi2c->ErrorCallback(hi2c);
;;;6894   #else
;;;6895       HAL_I2C_ErrorCallback(hi2c);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L52.78|
;;;6896   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6897     }
;;;6898   }
00004e  bd70              POP      {r4-r6,pc}
;;;6899   
                          ENDP


                          AREA ||i.I2C_DMAXferCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAXferCplt PROC
;;;6726     */
;;;6727   static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6728   {
000004  4607              MOV      r7,r0
;;;6729     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000006  6bbc              LDR      r4,[r7,#0x38]
;;;6730   
;;;6731     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6732     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000008  f894503d          LDRB     r5,[r4,#0x3d]
;;;6733     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
00000c  f894803e          LDRB     r8,[r4,#0x3e]
;;;6734     uint32_t CurrentXferOptions       = hi2c->XferOptions;
000010  6ae6              LDR      r6,[r4,#0x2c]
;;;6735   
;;;6736     /* Disable EVT and ERR interrupt */
;;;6737     __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000012  6820              LDR      r0,[r4,#0]
000014  6840              LDR      r0,[r0,#4]
000016  f4207040          BIC      r0,r0,#0x300
00001a  6821              LDR      r1,[r4,#0]
00001c  6048              STR      r0,[r1,#4]
;;;6738   
;;;6739     /* Clear Complete callback */
;;;6740     if (hi2c->hdmatx != NULL)
00001e  6b60              LDR      r0,[r4,#0x34]
000020  b110              CBZ      r0,|L53.40|
;;;6741     {
;;;6742       hi2c->hdmatx->XferCpltCallback = NULL;
000022  2000              MOVS     r0,#0
000024  6b61              LDR      r1,[r4,#0x34]
000026  63c8              STR      r0,[r1,#0x3c]
                  |L53.40|
;;;6743     }
;;;6744     if (hi2c->hdmarx != NULL)
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  b110              CBZ      r0,|L53.50|
;;;6745     {
;;;6746       hi2c->hdmarx->XferCpltCallback = NULL;
00002c  2000              MOVS     r0,#0
00002e  6ba1              LDR      r1,[r4,#0x38]
000030  63c8              STR      r0,[r1,#0x3c]
                  |L53.50|
;;;6747     }
;;;6748   
;;;6749     if ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_TX) == (uint32_t)HAL_I2C_STATE_BUSY_TX) || ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_RX) == (uint32_t)HAL_I2C_STATE_BUSY_RX) && (CurrentMode == HAL_I2C_MODE_SLAVE)))
000032  f0050021          AND      r0,r5,#0x21
000036  2821              CMP      r0,#0x21
000038  d006              BEQ      |L53.72|
00003a  f0050022          AND      r0,r5,#0x22
00003e  2822              CMP      r0,#0x22
000040  d126              BNE      |L53.144|
000042  f1b80f20          CMP      r8,#0x20
000046  d123              BNE      |L53.144|
                  |L53.72|
;;;6750     {
;;;6751       /* Disable DMA Request */
;;;6752       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000048  6820              LDR      r0,[r4,#0]
00004a  6840              LDR      r0,[r0,#4]
00004c  f4206000          BIC      r0,r0,#0x800
000050  6821              LDR      r1,[r4,#0]
000052  6048              STR      r0,[r1,#4]
;;;6753   
;;;6754       hi2c->XferCount = 0U;
000054  2000              MOVS     r0,#0
000056  8560              STRH     r0,[r4,#0x2a]
;;;6755   
;;;6756       if (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN)
000058  2d29              CMP      r5,#0x29
00005a  d108              BNE      |L53.110|
;;;6757       {
;;;6758         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6759         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
00005c  2021              MOVS     r0,#0x21
00005e  6320              STR      r0,[r4,#0x30]
;;;6760         hi2c->State = HAL_I2C_STATE_LISTEN;
000060  2028              MOVS     r0,#0x28
000062  f884003d          STRB     r0,[r4,#0x3d]
;;;6761   
;;;6762         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6763   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6764         hi2c->SlaveTxCpltCallback(hi2c);
;;;6765   #else
;;;6766         HAL_I2C_SlaveTxCpltCallback(hi2c);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
00006c  e009              B        |L53.130|
                  |L53.110|
;;;6767   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6768       }
;;;6769       else if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
00006e  2d2a              CMP      r5,#0x2a
000070  d107              BNE      |L53.130|
;;;6770       {
;;;6771         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6772         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000072  2022              MOVS     r0,#0x22
000074  6320              STR      r0,[r4,#0x30]
;;;6773         hi2c->State = HAL_I2C_STATE_LISTEN;
000076  2028              MOVS     r0,#0x28
000078  f884003d          STRB     r0,[r4,#0x3d]
;;;6774   
;;;6775         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6776   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6777         hi2c->SlaveRxCpltCallback(hi2c);
;;;6778   #else
;;;6779         HAL_I2C_SlaveRxCpltCallback(hi2c);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L53.130|
;;;6780   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6781       }
;;;6782       else
;;;6783       {
;;;6784         /* Do nothing */
;;;6785       }
;;;6786   
;;;6787       /* Enable EVT and ERR interrupt to treat end of transfer in IRQ handler */
;;;6788       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000082  6820              LDR      r0,[r4,#0]
000084  6840              LDR      r0,[r0,#4]
000086  f4407040          ORR      r0,r0,#0x300
00008a  6821              LDR      r1,[r4,#0]
00008c  6048              STR      r0,[r1,#4]
00008e  e04d              B        |L53.300|
                  |L53.144|
;;;6789     }
;;;6790     /* Check current Mode, in case of treatment DMA handler have been preempted by a prior interrupt */
;;;6791     else if (hi2c->Mode != HAL_I2C_MODE_NONE)
000090  f894003e          LDRB     r0,[r4,#0x3e]
000094  2800              CMP      r0,#0
000096  d049              BEQ      |L53.300|
;;;6792     {
;;;6793       if (hi2c->XferCount == (uint16_t)1)
000098  8d60              LDRH     r0,[r4,#0x2a]
00009a  2801              CMP      r0,#1
00009c  d105              BNE      |L53.170|
;;;6794       {
;;;6795         /* Disable Acknowledge */
;;;6796         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00009e  6820              LDR      r0,[r4,#0]
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f4206080          BIC      r0,r0,#0x400
0000a6  6821              LDR      r1,[r4,#0]
0000a8  6008              STR      r0,[r1,#0]
                  |L53.170|
;;;6797       }
;;;6798   
;;;6799       /* Disable EVT and ERR interrupt */
;;;6800       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6840              LDR      r0,[r0,#4]
0000ae  f4207040          BIC      r0,r0,#0x300
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6048              STR      r0,[r1,#4]
;;;6801   
;;;6802       /* Prepare next transfer or stop current transfer */
;;;6803       if ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_OTHER_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
0000b6  f5163f80          CMN      r6,#0x10000
0000ba  d006              BEQ      |L53.202|
0000bc  2e08              CMP      r6,#8
0000be  d004              BEQ      |L53.202|
0000c0  f1b64f2a          CMP      r6,#0xaa000000
0000c4  d001              BEQ      |L53.202|
0000c6  2e20              CMP      r6,#0x20
0000c8  d105              BNE      |L53.214|
                  |L53.202|
;;;6804       {
;;;6805         /* Generate Stop */
;;;6806         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6800              LDR      r0,[r0,#0]
0000ce  f4407000          ORR      r0,r0,#0x200
0000d2  6821              LDR      r1,[r4,#0]
0000d4  6008              STR      r0,[r1,#0]
                  |L53.214|
;;;6807       }
;;;6808   
;;;6809       /* Disable Last DMA */
;;;6810       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
0000d6  6820              LDR      r0,[r4,#0]
0000d8  6840              LDR      r0,[r0,#4]
0000da  f4205080          BIC      r0,r0,#0x1000
0000de  6821              LDR      r1,[r4,#0]
0000e0  6048              STR      r0,[r1,#4]
;;;6811   
;;;6812       /* Disable DMA Request */
;;;6813       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
0000e2  6820              LDR      r0,[r4,#0]
0000e4  6840              LDR      r0,[r0,#4]
0000e6  f4206000          BIC      r0,r0,#0x800
0000ea  6821              LDR      r1,[r4,#0]
0000ec  6048              STR      r0,[r1,#4]
;;;6814   
;;;6815       hi2c->XferCount = 0U;
0000ee  2000              MOVS     r0,#0
0000f0  8560              STRH     r0,[r4,#0x2a]
;;;6816   
;;;6817       /* Check if Errors has been detected during transfer */
;;;6818       if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
0000f2  6c20              LDR      r0,[r4,#0x40]
0000f4  b118              CBZ      r0,|L53.254|
;;;6819       {
;;;6820   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6821         hi2c->ErrorCallback(hi2c);
;;;6822   #else
;;;6823         HAL_I2C_ErrorCallback(hi2c);
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       HAL_I2C_ErrorCallback
0000fc  e016              B        |L53.300|
                  |L53.254|
;;;6824   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6825       }
;;;6826       else
;;;6827       {
;;;6828         hi2c->State = HAL_I2C_STATE_READY;
0000fe  2020              MOVS     r0,#0x20
000100  f884003d          STRB     r0,[r4,#0x3d]
;;;6829   
;;;6830         if (hi2c->Mode == HAL_I2C_MODE_MEM)
000104  f894003e          LDRB     r0,[r4,#0x3e]
000108  2840              CMP      r0,#0x40
00010a  d107              BNE      |L53.284|
;;;6831         {
;;;6832           hi2c->Mode = HAL_I2C_MODE_NONE;
00010c  2000              MOVS     r0,#0
00010e  f884003e          STRB     r0,[r4,#0x3e]
;;;6833           hi2c->PreviousState = I2C_STATE_NONE;
000112  6320              STR      r0,[r4,#0x30]
;;;6834   
;;;6835   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6836           hi2c->MemRxCpltCallback(hi2c);
;;;6837   #else
;;;6838           HAL_I2C_MemRxCpltCallback(hi2c);
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
00011a  e007              B        |L53.300|
                  |L53.284|
;;;6839   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6840         }
;;;6841         else
;;;6842         {
;;;6843           hi2c->Mode = HAL_I2C_MODE_NONE;
00011c  2000              MOVS     r0,#0
00011e  f884003e          STRB     r0,[r4,#0x3e]
;;;6844           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000122  2012              MOVS     r0,#0x12
000124  6320              STR      r0,[r4,#0x30]
;;;6845   
;;;6846   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6847           hi2c->MasterRxCpltCallback(hi2c);
;;;6848   #else
;;;6849           HAL_I2C_MasterRxCpltCallback(hi2c);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L53.300|
;;;6850   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6851         }
;;;6852       }
;;;6853     }
;;;6854     else
;;;6855     {
;;;6856       /* Do nothing */
;;;6857     }
;;;6858   }
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;6859   
                          ENDP


                          AREA ||i.I2C_ITError||, CODE, READONLY, ALIGN=2

                  I2C_ITError PROC
;;;6201     */
;;;6202   static void I2C_ITError(I2C_HandleTypeDef *hi2c)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6203   {
000004  4604              MOV      r4,r0
;;;6204     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6205     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000006  f894603d          LDRB     r6,[r4,#0x3d]
;;;6206     HAL_I2C_ModeTypeDef CurrentMode = hi2c->Mode;
00000a  f894703e          LDRB     r7,[r4,#0x3e]
;;;6207     uint32_t CurrentError;
;;;6208   
;;;6209     if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
00000e  2f10              CMP      r7,#0x10
000010  d001              BEQ      |L54.22|
000012  2f40              CMP      r7,#0x40
000014  d107              BNE      |L54.38|
                  |L54.22|
000016  2e22              CMP      r6,#0x22
000018  d105              BNE      |L54.38|
;;;6210     {
;;;6211       /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
;;;6212       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f4206000          BIC      r0,r0,#0x800
000022  6821              LDR      r1,[r4,#0]
000024  6008              STR      r0,[r1,#0]
                  |L54.38|
;;;6213     }
;;;6214   
;;;6215     if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000026  f0060028          AND      r0,r6,#0x28
00002a  2828              CMP      r0,#0x28
00002c  d105              BNE      |L54.58|
;;;6216     {
;;;6217       /* keep HAL_I2C_STATE_LISTEN */
;;;6218       hi2c->PreviousState = I2C_STATE_NONE;
00002e  2000              MOVS     r0,#0
000030  6320              STR      r0,[r4,#0x30]
;;;6219       hi2c->State = HAL_I2C_STATE_LISTEN;
000032  2028              MOVS     r0,#0x28
000034  f884003d          STRB     r0,[r4,#0x3d]
000038  e010              B        |L54.92|
                  |L54.58|
;;;6220     }
;;;6221     else
;;;6222     {
;;;6223       /* If state is an abort treatment on going, don't change state */
;;;6224       /* This change will be do later */
;;;6225       if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
00003a  6820              LDR      r0,[r4,#0]
00003c  6840              LDR      r0,[r0,#4]
00003e  f4006000          AND      r0,r0,#0x800
000042  f5b06f00          CMP      r0,#0x800
000046  d007              BEQ      |L54.88|
000048  2e60              CMP      r6,#0x60
00004a  d005              BEQ      |L54.88|
;;;6226       {
;;;6227         hi2c->State = HAL_I2C_STATE_READY;
00004c  2020              MOVS     r0,#0x20
00004e  f884003d          STRB     r0,[r4,#0x3d]
;;;6228         hi2c->Mode = HAL_I2C_MODE_NONE;
000052  2000              MOVS     r0,#0
000054  f884003e          STRB     r0,[r4,#0x3e]
                  |L54.88|
;;;6229       }
;;;6230       hi2c->PreviousState = I2C_STATE_NONE;
000058  2000              MOVS     r0,#0
00005a  6320              STR      r0,[r4,#0x30]
                  |L54.92|
;;;6231     }
;;;6232   
;;;6233     /* Abort DMA transfer */
;;;6234     if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
00005c  6820              LDR      r0,[r4,#0]
00005e  6840              LDR      r0,[r0,#4]
000060  f4006000          AND      r0,r0,#0x800
000064  f5b06f00          CMP      r0,#0x800
000068  d140              BNE      |L54.236|
;;;6235     {
;;;6236       hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
00006a  6820              LDR      r0,[r4,#0]
00006c  6840              LDR      r0,[r0,#4]
00006e  f4206000          BIC      r0,r0,#0x800
000072  6821              LDR      r1,[r4,#0]
000074  6048              STR      r0,[r1,#4]
;;;6237   
;;;6238       if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
000076  6b60              LDR      r0,[r4,#0x34]
000078  f8900035          LDRB     r0,[r0,#0x35]
00007c  2801              CMP      r0,#1
00007e  d014              BEQ      |L54.170|
;;;6239       {
;;;6240         /* Set the DMA Abort callback :
;;;6241         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6242         hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
000080  4848              LDR      r0,|L54.420|
000082  6b61              LDR      r1,[r4,#0x34]
000084  6508              STR      r0,[r1,#0x50]
;;;6243   
;;;6244         if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
000086  6b60              LDR      r0,[r4,#0x34]
000088  f7fffffe          BL       HAL_DMA_Abort_IT
00008c  2800              CMP      r0,#0
00008e  d05b              BEQ      |L54.328|
;;;6245         {
;;;6246           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6247           __HAL_I2C_DISABLE(hi2c);
000090  6820              LDR      r0,[r4,#0]
000092  6800              LDR      r0,[r0,#0]
000094  f0200001          BIC      r0,r0,#1
000098  6821              LDR      r1,[r4,#0]
00009a  6008              STR      r0,[r1,#0]
;;;6248   
;;;6249           hi2c->State = HAL_I2C_STATE_READY;
00009c  2020              MOVS     r0,#0x20
00009e  f884003d          STRB     r0,[r4,#0x3d]
;;;6250   
;;;6251           /* Call Directly XferAbortCallback function in case of error */
;;;6252           hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
0000a2  6b60              LDR      r0,[r4,#0x34]
0000a4  6d01              LDR      r1,[r0,#0x50]
0000a6  4788              BLX      r1
0000a8  e04e              B        |L54.328|
                  |L54.170|
;;;6253         }
;;;6254       }
;;;6255       else
;;;6256       {
;;;6257         /* Set the DMA Abort callback :
;;;6258         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6259         hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
0000aa  483e              LDR      r0,|L54.420|
0000ac  6ba1              LDR      r1,[r4,#0x38]
0000ae  6508              STR      r0,[r1,#0x50]
;;;6260   
;;;6261         if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
0000b0  6ba0              LDR      r0,[r4,#0x38]
0000b2  f7fffffe          BL       HAL_DMA_Abort_IT
0000b6  2800              CMP      r0,#0
0000b8  d046              BEQ      |L54.328|
;;;6262         {
;;;6263           /* Store Last receive data if any */
;;;6264           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6940              LDR      r0,[r0,#0x14]
0000be  f3c01080          UBFX     r0,r0,#6,#1
0000c2  b130              CBZ      r0,|L54.210|
;;;6265           {
;;;6266             /* Read data from DR */
;;;6267             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000c4  6820              LDR      r0,[r4,#0]
0000c6  6900              LDR      r0,[r0,#0x10]
0000c8  6a61              LDR      r1,[r4,#0x24]
0000ca  7008              STRB     r0,[r1,#0]
;;;6268   
;;;6269             /* Increment Buffer pointer */
;;;6270             hi2c->pBuffPtr++;
0000cc  6a60              LDR      r0,[r4,#0x24]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  6260              STR      r0,[r4,#0x24]
                  |L54.210|
;;;6271           }
;;;6272   
;;;6273           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6274           __HAL_I2C_DISABLE(hi2c);
0000d2  6820              LDR      r0,[r4,#0]
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f0200001          BIC      r0,r0,#1
0000da  6821              LDR      r1,[r4,#0]
0000dc  6008              STR      r0,[r1,#0]
;;;6275   
;;;6276           hi2c->State = HAL_I2C_STATE_READY;
0000de  2020              MOVS     r0,#0x20
0000e0  f884003d          STRB     r0,[r4,#0x3d]
;;;6277   
;;;6278           /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
;;;6279           hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
0000e4  6ba0              LDR      r0,[r4,#0x38]
0000e6  6d01              LDR      r1,[r0,#0x50]
0000e8  4788              BLX      r1
0000ea  e02d              B        |L54.328|
                  |L54.236|
;;;6280         }
;;;6281       }
;;;6282     }
;;;6283     else if (hi2c->State == HAL_I2C_STATE_ABORT)
0000ec  f894003d          LDRB     r0,[r4,#0x3d]
0000f0  2860              CMP      r0,#0x60
0000f2  d11a              BNE      |L54.298|
;;;6284     {
;;;6285       hi2c->State = HAL_I2C_STATE_READY;
0000f4  2020              MOVS     r0,#0x20
0000f6  f884003d          STRB     r0,[r4,#0x3d]
;;;6286       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
0000fa  2000              MOVS     r0,#0
0000fc  6420              STR      r0,[r4,#0x40]
;;;6287   
;;;6288       /* Store Last receive data if any */
;;;6289       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000fe  6820              LDR      r0,[r4,#0]
000100  6940              LDR      r0,[r0,#0x14]
000102  f3c01080          UBFX     r0,r0,#6,#1
000106  b130              CBZ      r0,|L54.278|
;;;6290       {
;;;6291         /* Read data from DR */
;;;6292         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000108  6820              LDR      r0,[r4,#0]
00010a  6900              LDR      r0,[r0,#0x10]
00010c  6a61              LDR      r1,[r4,#0x24]
00010e  7008              STRB     r0,[r1,#0]
;;;6293   
;;;6294         /* Increment Buffer pointer */
;;;6295         hi2c->pBuffPtr++;
000110  6a60              LDR      r0,[r4,#0x24]
000112  1c40              ADDS     r0,r0,#1
000114  6260              STR      r0,[r4,#0x24]
                  |L54.278|
;;;6296       }
;;;6297   
;;;6298       /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6299       __HAL_I2C_DISABLE(hi2c);
000116  6820              LDR      r0,[r4,#0]
000118  6800              LDR      r0,[r0,#0]
00011a  f0200001          BIC      r0,r0,#1
00011e  6821              LDR      r1,[r4,#0]
000120  6008              STR      r0,[r1,#0]
;;;6300   
;;;6301       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6302   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6303       hi2c->AbortCpltCallback(hi2c);
;;;6304   #else
;;;6305       HAL_I2C_AbortCpltCallback(hi2c);
000122  4620              MOV      r0,r4
000124  f7fffffe          BL       HAL_I2C_AbortCpltCallback
000128  e00e              B        |L54.328|
                  |L54.298|
;;;6306   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6307     }
;;;6308     else
;;;6309     {
;;;6310       /* Store Last receive data if any */
;;;6311       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
00012a  6820              LDR      r0,[r4,#0]
00012c  6940              LDR      r0,[r0,#0x14]
00012e  f3c01080          UBFX     r0,r0,#6,#1
000132  b130              CBZ      r0,|L54.322|
;;;6312       {
;;;6313         /* Read data from DR */
;;;6314         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000134  6820              LDR      r0,[r4,#0]
000136  6900              LDR      r0,[r0,#0x10]
000138  6a61              LDR      r1,[r4,#0x24]
00013a  7008              STRB     r0,[r1,#0]
;;;6315   
;;;6316         /* Increment Buffer pointer */
;;;6317         hi2c->pBuffPtr++;
00013c  6a60              LDR      r0,[r4,#0x24]
00013e  1c40              ADDS     r0,r0,#1
000140  6260              STR      r0,[r4,#0x24]
                  |L54.322|
;;;6318       }
;;;6319   
;;;6320       /* Call user error callback */
;;;6321   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6322       hi2c->ErrorCallback(hi2c);
;;;6323   #else
;;;6324       HAL_I2C_ErrorCallback(hi2c);
000142  4620              MOV      r0,r4
000144  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L54.328|
;;;6325   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6326     }
;;;6327   
;;;6328     /* STOP Flag is not set after a NACK reception, BusError, ArbitrationLost, OverRun */
;;;6329     CurrentError = hi2c->ErrorCode;
000148  6c25              LDR      r5,[r4,#0x40]
;;;6330   
;;;6331     if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
00014a  f0050001          AND      r0,r5,#1
00014e  b958              CBNZ     r0,|L54.360|
;;;6332         ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
000150  f0050002          AND      r0,r5,#2
000154  2802              CMP      r0,#2
000156  d007              BEQ      |L54.360|
;;;6333         ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
000158  f0050004          AND      r0,r5,#4
00015c  2804              CMP      r0,#4
00015e  d003              BEQ      |L54.360|
;;;6334         ((CurrentError & HAL_I2C_ERROR_OVR) == HAL_I2C_ERROR_OVR))
000160  f0050008          AND      r0,r5,#8
000164  2808              CMP      r0,#8
000166  d105              BNE      |L54.372|
                  |L54.360|
;;;6335     {
;;;6336       /* Disable EVT, BUF and ERR interrupt */
;;;6337       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000168  6820              LDR      r0,[r4,#0]
00016a  6840              LDR      r0,[r0,#4]
00016c  f42060e0          BIC      r0,r0,#0x700
000170  6821              LDR      r1,[r4,#0]
000172  6048              STR      r0,[r1,#4]
                  |L54.372|
;;;6338     }
;;;6339   
;;;6340     /* So may inform upper layer that listen phase is stopped */
;;;6341     /* during NACK error treatment */
;;;6342     CurrentState = hi2c->State;
000174  f894603d          LDRB     r6,[r4,#0x3d]
;;;6343     if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
000178  6c20              LDR      r0,[r4,#0x40]
00017a  f0000004          AND      r0,r0,#4
00017e  2804              CMP      r0,#4
000180  d10e              BNE      |L54.416|
000182  2e28              CMP      r6,#0x28
000184  d10c              BNE      |L54.416|
;;;6344     {
;;;6345       hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
000186  4808              LDR      r0,|L54.424|
000188  62e0              STR      r0,[r4,#0x2c]
;;;6346       hi2c->PreviousState = I2C_STATE_NONE;
00018a  2000              MOVS     r0,#0
00018c  6320              STR      r0,[r4,#0x30]
;;;6347       hi2c->State         = HAL_I2C_STATE_READY;
00018e  2020              MOVS     r0,#0x20
000190  f884003d          STRB     r0,[r4,#0x3d]
;;;6348       hi2c->Mode          = HAL_I2C_MODE_NONE;
000194  2000              MOVS     r0,#0
000196  f884003e          STRB     r0,[r4,#0x3e]
;;;6349   
;;;6350       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6351   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6352       hi2c->ListenCpltCallback(hi2c);
;;;6353   #else
;;;6354       HAL_I2C_ListenCpltCallback(hi2c);
00019a  4620              MOV      r0,r4
00019c  f7fffffe          BL       HAL_I2C_ListenCpltCallback
                  |L54.416|
;;;6355   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6356     }
;;;6357   }
0001a0  e8bd81f0          POP      {r4-r8,pc}
;;;6358   
                          ENDP

                  |L54.420|
                          DCD      I2C_DMAAbort
                  |L54.424|
                          DCD      0xffff0000

                          AREA ||i.I2C_IsAcknowledgeFailed||, CODE, READONLY, ALIGN=1

                  I2C_IsAcknowledgeFailed PROC
;;;7276     */
;;;7277   static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;7278   {
;;;7279     if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
000002  6808              LDR      r0,[r1,#0]
000004  6940              LDR      r0,[r0,#0x14]
000006  f3c02080          UBFX     r0,r0,#10,#1
00000a  b1b0              CBZ      r0,|L55.58|
;;;7280     {
;;;7281       /* Clear NACKF Flag */
;;;7282       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00000c  f46f6080          MVN      r0,#0x400
000010  680a              LDR      r2,[r1,#0]
000012  6150              STR      r0,[r2,#0x14]
;;;7283   
;;;7284       hi2c->PreviousState       = I2C_STATE_NONE;
000014  2000              MOVS     r0,#0
000016  6308              STR      r0,[r1,#0x30]
;;;7285       hi2c->State               = HAL_I2C_STATE_READY;
000018  2020              MOVS     r0,#0x20
00001a  f881003d          STRB     r0,[r1,#0x3d]
;;;7286       hi2c->Mode                = HAL_I2C_MODE_NONE;
00001e  2000              MOVS     r0,#0
000020  f881003e          STRB     r0,[r1,#0x3e]
;;;7287       hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
000024  6c08              LDR      r0,[r1,#0x40]
000026  f0400004          ORR      r0,r0,#4
00002a  6408              STR      r0,[r1,#0x40]
;;;7288   
;;;7289       /* Process Unlocked */
;;;7290       __HAL_UNLOCK(hi2c);
00002c  bf00              NOP      
00002e  2000              MOVS     r0,#0
000030  f881003c          STRB     r0,[r1,#0x3c]
000034  bf00              NOP      
;;;7291   
;;;7292       return HAL_ERROR;
000036  2001              MOVS     r0,#1
                  |L55.56|
;;;7293     }
;;;7294     return HAL_OK;
;;;7295   }
000038  4770              BX       lr
                  |L55.58|
00003a  2000              MOVS     r0,#0                 ;7294
00003c  e7fc              B        |L55.56|
;;;7296   
                          ENDP


                          AREA ||i.I2C_MasterReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_BTF PROC
;;;5437     */
;;;5438   static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5439   {
000002  4604              MOV      r4,r0
;;;5440     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5441     uint32_t CurrentXferOptions = hi2c->XferOptions;
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;5442   
;;;5443     if (hi2c->XferCount == 4U)
000006  8d60              LDRH     r0,[r4,#0x2a]
000008  2804              CMP      r0,#4
00000a  d110              BNE      |L56.46|
;;;5444     {
;;;5445       /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
;;;5446          on BTF subroutine if there is a reception delay between N-1 and N byte */
;;;5447       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
00000c  6820              LDR      r0,[r4,#0]
00000e  6840              LDR      r0,[r0,#4]
000010  f4206080          BIC      r0,r0,#0x400
000014  6821              LDR      r1,[r4,#0]
000016  6048              STR      r0,[r1,#4]
;;;5448   
;;;5449       /* Read data from DR */
;;;5450       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000018  6820              LDR      r0,[r4,#0]
00001a  6900              LDR      r0,[r0,#0x10]
00001c  6a61              LDR      r1,[r4,#0x24]
00001e  7008              STRB     r0,[r1,#0]
;;;5451   
;;;5452       /* Increment Buffer pointer */
;;;5453       hi2c->pBuffPtr++;
000020  6a60              LDR      r0,[r4,#0x24]
000022  1c40              ADDS     r0,r0,#1
000024  6260              STR      r0,[r4,#0x24]
;;;5454   
;;;5455       /* Update counter */
;;;5456       hi2c->XferCount--;
000026  8d60              LDRH     r0,[r4,#0x2a]
000028  1e40              SUBS     r0,r0,#1
00002a  8560              STRH     r0,[r4,#0x2a]
00002c  e07a              B        |L56.292|
                  |L56.46|
;;;5457     }
;;;5458     else if (hi2c->XferCount == 3U)
00002e  8d60              LDRH     r0,[r4,#0x2a]
000030  2803              CMP      r0,#3
000032  d11a              BNE      |L56.106|
;;;5459     {
;;;5460       /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
;;;5461          on BTF subroutine if there is a reception delay between N-1 and N byte */
;;;5462       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000034  6820              LDR      r0,[r4,#0]
000036  6840              LDR      r0,[r0,#4]
000038  f4206080          BIC      r0,r0,#0x400
00003c  6821              LDR      r1,[r4,#0]
00003e  6048              STR      r0,[r1,#4]
;;;5463   
;;;5464       if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
000040  2d04              CMP      r5,#4
000042  d007              BEQ      |L56.84|
000044  2d02              CMP      r5,#2
000046  d005              BEQ      |L56.84|
;;;5465       {
;;;5466         /* Disable Acknowledge */
;;;5467         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  f4206080          BIC      r0,r0,#0x400
000050  6821              LDR      r1,[r4,#0]
000052  6008              STR      r0,[r1,#0]
                  |L56.84|
;;;5468       }
;;;5469   
;;;5470       /* Read data from DR */
;;;5471       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000054  6820              LDR      r0,[r4,#0]
000056  6900              LDR      r0,[r0,#0x10]
000058  6a61              LDR      r1,[r4,#0x24]
00005a  7008              STRB     r0,[r1,#0]
;;;5472   
;;;5473       /* Increment Buffer pointer */
;;;5474       hi2c->pBuffPtr++;
00005c  6a60              LDR      r0,[r4,#0x24]
00005e  1c40              ADDS     r0,r0,#1
000060  6260              STR      r0,[r4,#0x24]
;;;5475   
;;;5476       /* Update counter */
;;;5477       hi2c->XferCount--;
000062  8d60              LDRH     r0,[r4,#0x2a]
000064  1e40              SUBS     r0,r0,#1
000066  8560              STRH     r0,[r4,#0x2a]
000068  e05c              B        |L56.292|
                  |L56.106|
;;;5478     }
;;;5479     else if (hi2c->XferCount == 2U)
00006a  8d60              LDRH     r0,[r4,#0x2a]
00006c  2802              CMP      r0,#2
00006e  d14f              BNE      |L56.272|
;;;5480     {
;;;5481       /* Prepare next transfer or stop current transfer */
;;;5482       if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
000070  2d01              CMP      r5,#1
000072  d001              BEQ      |L56.120|
000074  2d10              CMP      r5,#0x10
000076  d106              BNE      |L56.134|
                  |L56.120|
;;;5483       {
;;;5484         /* Disable Acknowledge */
;;;5485         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000078  6820              LDR      r0,[r4,#0]
00007a  6800              LDR      r0,[r0,#0]
00007c  f4206080          BIC      r0,r0,#0x400
000080  6821              LDR      r1,[r4,#0]
000082  6008              STR      r0,[r1,#0]
000084  e012              B        |L56.172|
                  |L56.134|
;;;5486       }
;;;5487       else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
000086  2d04              CMP      r5,#4
000088  d001              BEQ      |L56.142|
00008a  2d02              CMP      r5,#2
00008c  d106              BNE      |L56.156|
                  |L56.142|
;;;5488       {
;;;5489         /* Enable Acknowledge */
;;;5490         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00008e  6820              LDR      r0,[r4,#0]
000090  6800              LDR      r0,[r0,#0]
000092  f4406080          ORR      r0,r0,#0x400
000096  6821              LDR      r1,[r4,#0]
000098  6008              STR      r0,[r1,#0]
00009a  e007              B        |L56.172|
                  |L56.156|
;;;5491       }
;;;5492       else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
00009c  2d10              CMP      r5,#0x10
00009e  d005              BEQ      |L56.172|
;;;5493       {
;;;5494         /* Generate Stop */
;;;5495         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f4407000          ORR      r0,r0,#0x200
0000a8  6821              LDR      r1,[r4,#0]
0000aa  6008              STR      r0,[r1,#0]
                  |L56.172|
;;;5496       }
;;;5497       else
;;;5498       {
;;;5499         /* Do nothing */
;;;5500       }
;;;5501   
;;;5502       /* Read data from DR */
;;;5503       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6900              LDR      r0,[r0,#0x10]
0000b0  6a61              LDR      r1,[r4,#0x24]
0000b2  7008              STRB     r0,[r1,#0]
;;;5504   
;;;5505       /* Increment Buffer pointer */
;;;5506       hi2c->pBuffPtr++;
0000b4  6a60              LDR      r0,[r4,#0x24]
0000b6  1c40              ADDS     r0,r0,#1
0000b8  6260              STR      r0,[r4,#0x24]
;;;5507   
;;;5508       /* Update counter */
;;;5509       hi2c->XferCount--;
0000ba  8d60              LDRH     r0,[r4,#0x2a]
0000bc  1e40              SUBS     r0,r0,#1
0000be  8560              STRH     r0,[r4,#0x2a]
;;;5510   
;;;5511       /* Read data from DR */
;;;5512       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6900              LDR      r0,[r0,#0x10]
0000c4  6a61              LDR      r1,[r4,#0x24]
0000c6  7008              STRB     r0,[r1,#0]
;;;5513   
;;;5514       /* Increment Buffer pointer */
;;;5515       hi2c->pBuffPtr++;
0000c8  6a60              LDR      r0,[r4,#0x24]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  6260              STR      r0,[r4,#0x24]
;;;5516   
;;;5517       /* Update counter */
;;;5518       hi2c->XferCount--;
0000ce  8d60              LDRH     r0,[r4,#0x2a]
0000d0  1e40              SUBS     r0,r0,#1
0000d2  8560              STRH     r0,[r4,#0x2a]
;;;5519   
;;;5520       /* Disable EVT and ERR interrupt */
;;;5521       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6840              LDR      r0,[r0,#4]
0000d8  f4207040          BIC      r0,r0,#0x300
0000dc  6821              LDR      r1,[r4,#0]
0000de  6048              STR      r0,[r1,#4]
;;;5522   
;;;5523       hi2c->State = HAL_I2C_STATE_READY;
0000e0  2020              MOVS     r0,#0x20
0000e2  f884003d          STRB     r0,[r4,#0x3d]
;;;5524       if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000e6  f894003e          LDRB     r0,[r4,#0x3e]
0000ea  2840              CMP      r0,#0x40
0000ec  d107              BNE      |L56.254|
;;;5525       {
;;;5526         hi2c->Mode = HAL_I2C_MODE_NONE;
0000ee  2000              MOVS     r0,#0
0000f0  f884003e          STRB     r0,[r4,#0x3e]
;;;5527         hi2c->PreviousState = I2C_STATE_NONE;
0000f4  6320              STR      r0,[r4,#0x30]
;;;5528   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5529         hi2c->MemRxCpltCallback(hi2c);
;;;5530   #else
;;;5531         HAL_I2C_MemRxCpltCallback(hi2c);
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
0000fc  e012              B        |L56.292|
                  |L56.254|
;;;5532   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5533       }
;;;5534       else
;;;5535       {
;;;5536         hi2c->Mode = HAL_I2C_MODE_NONE;
0000fe  2000              MOVS     r0,#0
000100  f884003e          STRB     r0,[r4,#0x3e]
;;;5537         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000104  2012              MOVS     r0,#0x12
000106  6320              STR      r0,[r4,#0x30]
;;;5538   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5539         hi2c->MasterRxCpltCallback(hi2c);
;;;5540   #else
;;;5541         HAL_I2C_MasterRxCpltCallback(hi2c);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
00010e  e009              B        |L56.292|
                  |L56.272|
;;;5542   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5543       }
;;;5544     }
;;;5545     else
;;;5546     {
;;;5547       /* Read data from DR */
;;;5548       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000110  6820              LDR      r0,[r4,#0]
000112  6900              LDR      r0,[r0,#0x10]
000114  6a61              LDR      r1,[r4,#0x24]
000116  7008              STRB     r0,[r1,#0]
;;;5549   
;;;5550       /* Increment Buffer pointer */
;;;5551       hi2c->pBuffPtr++;
000118  6a60              LDR      r0,[r4,#0x24]
00011a  1c40              ADDS     r0,r0,#1
00011c  6260              STR      r0,[r4,#0x24]
;;;5552   
;;;5553       /* Update counter */
;;;5554       hi2c->XferCount--;
00011e  8d60              LDRH     r0,[r4,#0x2a]
000120  1e40              SUBS     r0,r0,#1
000122  8560              STRH     r0,[r4,#0x2a]
                  |L56.292|
;;;5555     }
;;;5556   }
000124  bd70              POP      {r4-r6,pc}
;;;5557   
                          ENDP


                          AREA ||i.I2C_MasterReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_RXNE PROC
;;;5329     */
;;;5330   static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5331   {
000002  4604              MOV      r4,r0
;;;5332     if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  2822              CMP      r0,#0x22
00000a  d169              BNE      |L57.224|
;;;5333     {
;;;5334       uint32_t tmp;
;;;5335   
;;;5336       tmp = hi2c->XferCount;
00000c  8d65              LDRH     r5,[r4,#0x2a]
;;;5337       if (tmp > 3U)
00000e  2d03              CMP      r5,#3
000010  d913              BLS      |L57.58|
;;;5338       {
;;;5339         /* Read data from DR */
;;;5340         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000012  6820              LDR      r0,[r4,#0]
000014  6900              LDR      r0,[r0,#0x10]
000016  6a61              LDR      r1,[r4,#0x24]
000018  7008              STRB     r0,[r1,#0]
;;;5341   
;;;5342         /* Increment Buffer pointer */
;;;5343         hi2c->pBuffPtr++;
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  1c40              ADDS     r0,r0,#1
00001e  6260              STR      r0,[r4,#0x24]
;;;5344   
;;;5345         /* Update counter */
;;;5346         hi2c->XferCount--;
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  1e40              SUBS     r0,r0,#1
000024  8560              STRH     r0,[r4,#0x2a]
;;;5347   
;;;5348         if (hi2c->XferCount == (uint16_t)3)
000026  8d60              LDRH     r0,[r4,#0x2a]
000028  2803              CMP      r0,#3
00002a  d158              BNE      |L57.222|
;;;5349         {
;;;5350           /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
;;;5351           on BTF subroutine */
;;;5352           /* Disable BUF interrupt */
;;;5353           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  f4206080          BIC      r0,r0,#0x400
000034  6821              LDR      r1,[r4,#0]
000036  6048              STR      r0,[r1,#4]
000038  e051              B        |L57.222|
                  |L57.58|
;;;5354         }
;;;5355       }
;;;5356       else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  2802              CMP      r0,#2
00003e  d04e              BEQ      |L57.222|
000040  2d01              CMP      r5,#1
000042  d001              BEQ      |L57.72|
000044  2d00              CMP      r5,#0
000046  d14a              BNE      |L57.222|
                  |L57.72|
;;;5357       {
;;;5358         if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       I2C_WaitOnSTOPRequestThroughIT
00004e  bb68              CBNZ     r0,|L57.172|
;;;5359         {
;;;5360           /* Disable Acknowledge */
;;;5361           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000050  6820              LDR      r0,[r4,#0]
000052  6800              LDR      r0,[r0,#0]
000054  f4206080          BIC      r0,r0,#0x400
000058  6821              LDR      r1,[r4,#0]
00005a  6008              STR      r0,[r1,#0]
;;;5362   
;;;5363           /* Disable EVT, BUF and ERR interrupt */
;;;5364           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00005c  6820              LDR      r0,[r4,#0]
00005e  6840              LDR      r0,[r0,#4]
000060  f42060e0          BIC      r0,r0,#0x700
000064  6821              LDR      r1,[r4,#0]
000066  6048              STR      r0,[r1,#4]
;;;5365   
;;;5366           /* Read data from DR */
;;;5367           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000068  6820              LDR      r0,[r4,#0]
00006a  6900              LDR      r0,[r0,#0x10]
00006c  6a61              LDR      r1,[r4,#0x24]
00006e  7008              STRB     r0,[r1,#0]
;;;5368   
;;;5369           /* Increment Buffer pointer */
;;;5370           hi2c->pBuffPtr++;
000070  6a60              LDR      r0,[r4,#0x24]
000072  1c40              ADDS     r0,r0,#1
000074  6260              STR      r0,[r4,#0x24]
;;;5371   
;;;5372           /* Update counter */
;;;5373           hi2c->XferCount--;
000076  8d60              LDRH     r0,[r4,#0x2a]
000078  1e40              SUBS     r0,r0,#1
00007a  8560              STRH     r0,[r4,#0x2a]
;;;5374   
;;;5375           hi2c->State = HAL_I2C_STATE_READY;
00007c  2020              MOVS     r0,#0x20
00007e  f884003d          STRB     r0,[r4,#0x3d]
;;;5376   
;;;5377           if (hi2c->Mode == HAL_I2C_MODE_MEM)
000082  f894003e          LDRB     r0,[r4,#0x3e]
000086  2840              CMP      r0,#0x40
000088  d107              BNE      |L57.154|
;;;5378           {
;;;5379             hi2c->Mode = HAL_I2C_MODE_NONE;
00008a  2000              MOVS     r0,#0
00008c  f884003e          STRB     r0,[r4,#0x3e]
;;;5380             hi2c->PreviousState = I2C_STATE_NONE;
000090  6320              STR      r0,[r4,#0x30]
;;;5381   
;;;5382   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5383             hi2c->MemRxCpltCallback(hi2c);
;;;5384   #else
;;;5385             HAL_I2C_MemRxCpltCallback(hi2c);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
000098  e021              B        |L57.222|
                  |L57.154|
;;;5386   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5387           }
;;;5388           else
;;;5389           {
;;;5390             hi2c->Mode = HAL_I2C_MODE_NONE;
00009a  2000              MOVS     r0,#0
00009c  f884003e          STRB     r0,[r4,#0x3e]
;;;5391             hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
0000a0  2012              MOVS     r0,#0x12
0000a2  6320              STR      r0,[r4,#0x30]
;;;5392   
;;;5393   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5394             hi2c->MasterRxCpltCallback(hi2c);
;;;5395   #else
;;;5396             HAL_I2C_MasterRxCpltCallback(hi2c);
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
0000aa  e018              B        |L57.222|
                  |L57.172|
;;;5397   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5398           }
;;;5399         }
;;;5400         else
;;;5401         {
;;;5402           /* Disable EVT, BUF and ERR interrupt */
;;;5403           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6840              LDR      r0,[r0,#4]
0000b0  f42060e0          BIC      r0,r0,#0x700
0000b4  6821              LDR      r1,[r4,#0]
0000b6  6048              STR      r0,[r1,#4]
;;;5404   
;;;5405           /* Read data from DR */
;;;5406           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6900              LDR      r0,[r0,#0x10]
0000bc  6a61              LDR      r1,[r4,#0x24]
0000be  7008              STRB     r0,[r1,#0]
;;;5407   
;;;5408           /* Increment Buffer pointer */
;;;5409           hi2c->pBuffPtr++;
0000c0  6a60              LDR      r0,[r4,#0x24]
0000c2  1c40              ADDS     r0,r0,#1
0000c4  6260              STR      r0,[r4,#0x24]
;;;5410   
;;;5411           /* Update counter */
;;;5412           hi2c->XferCount--;
0000c6  8d60              LDRH     r0,[r4,#0x2a]
0000c8  1e40              SUBS     r0,r0,#1
0000ca  8560              STRH     r0,[r4,#0x2a]
;;;5413   
;;;5414           hi2c->State = HAL_I2C_STATE_READY;
0000cc  2020              MOVS     r0,#0x20
0000ce  f884003d          STRB     r0,[r4,#0x3d]
;;;5415           hi2c->Mode = HAL_I2C_MODE_NONE;
0000d2  2000              MOVS     r0,#0
0000d4  f884003e          STRB     r0,[r4,#0x3e]
;;;5416   
;;;5417           /* Call user error callback */
;;;5418   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5419           hi2c->ErrorCallback(hi2c);
;;;5420   #else
;;;5421           HAL_I2C_ErrorCallback(hi2c);
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L57.222|
;;;5422   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5423         }
;;;5424       }
;;;5425       else
;;;5426       {
;;;5427         /* Do nothing */
;;;5428       }
;;;5429     }
0000de  bf00              NOP      
                  |L57.224|
;;;5430   }
0000e0  bd70              POP      {r4-r6,pc}
;;;5431   
                          ENDP


                          AREA ||i.I2C_MasterRequestRead||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestRead PROC
;;;6437     */
;;;6438   static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6439   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;6440     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6441     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000c  6ae7              LDR      r7,[r4,#0x2c]
;;;6442   
;;;6443     /* Enable Acknowledge */
;;;6444     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f4406080          ORR      r0,r0,#0x400
000016  6821              LDR      r1,[r4,#0]
000018  6008              STR      r0,[r1,#0]
;;;6445   
;;;6446     /* Generate Start condition if first transfer */
;;;6447     if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
00001a  2f08              CMP      r7,#8
00001c  d004              BEQ      |L58.40|
00001e  2f01              CMP      r7,#1
000020  d002              BEQ      |L58.40|
000022  f5173f80          CMN      r7,#0x10000
000026  d106              BNE      |L58.54|
                  |L58.40|
;;;6448     {
;;;6449       /* Generate Start */
;;;6450       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f4407080          ORR      r0,r0,#0x100
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
000034  e008              B        |L58.72|
                  |L58.54|
;;;6451     }
;;;6452     else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
000036  6b20              LDR      r0,[r4,#0x30]
000038  2811              CMP      r0,#0x11
00003a  d105              BNE      |L58.72|
;;;6453     {
;;;6454       /* Generate ReStart */
;;;6455       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00003c  6820              LDR      r0,[r4,#0]
00003e  6800              LDR      r0,[r0,#0]
000040  f4407080          ORR      r0,r0,#0x100
000044  6821              LDR      r1,[r4,#0]
000046  6008              STR      r0,[r1,#0]
                  |L58.72|
;;;6456     }
;;;6457     else
;;;6458     {
;;;6459       /* Do nothing */
;;;6460     }
;;;6461   
;;;6462     /* Wait until SB flag is set */
;;;6463     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000048  4643              MOV      r3,r8
00004a  2200              MOVS     r2,#0
00004c  f04f1101          MOV      r1,#0x10001
000050  4620              MOV      r0,r4
000052  9600              STR      r6,[sp,#0]
000054  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000058  b160              CBZ      r0,|L58.116|
;;;6464     {
;;;6465       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
00005a  6820              LDR      r0,[r4,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  f4007080          AND      r0,r0,#0x100
000062  f5b07f80          CMP      r0,#0x100
000066  d102              BNE      |L58.110|
;;;6466       {
;;;6467         hi2c->ErrorCode = HAL_I2C_WRONG_START;
000068  f44f7000          MOV      r0,#0x200
00006c  6420              STR      r0,[r4,#0x40]
                  |L58.110|
;;;6468       }
;;;6469       return HAL_TIMEOUT;
00006e  2003              MOVS     r0,#3
                  |L58.112|
;;;6470     }
;;;6471   
;;;6472     if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;6473     {
;;;6474       /* Send slave address */
;;;6475       hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;6476     }
;;;6477     else
;;;6478     {
;;;6479       /* Send header of slave address */
;;;6480       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;6481   
;;;6482       /* Wait until ADD10 flag is set */
;;;6483       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;6484       {
;;;6485         return HAL_ERROR;
;;;6486       }
;;;6487   
;;;6488       /* Send slave address */
;;;6489       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;6490   
;;;6491       /* Wait until ADDR flag is set */
;;;6492       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6493       {
;;;6494         return HAL_ERROR;
;;;6495       }
;;;6496   
;;;6497       /* Clear ADDR flag */
;;;6498       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6499   
;;;6500       /* Generate Restart */
;;;6501       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;6502   
;;;6503       /* Wait until SB flag is set */
;;;6504       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;6505       {
;;;6506         if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
;;;6507         {
;;;6508           hi2c->ErrorCode = HAL_I2C_WRONG_START;
;;;6509         }
;;;6510         return HAL_TIMEOUT;
;;;6511       }
;;;6512   
;;;6513       /* Send header of slave address */
;;;6514       hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
;;;6515     }
;;;6516   
;;;6517     /* Wait until ADDR flag is set */
;;;6518     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6519     {
;;;6520       return HAL_ERROR;
;;;6521     }
;;;6522   
;;;6523     return HAL_OK;
;;;6524   }
000070  e8bd83f8          POP      {r3-r9,pc}
                  |L58.116|
000074  6920              LDR      r0,[r4,#0x10]         ;6472
000076  f5b04f80          CMP      r0,#0x4000            ;6472
00007a  d105              BNE      |L58.136|
00007c  b2e8              UXTB     r0,r5                 ;6475
00007e  f0400001          ORR      r0,r0,#1              ;6475
000082  6821              LDR      r1,[r4,#0]            ;6475
000084  6108              STR      r0,[r1,#0x10]         ;6475
000086  e049              B        |L58.284|
                  |L58.136|
000088  f4057040          AND      r0,r5,#0x300          ;6480
00008c  21f0              MOVS     r1,#0xf0              ;6480
00008e  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6480
000092  6821              LDR      r1,[r4,#0]            ;6480
000094  6108              STR      r0,[r1,#0x10]         ;6480
000096  4633              MOV      r3,r6                 ;6483
000098  4642              MOV      r2,r8                 ;6483
00009a  4926              LDR      r1,|L58.308|
00009c  4620              MOV      r0,r4                 ;6483
00009e  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000a2  b108              CBZ      r0,|L58.168|
0000a4  2001              MOVS     r0,#1                 ;6485
0000a6  e7e3              B        |L58.112|
                  |L58.168|
0000a8  b2e8              UXTB     r0,r5                 ;6489
0000aa  6821              LDR      r1,[r4,#0]            ;6489
0000ac  6108              STR      r0,[r1,#0x10]         ;6489
0000ae  4633              MOV      r3,r6                 ;6492
0000b0  4642              MOV      r2,r8                 ;6492
0000b2  4920              LDR      r1,|L58.308|
0000b4  1f89              SUBS     r1,r1,#6              ;6492
0000b6  4620              MOV      r0,r4                 ;6492
0000b8  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000bc  b108              CBZ      r0,|L58.194|
0000be  2001              MOVS     r0,#1                 ;6494
0000c0  e7d6              B        |L58.112|
                  |L58.194|
0000c2  bf00              NOP                            ;6498
0000c4  2000              MOVS     r0,#0                 ;6498
0000c6  9000              STR      r0,[sp,#0]            ;6498
0000c8  6820              LDR      r0,[r4,#0]            ;6498
0000ca  6940              LDR      r0,[r0,#0x14]         ;6498
0000cc  9000              STR      r0,[sp,#0]            ;6498
0000ce  6820              LDR      r0,[r4,#0]            ;6498
0000d0  6980              LDR      r0,[r0,#0x18]         ;6498
0000d2  9000              STR      r0,[sp,#0]            ;6498
0000d4  bf00              NOP                            ;6498
0000d6  bf00              NOP                            ;6498
0000d8  6820              LDR      r0,[r4,#0]            ;6501
0000da  6800              LDR      r0,[r0,#0]            ;6501
0000dc  f4407080          ORR      r0,r0,#0x100          ;6501
0000e0  6821              LDR      r1,[r4,#0]            ;6501
0000e2  6008              STR      r0,[r1,#0]            ;6501
0000e4  4643              MOV      r3,r8                 ;6504
0000e6  2200              MOVS     r2,#0                 ;6504
0000e8  f04f1101          MOV      r1,#0x10001           ;6504
0000ec  4620              MOV      r0,r4                 ;6504
0000ee  9600              STR      r6,[sp,#0]            ;6504
0000f0  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000f4  b158              CBZ      r0,|L58.270|
0000f6  6820              LDR      r0,[r4,#0]            ;6506
0000f8  6800              LDR      r0,[r0,#0]            ;6506
0000fa  f4007080          AND      r0,r0,#0x100          ;6506
0000fe  f5b07f80          CMP      r0,#0x100             ;6506
000102  d102              BNE      |L58.266|
000104  f44f7000          MOV      r0,#0x200             ;6508
000108  6420              STR      r0,[r4,#0x40]         ;6508
                  |L58.266|
00010a  2003              MOVS     r0,#3                 ;6510
00010c  e7b0              B        |L58.112|
                  |L58.270|
00010e  f4057040          AND      r0,r5,#0x300          ;6514
000112  21f1              MOVS     r1,#0xf1              ;6514
000114  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6514
000118  6821              LDR      r1,[r4,#0]            ;6514
00011a  6108              STR      r0,[r1,#0x10]         ;6514
                  |L58.284|
00011c  4633              MOV      r3,r6                 ;6518
00011e  4642              MOV      r2,r8                 ;6518
000120  4904              LDR      r1,|L58.308|
000122  1f89              SUBS     r1,r1,#6              ;6518
000124  4620              MOV      r0,r4                 ;6518
000126  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00012a  b108              CBZ      r0,|L58.304|
00012c  2001              MOVS     r0,#1                 ;6520
00012e  e79f              B        |L58.112|
                  |L58.304|
000130  2000              MOVS     r0,#0                 ;6523
000132  e79d              B        |L58.112|
;;;6525   
                          ENDP

                  |L58.308|
                          DCD      0x00010008

                          AREA ||i.I2C_MasterRequestWrite||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestWrite PROC
;;;6367     */
;;;6368   static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6369   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;6370     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6371     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000c  6ae6              LDR      r6,[r4,#0x2c]
;;;6372   
;;;6373     /* Generate Start condition if first transfer */
;;;6374     if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
00000e  2e08              CMP      r6,#8
000010  d004              BEQ      |L59.28|
000012  2e01              CMP      r6,#1
000014  d002              BEQ      |L59.28|
000016  f5163f80          CMN      r6,#0x10000
00001a  d106              BNE      |L59.42|
                  |L59.28|
;;;6375     {
;;;6376       /* Generate Start */
;;;6377       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4407080          ORR      r0,r0,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  6008              STR      r0,[r1,#0]
000028  e008              B        |L59.60|
                  |L59.42|
;;;6378     }
;;;6379     else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  2812              CMP      r0,#0x12
00002e  d105              BNE      |L59.60|
;;;6380     {
;;;6381       /* Generate ReStart */
;;;6382       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000030  6820              LDR      r0,[r4,#0]
000032  6800              LDR      r0,[r0,#0]
000034  f4407080          ORR      r0,r0,#0x100
000038  6821              LDR      r1,[r4,#0]
00003a  6008              STR      r0,[r1,#0]
                  |L59.60|
;;;6383     }
;;;6384     else
;;;6385     {
;;;6386       /* Do nothing */
;;;6387     }
;;;6388   
;;;6389     /* Wait until SB flag is set */
;;;6390     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
00003c  463b              MOV      r3,r7
00003e  2200              MOVS     r2,#0
000040  f04f1101          MOV      r1,#0x10001
000044  4620              MOV      r0,r4
000046  f8cd8000          STR      r8,[sp,#0]
00004a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00004e  b160              CBZ      r0,|L59.106|
;;;6391     {
;;;6392       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
000050  6820              LDR      r0,[r4,#0]
000052  6800              LDR      r0,[r0,#0]
000054  f4007080          AND      r0,r0,#0x100
000058  f5b07f80          CMP      r0,#0x100
00005c  d102              BNE      |L59.100|
;;;6393       {
;;;6394         hi2c->ErrorCode = HAL_I2C_WRONG_START;
00005e  f44f7000          MOV      r0,#0x200
000062  6420              STR      r0,[r4,#0x40]
                  |L59.100|
;;;6395       }
;;;6396       return HAL_TIMEOUT;
000064  2003              MOVS     r0,#3
                  |L59.102|
;;;6397     }
;;;6398   
;;;6399     if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;6400     {
;;;6401       /* Send slave address */
;;;6402       hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6403     }
;;;6404     else
;;;6405     {
;;;6406       /* Send header of slave address */
;;;6407       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;6408   
;;;6409       /* Wait until ADD10 flag is set */
;;;6410       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;6411       {
;;;6412         return HAL_ERROR;
;;;6413       }
;;;6414   
;;;6415       /* Send slave address */
;;;6416       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;6417     }
;;;6418   
;;;6419     /* Wait until ADDR flag is set */
;;;6420     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6421     {
;;;6422       return HAL_ERROR;
;;;6423     }
;;;6424   
;;;6425     return HAL_OK;
;;;6426   }
000066  e8bd83f8          POP      {r3-r9,pc}
                  |L59.106|
00006a  6920              LDR      r0,[r4,#0x10]         ;6399
00006c  f5b04f80          CMP      r0,#0x4000            ;6399
000070  d104              BNE      |L59.124|
000072  f00500fe          AND      r0,r5,#0xfe           ;6402
000076  6821              LDR      r1,[r4,#0]            ;6402
000078  6108              STR      r0,[r1,#0x10]         ;6402
00007a  e012              B        |L59.162|
                  |L59.124|
00007c  f4057040          AND      r0,r5,#0x300          ;6407
000080  21f0              MOVS     r1,#0xf0              ;6407
000082  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6407
000086  6821              LDR      r1,[r4,#0]            ;6407
000088  6108              STR      r0,[r1,#0x10]         ;6407
00008a  4643              MOV      r3,r8                 ;6410
00008c  463a              MOV      r2,r7                 ;6410
00008e  490b              LDR      r1,|L59.188|
000090  4620              MOV      r0,r4                 ;6410
000092  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000096  b108              CBZ      r0,|L59.156|
000098  2001              MOVS     r0,#1                 ;6412
00009a  e7e4              B        |L59.102|
                  |L59.156|
00009c  b2e8              UXTB     r0,r5                 ;6416
00009e  6821              LDR      r1,[r4,#0]            ;6416
0000a0  6108              STR      r0,[r1,#0x10]         ;6416
                  |L59.162|
0000a2  4643              MOV      r3,r8                 ;6420
0000a4  463a              MOV      r2,r7                 ;6420
0000a6  4905              LDR      r1,|L59.188|
0000a8  1f89              SUBS     r1,r1,#6              ;6420
0000aa  4620              MOV      r0,r4                 ;6420
0000ac  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000b0  b108              CBZ      r0,|L59.182|
0000b2  2001              MOVS     r0,#1                 ;6422
0000b4  e7d7              B        |L59.102|
                  |L59.182|
0000b6  2000              MOVS     r0,#0                 ;6425
0000b8  e7d5              B        |L59.102|
;;;6427   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L59.188|
                          DCD      0x00010008

                          AREA ||i.I2C_MasterTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_BTF PROC
;;;5178     */
;;;5179   static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5180   {
000002  4604              MOV      r4,r0
;;;5181     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5182     uint32_t CurrentXferOptions = hi2c->XferOptions;
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;5183   
;;;5184     if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2821              CMP      r0,#0x21
00000c  d13c              BNE      |L60.136|
;;;5185     {
;;;5186       if (hi2c->XferCount != 0U)
00000e  8d60              LDRH     r0,[r4,#0x2a]
000010  b150              CBZ      r0,|L60.40|
;;;5187       {
;;;5188         /* Write data to DR */
;;;5189         hi2c->Instance->DR = *hi2c->pBuffPtr;
000012  6a60              LDR      r0,[r4,#0x24]
000014  7800              LDRB     r0,[r0,#0]
000016  6821              LDR      r1,[r4,#0]
000018  6108              STR      r0,[r1,#0x10]
;;;5190   
;;;5191         /* Increment Buffer pointer */
;;;5192         hi2c->pBuffPtr++;
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  1c40              ADDS     r0,r0,#1
00001e  6260              STR      r0,[r4,#0x24]
;;;5193   
;;;5194         /* Update counter */
;;;5195         hi2c->XferCount--;
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  1e40              SUBS     r0,r0,#1
000024  8560              STRH     r0,[r4,#0x2a]
000026  e02f              B        |L60.136|
                  |L60.40|
;;;5196       }
;;;5197       else
;;;5198       {
;;;5199         /* Call TxCpltCallback() directly if no stop mode is set */
;;;5200         if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
000028  2d08              CMP      r5,#8
00002a  d016              BEQ      |L60.90|
00002c  2d20              CMP      r5,#0x20
00002e  d014              BEQ      |L60.90|
000030  f5153f80          CMN      r5,#0x10000
000034  d011              BEQ      |L60.90|
;;;5201         {
;;;5202           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000036  6820              LDR      r0,[r4,#0]
000038  6840              LDR      r0,[r0,#4]
00003a  f42060e0          BIC      r0,r0,#0x700
00003e  6821              LDR      r1,[r4,#0]
000040  6048              STR      r0,[r1,#4]
;;;5203   
;;;5204           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
000042  2011              MOVS     r0,#0x11
000044  6320              STR      r0,[r4,#0x30]
;;;5205           hi2c->Mode = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;5206           hi2c->State = HAL_I2C_STATE_READY;
00004c  2020              MOVS     r0,#0x20
00004e  f884003d          STRB     r0,[r4,#0x3d]
;;;5207   
;;;5208   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5209           hi2c->MasterTxCpltCallback(hi2c);
;;;5210   #else
;;;5211           HAL_I2C_MasterTxCpltCallback(hi2c);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000058  e016              B        |L60.136|
                  |L60.90|
;;;5212   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5213         }
;;;5214         else /* Generate Stop condition then Call TxCpltCallback() */
;;;5215         {
;;;5216           /* Disable EVT, BUF and ERR interrupt */
;;;5217           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00005a  6820              LDR      r0,[r4,#0]
00005c  6840              LDR      r0,[r0,#4]
00005e  f42060e0          BIC      r0,r0,#0x700
000062  6821              LDR      r1,[r4,#0]
000064  6048              STR      r0,[r1,#4]
;;;5218   
;;;5219           /* Generate Stop */
;;;5220           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f4407000          ORR      r0,r0,#0x200
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
;;;5221   
;;;5222           hi2c->PreviousState = I2C_STATE_NONE;
000072  2000              MOVS     r0,#0
000074  6320              STR      r0,[r4,#0x30]
;;;5223           hi2c->State = HAL_I2C_STATE_READY;
000076  2020              MOVS     r0,#0x20
000078  f884003d          STRB     r0,[r4,#0x3d]
;;;5224           hi2c->Mode = HAL_I2C_MODE_NONE;
00007c  2000              MOVS     r0,#0
00007e  f884003e          STRB     r0,[r4,#0x3e]
;;;5225   
;;;5226   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5227           hi2c->MasterTxCpltCallback(hi2c);
;;;5228   #else
;;;5229           HAL_I2C_MasterTxCpltCallback(hi2c);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
                  |L60.136|
;;;5230   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5231         }
;;;5232       }
;;;5233     }
;;;5234     else
;;;5235     {
;;;5236       /* Do nothing */
;;;5237     }
;;;5238   }
000088  bd70              POP      {r4-r6,pc}
;;;5239   
                          ENDP


                          AREA ||i.I2C_MasterTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_TXE PROC
;;;5084     */
;;;5085   static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5086   {
000004  4604              MOV      r4,r0
;;;5087     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5088     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000006  f894503d          LDRB     r5,[r4,#0x3d]
;;;5089     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
00000a  f894703e          LDRB     r7,[r4,#0x3e]
;;;5090     uint32_t CurrentXferOptions       = hi2c->XferOptions;
00000e  6ae6              LDR      r6,[r4,#0x2c]
;;;5091   
;;;5092     if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
000010  8d20              LDRH     r0,[r4,#0x28]
000012  bbb0              CBNZ     r0,|L61.130|
000014  2d21              CMP      r5,#0x21
000016  d13c              BNE      |L61.146|
;;;5093     {
;;;5094       /* Call TxCpltCallback() directly if no stop mode is set */
;;;5095       if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
000018  2e08              CMP      r6,#8
00001a  d016              BEQ      |L61.74|
00001c  2e20              CMP      r6,#0x20
00001e  d014              BEQ      |L61.74|
000020  f5163f80          CMN      r6,#0x10000
000024  d011              BEQ      |L61.74|
;;;5096       {
;;;5097         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000026  6820              LDR      r0,[r4,#0]
000028  6840              LDR      r0,[r0,#4]
00002a  f42060e0          BIC      r0,r0,#0x700
00002e  6821              LDR      r1,[r4,#0]
000030  6048              STR      r0,[r1,#4]
;;;5098   
;;;5099         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
000032  2011              MOVS     r0,#0x11
000034  6320              STR      r0,[r4,#0x30]
;;;5100         hi2c->Mode = HAL_I2C_MODE_NONE;
000036  2000              MOVS     r0,#0
000038  f884003e          STRB     r0,[r4,#0x3e]
;;;5101         hi2c->State = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;5102   
;;;5103   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5104         hi2c->MasterTxCpltCallback(hi2c);
;;;5105   #else
;;;5106         HAL_I2C_MasterTxCpltCallback(hi2c);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000048  e044              B        |L61.212|
                  |L61.74|
;;;5107   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5108       }
;;;5109       else /* Generate Stop condition then Call TxCpltCallback() */
;;;5110       {
;;;5111         /* Disable EVT, BUF and ERR interrupt */
;;;5112         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00004a  6820              LDR      r0,[r4,#0]
00004c  6840              LDR      r0,[r0,#4]
00004e  f42060e0          BIC      r0,r0,#0x700
000052  6821              LDR      r1,[r4,#0]
000054  6048              STR      r0,[r1,#4]
;;;5113   
;;;5114         /* Generate Stop */
;;;5115         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f4407000          ORR      r0,r0,#0x200
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
;;;5116   
;;;5117         hi2c->PreviousState = I2C_STATE_NONE;
000062  2000              MOVS     r0,#0
000064  6320              STR      r0,[r4,#0x30]
;;;5118         hi2c->State = HAL_I2C_STATE_READY;
000066  2020              MOVS     r0,#0x20
000068  f884003d          STRB     r0,[r4,#0x3d]
;;;5119   
;;;5120         if (hi2c->Mode == HAL_I2C_MODE_MEM)
00006c  f894003e          LDRB     r0,[r4,#0x3e]
000070  2840              CMP      r0,#0x40
000072  d107              BNE      |L61.132|
;;;5121         {
;;;5122           hi2c->Mode = HAL_I2C_MODE_NONE;
000074  2000              MOVS     r0,#0
000076  f884003e          STRB     r0,[r4,#0x3e]
;;;5123   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5124           hi2c->MemTxCpltCallback(hi2c);
;;;5125   #else
;;;5126           HAL_I2C_MemTxCpltCallback(hi2c);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000080  e028              B        |L61.212|
                  |L61.130|
000082  e006              B        |L61.146|
                  |L61.132|
;;;5127   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5128         }
;;;5129         else
;;;5130         {
;;;5131           hi2c->Mode = HAL_I2C_MODE_NONE;
000084  2000              MOVS     r0,#0
000086  f884003e          STRB     r0,[r4,#0x3e]
;;;5132   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5133           hi2c->MasterTxCpltCallback(hi2c);
;;;5134   #else
;;;5135           HAL_I2C_MasterTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000090  e020              B        |L61.212|
                  |L61.146|
;;;5136   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5137         }
;;;5138       }
;;;5139     }
;;;5140     else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
000092  2d21              CMP      r5,#0x21
000094  d003              BEQ      |L61.158|
;;;5141              ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
000096  2f40              CMP      r7,#0x40
000098  d11c              BNE      |L61.212|
00009a  2d22              CMP      r5,#0x22
00009c  d11a              BNE      |L61.212|
                  |L61.158|
;;;5142     {
;;;5143       if (hi2c->XferCount == 0U)
00009e  8d60              LDRH     r0,[r4,#0x2a]
0000a0  b930              CBNZ     r0,|L61.176|
;;;5144       {
;;;5145         /* Disable BUF interrupt */
;;;5146         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6840              LDR      r0,[r0,#4]
0000a6  f4206080          BIC      r0,r0,#0x400
0000aa  6821              LDR      r1,[r4,#0]
0000ac  6048              STR      r0,[r1,#4]
0000ae  e011              B        |L61.212|
                  |L61.176|
;;;5147       }
;;;5148       else
;;;5149       {
;;;5150         if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000b0  f894003e          LDRB     r0,[r4,#0x3e]
0000b4  2840              CMP      r0,#0x40
0000b6  d103              BNE      |L61.192|
;;;5151         {
;;;5152           I2C_MemoryTransmit_TXE_BTF(hi2c);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       I2C_MemoryTransmit_TXE_BTF
0000be  e009              B        |L61.212|
                  |L61.192|
;;;5153         }
;;;5154         else
;;;5155         {
;;;5156           /* Write data to DR */
;;;5157           hi2c->Instance->DR = *hi2c->pBuffPtr;
0000c0  6a60              LDR      r0,[r4,#0x24]
0000c2  7800              LDRB     r0,[r0,#0]
0000c4  6821              LDR      r1,[r4,#0]
0000c6  6108              STR      r0,[r1,#0x10]
;;;5158   
;;;5159           /* Increment Buffer pointer */
;;;5160           hi2c->pBuffPtr++;
0000c8  6a60              LDR      r0,[r4,#0x24]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  6260              STR      r0,[r4,#0x24]
;;;5161   
;;;5162           /* Update counter */
;;;5163           hi2c->XferCount--;
0000ce  8d60              LDRH     r0,[r4,#0x2a]
0000d0  1e40              SUBS     r0,r0,#1
0000d2  8560              STRH     r0,[r4,#0x2a]
                  |L61.212|
;;;5164         }
;;;5165       }
;;;5166     }
;;;5167     else
;;;5168     {
;;;5169       /* Do nothing */
;;;5170     }
;;;5171   }
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;5172   
                          ENDP


                          AREA ||i.I2C_Master_ADD10||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADD10 PROC
;;;5624     */
;;;5625   static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
000000  6c41              LDR      r1,[r0,#0x44]
;;;5626   {
;;;5627     /* Send slave address */
;;;5628     hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
000002  b2c9              UXTB     r1,r1
000004  6802              LDR      r2,[r0,#0]
000006  6111              STR      r1,[r2,#0x10]
;;;5629   
;;;5630     if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
000008  6b41              LDR      r1,[r0,#0x34]
00000a  b909              CBNZ     r1,|L62.16|
00000c  6b81              LDR      r1,[r0,#0x38]
00000e  b159              CBZ      r1,|L62.40|
                  |L62.16|
;;;5631     {
;;;5632       if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
000010  6b41              LDR      r1,[r0,#0x34]
000012  6bc9              LDR      r1,[r1,#0x3c]
000014  b911              CBNZ     r1,|L62.28|
000016  6b81              LDR      r1,[r0,#0x38]
000018  6bc9              LDR      r1,[r1,#0x3c]
00001a  b129              CBZ      r1,|L62.40|
                  |L62.28|
;;;5633       {
;;;5634         /* Enable DMA Request */
;;;5635         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
00001c  6801              LDR      r1,[r0,#0]
00001e  6849              LDR      r1,[r1,#4]
000020  f4416100          ORR      r1,r1,#0x800
000024  6802              LDR      r2,[r0,#0]
000026  6051              STR      r1,[r2,#4]
                  |L62.40|
;;;5636       }
;;;5637     }
;;;5638   }
000028  4770              BX       lr
;;;5639   
                          ENDP


                          AREA ||i.I2C_Master_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADDR PROC
;;;5645     */
;;;5646   static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
000000  b538              PUSH     {r3-r5,lr}
;;;5647   {
;;;5648     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;5649     HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
000002  f890203e          LDRB     r2,[r0,#0x3e]
;;;5650     uint32_t CurrentXferOptions           = hi2c->XferOptions;
000006  6ac1              LDR      r1,[r0,#0x2c]
;;;5651     uint32_t Prev_State                   = hi2c->PreviousState;
000008  6b03              LDR      r3,[r0,#0x30]
;;;5652   
;;;5653     if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
00000a  f890403d          LDRB     r4,[r0,#0x3d]
00000e  2c22              CMP      r4,#0x22
000010  d173              BNE      |L63.250|
;;;5654     {
;;;5655       if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
000012  6d04              LDR      r4,[r0,#0x50]
000014  b964              CBNZ     r4,|L63.48|
000016  2a40              CMP      r2,#0x40
000018  d10a              BNE      |L63.48|
;;;5656       {
;;;5657         /* Clear ADDR flag */
;;;5658         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00001a  bf00              NOP      
00001c  2400              MOVS     r4,#0
00001e  9400              STR      r4,[sp,#0]
000020  6804              LDR      r4,[r0,#0]
000022  6964              LDR      r4,[r4,#0x14]
000024  9400              STR      r4,[sp,#0]
000026  6804              LDR      r4,[r0,#0]
000028  69a4              LDR      r4,[r4,#0x18]
00002a  9400              STR      r4,[sp,#0]
00002c  bf00              NOP      
00002e  e11a              B        |L63.614|
                  |L63.48|
;;;5659       }
;;;5660       else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
000030  6d04              LDR      r4,[r0,#0x50]
000032  b9c4              CBNZ     r4,|L63.102|
000034  6904              LDR      r4,[r0,#0x10]
000036  f5b44f40          CMP      r4,#0xc000
00003a  d114              BNE      |L63.102|
;;;5661       {
;;;5662         /* Clear ADDR flag */
;;;5663         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00003c  bf00              NOP      
00003e  2400              MOVS     r4,#0
000040  9400              STR      r4,[sp,#0]
000042  6804              LDR      r4,[r0,#0]
000044  6964              LDR      r4,[r4,#0x14]
000046  9400              STR      r4,[sp,#0]
000048  6804              LDR      r4,[r0,#0]
00004a  69a4              LDR      r4,[r4,#0x18]
00004c  9400              STR      r4,[sp,#0]
00004e  bf00              NOP      
000050  bf00              NOP      
;;;5664   
;;;5665         /* Generate Restart */
;;;5666         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000052  6804              LDR      r4,[r0,#0]
000054  6824              LDR      r4,[r4,#0]
000056  f4447480          ORR      r4,r4,#0x100
00005a  6805              LDR      r5,[r0,#0]
00005c  602c              STR      r4,[r5,#0]
;;;5667   
;;;5668         hi2c->EventCount++;
00005e  6d04              LDR      r4,[r0,#0x50]
000060  1c64              ADDS     r4,r4,#1
000062  6504              STR      r4,[r0,#0x50]
000064  e0ff              B        |L63.614|
                  |L63.102|
;;;5669       }
;;;5670       else
;;;5671       {
;;;5672         if (hi2c->XferCount == 0U)
000066  8d44              LDRH     r4,[r0,#0x2a]
000068  b98c              CBNZ     r4,|L63.142|
;;;5673         {
;;;5674           /* Clear ADDR flag */
;;;5675           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00006a  bf00              NOP      
00006c  2400              MOVS     r4,#0
00006e  9400              STR      r4,[sp,#0]
000070  6804              LDR      r4,[r0,#0]
000072  6964              LDR      r4,[r4,#0x14]
000074  9400              STR      r4,[sp,#0]
000076  6804              LDR      r4,[r0,#0]
000078  69a4              LDR      r4,[r4,#0x18]
00007a  9400              STR      r4,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
;;;5676   
;;;5677           /* Generate Stop */
;;;5678           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000080  6804              LDR      r4,[r0,#0]
000082  6824              LDR      r4,[r4,#0]
000084  f4447400          ORR      r4,r4,#0x200
000088  6805              LDR      r5,[r0,#0]
00008a  602c              STR      r4,[r5,#0]
00008c  e0dd              B        |L63.586|
                  |L63.142|
;;;5679         }
;;;5680         else if (hi2c->XferCount == 1U)
00008e  8d44              LDRH     r4,[r0,#0x2a]
000090  2c01              CMP      r4,#1
000092  d172              BNE      |L63.378|
;;;5681         {
;;;5682           if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
000094  f5113f80          CMN      r1,#0x10000
000098  d130              BNE      |L63.252|
;;;5683           {
;;;5684             /* Disable Acknowledge */
;;;5685             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00009a  6804              LDR      r4,[r0,#0]
00009c  6824              LDR      r4,[r4,#0]
00009e  f4246480          BIC      r4,r4,#0x400
0000a2  6805              LDR      r5,[r0,#0]
0000a4  602c              STR      r4,[r5,#0]
;;;5686   
;;;5687             if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
0000a6  6804              LDR      r4,[r0,#0]
0000a8  6864              LDR      r4,[r4,#4]
0000aa  f4046400          AND      r4,r4,#0x800
0000ae  f5b46f00          CMP      r4,#0x800
0000b2  d110              BNE      |L63.214|
;;;5688             {
;;;5689               /* Disable Acknowledge */
;;;5690               CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0000b4  6804              LDR      r4,[r0,#0]
0000b6  6824              LDR      r4,[r4,#0]
0000b8  f4246480          BIC      r4,r4,#0x400
0000bc  6805              LDR      r5,[r0,#0]
0000be  602c              STR      r4,[r5,#0]
;;;5691   
;;;5692               /* Clear ADDR flag */
;;;5693               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0000c0  bf00              NOP      
0000c2  2400              MOVS     r4,#0
0000c4  9400              STR      r4,[sp,#0]
0000c6  6804              LDR      r4,[r0,#0]
0000c8  6964              LDR      r4,[r4,#0x14]
0000ca  9400              STR      r4,[sp,#0]
0000cc  6804              LDR      r4,[r0,#0]
0000ce  69a4              LDR      r4,[r4,#0x18]
0000d0  9400              STR      r4,[sp,#0]
0000d2  bf00              NOP      
0000d4  e0b9              B        |L63.586|
                  |L63.214|
;;;5694             }
;;;5695             else
;;;5696             {
;;;5697               /* Clear ADDR flag */
;;;5698               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0000d6  bf00              NOP      
0000d8  2400              MOVS     r4,#0
0000da  9400              STR      r4,[sp,#0]
0000dc  6804              LDR      r4,[r0,#0]
0000de  6964              LDR      r4,[r4,#0x14]
0000e0  9400              STR      r4,[sp,#0]
0000e2  6804              LDR      r4,[r0,#0]
0000e4  69a4              LDR      r4,[r4,#0x18]
0000e6  9400              STR      r4,[sp,#0]
0000e8  bf00              NOP      
0000ea  bf00              NOP      
;;;5699   
;;;5700               /* Generate Stop */
;;;5701               SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000ec  6804              LDR      r4,[r0,#0]
0000ee  6824              LDR      r4,[r4,#0]
0000f0  f4447400          ORR      r4,r4,#0x200
0000f4  6805              LDR      r5,[r0,#0]
0000f6  602c              STR      r4,[r5,#0]
0000f8  e0a7              B        |L63.586|
                  |L63.250|
0000fa  e0a9              B        |L63.592|
                  |L63.252|
;;;5702             }
;;;5703           }
;;;5704           /* Prepare next transfer or stop current transfer */
;;;5705           else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
0000fc  2908              CMP      r1,#8
0000fe  d023              BEQ      |L63.328|
000100  2920              CMP      r1,#0x20
000102  d021              BEQ      |L63.328|
;;;5706                    && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
000104  2b12              CMP      r3,#0x12
000106  d101              BNE      |L63.268|
000108  2901              CMP      r1,#1
00010a  d11d              BNE      |L63.328|
                  |L63.268|
;;;5707           {
;;;5708             if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
00010c  2904              CMP      r1,#4
00010e  d00a              BEQ      |L63.294|
000110  2902              CMP      r1,#2
000112  d008              BEQ      |L63.294|
000114  2910              CMP      r1,#0x10
000116  d006              BEQ      |L63.294|
;;;5709             {
;;;5710               /* Disable Acknowledge */
;;;5711               CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000118  6804              LDR      r4,[r0,#0]
00011a  6824              LDR      r4,[r4,#0]
00011c  f4246480          BIC      r4,r4,#0x400
000120  6805              LDR      r5,[r0,#0]
000122  602c              STR      r4,[r5,#0]
000124  e005              B        |L63.306|
                  |L63.294|
;;;5712             }
;;;5713             else
;;;5714             {
;;;5715               /* Enable Acknowledge */
;;;5716               SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000126  6804              LDR      r4,[r0,#0]
000128  6824              LDR      r4,[r4,#0]
00012a  f4446480          ORR      r4,r4,#0x400
00012e  6805              LDR      r5,[r0,#0]
000130  602c              STR      r4,[r5,#0]
                  |L63.306|
;;;5717             }
;;;5718   
;;;5719             /* Clear ADDR flag */
;;;5720             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000132  bf00              NOP      
000134  2400              MOVS     r4,#0
000136  9400              STR      r4,[sp,#0]
000138  6804              LDR      r4,[r0,#0]
00013a  6964              LDR      r4,[r4,#0x14]
00013c  9400              STR      r4,[sp,#0]
00013e  6804              LDR      r4,[r0,#0]
000140  69a4              LDR      r4,[r4,#0x18]
000142  9400              STR      r4,[sp,#0]
000144  bf00              NOP      
000146  e080              B        |L63.586|
                  |L63.328|
;;;5721           }
;;;5722           else
;;;5723           {
;;;5724             /* Disable Acknowledge */
;;;5725             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000148  6804              LDR      r4,[r0,#0]
00014a  6824              LDR      r4,[r4,#0]
00014c  f4246480          BIC      r4,r4,#0x400
000150  6805              LDR      r5,[r0,#0]
000152  602c              STR      r4,[r5,#0]
;;;5726   
;;;5727             /* Clear ADDR flag */
;;;5728             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000154  bf00              NOP      
000156  2400              MOVS     r4,#0
000158  9400              STR      r4,[sp,#0]
00015a  6804              LDR      r4,[r0,#0]
00015c  6964              LDR      r4,[r4,#0x14]
00015e  9400              STR      r4,[sp,#0]
000160  6804              LDR      r4,[r0,#0]
000162  69a4              LDR      r4,[r4,#0x18]
000164  9400              STR      r4,[sp,#0]
000166  bf00              NOP      
000168  bf00              NOP      
;;;5729   
;;;5730             /* Generate Stop */
;;;5731             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00016a  6804              LDR      r4,[r0,#0]
00016c  6824              LDR      r4,[r4,#0]
00016e  f4447400          ORR      r4,r4,#0x200
000172  6805              LDR      r5,[r0,#0]
000174  602c              STR      r4,[r5,#0]
000176  e068              B        |L63.586|
000178  e7ff              B        |L63.378|
                  |L63.378|
;;;5732           }
;;;5733         }
;;;5734         else if (hi2c->XferCount == 2U)
00017a  8d44              LDRH     r4,[r0,#0x2a]
00017c  2c02              CMP      r4,#2
00017e  d13b              BNE      |L63.504|
;;;5735         {
;;;5736           if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
000180  2904              CMP      r1,#4
000182  d010              BEQ      |L63.422|
000184  2902              CMP      r1,#2
000186  d00e              BEQ      |L63.422|
000188  2910              CMP      r1,#0x10
00018a  d00c              BEQ      |L63.422|
;;;5737           {
;;;5738             /* Disable Acknowledge */
;;;5739             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00018c  6804              LDR      r4,[r0,#0]
00018e  6824              LDR      r4,[r4,#0]
000190  f4246480          BIC      r4,r4,#0x400
000194  6805              LDR      r5,[r0,#0]
000196  602c              STR      r4,[r5,#0]
;;;5740   
;;;5741             /* Enable Pos */
;;;5742             SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000198  6804              LDR      r4,[r0,#0]
00019a  6824              LDR      r4,[r4,#0]
00019c  f4446400          ORR      r4,r4,#0x800
0001a0  6805              LDR      r5,[r0,#0]
0001a2  602c              STR      r4,[r5,#0]
0001a4  e005              B        |L63.434|
                  |L63.422|
;;;5743           }
;;;5744           else
;;;5745           {
;;;5746             /* Enable Acknowledge */
;;;5747             SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0001a6  6804              LDR      r4,[r0,#0]
0001a8  6824              LDR      r4,[r4,#0]
0001aa  f4446480          ORR      r4,r4,#0x400
0001ae  6805              LDR      r5,[r0,#0]
0001b0  602c              STR      r4,[r5,#0]
                  |L63.434|
;;;5748           }
;;;5749   
;;;5750           if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
0001b2  6804              LDR      r4,[r0,#0]
0001b4  6864              LDR      r4,[r4,#4]
0001b6  f4046400          AND      r4,r4,#0x800
0001ba  f5b46f00          CMP      r4,#0x800
0001be  d110              BNE      |L63.482|
0001c0  f5113f80          CMN      r1,#0x10000
0001c4  d007              BEQ      |L63.470|
0001c6  2901              CMP      r1,#1
0001c8  d005              BEQ      |L63.470|
0001ca  2908              CMP      r1,#8
0001cc  d003              BEQ      |L63.470|
0001ce  2910              CMP      r1,#0x10
0001d0  d001              BEQ      |L63.470|
0001d2  2920              CMP      r1,#0x20
0001d4  d105              BNE      |L63.482|
                  |L63.470|
;;;5751           {
;;;5752             /* Enable Last DMA bit */
;;;5753             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
0001d6  6804              LDR      r4,[r0,#0]
0001d8  6864              LDR      r4,[r4,#4]
0001da  f4445480          ORR      r4,r4,#0x1000
0001de  6805              LDR      r5,[r0,#0]
0001e0  606c              STR      r4,[r5,#4]
                  |L63.482|
;;;5754           }
;;;5755   
;;;5756           /* Clear ADDR flag */
;;;5757           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0001e2  bf00              NOP      
0001e4  2400              MOVS     r4,#0
0001e6  9400              STR      r4,[sp,#0]
0001e8  6804              LDR      r4,[r0,#0]
0001ea  6964              LDR      r4,[r4,#0x14]
0001ec  9400              STR      r4,[sp,#0]
0001ee  6804              LDR      r4,[r0,#0]
0001f0  69a4              LDR      r4,[r4,#0x18]
0001f2  9400              STR      r4,[sp,#0]
0001f4  bf00              NOP      
0001f6  e028              B        |L63.586|
                  |L63.504|
;;;5758         }
;;;5759         else
;;;5760         {
;;;5761           /* Enable Acknowledge */
;;;5762           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0001f8  6804              LDR      r4,[r0,#0]
0001fa  6824              LDR      r4,[r4,#0]
0001fc  f4446480          ORR      r4,r4,#0x400
000200  6805              LDR      r5,[r0,#0]
000202  602c              STR      r4,[r5,#0]
;;;5763   
;;;5764           if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
000204  6804              LDR      r4,[r0,#0]
000206  6864              LDR      r4,[r4,#4]
000208  f4046400          AND      r4,r4,#0x800
00020c  f5b46f00          CMP      r4,#0x800
000210  d110              BNE      |L63.564|
000212  f5113f80          CMN      r1,#0x10000
000216  d007              BEQ      |L63.552|
000218  2901              CMP      r1,#1
00021a  d005              BEQ      |L63.552|
00021c  2908              CMP      r1,#8
00021e  d003              BEQ      |L63.552|
000220  2910              CMP      r1,#0x10
000222  d001              BEQ      |L63.552|
000224  2920              CMP      r1,#0x20
000226  d105              BNE      |L63.564|
                  |L63.552|
;;;5765           {
;;;5766             /* Enable Last DMA bit */
;;;5767             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
000228  6804              LDR      r4,[r0,#0]
00022a  6864              LDR      r4,[r4,#4]
00022c  f4445480          ORR      r4,r4,#0x1000
000230  6805              LDR      r5,[r0,#0]
000232  606c              STR      r4,[r5,#4]
                  |L63.564|
;;;5768           }
;;;5769   
;;;5770           /* Clear ADDR flag */
;;;5771           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000234  bf00              NOP      
000236  2400              MOVS     r4,#0
000238  9400              STR      r4,[sp,#0]
00023a  6804              LDR      r4,[r0,#0]
00023c  6964              LDR      r4,[r4,#0x14]
00023e  9400              STR      r4,[sp,#0]
000240  6804              LDR      r4,[r0,#0]
000242  69a4              LDR      r4,[r4,#0x18]
000244  9400              STR      r4,[sp,#0]
000246  bf00              NOP      
000248  bf00              NOP      
                  |L63.586|
;;;5772         }
;;;5773   
;;;5774         /* Reset Event counter  */
;;;5775         hi2c->EventCount = 0U;
00024a  2400              MOVS     r4,#0
00024c  6504              STR      r4,[r0,#0x50]
00024e  e00a              B        |L63.614|
                  |L63.592|
;;;5776       }
;;;5777     }
;;;5778     else
;;;5779     {
;;;5780       /* Clear ADDR flag */
;;;5781       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000250  bf00              NOP      
000252  2400              MOVS     r4,#0
000254  9400              STR      r4,[sp,#0]
000256  6804              LDR      r4,[r0,#0]
000258  6964              LDR      r4,[r4,#0x14]
00025a  9400              STR      r4,[sp,#0]
00025c  6804              LDR      r4,[r0,#0]
00025e  69a4              LDR      r4,[r4,#0x18]
000260  9400              STR      r4,[sp,#0]
000262  bf00              NOP      
000264  bf00              NOP      
                  |L63.614|
;;;5782     }
;;;5783   }
000266  bd38              POP      {r3-r5,pc}
;;;5784   
                          ENDP


                          AREA ||i.I2C_Master_SB||, CODE, READONLY, ALIGN=1

                  I2C_Master_SB PROC
;;;5563     */
;;;5564   static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
000000  f890103e          LDRB     r1,[r0,#0x3e]
;;;5565   {
;;;5566     if (hi2c->Mode == HAL_I2C_MODE_MEM)
000004  2940              CMP      r1,#0x40
000006  d10e              BNE      |L64.38|
;;;5567     {
;;;5568       if (hi2c->EventCount == 0U)
000008  6d01              LDR      r1,[r0,#0x50]
00000a  b929              CBNZ     r1,|L64.24|
;;;5569       {
;;;5570         /* Send slave address */
;;;5571         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
00000c  6c41              LDR      r1,[r0,#0x44]
00000e  f00101fe          AND      r1,r1,#0xfe
000012  6802              LDR      r2,[r0,#0]
000014  6111              STR      r1,[r2,#0x10]
000016  e041              B        |L64.156|
                  |L64.24|
;;;5572       }
;;;5573       else
;;;5574       {
;;;5575         hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
000018  6c41              LDR      r1,[r0,#0x44]
00001a  b2c9              UXTB     r1,r1
00001c  f0410101          ORR      r1,r1,#1
000020  6802              LDR      r2,[r0,#0]
000022  6111              STR      r1,[r2,#0x10]
000024  e03a              B        |L64.156|
                  |L64.38|
;;;5576       }
;;;5577     }
;;;5578     else
;;;5579     {
;;;5580       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
000026  6901              LDR      r1,[r0,#0x10]
000028  f5b14f80          CMP      r1,#0x4000
00002c  d120              BNE      |L64.112|
;;;5581       {
;;;5582         /* Send slave 7 Bits address */
;;;5583         if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
00002e  f890103d          LDRB     r1,[r0,#0x3d]
000032  2921              CMP      r1,#0x21
000034  d105              BNE      |L64.66|
;;;5584         {
;;;5585           hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
000036  6c41              LDR      r1,[r0,#0x44]
000038  f00101fe          AND      r1,r1,#0xfe
00003c  6802              LDR      r2,[r0,#0]
00003e  6111              STR      r1,[r2,#0x10]
000040  e005              B        |L64.78|
                  |L64.66|
;;;5586         }
;;;5587         else
;;;5588         {
;;;5589           hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
000042  6c41              LDR      r1,[r0,#0x44]
000044  b2c9              UXTB     r1,r1
000046  f0410101          ORR      r1,r1,#1
00004a  6802              LDR      r2,[r0,#0]
00004c  6111              STR      r1,[r2,#0x10]
                  |L64.78|
;;;5590         }
;;;5591   
;;;5592         if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
00004e  6b41              LDR      r1,[r0,#0x34]
000050  b111              CBZ      r1,|L64.88|
000052  6b41              LDR      r1,[r0,#0x34]
000054  6bc9              LDR      r1,[r1,#0x3c]
000056  b921              CBNZ     r1,|L64.98|
                  |L64.88|
;;;5593             || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
000058  6b81              LDR      r1,[r0,#0x38]
00005a  b1f9              CBZ      r1,|L64.156|
00005c  6b81              LDR      r1,[r0,#0x38]
00005e  6bc9              LDR      r1,[r1,#0x3c]
000060  b1e1              CBZ      r1,|L64.156|
                  |L64.98|
;;;5594         {
;;;5595           /* Enable DMA Request */
;;;5596           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000062  6801              LDR      r1,[r0,#0]
000064  6849              LDR      r1,[r1,#4]
000066  f4416100          ORR      r1,r1,#0x800
00006a  6802              LDR      r2,[r0,#0]
00006c  6051              STR      r1,[r2,#4]
00006e  e015              B        |L64.156|
                  |L64.112|
;;;5597         }
;;;5598       }
;;;5599       else
;;;5600       {
;;;5601         if (hi2c->EventCount == 0U)
000070  6d01              LDR      r1,[r0,#0x50]
000072  b941              CBNZ     r1,|L64.134|
;;;5602         {
;;;5603           /* Send header of slave address */
;;;5604           hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
000074  6c41              LDR      r1,[r0,#0x44]
000076  f4017140          AND      r1,r1,#0x300
00007a  22f0              MOVS     r2,#0xf0
00007c  ea4211e1          ORR      r1,r2,r1,ASR #7
000080  6802              LDR      r2,[r0,#0]
000082  6111              STR      r1,[r2,#0x10]
000084  e00a              B        |L64.156|
                  |L64.134|
;;;5605         }
;;;5606         else if (hi2c->EventCount == 1U)
000086  6d01              LDR      r1,[r0,#0x50]
000088  2901              CMP      r1,#1
00008a  d107              BNE      |L64.156|
;;;5607         {
;;;5608           /* Send header of slave address */
;;;5609           hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
00008c  6c41              LDR      r1,[r0,#0x44]
00008e  f4017140          AND      r1,r1,#0x300
000092  22f1              MOVS     r2,#0xf1
000094  ea4211e1          ORR      r1,r2,r1,ASR #7
000098  6802              LDR      r2,[r0,#0]
00009a  6111              STR      r1,[r2,#0x10]
                  |L64.156|
;;;5610         }
;;;5611         else
;;;5612         {
;;;5613           /* Do nothing */
;;;5614         }
;;;5615       }
;;;5616     }
;;;5617   }
00009c  4770              BX       lr
;;;5618   
                          ENDP


                          AREA ||i.I2C_MemoryTransmit_TXE_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MemoryTransmit_TXE_BTF PROC
;;;5245     */
;;;5246   static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5247   {
000002  4604              MOV      r4,r0
;;;5248     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5249     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5250   
;;;5251     if (hi2c->EventCount == 0U)
000008  6d20              LDR      r0,[r4,#0x50]
00000a  b998              CBNZ     r0,|L65.52|
;;;5252     {
;;;5253       /* If Memory address size is 8Bit */
;;;5254       if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
00000c  6ce0              LDR      r0,[r4,#0x4c]
00000e  2801              CMP      r0,#1
000010  d107              BNE      |L65.34|
;;;5255       {
;;;5256         /* Send Memory Address */
;;;5257         hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
000012  6ca0              LDR      r0,[r4,#0x48]
000014  b2c0              UXTB     r0,r0
000016  6821              LDR      r1,[r4,#0]
000018  6108              STR      r0,[r1,#0x10]
;;;5258   
;;;5259         hi2c->EventCount += 2U;
00001a  6d20              LDR      r0,[r4,#0x50]
00001c  1c80              ADDS     r0,r0,#2
00001e  6520              STR      r0,[r4,#0x50]
000020  e049              B        |L65.182|
                  |L65.34|
;;;5260       }
;;;5261       /* If Memory address size is 16Bit */
;;;5262       else
;;;5263       {
;;;5264         /* Send MSB of Memory Address */
;;;5265         hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
000022  6ca0              LDR      r0,[r4,#0x48]
000024  f3c02007          UBFX     r0,r0,#8,#8
000028  6821              LDR      r1,[r4,#0]
00002a  6108              STR      r0,[r1,#0x10]
;;;5266   
;;;5267         hi2c->EventCount++;
00002c  6d20              LDR      r0,[r4,#0x50]
00002e  1c40              ADDS     r0,r0,#1
000030  6520              STR      r0,[r4,#0x50]
000032  e040              B        |L65.182|
                  |L65.52|
;;;5268       }
;;;5269     }
;;;5270     else if (hi2c->EventCount == 1U)
000034  6d20              LDR      r0,[r4,#0x50]
000036  2801              CMP      r0,#1
000038  d107              BNE      |L65.74|
;;;5271     {
;;;5272       /* Send LSB of Memory Address */
;;;5273       hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
00003a  6ca0              LDR      r0,[r4,#0x48]
00003c  b2c0              UXTB     r0,r0
00003e  6821              LDR      r1,[r4,#0]
000040  6108              STR      r0,[r1,#0x10]
;;;5274   
;;;5275       hi2c->EventCount++;
000042  6d20              LDR      r0,[r4,#0x50]
000044  1c40              ADDS     r0,r0,#1
000046  6520              STR      r0,[r4,#0x50]
000048  e035              B        |L65.182|
                  |L65.74|
;;;5276     }
;;;5277     else if (hi2c->EventCount == 2U)
00004a  6d20              LDR      r0,[r4,#0x50]
00004c  2802              CMP      r0,#2
00004e  d132              BNE      |L65.182|
;;;5278     {
;;;5279       if (CurrentState == HAL_I2C_STATE_BUSY_RX)
000050  2d22              CMP      r5,#0x22
000052  d106              BNE      |L65.98|
;;;5280       {
;;;5281         /* Generate Restart */
;;;5282         hi2c->Instance->CR1 |= I2C_CR1_START;
000054  6820              LDR      r0,[r4,#0]
000056  6800              LDR      r0,[r0,#0]
000058  f4407080          ORR      r0,r0,#0x100
00005c  6821              LDR      r1,[r4,#0]
00005e  6008              STR      r0,[r1,#0]
000060  e029              B        |L65.182|
                  |L65.98|
;;;5283       }
;;;5284       else if ((hi2c->XferCount > 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
000062  8d60              LDRH     r0,[r4,#0x2a]
000064  b160              CBZ      r0,|L65.128|
000066  2d21              CMP      r5,#0x21
000068  d10a              BNE      |L65.128|
;;;5285       {
;;;5286         /* Write data to DR */
;;;5287         hi2c->Instance->DR = *hi2c->pBuffPtr;
00006a  6a60              LDR      r0,[r4,#0x24]
00006c  7800              LDRB     r0,[r0,#0]
00006e  6821              LDR      r1,[r4,#0]
000070  6108              STR      r0,[r1,#0x10]
;;;5288   
;;;5289         /* Increment Buffer pointer */
;;;5290         hi2c->pBuffPtr++;
000072  6a60              LDR      r0,[r4,#0x24]
000074  1c40              ADDS     r0,r0,#1
000076  6260              STR      r0,[r4,#0x24]
;;;5291   
;;;5292         /* Update counter */
;;;5293         hi2c->XferCount--;
000078  8d60              LDRH     r0,[r4,#0x2a]
00007a  1e40              SUBS     r0,r0,#1
00007c  8560              STRH     r0,[r4,#0x2a]
00007e  e01a              B        |L65.182|
                  |L65.128|
;;;5294       }
;;;5295       else if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
000080  8d60              LDRH     r0,[r4,#0x2a]
000082  b9c0              CBNZ     r0,|L65.182|
000084  2d21              CMP      r5,#0x21
000086  d116              BNE      |L65.182|
;;;5296       {
;;;5297         /* Generate Stop condition then Call TxCpltCallback() */
;;;5298         /* Disable EVT, BUF and ERR interrupt */
;;;5299         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000088  6820              LDR      r0,[r4,#0]
00008a  6840              LDR      r0,[r0,#4]
00008c  f42060e0          BIC      r0,r0,#0x700
000090  6821              LDR      r1,[r4,#0]
000092  6048              STR      r0,[r1,#4]
;;;5300   
;;;5301         /* Generate Stop */
;;;5302         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000094  6820              LDR      r0,[r4,#0]
000096  6800              LDR      r0,[r0,#0]
000098  f4407000          ORR      r0,r0,#0x200
00009c  6821              LDR      r1,[r4,#0]
00009e  6008              STR      r0,[r1,#0]
;;;5303   
;;;5304         hi2c->PreviousState = I2C_STATE_NONE;
0000a0  2000              MOVS     r0,#0
0000a2  6320              STR      r0,[r4,#0x30]
;;;5305         hi2c->State = HAL_I2C_STATE_READY;
0000a4  2020              MOVS     r0,#0x20
0000a6  f884003d          STRB     r0,[r4,#0x3d]
;;;5306         hi2c->Mode = HAL_I2C_MODE_NONE;
0000aa  2000              MOVS     r0,#0
0000ac  f884003e          STRB     r0,[r4,#0x3e]
;;;5307   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5308         hi2c->MemTxCpltCallback(hi2c);
;;;5309   #else
;;;5310         HAL_I2C_MemTxCpltCallback(hi2c);
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
                  |L65.182|
;;;5311   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5312       }
;;;5313       else
;;;5314       {
;;;5315         /* Do nothing */
;;;5316       }
;;;5317     }
;;;5318     else
;;;5319     {
;;;5320       /* Do nothing */
;;;5321     }
;;;5322   }
0000b6  bd70              POP      {r4-r6,pc}
;;;5323   
                          ENDP


                          AREA ||i.I2C_RequestMemoryRead||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryRead PROC
;;;6617     */
;;;6618   static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6619   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
00000c  e9dd8608          LDRD     r8,r6,[sp,#0x20]
;;;6620     /* Enable Acknowledge */
;;;6621     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f4406080          ORR      r0,r0,#0x400
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;6622   
;;;6623     /* Generate Start */
;;;6624     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4407080          ORR      r0,r0,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  6008              STR      r0,[r1,#0]
;;;6625   
;;;6626     /* Wait until SB flag is set */
;;;6627     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000028  4643              MOV      r3,r8
00002a  2200              MOVS     r2,#0
00002c  f04f1101          MOV      r1,#0x10001
000030  4620              MOV      r0,r4
000032  9600              STR      r6,[sp,#0]
000034  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000038  b160              CBZ      r0,|L66.84|
;;;6628     {
;;;6629       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
00003a  6820              LDR      r0,[r4,#0]
00003c  6800              LDR      r0,[r0,#0]
00003e  f4007080          AND      r0,r0,#0x100
000042  f5b07f80          CMP      r0,#0x100
000046  d102              BNE      |L66.78|
;;;6630       {
;;;6631         hi2c->ErrorCode = HAL_I2C_WRONG_START;
000048  f44f7000          MOV      r0,#0x200
00004c  6420              STR      r0,[r4,#0x40]
                  |L66.78|
;;;6632       }
;;;6633       return HAL_TIMEOUT;
00004e  2003              MOVS     r0,#3
                  |L66.80|
;;;6634     }
;;;6635   
;;;6636     /* Send slave address */
;;;6637     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6638   
;;;6639     /* Wait until ADDR flag is set */
;;;6640     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6641     {
;;;6642       return HAL_ERROR;
;;;6643     }
;;;6644   
;;;6645     /* Clear ADDR flag */
;;;6646     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6647   
;;;6648     /* Wait until TXE flag is set */
;;;6649     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6650     {
;;;6651       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6652       {
;;;6653         /* Generate Stop */
;;;6654         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6655       }
;;;6656       return HAL_ERROR;
;;;6657     }
;;;6658   
;;;6659     /* If Memory address size is 8Bit */
;;;6660     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;6661     {
;;;6662       /* Send Memory Address */
;;;6663       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6664     }
;;;6665     /* If Memory address size is 16Bit */
;;;6666     else
;;;6667     {
;;;6668       /* Send MSB of Memory Address */
;;;6669       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;6670   
;;;6671       /* Wait until TXE flag is set */
;;;6672       if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6673       {
;;;6674         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6675         {
;;;6676           /* Generate Stop */
;;;6677           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6678         }
;;;6679         return HAL_ERROR;
;;;6680       }
;;;6681   
;;;6682       /* Send LSB of Memory Address */
;;;6683       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6684     }
;;;6685   
;;;6686     /* Wait until TXE flag is set */
;;;6687     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6688     {
;;;6689       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6690       {
;;;6691         /* Generate Stop */
;;;6692         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6693       }
;;;6694       return HAL_ERROR;
;;;6695     }
;;;6696   
;;;6697     /* Generate Restart */
;;;6698     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;6699   
;;;6700     /* Wait until SB flag is set */
;;;6701     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;6702     {
;;;6703       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
;;;6704       {
;;;6705         hi2c->ErrorCode = HAL_I2C_WRONG_START;
;;;6706       }
;;;6707       return HAL_TIMEOUT;
;;;6708     }
;;;6709   
;;;6710     /* Send slave address */
;;;6711     hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;6712   
;;;6713     /* Wait until ADDR flag is set */
;;;6714     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6715     {
;;;6716       return HAL_ERROR;
;;;6717     }
;;;6718   
;;;6719     return HAL_OK;
;;;6720   }
000050  e8bd83f8          POP      {r3-r9,pc}
                  |L66.84|
000054  f00700fe          AND      r0,r7,#0xfe           ;6637
000058  6821              LDR      r1,[r4,#0]            ;6637
00005a  6108              STR      r0,[r1,#0x10]         ;6637
00005c  4633              MOV      r3,r6                 ;6640
00005e  4642              MOV      r2,r8                 ;6640
000060  493e              LDR      r1,|L66.348|
000062  4620              MOV      r0,r4                 ;6640
000064  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000068  b108              CBZ      r0,|L66.110|
00006a  2001              MOVS     r0,#1                 ;6642
00006c  e7f0              B        |L66.80|
                  |L66.110|
00006e  bf00              NOP                            ;6646
000070  2000              MOVS     r0,#0                 ;6646
000072  9000              STR      r0,[sp,#0]            ;6646
000074  6820              LDR      r0,[r4,#0]            ;6646
000076  6940              LDR      r0,[r0,#0x14]         ;6646
000078  9000              STR      r0,[sp,#0]            ;6646
00007a  6820              LDR      r0,[r4,#0]            ;6646
00007c  6980              LDR      r0,[r0,#0x18]         ;6646
00007e  9000              STR      r0,[sp,#0]            ;6646
000080  bf00              NOP                            ;6646
000082  bf00              NOP                            ;6646
000084  4632              MOV      r2,r6                 ;6649
000086  4641              MOV      r1,r8                 ;6649
000088  4620              MOV      r0,r4                 ;6649
00008a  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
00008e  b150              CBZ      r0,|L66.166|
000090  6c20              LDR      r0,[r4,#0x40]         ;6651
000092  2804              CMP      r0,#4                 ;6651
000094  d105              BNE      |L66.162|
000096  6820              LDR      r0,[r4,#0]            ;6654
000098  6800              LDR      r0,[r0,#0]            ;6654
00009a  f4407000          ORR      r0,r0,#0x200          ;6654
00009e  6821              LDR      r1,[r4,#0]            ;6654
0000a0  6008              STR      r0,[r1,#0]            ;6654
                  |L66.162|
0000a2  2001              MOVS     r0,#1                 ;6656
0000a4  e7d4              B        |L66.80|
                  |L66.166|
0000a6  f1b90f01          CMP      r9,#1                 ;6660
0000aa  d103              BNE      |L66.180|
0000ac  b2e8              UXTB     r0,r5                 ;6663
0000ae  6821              LDR      r1,[r4,#0]            ;6663
0000b0  6108              STR      r0,[r1,#0x10]         ;6663
0000b2  e017              B        |L66.228|
                  |L66.180|
0000b4  f3c52007          UBFX     r0,r5,#8,#8           ;6669
0000b8  6821              LDR      r1,[r4,#0]            ;6669
0000ba  6108              STR      r0,[r1,#0x10]         ;6669
0000bc  4632              MOV      r2,r6                 ;6672
0000be  4641              MOV      r1,r8                 ;6672
0000c0  4620              MOV      r0,r4                 ;6672
0000c2  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000c6  b150              CBZ      r0,|L66.222|
0000c8  6c20              LDR      r0,[r4,#0x40]         ;6674
0000ca  2804              CMP      r0,#4                 ;6674
0000cc  d105              BNE      |L66.218|
0000ce  6820              LDR      r0,[r4,#0]            ;6677
0000d0  6800              LDR      r0,[r0,#0]            ;6677
0000d2  f4407000          ORR      r0,r0,#0x200          ;6677
0000d6  6821              LDR      r1,[r4,#0]            ;6677
0000d8  6008              STR      r0,[r1,#0]            ;6677
                  |L66.218|
0000da  2001              MOVS     r0,#1                 ;6679
0000dc  e7b8              B        |L66.80|
                  |L66.222|
0000de  b2e8              UXTB     r0,r5                 ;6683
0000e0  6821              LDR      r1,[r4,#0]            ;6683
0000e2  6108              STR      r0,[r1,#0x10]         ;6683
                  |L66.228|
0000e4  4632              MOV      r2,r6                 ;6687
0000e6  4641              MOV      r1,r8                 ;6687
0000e8  4620              MOV      r0,r4                 ;6687
0000ea  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ee  b150              CBZ      r0,|L66.262|
0000f0  6c20              LDR      r0,[r4,#0x40]         ;6689
0000f2  2804              CMP      r0,#4                 ;6689
0000f4  d105              BNE      |L66.258|
0000f6  6820              LDR      r0,[r4,#0]            ;6692
0000f8  6800              LDR      r0,[r0,#0]            ;6692
0000fa  f4407000          ORR      r0,r0,#0x200          ;6692
0000fe  6821              LDR      r1,[r4,#0]            ;6692
000100  6008              STR      r0,[r1,#0]            ;6692
                  |L66.258|
000102  2001              MOVS     r0,#1                 ;6694
000104  e7a4              B        |L66.80|
                  |L66.262|
000106  6820              LDR      r0,[r4,#0]            ;6698
000108  6800              LDR      r0,[r0,#0]            ;6698
00010a  f4407080          ORR      r0,r0,#0x100          ;6698
00010e  6821              LDR      r1,[r4,#0]            ;6698
000110  6008              STR      r0,[r1,#0]            ;6698
000112  4643              MOV      r3,r8                 ;6701
000114  2200              MOVS     r2,#0                 ;6701
000116  f04f1101          MOV      r1,#0x10001           ;6701
00011a  4620              MOV      r0,r4                 ;6701
00011c  9600              STR      r6,[sp,#0]            ;6701
00011e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000122  b158              CBZ      r0,|L66.316|
000124  6820              LDR      r0,[r4,#0]            ;6703
000126  6800              LDR      r0,[r0,#0]            ;6703
000128  f4007080          AND      r0,r0,#0x100          ;6703
00012c  f5b07f80          CMP      r0,#0x100             ;6703
000130  d102              BNE      |L66.312|
000132  f44f7000          MOV      r0,#0x200             ;6705
000136  6420              STR      r0,[r4,#0x40]         ;6705
                  |L66.312|
000138  2003              MOVS     r0,#3                 ;6707
00013a  e789              B        |L66.80|
                  |L66.316|
00013c  b2f8              UXTB     r0,r7                 ;6711
00013e  f0400001          ORR      r0,r0,#1              ;6711
000142  6821              LDR      r1,[r4,#0]            ;6711
000144  6108              STR      r0,[r1,#0x10]         ;6711
000146  4633              MOV      r3,r6                 ;6714
000148  4642              MOV      r2,r8                 ;6714
00014a  4904              LDR      r1,|L66.348|
00014c  4620              MOV      r0,r4                 ;6714
00014e  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000152  b108              CBZ      r0,|L66.344|
000154  2001              MOVS     r0,#1                 ;6716
000156  e77b              B        |L66.80|
                  |L66.344|
000158  2000              MOVS     r0,#0                 ;6719
00015a  e779              B        |L66.80|
;;;6721   
                          ENDP

                  |L66.348|
                          DCD      0x00010002

                          AREA ||i.I2C_RequestMemoryWrite||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryWrite PROC
;;;6537     */
;;;6538   static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6539   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
00000c  e9dd6708          LDRD     r6,r7,[sp,#0x20]
;;;6540     /* Generate Start */
;;;6541     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f4407080          ORR      r0,r0,#0x100
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;6542   
;;;6543     /* Wait until SB flag is set */
;;;6544     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
00001c  4633              MOV      r3,r6
00001e  2200              MOVS     r2,#0
000020  f04f1101          MOV      r1,#0x10001
000024  4620              MOV      r0,r4
000026  9700              STR      r7,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b160              CBZ      r0,|L67.72|
;;;6545     {
;;;6546       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f4007080          AND      r0,r0,#0x100
000036  f5b07f80          CMP      r0,#0x100
00003a  d102              BNE      |L67.66|
;;;6547       {
;;;6548         hi2c->ErrorCode = HAL_I2C_WRONG_START;
00003c  f44f7000          MOV      r0,#0x200
000040  6420              STR      r0,[r4,#0x40]
                  |L67.66|
;;;6549       }
;;;6550       return HAL_TIMEOUT;
000042  2003              MOVS     r0,#3
                  |L67.68|
;;;6551     }
;;;6552   
;;;6553     /* Send slave address */
;;;6554     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6555   
;;;6556     /* Wait until ADDR flag is set */
;;;6557     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6558     {
;;;6559       return HAL_ERROR;
;;;6560     }
;;;6561   
;;;6562     /* Clear ADDR flag */
;;;6563     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6564   
;;;6565     /* Wait until TXE flag is set */
;;;6566     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6567     {
;;;6568       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6569       {
;;;6570         /* Generate Stop */
;;;6571         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6572       }
;;;6573       return HAL_ERROR;
;;;6574     }
;;;6575   
;;;6576     /* If Memory address size is 8Bit */
;;;6577     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;6578     {
;;;6579       /* Send Memory Address */
;;;6580       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6581     }
;;;6582     /* If Memory address size is 16Bit */
;;;6583     else
;;;6584     {
;;;6585       /* Send MSB of Memory Address */
;;;6586       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;6587   
;;;6588       /* Wait until TXE flag is set */
;;;6589       if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6590       {
;;;6591         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6592         {
;;;6593           /* Generate Stop */
;;;6594           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6595         }
;;;6596         return HAL_ERROR;
;;;6597       }
;;;6598   
;;;6599       /* Send LSB of Memory Address */
;;;6600       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6601     }
;;;6602   
;;;6603     return HAL_OK;
;;;6604   }
000044  e8bd83f8          POP      {r3-r9,pc}
                  |L67.72|
000048  f00800fe          AND      r0,r8,#0xfe           ;6554
00004c  6821              LDR      r1,[r4,#0]            ;6554
00004e  6108              STR      r0,[r1,#0x10]         ;6554
000050  463b              MOV      r3,r7                 ;6557
000052  4632              MOV      r2,r6                 ;6557
000054  4921              LDR      r1,|L67.220|
000056  4620              MOV      r0,r4                 ;6557
000058  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00005c  b108              CBZ      r0,|L67.98|
00005e  2001              MOVS     r0,#1                 ;6559
000060  e7f0              B        |L67.68|
                  |L67.98|
000062  bf00              NOP                            ;6563
000064  2000              MOVS     r0,#0                 ;6563
000066  9000              STR      r0,[sp,#0]            ;6563
000068  6820              LDR      r0,[r4,#0]            ;6563
00006a  6940              LDR      r0,[r0,#0x14]         ;6563
00006c  9000              STR      r0,[sp,#0]            ;6563
00006e  6820              LDR      r0,[r4,#0]            ;6563
000070  6980              LDR      r0,[r0,#0x18]         ;6563
000072  9000              STR      r0,[sp,#0]            ;6563
000074  bf00              NOP                            ;6563
000076  bf00              NOP                            ;6563
000078  463a              MOV      r2,r7                 ;6566
00007a  4631              MOV      r1,r6                 ;6566
00007c  4620              MOV      r0,r4                 ;6566
00007e  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000082  b150              CBZ      r0,|L67.154|
000084  6c20              LDR      r0,[r4,#0x40]         ;6568
000086  2804              CMP      r0,#4                 ;6568
000088  d105              BNE      |L67.150|
00008a  6820              LDR      r0,[r4,#0]            ;6571
00008c  6800              LDR      r0,[r0,#0]            ;6571
00008e  f4407000          ORR      r0,r0,#0x200          ;6571
000092  6821              LDR      r1,[r4,#0]            ;6571
000094  6008              STR      r0,[r1,#0]            ;6571
                  |L67.150|
000096  2001              MOVS     r0,#1                 ;6573
000098  e7d4              B        |L67.68|
                  |L67.154|
00009a  f1b90f01          CMP      r9,#1                 ;6577
00009e  d103              BNE      |L67.168|
0000a0  b2e8              UXTB     r0,r5                 ;6580
0000a2  6821              LDR      r1,[r4,#0]            ;6580
0000a4  6108              STR      r0,[r1,#0x10]         ;6580
0000a6  e017              B        |L67.216|
                  |L67.168|
0000a8  f3c52007          UBFX     r0,r5,#8,#8           ;6586
0000ac  6821              LDR      r1,[r4,#0]            ;6586
0000ae  6108              STR      r0,[r1,#0x10]         ;6586
0000b0  463a              MOV      r2,r7                 ;6589
0000b2  4631              MOV      r1,r6                 ;6589
0000b4  4620              MOV      r0,r4                 ;6589
0000b6  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ba  b150              CBZ      r0,|L67.210|
0000bc  6c20              LDR      r0,[r4,#0x40]         ;6591
0000be  2804              CMP      r0,#4                 ;6591
0000c0  d105              BNE      |L67.206|
0000c2  6820              LDR      r0,[r4,#0]            ;6594
0000c4  6800              LDR      r0,[r0,#0]            ;6594
0000c6  f4407000          ORR      r0,r0,#0x200          ;6594
0000ca  6821              LDR      r1,[r4,#0]            ;6594
0000cc  6008              STR      r0,[r1,#0]            ;6594
                  |L67.206|
0000ce  2001              MOVS     r0,#1                 ;6596
0000d0  e7b8              B        |L67.68|
                  |L67.210|
0000d2  b2e8              UXTB     r0,r5                 ;6600
0000d4  6821              LDR      r1,[r4,#0]            ;6600
0000d6  6108              STR      r0,[r1,#0x10]         ;6600
                  |L67.216|
0000d8  2000              MOVS     r0,#0                 ;6603
0000da  e7b3              B        |L67.68|
;;;6605   
                          ENDP

                  |L67.220|
                          DCD      0x00010002

                          AREA ||i.I2C_SlaveReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_BTF PROC
;;;5893     */
;;;5894   static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;5895   {
;;;5896     if (hi2c->XferCount != 0U)
000002  b149              CBZ      r1,|L68.24|
;;;5897     {
;;;5898       /* Read data from DR */
;;;5899       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000004  6801              LDR      r1,[r0,#0]
000006  6909              LDR      r1,[r1,#0x10]
000008  6a42              LDR      r2,[r0,#0x24]
00000a  7011              STRB     r1,[r2,#0]
;;;5900   
;;;5901       /* Increment Buffer pointer */
;;;5902       hi2c->pBuffPtr++;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c49              ADDS     r1,r1,#1
000010  6241              STR      r1,[r0,#0x24]
;;;5903   
;;;5904       /* Update counter */
;;;5905       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L68.24|
;;;5906     }
;;;5907   }
000018  4770              BX       lr
;;;5908   
                          ENDP


                          AREA ||i.I2C_SlaveReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_RXNE PROC
;;;5852     */
;;;5853   static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5854   {
000002  4604              MOV      r4,r0
;;;5855     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5856     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5857   
;;;5858     if (hi2c->XferCount != 0U)
000008  8d60              LDRH     r0,[r4,#0x2a]
00000a  b1d8              CBZ      r0,|L69.68|
;;;5859     {
;;;5860       /* Read data from DR */
;;;5861       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
00000c  6820              LDR      r0,[r4,#0]
00000e  6900              LDR      r0,[r0,#0x10]
000010  6a61              LDR      r1,[r4,#0x24]
000012  7008              STRB     r0,[r1,#0]
;;;5862   
;;;5863       /* Increment Buffer pointer */
;;;5864       hi2c->pBuffPtr++;
000014  6a60              LDR      r0,[r4,#0x24]
000016  1c40              ADDS     r0,r0,#1
000018  6260              STR      r0,[r4,#0x24]
;;;5865   
;;;5866       /* Update counter */
;;;5867       hi2c->XferCount--;
00001a  8d60              LDRH     r0,[r4,#0x2a]
00001c  1e40              SUBS     r0,r0,#1
00001e  8560              STRH     r0,[r4,#0x2a]
;;;5868   
;;;5869       if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  b978              CBNZ     r0,|L69.68|
000024  2d2a              CMP      r5,#0x2a
000026  d10d              BNE      |L69.68|
;;;5870       {
;;;5871         /* Last Byte is received, disable Interrupt */
;;;5872         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  f4206080          BIC      r0,r0,#0x400
000030  6821              LDR      r1,[r4,#0]
000032  6048              STR      r0,[r1,#4]
;;;5873   
;;;5874         /* Set state at HAL_I2C_STATE_LISTEN */
;;;5875         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000034  2022              MOVS     r0,#0x22
000036  6320              STR      r0,[r4,#0x30]
;;;5876         hi2c->State = HAL_I2C_STATE_LISTEN;
000038  2028              MOVS     r0,#0x28
00003a  f884003d          STRB     r0,[r4,#0x3d]
;;;5877   
;;;5878         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5879   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5880         hi2c->SlaveRxCpltCallback(hi2c);
;;;5881   #else
;;;5882         HAL_I2C_SlaveRxCpltCallback(hi2c);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L69.68|
;;;5883   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5884       }
;;;5885     }
;;;5886   }
000044  bd70              POP      {r4-r6,pc}
;;;5887   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_BTF PROC
;;;5831     */
;;;5832   static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;5833   {
;;;5834     if (hi2c->XferCount != 0U)
000002  b149              CBZ      r1,|L70.24|
;;;5835     {
;;;5836       /* Write data to DR */
;;;5837       hi2c->Instance->DR = *hi2c->pBuffPtr;
000004  6a41              LDR      r1,[r0,#0x24]
000006  7809              LDRB     r1,[r1,#0]
000008  6802              LDR      r2,[r0,#0]
00000a  6111              STR      r1,[r2,#0x10]
;;;5838   
;;;5839       /* Increment Buffer pointer */
;;;5840       hi2c->pBuffPtr++;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c49              ADDS     r1,r1,#1
000010  6241              STR      r1,[r0,#0x24]
;;;5841   
;;;5842       /* Update counter */
;;;5843       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L70.24|
;;;5844     }
;;;5845   }
000018  4770              BX       lr
;;;5846   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_TXE PROC
;;;5790     */
;;;5791   static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5792   {
000002  4604              MOV      r4,r0
;;;5793     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5794     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5795   
;;;5796     if (hi2c->XferCount != 0U)
000008  8d60              LDRH     r0,[r4,#0x2a]
00000a  b1d8              CBZ      r0,|L71.68|
;;;5797     {
;;;5798       /* Write data to DR */
;;;5799       hi2c->Instance->DR = *hi2c->pBuffPtr;
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  7800              LDRB     r0,[r0,#0]
000010  6821              LDR      r1,[r4,#0]
000012  6108              STR      r0,[r1,#0x10]
;;;5800   
;;;5801       /* Increment Buffer pointer */
;;;5802       hi2c->pBuffPtr++;
000014  6a60              LDR      r0,[r4,#0x24]
000016  1c40              ADDS     r0,r0,#1
000018  6260              STR      r0,[r4,#0x24]
;;;5803   
;;;5804       /* Update counter */
;;;5805       hi2c->XferCount--;
00001a  8d60              LDRH     r0,[r4,#0x2a]
00001c  1e40              SUBS     r0,r0,#1
00001e  8560              STRH     r0,[r4,#0x2a]
;;;5806   
;;;5807       if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  b978              CBNZ     r0,|L71.68|
000024  2d29              CMP      r5,#0x29
000026  d10d              BNE      |L71.68|
;;;5808       {
;;;5809         /* Last Byte is received, disable Interrupt */
;;;5810         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  f4206080          BIC      r0,r0,#0x400
000030  6821              LDR      r1,[r4,#0]
000032  6048              STR      r0,[r1,#4]
;;;5811   
;;;5812         /* Set state at HAL_I2C_STATE_LISTEN */
;;;5813         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
000034  2021              MOVS     r0,#0x21
000036  6320              STR      r0,[r4,#0x30]
;;;5814         hi2c->State = HAL_I2C_STATE_LISTEN;
000038  2028              MOVS     r0,#0x28
00003a  f884003d          STRB     r0,[r4,#0x3d]
;;;5815   
;;;5816         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5817   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5818         hi2c->SlaveTxCpltCallback(hi2c);
;;;5819   #else
;;;5820         HAL_I2C_SlaveTxCpltCallback(hi2c);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
                  |L71.68|
;;;5821   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5822       }
;;;5823     }
;;;5824   }
000044  bd70              POP      {r4-r6,pc}
;;;5825   
                          ENDP


                          AREA ||i.I2C_Slave_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Slave_ADDR PROC
;;;5915     */
;;;5916   static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5917   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;5918     uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
000008  2700              MOVS     r7,#0
;;;5919     uint16_t SlaveAddrCode;
;;;5920   
;;;5921     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  f0000028          AND      r0,r0,#0x28
000012  2828              CMP      r0,#0x28
000014  d11c              BNE      |L72.80|
;;;5922     {
;;;5923       /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
;;;5924       __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
000016  6820              LDR      r0,[r4,#0]
000018  6840              LDR      r0,[r0,#4]
00001a  f4206080          BIC      r0,r0,#0x400
00001e  6821              LDR      r1,[r4,#0]
000020  6048              STR      r0,[r1,#4]
;;;5925   
;;;5926       /* Transfer Direction requested by Master */
;;;5927       if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
000022  f3c50080          UBFX     r0,r5,#2,#1
000026  b900              CBNZ     r0,|L72.42|
;;;5928       {
;;;5929         TransferDirection = I2C_DIRECTION_TRANSMIT;
000028  2701              MOVS     r7,#1
                  |L72.42|
;;;5930       }
;;;5931   
;;;5932       if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
00002a  f3c510c0          UBFX     r0,r5,#7,#1
00002e  b910              CBNZ     r0,|L72.54|
;;;5933       {
;;;5934         SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
000030  89a0              LDRH     r0,[r4,#0xc]
000032  b286              UXTH     r6,r0
000034  e001              B        |L72.58|
                  |L72.54|
;;;5935       }
;;;5936       else
;;;5937       {
;;;5938         SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
000036  8b20              LDRH     r0,[r4,#0x18]
000038  b286              UXTH     r6,r0
                  |L72.58|
;;;5939       }
;;;5940   
;;;5941       /* Process Unlocked */
;;;5942       __HAL_UNLOCK(hi2c);
00003a  bf00              NOP      
00003c  2000              MOVS     r0,#0
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;5943   
;;;5944       /* Call Slave Addr callback */
;;;5945   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5946       hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
;;;5947   #else
;;;5948       HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
000044  4632              MOV      r2,r6
000046  4639              MOV      r1,r7
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_I2C_AddrCallback
00004e  e008              B        |L72.98|
                  |L72.80|
;;;5949   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5950     }
;;;5951     else
;;;5952     {
;;;5953       /* Clear ADDR flag */
;;;5954       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
000050  f06f0002          MVN      r0,#2
000054  6821              LDR      r1,[r4,#0]
000056  6148              STR      r0,[r1,#0x14]
;;;5955   
;;;5956       /* Process Unlocked */
;;;5957       __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
                  |L72.98|
;;;5958     }
;;;5959   }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;5960   
                          ENDP


                          AREA ||i.I2C_Slave_AF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_AF PROC
;;;6135     */
;;;6136   static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;6137   {
000002  4604              MOV      r4,r0
;;;6138     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;6139     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;6140     uint32_t CurrentXferOptions       = hi2c->XferOptions;
000008  6ae6              LDR      r6,[r4,#0x2c]
;;;6141   
;;;6142     if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
00000a  2e08              CMP      r6,#8
00000c  d001              BEQ      |L73.18|
00000e  2e20              CMP      r6,#0x20
000010  d11f              BNE      |L73.82|
                  |L73.18|
;;;6143         (CurrentState == HAL_I2C_STATE_LISTEN))
000012  2d28              CMP      r5,#0x28
000014  d11d              BNE      |L73.82|
;;;6144     {
;;;6145       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000016  4821              LDR      r0,|L73.156|
000018  62e0              STR      r0,[r4,#0x2c]
;;;6146   
;;;6147       /* Disable EVT, BUF and ERR interrupt */
;;;6148       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f42060e0          BIC      r0,r0,#0x700
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;6149   
;;;6150       /* Clear AF flag */
;;;6151       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000026  f46f6080          MVN      r0,#0x400
00002a  6821              LDR      r1,[r4,#0]
00002c  6148              STR      r0,[r1,#0x14]
;;;6152   
;;;6153       /* Disable Acknowledge */
;;;6154       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f4206080          BIC      r0,r0,#0x400
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;6155   
;;;6156       hi2c->PreviousState = I2C_STATE_NONE;
00003a  2000              MOVS     r0,#0
00003c  6320              STR      r0,[r4,#0x30]
;;;6157       hi2c->State         = HAL_I2C_STATE_READY;
00003e  2020              MOVS     r0,#0x20
000040  f884003d          STRB     r0,[r4,#0x3d]
;;;6158       hi2c->Mode          = HAL_I2C_MODE_NONE;
000044  2000              MOVS     r0,#0
000046  f884003e          STRB     r0,[r4,#0x3e]
;;;6159   
;;;6160       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6161   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6162       hi2c->ListenCpltCallback(hi2c);
;;;6163   #else
;;;6164       HAL_I2C_ListenCpltCallback(hi2c);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       HAL_I2C_ListenCpltCallback
000050  e023              B        |L73.154|
                  |L73.82|
;;;6165   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6166     }
;;;6167     else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
000052  2d21              CMP      r5,#0x21
000054  d11d              BNE      |L73.146|
;;;6168     {
;;;6169       hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
000056  4811              LDR      r0,|L73.156|
000058  62e0              STR      r0,[r4,#0x2c]
;;;6170       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
00005a  2021              MOVS     r0,#0x21
00005c  6320              STR      r0,[r4,#0x30]
;;;6171       hi2c->State         = HAL_I2C_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;6172       hi2c->Mode          = HAL_I2C_MODE_NONE;
000064  2000              MOVS     r0,#0
000066  f884003e          STRB     r0,[r4,#0x3e]
;;;6173   
;;;6174       /* Disable EVT, BUF and ERR interrupt */
;;;6175       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00006a  6820              LDR      r0,[r4,#0]
00006c  6840              LDR      r0,[r0,#4]
00006e  f42060e0          BIC      r0,r0,#0x700
000072  6821              LDR      r1,[r4,#0]
000074  6048              STR      r0,[r1,#4]
;;;6176   
;;;6177       /* Clear AF flag */
;;;6178       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000076  f46f6080          MVN      r0,#0x400
00007a  6821              LDR      r1,[r4,#0]
00007c  6148              STR      r0,[r1,#0x14]
;;;6179   
;;;6180       /* Disable Acknowledge */
;;;6181       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00007e  6820              LDR      r0,[r4,#0]
000080  6800              LDR      r0,[r0,#0]
000082  f4206080          BIC      r0,r0,#0x400
000086  6821              LDR      r1,[r4,#0]
000088  6008              STR      r0,[r1,#0]
;;;6182   
;;;6183   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6184       hi2c->SlaveTxCpltCallback(hi2c);
;;;6185   #else
;;;6186       HAL_I2C_SlaveTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
000090  e003              B        |L73.154|
                  |L73.146|
;;;6187   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6188     }
;;;6189     else
;;;6190     {
;;;6191       /* Clear AF flag only */
;;;6192       /* State Listen, but XferOptions == FIRST or NEXT */
;;;6193       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000092  f46f6080          MVN      r0,#0x400
000096  6821              LDR      r1,[r4,#0]
000098  6148              STR      r0,[r1,#0x14]
                  |L73.154|
;;;6194     }
;;;6195   }
00009a  bd70              POP      {r4-r6,pc}
;;;6196   
                          ENDP

                  |L73.156|
                          DCD      0xffff0000

                          AREA ||i.I2C_Slave_STOPF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_STOPF PROC
;;;5966     */
;;;5967   static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
000000  b538              PUSH     {r3-r5,lr}
;;;5968   {
000002  4604              MOV      r4,r0
;;;5969     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;5970     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5971   
;;;5972     /* Disable EVT, BUF and ERR interrupt */
;;;5973     __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  f42060e0          BIC      r0,r0,#0x700
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;5974   
;;;5975     /* Clear STOPF flag */
;;;5976     __HAL_I2C_CLEAR_STOPFLAG(hi2c);
000014  bf00              NOP      
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  6820              LDR      r0,[r4,#0]
00001c  6940              LDR      r0,[r0,#0x14]
00001e  9000              STR      r0,[sp,#0]
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0400001          ORR      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;5977   
;;;5978     /* Disable Acknowledge */
;;;5979     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000030  6820              LDR      r0,[r4,#0]
000032  6800              LDR      r0,[r0,#0]
000034  f4206080          BIC      r0,r0,#0x400
000038  6821              LDR      r1,[r4,#0]
00003a  6008              STR      r0,[r1,#0]
;;;5980   
;;;5981     /* If a DMA is ongoing, Update handle size context */
;;;5982     if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
00003c  6820              LDR      r0,[r4,#0]
00003e  6840              LDR      r0,[r0,#4]
000040  f4006000          AND      r0,r0,#0x800
000044  f5b06f00          CMP      r0,#0x800
000048  d142              BNE      |L74.208|
;;;5983     {
;;;5984       if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
00004a  2d22              CMP      r5,#0x22
00004c  d001              BEQ      |L74.82|
00004e  2d2a              CMP      r5,#0x2a
000050  d11f              BNE      |L74.146|
                  |L74.82|
;;;5985       {
;;;5986         hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
000052  6ba0              LDR      r0,[r4,#0x38]
000054  6800              LDR      r0,[r0,#0]
000056  6840              LDR      r0,[r0,#4]
000058  8560              STRH     r0,[r4,#0x2a]
;;;5987   
;;;5988         if (hi2c->XferCount != 0U)
00005a  8d60              LDRH     r0,[r4,#0x2a]
00005c  b118              CBZ      r0,|L74.102|
;;;5989         {
;;;5990           /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;5991           hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00005e  6c20              LDR      r0,[r4,#0x40]
000060  f0400004          ORR      r0,r0,#4
000064  6420              STR      r0,[r4,#0x40]
                  |L74.102|
;;;5992         }
;;;5993   
;;;5994         /* Disable, stop the current DMA */
;;;5995         CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000066  6820              LDR      r0,[r4,#0]
000068  6840              LDR      r0,[r0,#4]
00006a  f4206000          BIC      r0,r0,#0x800
00006e  6821              LDR      r1,[r4,#0]
000070  6048              STR      r0,[r1,#4]
;;;5996   
;;;5997         /* Abort DMA Xfer if any */
;;;5998         if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
000072  6ba0              LDR      r0,[r4,#0x38]
000074  f7fffffe          BL       HAL_DMA_GetState
000078  2801              CMP      r0,#1
00007a  d029              BEQ      |L74.208|
;;;5999         {
;;;6000           /* Set the I2C DMA Abort callback :
;;;6001           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6002           hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
00007c  4841              LDR      r0,|L74.388|
00007e  6ba1              LDR      r1,[r4,#0x38]
000080  6508              STR      r0,[r1,#0x50]
;;;6003   
;;;6004           /* Abort DMA RX */
;;;6005           if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
000082  6ba0              LDR      r0,[r4,#0x38]
000084  f7fffffe          BL       HAL_DMA_Abort_IT
000088  b310              CBZ      r0,|L74.208|
;;;6006           {
;;;6007             /* Call Directly XferAbortCallback function in case of error */
;;;6008             hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
00008a  6ba0              LDR      r0,[r4,#0x38]
00008c  6d01              LDR      r1,[r0,#0x50]
00008e  4788              BLX      r1
000090  e01e              B        |L74.208|
                  |L74.146|
;;;6009           }
;;;6010         }
;;;6011       }
;;;6012       else
;;;6013       {
;;;6014         hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
000092  6b60              LDR      r0,[r4,#0x34]
000094  6800              LDR      r0,[r0,#0]
000096  6840              LDR      r0,[r0,#4]
000098  8560              STRH     r0,[r4,#0x2a]
;;;6015   
;;;6016         if (hi2c->XferCount != 0U)
00009a  8d60              LDRH     r0,[r4,#0x2a]
00009c  b118              CBZ      r0,|L74.166|
;;;6017         {
;;;6018           /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;6019           hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00009e  6c20              LDR      r0,[r4,#0x40]
0000a0  f0400004          ORR      r0,r0,#4
0000a4  6420              STR      r0,[r4,#0x40]
                  |L74.166|
;;;6020         }
;;;6021   
;;;6022         /* Disable, stop the current DMA */
;;;6023         CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6840              LDR      r0,[r0,#4]
0000aa  f4206000          BIC      r0,r0,#0x800
0000ae  6821              LDR      r1,[r4,#0]
0000b0  6048              STR      r0,[r1,#4]
;;;6024   
;;;6025         /* Abort DMA Xfer if any */
;;;6026         if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
0000b2  6b60              LDR      r0,[r4,#0x34]
0000b4  f7fffffe          BL       HAL_DMA_GetState
0000b8  2801              CMP      r0,#1
0000ba  d009              BEQ      |L74.208|
;;;6027         {
;;;6028           /* Set the I2C DMA Abort callback :
;;;6029           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6030           hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
0000bc  4831              LDR      r0,|L74.388|
0000be  6b61              LDR      r1,[r4,#0x34]
0000c0  6508              STR      r0,[r1,#0x50]
;;;6031   
;;;6032           /* Abort DMA TX */
;;;6033           if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
0000c2  6b60              LDR      r0,[r4,#0x34]
0000c4  f7fffffe          BL       HAL_DMA_Abort_IT
0000c8  b110              CBZ      r0,|L74.208|
;;;6034           {
;;;6035             /* Call Directly XferAbortCallback function in case of error */
;;;6036             hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
0000ca  6b60              LDR      r0,[r4,#0x34]
0000cc  6d01              LDR      r1,[r0,#0x50]
0000ce  4788              BLX      r1
                  |L74.208|
;;;6037           }
;;;6038         }
;;;6039       }
;;;6040     }
;;;6041   
;;;6042     /* All data are not transferred, so set error code accordingly */
;;;6043     if (hi2c->XferCount != 0U)
0000d0  8d60              LDRH     r0,[r4,#0x2a]
0000d2  b318              CBZ      r0,|L74.284|
;;;6044     {
;;;6045       /* Store Last receive data if any */
;;;6046       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6940              LDR      r0,[r0,#0x14]
0000d8  f3c00080          UBFX     r0,r0,#2,#1
0000dc  b148              CBZ      r0,|L74.242|
;;;6047       {
;;;6048         /* Read data from DR */
;;;6049         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000de  6820              LDR      r0,[r4,#0]
0000e0  6900              LDR      r0,[r0,#0x10]
0000e2  6a61              LDR      r1,[r4,#0x24]
0000e4  7008              STRB     r0,[r1,#0]
;;;6050   
;;;6051         /* Increment Buffer pointer */
;;;6052         hi2c->pBuffPtr++;
0000e6  6a60              LDR      r0,[r4,#0x24]
0000e8  1c40              ADDS     r0,r0,#1
0000ea  6260              STR      r0,[r4,#0x24]
;;;6053   
;;;6054         /* Update counter */
;;;6055         hi2c->XferCount--;
0000ec  8d60              LDRH     r0,[r4,#0x2a]
0000ee  1e40              SUBS     r0,r0,#1
0000f0  8560              STRH     r0,[r4,#0x2a]
                  |L74.242|
;;;6056       }
;;;6057   
;;;6058       /* Store Last receive data if any */
;;;6059       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6940              LDR      r0,[r0,#0x14]
0000f6  f3c01080          UBFX     r0,r0,#6,#1
0000fa  b148              CBZ      r0,|L74.272|
;;;6060       {
;;;6061         /* Read data from DR */
;;;6062         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000fc  6820              LDR      r0,[r4,#0]
0000fe  6900              LDR      r0,[r0,#0x10]
000100  6a61              LDR      r1,[r4,#0x24]
000102  7008              STRB     r0,[r1,#0]
;;;6063   
;;;6064         /* Increment Buffer pointer */
;;;6065         hi2c->pBuffPtr++;
000104  6a60              LDR      r0,[r4,#0x24]
000106  1c40              ADDS     r0,r0,#1
000108  6260              STR      r0,[r4,#0x24]
;;;6066   
;;;6067         /* Update counter */
;;;6068         hi2c->XferCount--;
00010a  8d60              LDRH     r0,[r4,#0x2a]
00010c  1e40              SUBS     r0,r0,#1
00010e  8560              STRH     r0,[r4,#0x2a]
                  |L74.272|
;;;6069       }
;;;6070   
;;;6071       if (hi2c->XferCount != 0U)
000110  8d60              LDRH     r0,[r4,#0x2a]
000112  b118              CBZ      r0,|L74.284|
;;;6072       {
;;;6073         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;6074         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000114  6c20              LDR      r0,[r4,#0x40]
000116  f0400004          ORR      r0,r0,#4
00011a  6420              STR      r0,[r4,#0x40]
                  |L74.284|
;;;6075       }
;;;6076     }
;;;6077   
;;;6078     if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00011c  6c20              LDR      r0,[r4,#0x40]
00011e  b118              CBZ      r0,|L74.296|
;;;6079     {
;;;6080       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6081       I2C_ITError(hi2c);
000120  4620              MOV      r0,r4
000122  f7fffffe          BL       I2C_ITError
000126  e02b              B        |L74.384|
                  |L74.296|
;;;6082     }
;;;6083     else
;;;6084     {
;;;6085       if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
000128  2d2a              CMP      r5,#0x2a
00012a  d107              BNE      |L74.316|
;;;6086       {
;;;6087         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6088         hi2c->PreviousState = I2C_STATE_NONE;
00012c  2000              MOVS     r0,#0
00012e  6320              STR      r0,[r4,#0x30]
;;;6089         hi2c->State = HAL_I2C_STATE_LISTEN;
000130  2028              MOVS     r0,#0x28
000132  f884003d          STRB     r0,[r4,#0x3d]
;;;6090   
;;;6091         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6092   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6093         hi2c->SlaveRxCpltCallback(hi2c);
;;;6094   #else
;;;6095         HAL_I2C_SlaveRxCpltCallback(hi2c);
000136  4620              MOV      r0,r4
000138  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L74.316|
;;;6096   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6097       }
;;;6098   
;;;6099       if (hi2c->State == HAL_I2C_STATE_LISTEN)
00013c  f894003d          LDRB     r0,[r4,#0x3d]
000140  2828              CMP      r0,#0x28
000142  d10d              BNE      |L74.352|
;;;6100       {
;;;6101         hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000144  4810              LDR      r0,|L74.392|
000146  62e0              STR      r0,[r4,#0x2c]
;;;6102         hi2c->PreviousState = I2C_STATE_NONE;
000148  2000              MOVS     r0,#0
00014a  6320              STR      r0,[r4,#0x30]
;;;6103         hi2c->State = HAL_I2C_STATE_READY;
00014c  2020              MOVS     r0,#0x20
00014e  f884003d          STRB     r0,[r4,#0x3d]
;;;6104         hi2c->Mode = HAL_I2C_MODE_NONE;
000152  2000              MOVS     r0,#0
000154  f884003e          STRB     r0,[r4,#0x3e]
;;;6105   
;;;6106         /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6107   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6108         hi2c->ListenCpltCallback(hi2c);
;;;6109   #else
;;;6110         HAL_I2C_ListenCpltCallback(hi2c);
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       HAL_I2C_ListenCpltCallback
00015e  e00f              B        |L74.384|
                  |L74.352|
;;;6111   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6112       }
;;;6113       else
;;;6114       {
;;;6115         if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
000160  6b20              LDR      r0,[r4,#0x30]
000162  2822              CMP      r0,#0x22
000164  d001              BEQ      |L74.362|
000166  2d22              CMP      r5,#0x22
000168  d10a              BNE      |L74.384|
                  |L74.362|
;;;6116         {
;;;6117           hi2c->PreviousState = I2C_STATE_NONE;
00016a  2000              MOVS     r0,#0
00016c  6320              STR      r0,[r4,#0x30]
;;;6118           hi2c->State = HAL_I2C_STATE_READY;
00016e  2020              MOVS     r0,#0x20
000170  f884003d          STRB     r0,[r4,#0x3d]
;;;6119           hi2c->Mode = HAL_I2C_MODE_NONE;
000174  2000              MOVS     r0,#0
000176  f884003e          STRB     r0,[r4,#0x3e]
;;;6120   
;;;6121   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6122           hi2c->SlaveRxCpltCallback(hi2c);
;;;6123   #else
;;;6124           HAL_I2C_SlaveRxCpltCallback(hi2c);
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L74.384|
;;;6125   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6126         }
;;;6127       }
;;;6128     }
;;;6129   }
000180  bd38              POP      {r3-r5,pc}
;;;6130   
                          ENDP

000182  0000              DCW      0x0000
                  |L74.388|
                          DCD      I2C_DMAAbort
                  |L74.392|
                          DCD      0xffff0000

                          AREA ||i.I2C_WaitOnBTFFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnBTFFlagUntilTimeout PROC
;;;7131     */
;;;7132   static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7133   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7134     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
000008  e020              B        |L75.76|
                  |L75.10|
;;;7135     {
;;;7136       /* Check if a NACK is detected */
;;;7137       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L75.22|
;;;7138       {
;;;7139         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L75.20|
;;;7140       }
;;;7141   
;;;7142       /* Check for the Timeout */
;;;7143       if (Timeout != HAL_MAX_DELAY)
;;;7144       {
;;;7145         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7146         {
;;;7147           hi2c->PreviousState       = I2C_STATE_NONE;
;;;7148           hi2c->State               = HAL_I2C_STATE_READY;
;;;7149           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7150           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7151   
;;;7152           /* Process Unlocked */
;;;7153           __HAL_UNLOCK(hi2c);
;;;7154   
;;;7155           return HAL_ERROR;
;;;7156         }
;;;7157       }
;;;7158     }
;;;7159     return HAL_OK;
;;;7160   }
000014  bd70              POP      {r4-r6,pc}
                  |L75.22|
000016  1c68              ADDS     r0,r5,#1              ;7143
000018  b1c0              CBZ      r0,|L75.76|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6              ;7145
000020  42a8              CMP      r0,r5                 ;7145
000022  d800              BHI      |L75.38|
000024  b995              CBNZ     r5,|L75.76|
                  |L75.38|
000026  2000              MOVS     r0,#0                 ;7147
000028  6320              STR      r0,[r4,#0x30]         ;7147
00002a  2020              MOVS     r0,#0x20              ;7148
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;7148
000030  2000              MOVS     r0,#0                 ;7149
000032  f884003e          STRB     r0,[r4,#0x3e]         ;7149
000036  6c20              LDR      r0,[r4,#0x40]         ;7150
000038  f0400020          ORR      r0,r0,#0x20           ;7150
00003c  6420              STR      r0,[r4,#0x40]         ;7150
00003e  bf00              NOP                            ;7153
000040  2000              MOVS     r0,#0                 ;7153
000042  f884003c          STRB     r0,[r4,#0x3c]         ;7153
000046  bf00              NOP                            ;7153
000048  2001              MOVS     r0,#1                 ;7155
00004a  e7e3              B        |L75.20|
                  |L75.76|
00004c  6820              LDR      r0,[r4,#0]            ;7134
00004e  6940              LDR      r0,[r0,#0x14]         ;7134
000050  f3c00080          UBFX     r0,r0,#2,#1           ;7134
000054  2800              CMP      r0,#0                 ;7134
000056  d0d8              BEQ      |L75.10|
000058  2000              MOVS     r0,#0                 ;7159
00005a  e7db              B        |L75.20|
;;;7161   
                          ENDP


                          AREA ||i.I2C_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnFlagUntilTimeout PROC
;;;7008     */
;;;7009   static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;7010   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;7011     /* Wait until flag is set */
;;;7012     while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
000010  e01c              B        |L76.76|
                  |L76.18|
;;;7013     {
;;;7014       /* Check for the Timeout */
;;;7015       if (Timeout != HAL_MAX_DELAY)
000012  1c70              ADDS     r0,r6,#1
000014  b1d0              CBZ      r0,|L76.76|
;;;7016       {
;;;7017         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d800              BHI      |L76.36|
000022  b99e              CBNZ     r6,|L76.76|
                  |L76.36|
;;;7018         {
;;;7019           hi2c->PreviousState     = I2C_STATE_NONE;
000024  2000              MOVS     r0,#0
000026  6320              STR      r0,[r4,#0x30]
;;;7020           hi2c->State             = HAL_I2C_STATE_READY;
000028  2020              MOVS     r0,#0x20
00002a  f884003d          STRB     r0,[r4,#0x3d]
;;;7021           hi2c->Mode              = HAL_I2C_MODE_NONE;
00002e  2000              MOVS     r0,#0
000030  f884003e          STRB     r0,[r4,#0x3e]
;;;7022           hi2c->ErrorCode         |= HAL_I2C_ERROR_TIMEOUT;
000034  6c20              LDR      r0,[r4,#0x40]
000036  f0400020          ORR      r0,r0,#0x20
00003a  6420              STR      r0,[r4,#0x40]
;;;7023   
;;;7024           /* Process Unlocked */
;;;7025           __HAL_UNLOCK(hi2c);
00003c  bf00              NOP      
00003e  2000              MOVS     r0,#0
000040  f884003c          STRB     r0,[r4,#0x3c]
000044  bf00              NOP      
;;;7026   
;;;7027           return HAL_ERROR;
000046  2001              MOVS     r0,#1
                  |L76.72|
;;;7028         }
;;;7029       }
;;;7030     }
;;;7031     return HAL_OK;
;;;7032   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L76.76|
00004c  f3c54007          UBFX     r0,r5,#16,#8          ;7012
000050  2801              CMP      r0,#1                 ;7012
000052  d10a              BNE      |L76.106|
000054  6820              LDR      r0,[r4,#0]            ;7012
000056  6940              LDR      r0,[r0,#0x14]         ;7012
000058  b2a9              UXTH     r1,r5                 ;7012
00005a  4008              ANDS     r0,r0,r1              ;7012
00005c  b2a9              UXTH     r1,r5                 ;7012
00005e  4288              CMP      r0,r1                 ;7012
000060  d101              BNE      |L76.102|
000062  2001              MOVS     r0,#1                 ;7012
000064  e00b              B        |L76.126|
                  |L76.102|
000066  2000              MOVS     r0,#0                 ;7012
000068  e009              B        |L76.126|
                  |L76.106|
00006a  6820              LDR      r0,[r4,#0]            ;7012
00006c  6980              LDR      r0,[r0,#0x18]         ;7012
00006e  b2a9              UXTH     r1,r5                 ;7012
000070  4008              ANDS     r0,r0,r1              ;7012
000072  b2a9              UXTH     r1,r5                 ;7012
000074  4288              CMP      r0,r1                 ;7012
000076  d101              BNE      |L76.124|
000078  2001              MOVS     r0,#1                 ;7012
00007a  e000              B        |L76.126|
                  |L76.124|
00007c  2000              MOVS     r0,#0                 ;7012
                  |L76.126|
00007e  42b8              CMP      r0,r7                 ;7012
000080  d0c7              BEQ      |L76.18|
000082  2000              MOVS     r0,#0                 ;7031
000084  e7e0              B        |L76.72|
;;;7033   
                          ENDP


                          AREA ||i.I2C_WaitOnMasterAddressFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnMasterAddressFlagUntilTimeout PROC
;;;7042     */
;;;7043   static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;7044   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;7045     while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
00000c  e03d              B        |L77.138|
                  |L77.14|
;;;7046     {
;;;7047       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
00000e  6820              LDR      r0,[r4,#0]
000010  6940              LDR      r0,[r0,#0x14]
000012  f3c02080          UBFX     r0,r0,#10,#1
000016  b1e8              CBZ      r0,|L77.84|
;;;7048       {
;;;7049         /* Generate Stop */
;;;7050         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000018  6820              LDR      r0,[r4,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  f4407000          ORR      r0,r0,#0x200
000020  6821              LDR      r1,[r4,#0]
000022  6008              STR      r0,[r1,#0]
;;;7051   
;;;7052         /* Clear AF Flag */
;;;7053         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000024  f46f6080          MVN      r0,#0x400
000028  6821              LDR      r1,[r4,#0]
00002a  6148              STR      r0,[r1,#0x14]
;;;7054   
;;;7055         hi2c->PreviousState       = I2C_STATE_NONE;
00002c  2000              MOVS     r0,#0
00002e  6320              STR      r0,[r4,#0x30]
;;;7056         hi2c->State               = HAL_I2C_STATE_READY;
000030  2020              MOVS     r0,#0x20
000032  f884003d          STRB     r0,[r4,#0x3d]
;;;7057         hi2c->Mode                = HAL_I2C_MODE_NONE;
000036  2000              MOVS     r0,#0
000038  f884003e          STRB     r0,[r4,#0x3e]
;;;7058         hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
00003c  6c20              LDR      r0,[r4,#0x40]
00003e  f0400004          ORR      r0,r0,#4
000042  6420              STR      r0,[r4,#0x40]
;;;7059   
;;;7060         /* Process Unlocked */
;;;7061         __HAL_UNLOCK(hi2c);
000044  bf00              NOP      
000046  2000              MOVS     r0,#0
000048  f884003c          STRB     r0,[r4,#0x3c]
00004c  bf00              NOP      
;;;7062   
;;;7063         return HAL_ERROR;
00004e  2001              MOVS     r0,#1
                  |L77.80|
;;;7064       }
;;;7065   
;;;7066       /* Check for the Timeout */
;;;7067       if (Timeout != HAL_MAX_DELAY)
;;;7068       {
;;;7069         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7070         {
;;;7071           hi2c->PreviousState       = I2C_STATE_NONE;
;;;7072           hi2c->State               = HAL_I2C_STATE_READY;
;;;7073           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7074           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7075   
;;;7076           /* Process Unlocked */
;;;7077           __HAL_UNLOCK(hi2c);
;;;7078   
;;;7079           return HAL_ERROR;
;;;7080         }
;;;7081       }
;;;7082     }
;;;7083     return HAL_OK;
;;;7084   }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L77.84|
000054  1c70              ADDS     r0,r6,#1              ;7067
000056  b1c0              CBZ      r0,|L77.138|
000058  f7fffffe          BL       HAL_GetTick
00005c  1bc0              SUBS     r0,r0,r7              ;7069
00005e  42b0              CMP      r0,r6                 ;7069
000060  d800              BHI      |L77.100|
000062  b996              CBNZ     r6,|L77.138|
                  |L77.100|
000064  2000              MOVS     r0,#0                 ;7071
000066  6320              STR      r0,[r4,#0x30]         ;7071
000068  2020              MOVS     r0,#0x20              ;7072
00006a  f884003d          STRB     r0,[r4,#0x3d]         ;7072
00006e  2000              MOVS     r0,#0                 ;7073
000070  f884003e          STRB     r0,[r4,#0x3e]         ;7073
000074  6c20              LDR      r0,[r4,#0x40]         ;7074
000076  f0400020          ORR      r0,r0,#0x20           ;7074
00007a  6420              STR      r0,[r4,#0x40]         ;7074
00007c  bf00              NOP                            ;7077
00007e  2000              MOVS     r0,#0                 ;7077
000080  f884003c          STRB     r0,[r4,#0x3c]         ;7077
000084  bf00              NOP                            ;7077
000086  2001              MOVS     r0,#1                 ;7079
000088  e7e2              B        |L77.80|
                  |L77.138|
00008a  f3c54007          UBFX     r0,r5,#16,#8          ;7045
00008e  2801              CMP      r0,#1                 ;7045
000090  d10a              BNE      |L77.168|
000092  6820              LDR      r0,[r4,#0]            ;7045
000094  6940              LDR      r0,[r0,#0x14]         ;7045
000096  b2a9              UXTH     r1,r5                 ;7045
000098  4008              ANDS     r0,r0,r1              ;7045
00009a  b2a9              UXTH     r1,r5                 ;7045
00009c  4288              CMP      r0,r1                 ;7045
00009e  d101              BNE      |L77.164|
0000a0  2001              MOVS     r0,#1                 ;7045
0000a2  e00b              B        |L77.188|
                  |L77.164|
0000a4  2000              MOVS     r0,#0                 ;7045
0000a6  e009              B        |L77.188|
                  |L77.168|
0000a8  6820              LDR      r0,[r4,#0]            ;7045
0000aa  6980              LDR      r0,[r0,#0x18]         ;7045
0000ac  b2a9              UXTH     r1,r5                 ;7045
0000ae  4008              ANDS     r0,r0,r1              ;7045
0000b0  b2a9              UXTH     r1,r5                 ;7045
0000b2  4288              CMP      r0,r1                 ;7045
0000b4  d101              BNE      |L77.186|
0000b6  2001              MOVS     r0,#1                 ;7045
0000b8  e000              B        |L77.188|
                  |L77.186|
0000ba  2000              MOVS     r0,#0                 ;7045
                  |L77.188|
0000bc  2800              CMP      r0,#0                 ;7045
0000be  d0a6              BEQ      |L77.14|
0000c0  2000              MOVS     r0,#0                 ;7083
0000c2  e7c5              B        |L77.80|
;;;7085   
                          ENDP


                          AREA ||i.I2C_WaitOnRXNEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnRXNEFlagUntilTimeout PROC
;;;7231     */
;;;7232   static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7233   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7234   
;;;7235     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
000008  e032              B        |L78.112|
                  |L78.10|
;;;7236     {
;;;7237       /* Check if a STOPF is detected */
;;;7238       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
00000a  6820              LDR      r0,[r4,#0]
00000c  6940              LDR      r0,[r0,#0x14]
00000e  f3c01000          UBFX     r0,r0,#4,#1
000012  b1a0              CBZ      r0,|L78.62|
;;;7239       {
;;;7240         /* Clear STOP Flag */
;;;7241         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
000014  f06f0010          MVN      r0,#0x10
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;7242   
;;;7243         hi2c->PreviousState       = I2C_STATE_NONE;
00001c  2000              MOVS     r0,#0
00001e  6320              STR      r0,[r4,#0x30]
;;;7244         hi2c->State               = HAL_I2C_STATE_READY;
000020  2020              MOVS     r0,#0x20
000022  f884003d          STRB     r0,[r4,#0x3d]
;;;7245         hi2c->Mode                = HAL_I2C_MODE_NONE;
000026  2000              MOVS     r0,#0
000028  f884003e          STRB     r0,[r4,#0x3e]
;;;7246         hi2c->ErrorCode           |= HAL_I2C_ERROR_NONE;
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  6420              STR      r0,[r4,#0x40]
;;;7247   
;;;7248         /* Process Unlocked */
;;;7249         __HAL_UNLOCK(hi2c);
000030  bf00              NOP      
000032  2000              MOVS     r0,#0
000034  f884003c          STRB     r0,[r4,#0x3c]
000038  bf00              NOP      
;;;7250   
;;;7251         return HAL_ERROR;
00003a  2001              MOVS     r0,#1
                  |L78.60|
;;;7252       }
;;;7253   
;;;7254       /* Check for the Timeout */
;;;7255       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7256       {
;;;7257         hi2c->PreviousState       = I2C_STATE_NONE;
;;;7258         hi2c->State               = HAL_I2C_STATE_READY;
;;;7259         hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7260         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7261   
;;;7262         /* Process Unlocked */
;;;7263         __HAL_UNLOCK(hi2c);
;;;7264   
;;;7265         return HAL_ERROR;
;;;7266       }
;;;7267     }
;;;7268     return HAL_OK;
;;;7269   }
00003c  bd70              POP      {r4-r6,pc}
                  |L78.62|
00003e  f7fffffe          BL       HAL_GetTick
000042  1b80              SUBS     r0,r0,r6              ;7255
000044  42a8              CMP      r0,r5                 ;7255
000046  d800              BHI      |L78.74|
000048  b995              CBNZ     r5,|L78.112|
                  |L78.74|
00004a  2000              MOVS     r0,#0                 ;7257
00004c  6320              STR      r0,[r4,#0x30]         ;7257
00004e  2020              MOVS     r0,#0x20              ;7258
000050  f884003d          STRB     r0,[r4,#0x3d]         ;7258
000054  2000              MOVS     r0,#0                 ;7259
000056  f884003e          STRB     r0,[r4,#0x3e]         ;7259
00005a  6c20              LDR      r0,[r4,#0x40]         ;7260
00005c  f0400020          ORR      r0,r0,#0x20           ;7260
000060  6420              STR      r0,[r4,#0x40]         ;7260
000062  bf00              NOP                            ;7263
000064  2000              MOVS     r0,#0                 ;7263
000066  f884003c          STRB     r0,[r4,#0x3c]         ;7263
00006a  bf00              NOP                            ;7263
00006c  2001              MOVS     r0,#1                 ;7265
00006e  e7e5              B        |L78.60|
                  |L78.112|
000070  6820              LDR      r0,[r4,#0]            ;7235
000072  6940              LDR      r0,[r0,#0x14]         ;7235
000074  f3c01080          UBFX     r0,r0,#6,#1           ;7235
000078  2800              CMP      r0,#0                 ;7235
00007a  d0c6              BEQ      |L78.10|
00007c  2000              MOVS     r0,#0                 ;7268
00007e  e7dd              B        |L78.60|
;;;7270   
                          ENDP


                          AREA ||i.I2C_WaitOnSTOPFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnSTOPFlagUntilTimeout PROC
;;;7169     */
;;;7170   static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7171   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7172     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
000008  e01e              B        |L79.72|
                  |L79.10|
;;;7173     {
;;;7174       /* Check if a NACK is detected */
;;;7175       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L79.22|
;;;7176       {
;;;7177         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L79.20|
;;;7178       }
;;;7179   
;;;7180       /* Check for the Timeout */
;;;7181       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7182       {
;;;7183         hi2c->PreviousState       = I2C_STATE_NONE;
;;;7184         hi2c->State               = HAL_I2C_STATE_READY;
;;;7185         hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7186         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7187   
;;;7188         /* Process Unlocked */
;;;7189         __HAL_UNLOCK(hi2c);
;;;7190   
;;;7191         return HAL_ERROR;
;;;7192       }
;;;7193     }
;;;7194     return HAL_OK;
;;;7195   }
000014  bd70              POP      {r4-r6,pc}
                  |L79.22|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6              ;7181
00001c  42a8              CMP      r0,r5                 ;7181
00001e  d800              BHI      |L79.34|
000020  b995              CBNZ     r5,|L79.72|
                  |L79.34|
000022  2000              MOVS     r0,#0                 ;7183
000024  6320              STR      r0,[r4,#0x30]         ;7183
000026  2020              MOVS     r0,#0x20              ;7184
000028  f884003d          STRB     r0,[r4,#0x3d]         ;7184
00002c  2000              MOVS     r0,#0                 ;7185
00002e  f884003e          STRB     r0,[r4,#0x3e]         ;7185
000032  6c20              LDR      r0,[r4,#0x40]         ;7186
000034  f0400020          ORR      r0,r0,#0x20           ;7186
000038  6420              STR      r0,[r4,#0x40]         ;7186
00003a  bf00              NOP                            ;7189
00003c  2000              MOVS     r0,#0                 ;7189
00003e  f884003c          STRB     r0,[r4,#0x3c]         ;7189
000042  bf00              NOP                            ;7189
000044  2001              MOVS     r0,#1                 ;7191
000046  e7e5              B        |L79.20|
                  |L79.72|
000048  6820              LDR      r0,[r4,#0]            ;7172
00004a  6940              LDR      r0,[r0,#0x14]         ;7172
00004c  f3c01000          UBFX     r0,r0,#4,#1           ;7172
000050  2800              CMP      r0,#0                 ;7172
000052  d0da              BEQ      |L79.10|
000054  2000              MOVS     r0,#0                 ;7194
000056  e7dd              B        |L79.20|
;;;7196   
                          ENDP


                          AREA ||i.I2C_WaitOnSTOPRequestThroughIT||, CODE, READONLY, ALIGN=2

                  I2C_WaitOnSTOPRequestThroughIT PROC
;;;7202     */
;;;7203   static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c)
000000  b508              PUSH     {r3,lr}
;;;7204   {
000002  4601              MOV      r1,r0
;;;7205     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;7206   
;;;7207     /* Wait until STOP flag is reset */
;;;7208     count = I2C_TIMEOUT_STOP_FLAG * (SystemCoreClock / 25U / 1000U);
000008  4810              LDR      r0,|L80.76|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  2219              MOVS     r2,#0x19
00000e  fbb0f0f2          UDIV     r0,r0,r2
000012  f44f727a          MOV      r2,#0x3e8
000016  fbb0f0f2          UDIV     r0,r0,r2
00001a  eb000080          ADD      r0,r0,r0,LSL #2
00001e  9000              STR      r0,[sp,#0]
;;;7209     do
000020  bf00              NOP      
                  |L80.34|
;;;7210     {
;;;7211       count--;
000022  9800              LDR      r0,[sp,#0]
000024  1e40              SUBS     r0,r0,#1
000026  9000              STR      r0,[sp,#0]
;;;7212       if (count == 0U)
000028  9800              LDR      r0,[sp,#0]
00002a  b928              CBNZ     r0,|L80.56|
;;;7213       {
;;;7214         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00002c  6c08              LDR      r0,[r1,#0x40]
00002e  f0400020          ORR      r0,r0,#0x20
000032  6408              STR      r0,[r1,#0x40]
;;;7215   
;;;7216         return HAL_ERROR;
000034  2001              MOVS     r0,#1
                  |L80.54|
;;;7217       }
;;;7218     }
;;;7219     while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
;;;7220   
;;;7221     return HAL_OK;
;;;7222   }
000036  bd08              POP      {r3,pc}
                  |L80.56|
000038  6808              LDR      r0,[r1,#0]            ;7219
00003a  6800              LDR      r0,[r0,#0]            ;7219
00003c  f4007000          AND      r0,r0,#0x200          ;7219
000040  f5b07f00          CMP      r0,#0x200             ;7219
000044  d0ed              BEQ      |L80.34|
000046  2000              MOVS     r0,#0                 ;7221
000048  e7f5              B        |L80.54|
;;;7223   
                          ENDP

00004a  0000              DCW      0x0000
                  |L80.76|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_WaitOnTXEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnTXEFlagUntilTimeout PROC
;;;7093     */
;;;7094   static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7095   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7096     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
000008  e020              B        |L81.76|
                  |L81.10|
;;;7097     {
;;;7098       /* Check if a NACK is detected */
;;;7099       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L81.22|
;;;7100       {
;;;7101         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L81.20|
;;;7102       }
;;;7103   
;;;7104       /* Check for the Timeout */
;;;7105       if (Timeout != HAL_MAX_DELAY)
;;;7106       {
;;;7107         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7108         {
;;;7109           hi2c->PreviousState       = I2C_STATE_NONE;
;;;7110           hi2c->State               = HAL_I2C_STATE_READY;
;;;7111           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7112           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7113   
;;;7114           /* Process Unlocked */
;;;7115           __HAL_UNLOCK(hi2c);
;;;7116   
;;;7117           return HAL_ERROR;
;;;7118         }
;;;7119       }
;;;7120     }
;;;7121     return HAL_OK;
;;;7122   }
000014  bd70              POP      {r4-r6,pc}
                  |L81.22|
000016  1c68              ADDS     r0,r5,#1              ;7105
000018  b1c0              CBZ      r0,|L81.76|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6              ;7107
000020  42a8              CMP      r0,r5                 ;7107
000022  d800              BHI      |L81.38|
000024  b995              CBNZ     r5,|L81.76|
                  |L81.38|
000026  2000              MOVS     r0,#0                 ;7109
000028  6320              STR      r0,[r4,#0x30]         ;7109
00002a  2020              MOVS     r0,#0x20              ;7110
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;7110
000030  2000              MOVS     r0,#0                 ;7111
000032  f884003e          STRB     r0,[r4,#0x3e]         ;7111
000036  6c20              LDR      r0,[r4,#0x40]         ;7112
000038  f0400020          ORR      r0,r0,#0x20           ;7112
00003c  6420              STR      r0,[r4,#0x40]         ;7112
00003e  bf00              NOP                            ;7115
000040  2000              MOVS     r0,#0                 ;7115
000042  f884003c          STRB     r0,[r4,#0x3c]         ;7115
000046  bf00              NOP                            ;7115
000048  2001              MOVS     r0,#1                 ;7117
00004a  e7e3              B        |L81.20|
                  |L81.76|
00004c  6820              LDR      r0,[r4,#0]            ;7096
00004e  6940              LDR      r0,[r0,#0x14]         ;7096
000050  f3c010c0          UBFX     r0,r0,#7,#1           ;7096
000054  2800              CMP      r0,#0                 ;7096
000056  d0d8              BEQ      |L81.10|
000058  2000              MOVS     r0,#0                 ;7121
00005a  e7db              B        |L81.20|
;;;7123   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REVSH|
#line 478
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____RRX|
#line 665
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
