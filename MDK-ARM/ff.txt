; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\ff.o --asm_dir=./ --list_dir=--list --depend=mcu_application\ff.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\ff.crf ../Middlewares/Third_Party/FatFs/src/ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2964   static
;;;2965   BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;2966   	FATFS* fs,	/* File system object */
;;;2967   	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
;;;2968   )
;;;2969   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2970   	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
000006  2000              MOVS     r0,#0
000008  70e0              STRB     r0,[r4,#3]
00000a  1e40              SUBS     r0,r0,#1
00000c  62e0              STR      r0,[r4,#0x2c]
;;;2971   	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       move_window
000016  b108              CBZ      r0,|L1.28|
000018  2004              MOVS     r0,#4
                  |L1.26|
;;;2972   
;;;2973   	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
;;;2974   
;;;2975   	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
;;;2976   		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
;;;2977   		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
;;;2978   	}
;;;2979   #if _FS_EXFAT
;;;2980   	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
;;;2981   #endif
;;;2982   	return 2;
;;;2983   }
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  f204202e          ADD      r0,r4,#0x22e          ;2973
000020  f7fffffe          BL       ld_word
000024  f64a2155          MOV      r1,#0xaa55            ;2973
000028  4288              CMP      r0,r1                 ;2973
00002a  d001              BEQ      |L1.48|
00002c  2003              MOVS     r0,#3                 ;2973
00002e  e7f4              B        |L1.26|
                  |L1.48|
000030  f8940030          LDRB     r0,[r4,#0x30]         ;2975
000034  28e9              CMP      r0,#0xe9              ;2975
000036  d007              BEQ      |L1.72|
000038  f8940030          LDRB     r0,[r4,#0x30]         ;2975
00003c  28eb              CMP      r0,#0xeb              ;2975
00003e  d117              BNE      |L1.112|
000040  2032              MOVS     r0,#0x32              ;2975
000042  5d00              LDRB     r0,[r0,r4]            ;2975
000044  2890              CMP      r0,#0x90              ;2975
000046  d113              BNE      |L1.112|
                  |L1.72|
000048  f1040066          ADD      r0,r4,#0x66           ;2976
00004c  f7fffffe          BL       ld_dword
000050  f020407f          BIC      r0,r0,#0xff000000     ;2976
000054  4907              LDR      r1,|L1.116|
000056  4288              CMP      r0,r1                 ;2976
000058  d101              BNE      |L1.94|
00005a  2000              MOVS     r0,#0                 ;2976
00005c  e7dd              B        |L1.26|
                  |L1.94|
00005e  f1040082          ADD      r0,r4,#0x82           ;2977
000062  f7fffffe          BL       ld_dword
000066  4904              LDR      r1,|L1.120|
000068  4288              CMP      r0,r1                 ;2977
00006a  d101              BNE      |L1.112|
00006c  2000              MOVS     r0,#0                 ;2977
00006e  e7d4              B        |L1.26|
                  |L1.112|
000070  2002              MOVS     r0,#2                 ;2982
000072  e7d2              B        |L1.26|
;;;2984   
                          ENDP

                  |L1.116|
                          DCD      0x00544146
                  |L1.120|
                          DCD      0x33544146

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;728    static
;;;729    int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
000000  4602              MOV      r2,r0
;;;730    	while (*str && *str != chr) str++;
000002  e000              B        |L2.6|
                  |L2.4|
000004  1c52              ADDS     r2,r2,#1
                  |L2.6|
000006  7810              LDRB     r0,[r2,#0]
000008  b110              CBZ      r0,|L2.16|
00000a  7810              LDRB     r0,[r2,#0]
00000c  4288              CMP      r0,r1
00000e  d1f9              BNE      |L2.4|
                  |L2.16|
;;;731    	return *str;
000010  7810              LDRB     r0,[r2,#0]
;;;732    }
000012  4770              BX       lr
;;;733    
                          ENDP


                          AREA ||i.chk_lock||, CODE, READONLY, ALIGN=2

                  chk_lock PROC
;;;770    static
;;;771    FRESULT chk_lock (	/* Check if the file can be accessed */
000000  b530              PUSH     {r4,r5,lr}
;;;772    	DIR* dp,		/* Directory object pointing the file to be checked */
;;;773    	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
;;;774    )
;;;775    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;776    	UINT i, be;
;;;777    
;;;778    	/* Search file semaphore table */
;;;779    	for (i = be = 0; i < _FS_LOCK; i++) {
000006  2000              MOVS     r0,#0
000008  4604              MOV      r4,r0
00000a  4601              MOV      r1,r0
00000c  e01c              B        |L3.72|
                  |L3.14|
;;;780    		if (Files[i].fs) {	/* Existing entry */
00000e  481a              LDR      r0,|L3.120|
000010  eb001001          ADD      r0,r0,r1,LSL #4
000014  6800              LDR      r0,[r0,#0]
000016  b1a8              CBZ      r0,|L3.68|
;;;781    			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
000018  4817              LDR      r0,|L3.120|
00001a  eb001001          ADD      r0,r0,r1,LSL #4
00001e  6800              LDR      r0,[r0,#0]
000020  6815              LDR      r5,[r2,#0]
000022  42a8              CMP      r0,r5
000024  d10f              BNE      |L3.70|
;;;782    				Files[i].clu == dp->obj.sclust &&
000026  4814              LDR      r0,|L3.120|
000028  eb001001          ADD      r0,r0,r1,LSL #4
00002c  6840              LDR      r0,[r0,#4]
00002e  6895              LDR      r5,[r2,#8]
000030  42a8              CMP      r0,r5
000032  d108              BNE      |L3.70|
;;;783    				Files[i].ofs == dp->dptr) break;
000034  4810              LDR      r0,|L3.120|
000036  eb001001          ADD      r0,r0,r1,LSL #4
00003a  6880              LDR      r0,[r0,#8]
00003c  6955              LDR      r5,[r2,#0x14]
00003e  42a8              CMP      r0,r5
000040  d101              BNE      |L3.70|
000042  e003              B        |L3.76|
                  |L3.68|
;;;784    		} else {			/* Blank entry */
;;;785    			be = 1;
000044  2401              MOVS     r4,#1
                  |L3.70|
000046  1c49              ADDS     r1,r1,#1              ;779
                  |L3.72|
000048  290a              CMP      r1,#0xa               ;779
00004a  d3e0              BCC      |L3.14|
                  |L3.76|
00004c  bf00              NOP                            ;783
;;;786    		}
;;;787    	}
;;;788    	if (i == _FS_LOCK) {	/* The object is not opened */
00004e  290a              CMP      r1,#0xa
000050  d106              BNE      |L3.96|
;;;789    		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
000052  b90c              CBNZ     r4,|L3.88|
000054  2b02              CMP      r3,#2
000056  d101              BNE      |L3.92|
                  |L3.88|
000058  2000              MOVS     r0,#0
                  |L3.90|
;;;790    	}
;;;791    
;;;792    	/* The object has been opened. Reject any open against writing file and all write mode open */
;;;793    	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
;;;794    }
00005a  bd30              POP      {r4,r5,pc}
                  |L3.92|
00005c  2012              MOVS     r0,#0x12              ;789
00005e  e7fc              B        |L3.90|
                  |L3.96|
000060  b933              CBNZ     r3,|L3.112|
000062  4805              LDR      r0,|L3.120|
000064  eb001001          ADD      r0,r0,r1,LSL #4       ;793
000068  8980              LDRH     r0,[r0,#0xc]          ;793
00006a  f5b07f80          CMP      r0,#0x100             ;793
00006e  d101              BNE      |L3.116|
                  |L3.112|
000070  2010              MOVS     r0,#0x10              ;793
000072  e7f2              B        |L3.90|
                  |L3.116|
000074  2000              MOVS     r0,#0                 ;793
000076  e7f0              B        |L3.90|
;;;795    
                          ENDP

                  |L3.120|
                          DCD      Files

                          AREA ||i.clear_lock||, CODE, READONLY, ALIGN=2

                  clear_lock PROC
;;;862    static
;;;863    void clear_lock (	/* Clear lock entries of the volume */
000000  4601              MOV      r1,r0
;;;864    	FATFS *fs
;;;865    )
;;;866    {
;;;867    	UINT i;
;;;868    
;;;869    	for (i = 0; i < _FS_LOCK; i++) {
000002  2000              MOVS     r0,#0
000004  e00b              B        |L4.30|
                  |L4.6|
;;;870    		if (Files[i].fs == fs) Files[i].fs = 0;
000006  4a07              LDR      r2,|L4.36|
000008  eb021200          ADD      r2,r2,r0,LSL #4
00000c  6812              LDR      r2,[r2,#0]
00000e  428a              CMP      r2,r1
000010  d104              BNE      |L4.28|
000012  2200              MOVS     r2,#0
000014  4b03              LDR      r3,|L4.36|
000016  eb031300          ADD      r3,r3,r0,LSL #4
00001a  601a              STR      r2,[r3,#0]
                  |L4.28|
00001c  1c40              ADDS     r0,r0,#1              ;869
                  |L4.30|
00001e  280a              CMP      r0,#0xa               ;869
000020  d3f1              BCC      |L4.6|
;;;871    	}
;;;872    }
000022  4770              BX       lr
;;;873    
                          ENDP

                  |L4.36|
                          DCD      Files

                          AREA ||i.clmt_clust||, CODE, READONLY, ALIGN=1

                  clmt_clust PROC
;;;1439   static
;;;1440   DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
000000  b5f0              PUSH     {r4-r7,lr}
;;;1441   	FIL* fp,		/* Pointer to the file object */
;;;1442   	FSIZE_t ofs		/* File offset to be converted to cluster# */
;;;1443   )
;;;1444   {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
;;;1445   	DWORD cl, ncl, *tbl;
;;;1446   	FATFS *fs = fp->obj.fs;
000006  681e              LDR      r6,[r3,#0]
;;;1447   
;;;1448   
;;;1449   	tbl = fp->cltbl + 1;	/* Top of CLMT */
000008  6ad8              LDR      r0,[r3,#0x2c]
00000a  1d02              ADDS     r2,r0,#4
;;;1450   	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
00000c  0a68              LSRS     r0,r5,#9
00000e  8977              LDRH     r7,[r6,#0xa]
000010  fbb0f4f7          UDIV     r4,r0,r7
;;;1451   	for (;;) {
000014  bf00              NOP      
                  |L5.22|
;;;1452   		ncl = *tbl++;			/* Number of cluters in the fragment */
000016  ca02              LDM      r2!,{r1}
;;;1453   		if (ncl == 0) return 0;	/* End of table? (error) */
000018  b909              CBNZ     r1,|L5.30|
00001a  2000              MOVS     r0,#0
                  |L5.28|
;;;1454   		if (cl < ncl) break;	/* In this fragment? */
;;;1455   		cl -= ncl; tbl++;		/* Next fragment */
;;;1456   	}
;;;1457   	return cl + *tbl;	/* Return the cluster number */
;;;1458   }
00001c  bdf0              POP      {r4-r7,pc}
                  |L5.30|
00001e  428c              CMP      r4,r1                 ;1454
000020  d200              BCS      |L5.36|
000022  e002              B        |L5.42|
                  |L5.36|
000024  1a64              SUBS     r4,r4,r1              ;1455
000026  1d12              ADDS     r2,r2,#4              ;1455
000028  e7f5              B        |L5.22|
                  |L5.42|
00002a  bf00              NOP                            ;1454
00002c  6810              LDR      r0,[r2,#0]            ;1457
00002e  4420              ADD      r0,r0,r4              ;1457
000030  e7f4              B        |L5.28|
;;;1459   
                          ENDP


                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;982    static
;;;983    DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
000000  4602              MOV      r2,r0
;;;984    	FATFS* fs,		/* File system object */
;;;985    	DWORD clst		/* Cluster# to be converted */
;;;986    )
;;;987    {
;;;988    	clst -= 2;
000002  1e89              SUBS     r1,r1,#2
;;;989    	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
000004  6950              LDR      r0,[r2,#0x14]
000006  1e80              SUBS     r0,r0,#2
000008  4288              CMP      r0,r1
00000a  d801              BHI      |L6.16|
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;990    	return clst * fs->csize + fs->database;
;;;991    }
00000e  4770              BX       lr
                  |L6.16|
000010  8953              LDRH     r3,[r2,#0xa]          ;990
000012  6a90              LDR      r0,[r2,#0x28]         ;990
000014  fb010003          MLA      r0,r1,r3,r0           ;990
000018  e7f9              B        |L6.14|
;;;992    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;1350   static
;;;1351   DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1352   	_FDID* obj,			/* Corresponding object */
;;;1353   	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
;;;1354   )
;;;1355   {
000004  4682              MOV      r10,r0
000006  4689              MOV      r9,r1
;;;1356   	DWORD cs, ncl, scl;
;;;1357   	FRESULT res;
;;;1358   	FATFS *fs = obj->fs;
000008  f8da4000          LDR      r4,[r10,#0]
;;;1359   
;;;1360   
;;;1361   	if (clst == 0) {	/* Create a new chain */
00000c  f1b90f00          CMP      r9,#0
000010  d106              BNE      |L7.32|
;;;1362   		scl = fs->last_clst;				/* Get suggested cluster to start from */
000012  68e7              LDR      r7,[r4,#0xc]
;;;1363   		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
000014  b117              CBZ      r7,|L7.28|
000016  6960              LDR      r0,[r4,#0x14]
000018  42b8              CMP      r0,r7
00001a  d815              BHI      |L7.72|
                  |L7.28|
00001c  2701              MOVS     r7,#1
00001e  e013              B        |L7.72|
                  |L7.32|
;;;1364   	}
;;;1365   	else {				/* Stretch current chain */
;;;1366   		cs = get_fat(obj, clst);			/* Check the cluster status */
000020  4649              MOV      r1,r9
000022  4650              MOV      r0,r10
000024  f7fffffe          BL       get_fat
000028  4606              MOV      r6,r0
;;;1367   		if (cs < 2) return 1;				/* Invalid FAT value */
00002a  2e02              CMP      r6,#2
00002c  d202              BCS      |L7.52|
00002e  2001              MOVS     r0,#1
                  |L7.48|
;;;1368   		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
;;;1369   		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;1370   		scl = clst;
;;;1371   	}
;;;1372   
;;;1373   #if _FS_EXFAT
;;;1374   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;1375   		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
;;;1376   		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
;;;1377   		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
;;;1378   		if (res == FR_INT_ERR) return 1;
;;;1379   		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
;;;1380   		if (clst == 0) {							/* Is it a new chain? */
;;;1381   			obj->stat = 2;							/* Set status 'contiguous' */
;;;1382   		} else {									/* It is a stretched chain */
;;;1383   			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
;;;1384   				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
;;;1385   				obj->stat = 3;						/* Change status 'just fragmented' */
;;;1386   			}
;;;1387   		}
;;;1388   		if (obj->stat != 2) {	/* Is the file non-contiguous? */
;;;1389   			if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
;;;1390   				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
;;;1391   			} else {				/* New fragment */
;;;1392   				if (obj->n_frag == 0) obj->n_frag = 1;
;;;1393   				res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
;;;1394   				if (res == FR_OK) obj->n_frag = 1;
;;;1395   			}
;;;1396   		}
;;;1397   	} else
;;;1398   #endif
;;;1399   	{	/* On the FAT12/16/32 volume */
;;;1400   		ncl = scl;	/* Start cluster */
;;;1401   		for (;;) {
;;;1402   			ncl++;							/* Next cluster */
;;;1403   			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
;;;1404   				ncl = 2;
;;;1405   				if (ncl > scl) return 0;	/* No free cluster */
;;;1406   			}
;;;1407   			cs = get_fat(obj, ncl);			/* Get the cluster status */
;;;1408   			if (cs == 0) break;				/* Found a free cluster */
;;;1409   			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
;;;1410   			if (ncl == scl) return 0;		/* No free cluster */
;;;1411   		}
;;;1412   		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
;;;1413   		if (res == FR_OK && clst != 0) {
;;;1414   			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
;;;1415   		}
;;;1416   	}
;;;1417   
;;;1418   	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
;;;1419   		fs->last_clst = ncl;
;;;1420   		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
;;;1421   		fs->fsi_flag |= 1;
;;;1422   	} else {
;;;1423   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
;;;1424   	}
;;;1425   
;;;1426   	return ncl;		/* Return new cluster number or error status */
;;;1427   }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L7.52|
000034  1c70              ADDS     r0,r6,#1              ;1368
000036  b908              CBNZ     r0,|L7.60|
000038  4630              MOV      r0,r6                 ;1368
00003a  e7f9              B        |L7.48|
                  |L7.60|
00003c  6960              LDR      r0,[r4,#0x14]         ;1369
00003e  42b0              CMP      r0,r6                 ;1369
000040  d901              BLS      |L7.70|
000042  4630              MOV      r0,r6                 ;1369
000044  e7f4              B        |L7.48|
                  |L7.70|
000046  464f              MOV      r7,r9                 ;1370
                  |L7.72|
000048  463d              MOV      r5,r7                 ;1400
00004a  bf00              NOP                            ;1401
                  |L7.76|
00004c  1c6d              ADDS     r5,r5,#1              ;1402
00004e  6960              LDR      r0,[r4,#0x14]         ;1403
000050  42a8              CMP      r0,r5                 ;1403
000052  d804              BHI      |L7.94|
000054  2502              MOVS     r5,#2                 ;1404
000056  42bd              CMP      r5,r7                 ;1405
000058  d901              BLS      |L7.94|
00005a  2000              MOVS     r0,#0                 ;1405
00005c  e7e8              B        |L7.48|
                  |L7.94|
00005e  4629              MOV      r1,r5                 ;1407
000060  4650              MOV      r0,r10                ;1407
000062  f7fffffe          BL       get_fat
000066  4606              MOV      r6,r0                 ;1407
000068  b906              CBNZ     r6,|L7.108|
00006a  e009              B        |L7.128|
                  |L7.108|
00006c  2e01              CMP      r6,#1                 ;1409
00006e  d001              BEQ      |L7.116|
000070  1c70              ADDS     r0,r6,#1              ;1409
000072  b908              CBNZ     r0,|L7.120|
                  |L7.116|
000074  4630              MOV      r0,r6                 ;1409
000076  e7db              B        |L7.48|
                  |L7.120|
000078  42bd              CMP      r5,r7                 ;1410
00007a  d1e7              BNE      |L7.76|
00007c  2000              MOVS     r0,#0                 ;1410
00007e  e7d7              B        |L7.48|
                  |L7.128|
000080  bf00              NOP                            ;1408
000082  f04f32ff          MOV      r2,#0xffffffff        ;1412
000086  4629              MOV      r1,r5                 ;1412
000088  4620              MOV      r0,r4                 ;1412
00008a  f7fffffe          BL       put_fat
00008e  4680              MOV      r8,r0                 ;1412
000090  f1b80f00          CMP      r8,#0                 ;1413
000094  d108              BNE      |L7.168|
000096  f1b90f00          CMP      r9,#0                 ;1413
00009a  d005              BEQ      |L7.168|
00009c  462a              MOV      r2,r5                 ;1414
00009e  4649              MOV      r1,r9                 ;1414
0000a0  4620              MOV      r0,r4                 ;1414
0000a2  f7fffffe          BL       put_fat
0000a6  4680              MOV      r8,r0                 ;1414
                  |L7.168|
0000a8  f1b80f00          CMP      r8,#0                 ;1418
0000ac  d10d              BNE      |L7.202|
0000ae  60e5              STR      r5,[r4,#0xc]          ;1419
0000b0  e9d41004          LDRD     r1,r0,[r4,#0x10]      ;1420
0000b4  1e80              SUBS     r0,r0,#2              ;1420
0000b6  4281              CMP      r1,r0                 ;1420
0000b8  d802              BHI      |L7.192|
0000ba  6920              LDR      r0,[r4,#0x10]         ;1420
0000bc  1e40              SUBS     r0,r0,#1              ;1420
0000be  6120              STR      r0,[r4,#0x10]         ;1420
                  |L7.192|
0000c0  7920              LDRB     r0,[r4,#4]            ;1421
0000c2  f0400001          ORR      r0,r0,#1              ;1421
0000c6  7120              STRB     r0,[r4,#4]            ;1421
0000c8  e007              B        |L7.218|
                  |L7.202|
0000ca  f1b80f01          CMP      r8,#1                 ;1423
0000ce  d102              BNE      |L7.214|
0000d0  f04f30ff          MOV      r0,#0xffffffff        ;1423
0000d4  e000              B        |L7.216|
                  |L7.214|
0000d6  2001              MOVS     r0,#1                 ;1423
                  |L7.216|
0000d8  4605              MOV      r5,r0                 ;1423
                  |L7.218|
0000da  4628              MOV      r0,r5                 ;1426
0000dc  e7a8              B        |L7.48|
;;;1428   
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;2617   static
;;;2618   FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2619   	DIR* dp,			/* Pointer to the directory object */
;;;2620   	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;;;2621   )
;;;2622   {
000004  4682              MOV      r10,r0
000006  4688              MOV      r8,r1
;;;2623   #if _USE_LFN != 0	/* LFN configuration */
;;;2624   	BYTE b, cf;
;;;2625   	WCHAR w, *lfn;
;;;2626   	UINT i, ni, si, di;
;;;2627   	const TCHAR *p;
;;;2628   
;;;2629   	/* Create LFN in Unicode */
;;;2630   	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
;;;2631   	for (;;) {
;;;2632   		w = p[si++];					/* Get a character */
;;;2633   		if (w < ' ') break;				/* Break if end of the path name */
;;;2634   		if (w == '/' || w == '\\') {	/* Break if a separator is found */
;;;2635   			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
;;;2636   			break;
;;;2637   		}
;;;2638   		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
;;;2639   #if !_LFN_UNICODE
;;;2640   		w &= 0xFF;
;;;2641   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;2642   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;2643   			w = (w << 8) + b;			/* Create a DBC */
;;;2644   			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;2645   		}
;;;2646   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;2647   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;2648   #endif
;;;2649   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
;;;2650   		lfn[di++] = w;					/* Store the Unicode character */
;;;2651   	}
;;;2652   	*path = &p[si];						/* Return pointer to the next segment */
;;;2653   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
;;;2654   #if _FS_RPATH != 0
;;;2655   	if ((di == 1 && lfn[di - 1] == '.') ||
;;;2656   		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
;;;2657   		lfn[di] = 0;
;;;2658   		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
;;;2659   			dp->fn[i] = (i < di) ? '.' : ' ';
;;;2660   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;2661   		return FR_OK;
;;;2662   	}
;;;2663   #endif
;;;2664   	while (di) {						/* Snip off trailing spaces and dots if exist */
;;;2665   		w = lfn[di - 1];
;;;2666   		if (w != ' ' && w != '.') break;
;;;2667   		di--;
;;;2668   	}
;;;2669   	lfn[di] = 0;						/* LFN is created */
;;;2670   	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
;;;2671   
;;;2672   	/* Create SFN in directory form */
;;;2673   	mem_set(dp->fn, ' ', 11);
;;;2674   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;2675   	if (si) cf |= NS_LOSS | NS_LFN;
;;;2676   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;2677   
;;;2678   	i = b = 0; ni = 8;
;;;2679   	for (;;) {
;;;2680   		w = lfn[si++];					/* Get an LFN character */
;;;2681   		if (!w) break;					/* Break on end of the LFN */
;;;2682   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;2683   			cf |= NS_LOSS | NS_LFN; continue;
;;;2684   		}
;;;2685   
;;;2686   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;2687   			if (ni == 11) {				/* Long extension */
;;;2688   				cf |= NS_LOSS | NS_LFN; break;
;;;2689   			}
;;;2690   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;2691   			if (si > di) break;			/* No extension */
;;;2692   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;2693   			b <<= 2; continue;
;;;2694   		}
;;;2695   
;;;2696   		if (w >= 0x80) {				/* Non ASCII character */
;;;2697   #ifdef _EXCVT
;;;2698   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;2699   			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;;;2700   #else
;;;2701   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;2702   #endif
;;;2703   			cf |= NS_LFN;				/* Force create LFN entry */
;;;2704   		}
;;;2705   
;;;2706   		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
;;;2707   			if (i >= ni - 1) {
;;;2708   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;2709   			}
;;;2710   			dp->fn[i++] = (BYTE)(w >> 8);
;;;2711   		} else {						/* SBC */
;;;2712   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;;;2713   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;2714   			} else {
;;;2715   				if (IsUpper(w)) {		/* ASCII large capital */
;;;2716   					b |= 2;
;;;2717   				} else {
;;;2718   					if (IsLower(w)) {	/* ASCII small capital */
;;;2719   						b |= 1; w -= 0x20;
;;;2720   					}
;;;2721   				}
;;;2722   			}
;;;2723   		}
;;;2724   		dp->fn[i++] = (BYTE)w;
;;;2725   	}
;;;2726   
;;;2727   	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;2728   
;;;2729   	if (ni == 8) b <<= 2;
;;;2730   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
;;;2731   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;2732   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;2733   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;2734   	}
;;;2735   
;;;2736   	dp->fn[NSFLAG] = cf;	/* SFN is created */
;;;2737   
;;;2738   	return FR_OK;
;;;2739   
;;;2740   
;;;2741   #else	/* _USE_LFN != 0 : Non-LFN configuration */
;;;2742   	BYTE c, d, *sfn;
;;;2743   	UINT ni, si, i;
;;;2744   	const char *p;
;;;2745   
;;;2746   	/* Create file name in directory form */
;;;2747   	p = *path; sfn = dp->fn;
000008  f8d87000          LDR      r7,[r8,#0]
00000c  f10a0524          ADD      r5,r10,#0x24
;;;2748   	mem_set(sfn, ' ', 11);
000010  220b              MOVS     r2,#0xb
000012  2120              MOVS     r1,#0x20
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       mem_set
;;;2749   	si = i = 0; ni = 8;
00001a  2000              MOVS     r0,#0
00001c  4681              MOV      r9,r0
00001e  4606              MOV      r6,r0
000020  f04f0b08          MOV      r11,#8
;;;2750   #if _FS_RPATH != 0
;;;2751   	if (p[si] == '.') { /* Is this a dot entry? */
;;;2752   		for (;;) {
;;;2753   			c = (BYTE)p[si++];
;;;2754   			if (c != '.' || si >= 3) break;
;;;2755   			sfn[i++] = c;
;;;2756   		}
;;;2757   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;2758   		*path = p + si;								/* Return pointer to the next segment */
;;;2759   		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
;;;2760   		return FR_OK;
;;;2761   	}
;;;2762   #endif
;;;2763   	for (;;) {
000024  bf00              NOP      
                  |L8.38|
;;;2764   		c = (BYTE)p[si++];
000026  4630              MOV      r0,r6
000028  1c76              ADDS     r6,r6,#1
00002a  5c3c              LDRB     r4,[r7,r0]
;;;2765   		if (c <= ' ') break; 			/* Break if end of the path name */
00002c  2c20              CMP      r4,#0x20
00002e  dc00              BGT      |L8.50|
000030  e036              B        |L8.160|
                  |L8.50|
;;;2766   		if (c == '/' || c == '\\') {	/* Break if a separator is found */
000032  2c2f              CMP      r4,#0x2f
000034  d001              BEQ      |L8.58|
000036  2c5c              CMP      r4,#0x5c
000038  d108              BNE      |L8.76|
                  |L8.58|
;;;2767   			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
00003a  e000              B        |L8.62|
                  |L8.60|
00003c  1c76              ADDS     r6,r6,#1
                  |L8.62|
00003e  5db8              LDRB     r0,[r7,r6]
000040  282f              CMP      r0,#0x2f
000042  d0fb              BEQ      |L8.60|
000044  5db8              LDRB     r0,[r7,r6]
000046  285c              CMP      r0,#0x5c
000048  d0f8              BEQ      |L8.60|
;;;2768   			break;
00004a  e029              B        |L8.160|
                  |L8.76|
;;;2769   		}
;;;2770   		if (c == '.' || i >= ni) {		/* End of body or over size? */
00004c  2c2e              CMP      r4,#0x2e
00004e  d001              BEQ      |L8.84|
000050  45d9              CMP      r9,r11
000052  d30c              BCC      |L8.110|
                  |L8.84|
;;;2771   			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
000054  f1bb0f0b          CMP      r11,#0xb
000058  d001              BEQ      |L8.94|
00005a  2c2e              CMP      r4,#0x2e
00005c  d002              BEQ      |L8.100|
                  |L8.94|
00005e  2006              MOVS     r0,#6
                  |L8.96|
;;;2772   			i = 8; ni = 11;				/* Goto extension */
;;;2773   			continue;
;;;2774   		}
;;;2775   		if (c >= 0x80) {				/* Extended character? */
;;;2776   #ifdef _EXCVT
;;;2777   			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
;;;2778   #else
;;;2779   #if !_DF1S
;;;2780   			return FR_INVALID_NAME;		/* Reject extended characters (ASCII only cfg) */
;;;2781   #endif
;;;2782   #endif
;;;2783   		}
;;;2784   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
;;;2785   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;2786   			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
;;;2787   			sfn[i++] = c;
;;;2788   			sfn[i++] = d;
;;;2789   		} else {						/* SBC */
;;;2790   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
;;;2791   			if (IsLower(c)) c -= 0x20;	/* To upper */
;;;2792   			sfn[i++] = c;
;;;2793   		}
;;;2794   	}
;;;2795   	*path = p + si;						/* Return pointer to the next segment */
;;;2796   	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
;;;2797   
;;;2798   	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;2799   	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
;;;2800   
;;;2801   	return FR_OK;
;;;2802   #endif /* _USE_LFN != 0 */
;;;2803   }
000060  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.100|
000064  f04f0908          MOV      r9,#8                 ;2772
000068  f04f0b0b          MOV      r11,#0xb              ;2772
00006c  e7db              B        |L8.38|
                  |L8.110|
00006e  2c80              CMP      r4,#0x80              ;2775
000070  db03              BLT      |L8.122|
000072  f1a40080          SUB      r0,r4,#0x80           ;2777
000076  4915              LDR      r1,|L8.204|
000078  5c0c              LDRB     r4,[r1,r0]            ;2777
                  |L8.122|
00007a  4621              MOV      r1,r4                 ;2790
00007c  a014              ADR      r0,|L8.208|
00007e  f7fffffe          BL       chk_chr
000082  b108              CBZ      r0,|L8.136|
000084  2006              MOVS     r0,#6                 ;2790
000086  e7eb              B        |L8.96|
                  |L8.136|
000088  2c61              CMP      r4,#0x61              ;2791
00008a  db04              BLT      |L8.150|
00008c  2c7a              CMP      r4,#0x7a              ;2791
00008e  dc02              BGT      |L8.150|
000090  f1a40020          SUB      r0,r4,#0x20           ;2791
000094  b2c4              UXTB     r4,r0                 ;2791
                  |L8.150|
000096  4648              MOV      r0,r9                 ;2792
000098  f1090901          ADD      r9,r9,#1              ;2792
00009c  542c              STRB     r4,[r5,r0]            ;2792
00009e  e7c2              B        |L8.38|
                  |L8.160|
0000a0  bf00              NOP                            ;2765
0000a2  19b8              ADDS     r0,r7,r6              ;2795
0000a4  f8c80000          STR      r0,[r8,#0]            ;2795
0000a8  f1b90f00          CMP      r9,#0                 ;2796
0000ac  d101              BNE      |L8.178|
0000ae  2006              MOVS     r0,#6                 ;2796
0000b0  e7d6              B        |L8.96|
                  |L8.178|
0000b2  7828              LDRB     r0,[r5,#0]            ;2798
0000b4  28e5              CMP      r0,#0xe5              ;2798
0000b6  d101              BNE      |L8.188|
0000b8  2005              MOVS     r0,#5                 ;2798
0000ba  7028              STRB     r0,[r5,#0]            ;2798
                  |L8.188|
0000bc  2c20              CMP      r4,#0x20              ;2799
0000be  dc01              BGT      |L8.196|
0000c0  2004              MOVS     r0,#4                 ;2799
0000c2  e000              B        |L8.198|
                  |L8.196|
0000c4  2000              MOVS     r0,#0                 ;2799
                  |L8.198|
0000c6  72e8              STRB     r0,[r5,#0xb]          ;2799
0000c8  2000              MOVS     r0,#0                 ;2801
0000ca  e7c9              B        |L8.96|
;;;2804   
                          ENDP

                  |L8.204|
                          DCD      ExCvt
                  |L8.208|
0000d0  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
0000d4  3a3b3c3d
0000d8  3e3f5b5d
0000dc  7c7f00  
0000df  00                DCB      0

                          AREA ||i.dec_lock||, CODE, READONLY, ALIGN=2

                  dec_lock PROC
;;;839    static
;;;840    FRESULT dec_lock (	/* Decrement object open counter */
000000  b510              PUSH     {r4,lr}
;;;841    	UINT i			/* Semaphore index (1..) */
;;;842    )
;;;843    {
000002  4602              MOV      r2,r0
;;;844    	WORD n;
;;;845    	FRESULT res;
;;;846    
;;;847    
;;;848    	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
000004  1e53              SUBS     r3,r2,#1
000006  461a              MOV      r2,r3
000008  2b0a              CMP      r3,#0xa
00000a  d217              BCS      |L9.60|
;;;849    		n = Files[i].ctr;
00000c  4b0c              LDR      r3,|L9.64|
00000e  eb031302          ADD      r3,r3,r2,LSL #4
000012  8999              LDRH     r1,[r3,#0xc]
;;;850    		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
000014  f5b17f80          CMP      r1,#0x100
000018  d100              BNE      |L9.28|
00001a  2100              MOVS     r1,#0
                  |L9.28|
;;;851    		if (n > 0) n--;				/* Decrement read mode open count */
00001c  2900              CMP      r1,#0
00001e  dd01              BLE      |L9.36|
000020  1e4b              SUBS     r3,r1,#1
000022  b299              UXTH     r1,r3
                  |L9.36|
;;;852    		Files[i].ctr = n;
000024  4b06              LDR      r3,|L9.64|
000026  eb031302          ADD      r3,r3,r2,LSL #4
00002a  8199              STRH     r1,[r3,#0xc]
;;;853    		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
00002c  b921              CBNZ     r1,|L9.56|
00002e  2300              MOVS     r3,#0
000030  4c03              LDR      r4,|L9.64|
000032  eb041402          ADD      r4,r4,r2,LSL #4
000036  6023              STR      r3,[r4,#0]
                  |L9.56|
;;;854    		res = FR_OK;
000038  2000              MOVS     r0,#0
00003a  e000              B        |L9.62|
                  |L9.60|
;;;855    	} else {
;;;856    		res = FR_INT_ERR;			/* Invalid index nunber */
00003c  2002              MOVS     r0,#2
                  |L9.62|
;;;857    	}
;;;858    	return res;
;;;859    }
00003e  bd10              POP      {r4,pc}
;;;860    
                          ENDP

                  |L9.64|
                          DCD      Files

                          AREA ||i.dir_alloc||, CODE, READONLY, ALIGN=1

                  dir_alloc PROC
;;;1588   static
;;;1589   FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1590   	DIR* dp,		/* Pointer to the directory object */
;;;1591   	UINT nent		/* Number of contiguous entries to allocate */
;;;1592   )
;;;1593   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1594   	FRESULT res;
;;;1595   	UINT n;
;;;1596   	FATFS *fs = dp->obj.fs;
000008  f8d48000          LDR      r8,[r4,#0]
;;;1597   
;;;1598   
;;;1599   	res = dir_sdi(dp, 0);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       dir_sdi
000014  4605              MOV      r5,r0
;;;1600   	if (res == FR_OK) {
000016  b9ed              CBNZ     r5,|L10.84|
;;;1601   		n = 0;
000018  2700              MOVS     r7,#0
;;;1602   		do {
00001a  bf00              NOP      
                  |L10.28|
;;;1603   			res = move_window(fs, dp->sect);
00001c  4640              MOV      r0,r8
00001e  69e1              LDR      r1,[r4,#0x1c]
000020  f7fffffe          BL       move_window
000024  4605              MOV      r5,r0
;;;1604   			if (res != FR_OK) break;
000026  b105              CBZ      r5,|L10.42|
000028  e013              B        |L10.82|
                  |L10.42|
;;;1605   #if _FS_EXFAT
;;;1606   			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
;;;1607   #else
;;;1608   			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
00002a  6a20              LDR      r0,[r4,#0x20]
00002c  7800              LDRB     r0,[r0,#0]
00002e  28e5              CMP      r0,#0xe5
000030  d002              BEQ      |L10.56|
000032  6a20              LDR      r0,[r4,#0x20]
000034  7800              LDRB     r0,[r0,#0]
000036  b920              CBNZ     r0,|L10.66|
                  |L10.56|
;;;1609   #endif
;;;1610   				if (++n == nent) break;	/* A block of contiguous free entries is found */
000038  1c78              ADDS     r0,r7,#1
00003a  4607              MOV      r7,r0
00003c  42b0              CMP      r0,r6
00003e  d101              BNE      |L10.68|
000040  e007              B        |L10.82|
                  |L10.66|
;;;1611   			} else {
;;;1612   				n = 0;					/* Not a blank entry. Restart to search */
000042  2700              MOVS     r7,#0
                  |L10.68|
;;;1613   			}
;;;1614   			res = dir_next(dp, 1);
000044  2101              MOVS     r1,#1
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       dir_next
00004c  4605              MOV      r5,r0
;;;1615   		} while (res == FR_OK);	/* Next entry with table stretch enabled */
00004e  2d00              CMP      r5,#0
000050  d0e4              BEQ      |L10.28|
                  |L10.82|
000052  bf00              NOP                            ;1604
                  |L10.84|
;;;1616   	}
;;;1617   
;;;1618   	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
000054  2d04              CMP      r5,#4
000056  d100              BNE      |L10.90|
000058  2507              MOVS     r5,#7
                  |L10.90|
;;;1619   	return res;
00005a  4628              MOV      r0,r5
;;;1620   }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;1621   
                          ENDP


                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=1

                  dir_find PROC
;;;2209   static
;;;2210   FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2211   	DIR* dp			/* Pointer to the directory object with the file name */
;;;2212   )
;;;2213   {
000004  4604              MOV      r4,r0
;;;2214   	FRESULT res;
;;;2215   	FATFS *fs = dp->obj.fs;
000006  6827              LDR      r7,[r4,#0]
;;;2216   	BYTE c;
;;;2217   #if _USE_LFN != 0
;;;2218   	BYTE a, ord, sum;
;;;2219   #endif
;;;2220   
;;;2221   	res = dir_sdi(dp, 0);			/* Rewind directory object */
000008  2100              MOVS     r1,#0
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       dir_sdi
000010  4605              MOV      r5,r0
;;;2222   	if (res != FR_OK) return res;
000012  b115              CBZ      r5,|L11.26|
000014  4628              MOV      r0,r5
                  |L11.22|
;;;2223   #if _FS_EXFAT
;;;2224   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2225   		BYTE nc;
;;;2226   		UINT di, ni;
;;;2227   		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
;;;2228   
;;;2229   		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
;;;2230   #if _MAX_LFN < 255
;;;2231   			if (fs->dirbuf[XDIR_NumName] > _MAX_LFN) continue;			/* Skip comparison if inaccessible object name */
;;;2232   #endif
;;;2233   			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
;;;2234   			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
;;;2235   				if ((di % SZDIRE) == 0) di += 2;
;;;2236   				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
;;;2237   			}
;;;2238   			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
;;;2239   		}
;;;2240   		return res;
;;;2241   	}
;;;2242   #endif
;;;2243   	/* On the FAT12/16/32 volume */
;;;2244   #if _USE_LFN != 0
;;;2245   	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;2246   #endif
;;;2247   	do {
;;;2248   		res = move_window(fs, dp->sect);
;;;2249   		if (res != FR_OK) break;
;;;2250   		c = dp->dir[DIR_Name];
;;;2251   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
;;;2252   #if _USE_LFN != 0	/* LFN configuration */
;;;2253   		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
;;;2254   		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;2255   			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;2256   		} else {
;;;2257   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;2258   				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
;;;2259   					if (c & LLEF) {		/* Is it start of LFN sequence? */
;;;2260   						sum = dp->dir[LDIR_Chksum];
;;;2261   						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
;;;2262   						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
;;;2263   					}
;;;2264   					/* Check validity of the LFN entry and compare it with given name */
;;;2265   					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
;;;2266   				}
;;;2267   			} else {					/* An SFN entry is found */
;;;2268   				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
;;;2269   				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
;;;2270   				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;2271   			}
;;;2272   		}
;;;2273   #else		/* Non LFN configuration */
;;;2274   		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
;;;2275   		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
;;;2276   #endif
;;;2277   		res = dir_next(dp, 0);	/* Next entry */
;;;2278   	} while (res == FR_OK);
;;;2279   
;;;2280   	return res;
;;;2281   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L11.26|
00001a  bf00              NOP                            ;2247
                  |L11.28|
00001c  4638              MOV      r0,r7                 ;2248
00001e  69e1              LDR      r1,[r4,#0x1c]         ;2248
000020  f7fffffe          BL       move_window
000024  4605              MOV      r5,r0                 ;2248
000026  b105              CBZ      r5,|L11.42|
000028  e01d              B        |L11.102|
                  |L11.42|
00002a  6a20              LDR      r0,[r4,#0x20]         ;2250
00002c  7806              LDRB     r6,[r0,#0]            ;2250
00002e  b90e              CBNZ     r6,|L11.52|
000030  2504              MOVS     r5,#4                 ;2251
000032  e018              B        |L11.102|
                  |L11.52|
000034  6a20              LDR      r0,[r4,#0x20]         ;2274
000036  7ac0              LDRB     r0,[r0,#0xb]          ;2274
000038  f000003f          AND      r0,r0,#0x3f           ;2274
00003c  71a0              STRB     r0,[r4,#6]            ;2274
00003e  6a20              LDR      r0,[r4,#0x20]         ;2275
000040  7ac0              LDRB     r0,[r0,#0xb]          ;2275
000042  f0000008          AND      r0,r0,#8              ;2275
000046  b938              CBNZ     r0,|L11.88|
000048  220b              MOVS     r2,#0xb               ;2275
00004a  f1040124          ADD      r1,r4,#0x24           ;2275
00004e  6a20              LDR      r0,[r4,#0x20]         ;2275
000050  f7fffffe          BL       mem_cmp
000054  b900              CBNZ     r0,|L11.88|
000056  e006              B        |L11.102|
                  |L11.88|
000058  2100              MOVS     r1,#0                 ;2277
00005a  4620              MOV      r0,r4                 ;2277
00005c  f7fffffe          BL       dir_next
000060  4605              MOV      r5,r0                 ;2277
000062  2d00              CMP      r5,#0                 ;2278
000064  d0da              BEQ      |L11.28|
                  |L11.102|
000066  bf00              NOP                            ;2249
000068  4628              MOV      r0,r5                 ;2280
00006a  e7d4              B        |L11.22|
;;;2282   
                          ENDP


                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1518   static
;;;1519   FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1520   	DIR* dp,		/* Pointer to the directory object */
;;;1521   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1522   )
;;;1523   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;1524   	DWORD ofs, clst;
;;;1525   	FATFS *fs = dp->obj.fs;
000008  6825              LDR      r5,[r4,#0]
;;;1526   #if !_FS_READONLY
;;;1527   	UINT n;
;;;1528   #endif
;;;1529   
;;;1530   	ofs = dp->dptr + SZDIRE;	/* Next entry */
00000a  6960              LDR      r0,[r4,#0x14]
00000c  f1000720          ADD      r7,r0,#0x20
;;;1531   	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
000010  69e0              LDR      r0,[r4,#0x1c]
000012  b110              CBZ      r0,|L12.26|
000014  f5b71f00          CMP      r7,#0x200000
000018  d302              BCC      |L12.32|
                  |L12.26|
00001a  2004              MOVS     r0,#4
                  |L12.28|
;;;1532   
;;;1533   	if (ofs % SS(fs) == 0) {	/* Sector changed? */
;;;1534   		dp->sect++;				/* Next sector */
;;;1535   
;;;1536   		if (!dp->clust) {		/* Static table */
;;;1537   			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
;;;1538   				dp->sect = 0; return FR_NO_FILE;
;;;1539   			}
;;;1540   		}
;;;1541   		else {					/* Dynamic table */
;;;1542   			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
;;;1543   				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
;;;1544   				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
;;;1545   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
;;;1546   				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
;;;1547   #if !_FS_READONLY
;;;1548   					if (!stretch) {								/* If no stretch, report EOT */
;;;1549   						dp->sect = 0; return FR_NO_FILE;
;;;1550   					}
;;;1551   					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
;;;1552   					if (clst == 0) return FR_DENIED;			/* No free cluster */
;;;1553   					if (clst == 1) return FR_INT_ERR;			/* Internal error */
;;;1554   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;;;1555   					/* Clean-up the stretched table */
;;;1556   					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
;;;1557   					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
;;;1558   					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
;;;1559   					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
;;;1560   						fs->wflag = 1;
;;;1561   						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
;;;1562   					}
;;;1563   					fs->winsect -= n;							/* Restore window offset */
;;;1564   #else
;;;1565   					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
;;;1566   					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
;;;1567   #endif
;;;1568   				}
;;;1569   				dp->clust = clst;		/* Initialize data for new cluster */
;;;1570   				dp->sect = clust2sect(fs, clst);
;;;1571   			}
;;;1572   		}
;;;1573   	}
;;;1574   	dp->dptr = ofs;						/* Current entry */
;;;1575   	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
;;;1576   
;;;1577   	return FR_OK;
;;;1578   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L12.32|
000020  f3c70008          UBFX     r0,r7,#0,#9           ;1533
000024  2800              CMP      r0,#0                 ;1533
000026  d168              BNE      |L12.250|
000028  69e0              LDR      r0,[r4,#0x1c]         ;1534
00002a  1c40              ADDS     r0,r0,#1              ;1534
00002c  61e0              STR      r0,[r4,#0x1c]         ;1534
00002e  69a0              LDR      r0,[r4,#0x18]         ;1536
000030  b938              CBNZ     r0,|L12.66|
000032  8928              LDRH     r0,[r5,#8]            ;1537
000034  ebb01f57          CMP      r0,r7,LSR #5          ;1537
000038  d85f              BHI      |L12.250|
00003a  2000              MOVS     r0,#0                 ;1538
00003c  61e0              STR      r0,[r4,#0x1c]         ;1538
00003e  2004              MOVS     r0,#4                 ;1538
000040  e7ec              B        |L12.28|
                  |L12.66|
000042  8968              LDRH     r0,[r5,#0xa]          ;1542
000044  1e40              SUBS     r0,r0,#1              ;1542
000046  ea002057          AND      r0,r0,r7,LSR #9       ;1542
00004a  2800              CMP      r0,#0                 ;1542
00004c  d155              BNE      |L12.250|
00004e  4620              MOV      r0,r4                 ;1543
000050  69a1              LDR      r1,[r4,#0x18]         ;1543
000052  f7fffffe          BL       get_fat
000056  4606              MOV      r6,r0                 ;1543
000058  2e01              CMP      r6,#1                 ;1544
00005a  d801              BHI      |L12.96|
00005c  2002              MOVS     r0,#2                 ;1544
00005e  e7dd              B        |L12.28|
                  |L12.96|
000060  1c70              ADDS     r0,r6,#1              ;1545
000062  b908              CBNZ     r0,|L12.104|
000064  2001              MOVS     r0,#1                 ;1545
000066  e7d9              B        |L12.28|
                  |L12.104|
000068  6968              LDR      r0,[r5,#0x14]         ;1546
00006a  42b0              CMP      r0,r6                 ;1546
00006c  d83f              BHI      |L12.238|
00006e  f1b90f00          CMP      r9,#0                 ;1548
000072  d103              BNE      |L12.124|
000074  2000              MOVS     r0,#0                 ;1549
000076  61e0              STR      r0,[r4,#0x1c]         ;1549
000078  2004              MOVS     r0,#4                 ;1549
00007a  e7cf              B        |L12.28|
                  |L12.124|
00007c  4620              MOV      r0,r4                 ;1551
00007e  69a1              LDR      r1,[r4,#0x18]         ;1551
000080  f7fffffe          BL       create_chain
000084  4606              MOV      r6,r0                 ;1551
000086  b90e              CBNZ     r6,|L12.140|
000088  2007              MOVS     r0,#7                 ;1552
00008a  e7c7              B        |L12.28|
                  |L12.140|
00008c  2e01              CMP      r6,#1                 ;1553
00008e  d101              BNE      |L12.148|
000090  2002              MOVS     r0,#2                 ;1553
000092  e7c3              B        |L12.28|
                  |L12.148|
000094  1c70              ADDS     r0,r6,#1              ;1554
000096  b908              CBNZ     r0,|L12.156|
000098  2001              MOVS     r0,#1                 ;1554
00009a  e7bf              B        |L12.28|
                  |L12.156|
00009c  4628              MOV      r0,r5                 ;1557
00009e  f7fffffe          BL       sync_window
0000a2  b108              CBZ      r0,|L12.168|
0000a4  2001              MOVS     r0,#1                 ;1557
0000a6  e7b9              B        |L12.28|
                  |L12.168|
0000a8  f44f7200          MOV      r2,#0x200             ;1558
0000ac  2100              MOVS     r1,#0                 ;1558
0000ae  f1050030          ADD      r0,r5,#0x30           ;1558
0000b2  f7fffffe          BL       mem_set
0000b6  f04f0800          MOV      r8,#0                 ;1559
0000ba  4631              MOV      r1,r6                 ;1559
0000bc  4628              MOV      r0,r5                 ;1559
0000be  f7fffffe          BL       clust2sect
0000c2  62e8              STR      r0,[r5,#0x2c]         ;1559
0000c4  e00c              B        |L12.224|
                  |L12.198|
0000c6  2001              MOVS     r0,#1                 ;1560
0000c8  70e8              STRB     r0,[r5,#3]            ;1560
0000ca  4628              MOV      r0,r5                 ;1561
0000cc  f7fffffe          BL       sync_window
0000d0  b108              CBZ      r0,|L12.214|
0000d2  2001              MOVS     r0,#1                 ;1561
0000d4  e7a2              B        |L12.28|
                  |L12.214|
0000d6  f1080801          ADD      r8,r8,#1              ;1559
0000da  6ae8              LDR      r0,[r5,#0x2c]         ;1559
0000dc  1c40              ADDS     r0,r0,#1              ;1559
0000de  62e8              STR      r0,[r5,#0x2c]         ;1559
                  |L12.224|
0000e0  8968              LDRH     r0,[r5,#0xa]          ;1559
0000e2  4540              CMP      r0,r8                 ;1559
0000e4  d8ef              BHI      |L12.198|
0000e6  6ae8              LDR      r0,[r5,#0x2c]         ;1563
0000e8  eba00008          SUB      r0,r0,r8              ;1563
0000ec  62e8              STR      r0,[r5,#0x2c]         ;1563
                  |L12.238|
0000ee  61a6              STR      r6,[r4,#0x18]         ;1569
0000f0  4631              MOV      r1,r6                 ;1570
0000f2  4628              MOV      r0,r5                 ;1570
0000f4  f7fffffe          BL       clust2sect
0000f8  61e0              STR      r0,[r4,#0x1c]         ;1570
                  |L12.250|
0000fa  6167              STR      r7,[r4,#0x14]         ;1574
0000fc  f3c70108          UBFX     r1,r7,#0,#9           ;1575
000100  f1050030          ADD      r0,r5,#0x30           ;1575
000104  4408              ADD      r0,r0,r1              ;1575
000106  6220              STR      r0,[r4,#0x20]         ;1575
000108  2000              MOVS     r0,#0                 ;1577
00010a  e787              B        |L12.28|
;;;1579   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;2130   static
;;;2131   FRESULT dir_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2132   	DIR* dp,		/* Pointer to the directory object */
;;;2133   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;2134   )
;;;2135   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;2136   	FRESULT res = FR_NO_FILE;
000008  2504              MOVS     r5,#4
;;;2137   	FATFS *fs = dp->obj.fs;
00000a  f8d49000          LDR      r9,[r4,#0]
;;;2138   	BYTE a, c;
;;;2139   #if _USE_LFN != 0
;;;2140   	BYTE ord = 0xFF, sum = 0xFF;
;;;2141   #endif
;;;2142   
;;;2143   	while (dp->sect) {
00000e  e027              B        |L13.96|
                  |L13.16|
;;;2144   		res = move_window(fs, dp->sect);
000010  4648              MOV      r0,r9
000012  69e1              LDR      r1,[r4,#0x1c]
000014  f7fffffe          BL       move_window
000018  4605              MOV      r5,r0
;;;2145   		if (res != FR_OK) break;
00001a  b105              CBZ      r5,|L13.30|
00001c  e023              B        |L13.102|
                  |L13.30|
;;;2146   		c = dp->dir[DIR_Name];	/* Test for the entry type */
00001e  6a20              LDR      r0,[r4,#0x20]
000020  7806              LDRB     r6,[r0,#0]
;;;2147   		if (c == 0) {
000022  b90e              CBNZ     r6,|L13.40|
;;;2148   			res = FR_NO_FILE; break; /* Reached to end of the directory */
000024  2504              MOVS     r5,#4
000026  e01e              B        |L13.102|
                  |L13.40|
;;;2149   		}
;;;2150   #if _FS_EXFAT
;;;2151   		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2152   			if (_USE_LABEL && vol) {
;;;2153   				if (c == 0x83) break;	/* Volume label entry? */
;;;2154   			} else {
;;;2155   				if (c == 0x85) {		/* Start of the file entry block? */
;;;2156   					dp->blk_ofs = dp->dptr;	/* Get location of the block */
;;;2157   					res = load_xdir(dp);	/* Load the entry block */
;;;2158   					if (res == FR_OK) {
;;;2159   						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
;;;2160   					}
;;;2161   					break;
;;;2162   				}
;;;2163   			}
;;;2164   		} else
;;;2165   #endif
;;;2166   		{	/* On the FAT12/16/32 volume */
;;;2167   			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
000028  6a20              LDR      r0,[r4,#0x20]
00002a  7ac0              LDRB     r0,[r0,#0xb]
00002c  f000073f          AND      r7,r0,#0x3f
000030  71a7              STRB     r7,[r4,#6]
;;;2168   #if _USE_LFN != 0	/* LFN configuration */
;;;2169   			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
;;;2170   				ord = 0xFF;
;;;2171   			} else {
;;;2172   				if (a == AM_LFN) {			/* An LFN entry is found */
;;;2173   					if (c & LLEF) {			/* Is it start of an LFN sequence? */
;;;2174   						sum = dp->dir[LDIR_Chksum];
;;;2175   						c &= (BYTE)~LLEF; ord = c;
;;;2176   						dp->blk_ofs = dp->dptr;
;;;2177   					}
;;;2178   					/* Check LFN validity and capture it */
;;;2179   					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
;;;2180   				} else {					/* An SFN entry is found */
;;;2181   					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
;;;2182   						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
;;;2183   					}
;;;2184   					break;
;;;2185   				}
;;;2186   			}
;;;2187   #else		/* Non LFN configuration */
;;;2188   			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
000032  2ee5              CMP      r6,#0xe5
000034  d00d              BEQ      |L13.82|
000036  2e2e              CMP      r6,#0x2e
000038  d00b              BEQ      |L13.82|
00003a  2f0f              CMP      r7,#0xf
00003c  d009              BEQ      |L13.82|
00003e  f0270020          BIC      r0,r7,#0x20
000042  2808              CMP      r0,#8
000044  d101              BNE      |L13.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L13.76|
                  |L13.74|
00004a  2000              MOVS     r0,#0
                  |L13.76|
00004c  4540              CMP      r0,r8
00004e  d100              BNE      |L13.82|
;;;2189   				break;
000050  e009              B        |L13.102|
                  |L13.82|
;;;2190   			}
;;;2191   #endif
;;;2192   		}
;;;2193   		res = dir_next(dp, 0);		/* Next entry */
000052  2100              MOVS     r1,#0
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       dir_next
00005a  4605              MOV      r5,r0
;;;2194   		if (res != FR_OK) break;
00005c  b105              CBZ      r5,|L13.96|
00005e  e002              B        |L13.102|
                  |L13.96|
000060  69e0              LDR      r0,[r4,#0x1c]         ;2143
000062  2800              CMP      r0,#0                 ;2143
000064  d1d4              BNE      |L13.16|
                  |L13.102|
000066  bf00              NOP                            ;2145
;;;2195   	}
;;;2196   
;;;2197   	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
000068  b10d              CBZ      r5,|L13.110|
00006a  2000              MOVS     r0,#0
00006c  61e0              STR      r0,[r4,#0x1c]
                  |L13.110|
;;;2198   	return res;
00006e  4628              MOV      r0,r5
;;;2199   }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;2200   
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;2291   static
;;;2292   FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;2293   	DIR* dp				/* Target directory with object name to be created */
;;;2294   )
;;;2295   {
000002  4604              MOV      r4,r0
;;;2296   	FRESULT res;
;;;2297   	FATFS *fs = dp->obj.fs;
000004  6826              LDR      r6,[r4,#0]
;;;2298   #if _USE_LFN != 0	/* LFN configuration */
;;;2299   	UINT n, nlen, nent;
;;;2300   	BYTE sn[12], sum;
;;;2301   
;;;2302   
;;;2303   	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
;;;2304   	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
;;;2305   
;;;2306   #if _FS_EXFAT
;;;2307   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2308   		DIR dj;
;;;2309   
;;;2310   		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
;;;2311   		res = dir_alloc(dp, nent);		/* Allocate entries */
;;;2312   		if (res != FR_OK) return res;
;;;2313   		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);	/* Set the allocated entry block offset */
;;;2314   
;;;2315   		if (dp->obj.sclust != 0 && (dp->obj.stat & 4)) {	/* Has the sub-directory been stretched? */
;;;2316   			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase the directory size by cluster size */
;;;2317   			res = fill_first_frag(&dp->obj);				/* Fill first fragment on the FAT if needed */
;;;2318   			if (res != FR_OK) return res;
;;;2319   			res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
;;;2320   			if (res != FR_OK) return res;
;;;2321   			res = load_obj_dir(&dj, &dp->obj);				/* Load the object status */
;;;2322   			if (res != FR_OK) return res;
;;;2323   			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
;;;2324   			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
;;;2325   			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
;;;2326   			res = store_xdir(&dj);							/* Store the object status */
;;;2327   			if (res != FR_OK) return res;
;;;2328   		}
;;;2329   
;;;2330   		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
;;;2331   		return FR_OK;
;;;2332   	}
;;;2333   #endif
;;;2334   	/* On the FAT12/16/32 volume */
;;;2335   	mem_cpy(sn, dp->fn, 12);
;;;2336   	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;2337   		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
;;;2338   		for (n = 1; n < 100; n++) {
;;;2339   			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
;;;2340   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;;;2341   			if (res != FR_OK) break;
;;;2342   		}
;;;2343   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;2344   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;2345   		dp->fn[NSFLAG] = sn[NSFLAG];
;;;2346   	}
;;;2347   
;;;2348   	/* Create an SFN with/without LFNs. */
;;;2349   	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
;;;2350   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;2351   	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
;;;2352   		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
;;;2353   		if (res == FR_OK) {
;;;2354   			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
;;;2355   			do {					/* Store LFN entries in bottom first */
;;;2356   				res = move_window(fs, dp->sect);
;;;2357   				if (res != FR_OK) break;
;;;2358   				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
;;;2359   				fs->wflag = 1;
;;;2360   				res = dir_next(dp, 0);	/* Next entry */
;;;2361   			} while (res == FR_OK && --nent);
;;;2362   		}
;;;2363   	}
;;;2364   
;;;2365   #else	/* Non LFN configuration */
;;;2366   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dir_alloc
00000e  4605              MOV      r5,r0
;;;2367   
;;;2368   #endif
;;;2369   
;;;2370   	/* Set SFN entry */
;;;2371   	if (res == FR_OK) {
000010  b995              CBNZ     r5,|L14.56|
;;;2372   		res = move_window(fs, dp->sect);
000012  4630              MOV      r0,r6
000014  69e1              LDR      r1,[r4,#0x1c]
000016  f7fffffe          BL       move_window
00001a  4605              MOV      r5,r0
;;;2373   		if (res == FR_OK) {
00001c  b965              CBNZ     r5,|L14.56|
;;;2374   			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
00001e  2220              MOVS     r2,#0x20
000020  2100              MOVS     r1,#0
000022  6a20              LDR      r0,[r4,#0x20]
000024  f7fffffe          BL       mem_set
;;;2375   			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
000028  220b              MOVS     r2,#0xb
00002a  f1040124          ADD      r1,r4,#0x24
00002e  6a20              LDR      r0,[r4,#0x20]
000030  f7fffffe          BL       mem_cpy
;;;2376   #if _USE_LFN != 0
;;;2377   			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;2378   #endif
;;;2379   			fs->wflag = 1;
000034  2001              MOVS     r0,#1
000036  70f0              STRB     r0,[r6,#3]
                  |L14.56|
;;;2380   		}
;;;2381   	}
;;;2382   
;;;2383   	return res;
000038  4628              MOV      r0,r5
;;;2384   }
00003a  bd70              POP      {r4-r6,pc}
;;;2385   
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1469   static
;;;1470   FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1471   	DIR* dp,		/* Pointer to directory object */
;;;1472   	DWORD ofs		/* Offset of directory table */
;;;1473   )
;;;1474   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1475   	DWORD csz, clst;
;;;1476   	FATFS *fs = dp->obj.fs;
000008  6826              LDR      r6,[r4,#0]
;;;1477   
;;;1478   
;;;1479   	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
00000a  f5b51f00          CMP      r5,#0x200000
00000e  d202              BCS      |L15.22|
000010  f005001f          AND      r0,r5,#0x1f
000014  b110              CBZ      r0,|L15.28|
                  |L15.22|
;;;1480   		return FR_INT_ERR;
000016  2002              MOVS     r0,#2
                  |L15.24|
;;;1481   	}
;;;1482   	dp->dptr = ofs;				/* Set current offset */
;;;1483   	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
;;;1484   	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
;;;1485   		clst = fs->dirbase;
;;;1486   		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
;;;1487   	}
;;;1488   
;;;1489   	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;;;1490   		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
;;;1491   		dp->sect = fs->dirbase;
;;;1492   
;;;1493   	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
;;;1494   		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
;;;1495   		while (ofs >= csz) {				/* Follow cluster chain */
;;;1496   			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
;;;1497   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;;;1498   			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
;;;1499   			ofs -= csz;
;;;1500   		}
;;;1501   		dp->sect = clust2sect(fs, clst);
;;;1502   	}
;;;1503   	dp->clust = clst;					/* Current cluster# */
;;;1504   	if (!dp->sect) return FR_INT_ERR;
;;;1505   	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
;;;1506   	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
;;;1507   
;;;1508   	return FR_OK;
;;;1509   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L15.28|
00001c  6165              STR      r5,[r4,#0x14]         ;1482
00001e  68a7              LDR      r7,[r4,#8]            ;1483
000020  b91f              CBNZ     r7,|L15.42|
000022  7830              LDRB     r0,[r6,#0]            ;1484
000024  2803              CMP      r0,#3                 ;1484
000026  db00              BLT      |L15.42|
000028  6a77              LDR      r7,[r6,#0x24]         ;1485
                  |L15.42|
00002a  b947              CBNZ     r7,|L15.62|
00002c  8930              LDRH     r0,[r6,#8]            ;1490
00002e  ebb01f55          CMP      r0,r5,LSR #5          ;1490
000032  d801              BHI      |L15.56|
000034  2002              MOVS     r0,#2                 ;1490
000036  e7ef              B        |L15.24|
                  |L15.56|
000038  6a70              LDR      r0,[r6,#0x24]         ;1491
00003a  61e0              STR      r0,[r4,#0x1c]         ;1491
00003c  e01c              B        |L15.120|
                  |L15.62|
00003e  8970              LDRH     r0,[r6,#0xa]          ;1494
000040  ea4f2840          LSL      r8,r0,#9              ;1494
000044  e011              B        |L15.106|
                  |L15.70|
000046  4639              MOV      r1,r7                 ;1496
000048  4620              MOV      r0,r4                 ;1496
00004a  f7fffffe          BL       get_fat
00004e  4607              MOV      r7,r0                 ;1496
000050  1c78              ADDS     r0,r7,#1              ;1497
000052  b908              CBNZ     r0,|L15.88|
000054  2001              MOVS     r0,#1                 ;1497
000056  e7df              B        |L15.24|
                  |L15.88|
000058  2f02              CMP      r7,#2                 ;1498
00005a  d302              BCC      |L15.98|
00005c  6970              LDR      r0,[r6,#0x14]         ;1498
00005e  42b8              CMP      r0,r7                 ;1498
000060  d801              BHI      |L15.102|
                  |L15.98|
000062  2002              MOVS     r0,#2                 ;1498
000064  e7d8              B        |L15.24|
                  |L15.102|
000066  eba50508          SUB      r5,r5,r8              ;1499
                  |L15.106|
00006a  4545              CMP      r5,r8                 ;1495
00006c  d2eb              BCS      |L15.70|
00006e  4639              MOV      r1,r7                 ;1501
000070  4630              MOV      r0,r6                 ;1501
000072  f7fffffe          BL       clust2sect
000076  61e0              STR      r0,[r4,#0x1c]         ;1501
                  |L15.120|
000078  61a7              STR      r7,[r4,#0x18]         ;1503
00007a  69e0              LDR      r0,[r4,#0x1c]         ;1504
00007c  b908              CBNZ     r0,|L15.130|
00007e  2002              MOVS     r0,#2                 ;1504
000080  e7ca              B        |L15.24|
                  |L15.130|
000082  69e0              LDR      r0,[r4,#0x1c]         ;1505
000084  eb002055          ADD      r0,r0,r5,LSR #9       ;1505
000088  61e0              STR      r0,[r4,#0x1c]         ;1505
00008a  f3c50108          UBFX     r1,r5,#0,#9           ;1506
00008e  f1060030          ADD      r0,r6,#0x30           ;1506
000092  4408              ADD      r0,r0,r1              ;1506
000094  6220              STR      r0,[r4,#0x20]         ;1506
000096  2000              MOVS     r0,#0                 ;1508
000098  e7be              B        |L15.24|
;;;1510   
                          ENDP


                          AREA ||i.enq_lock||, CODE, READONLY, ALIGN=2

                  enq_lock PROC
;;;797    static
;;;798    int enq_lock (void)	/* Check if an entry is available for a new object */
000000  2100              MOVS     r1,#0
;;;799    {
;;;800    	UINT i;
;;;801    
;;;802    	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
000002  e000              B        |L16.6|
                  |L16.4|
000004  1c49              ADDS     r1,r1,#1
                  |L16.6|
000006  290a              CMP      r1,#0xa
000008  d205              BCS      |L16.22|
00000a  4806              LDR      r0,|L16.36|
00000c  eb001001          ADD      r0,r0,r1,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  2800              CMP      r0,#0
000014  d1f6              BNE      |L16.4|
                  |L16.22|
;;;803    	return (i == _FS_LOCK) ? 0 : 1;
000016  290a              CMP      r1,#0xa
000018  d001              BEQ      |L16.30|
00001a  2001              MOVS     r0,#1
                  |L16.28|
;;;804    }
00001c  4770              BX       lr
                  |L16.30|
00001e  2000              MOVS     r0,#0                 ;803
000020  e7fc              B        |L16.28|
;;;805    
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      Files

                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;3812   
;;;3813   FRESULT f_close (
000000  b538              PUSH     {r3-r5,lr}
;;;3814   	FIL* fp		/* Pointer to the file object to be closed */
;;;3815   )
;;;3816   {
000002  4605              MOV      r5,r0
;;;3817   	FRESULT res;
;;;3818   	FATFS *fs;
;;;3819   
;;;3820   #if !_FS_READONLY
;;;3821   	res = f_sync(fp);					/* Flush cached data */
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       f_sync
00000a  4604              MOV      r4,r0
;;;3822   	if (res == FR_OK)
00000c  b964              CBNZ     r4,|L17.40|
;;;3823   #endif
;;;3824   	{
;;;3825   		res = validate(&fp->obj, &fs);	/* Lock volume */
00000e  4669              MOV      r1,sp
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       validate
000016  4604              MOV      r4,r0
;;;3826   		if (res == FR_OK) {
000018  b934              CBNZ     r4,|L17.40|
;;;3827   #if _FS_LOCK != 0
;;;3828   			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
00001a  6928              LDR      r0,[r5,#0x10]
00001c  f7fffffe          BL       dec_lock
000020  4604              MOV      r4,r0
;;;3829   			if (res == FR_OK)
000022  b90c              CBNZ     r4,|L17.40|
;;;3830   #endif
;;;3831   			{
;;;3832   				fp->obj.fs = 0;			/* Invalidate file object */
000024  2000              MOVS     r0,#0
000026  6028              STR      r0,[r5,#0]
                  |L17.40|
;;;3833   			}
;;;3834   #if _FS_REENTRANT
;;;3835   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;3836   #endif
;;;3837   		}
;;;3838   	}
;;;3839   	return res;
000028  4620              MOV      r0,r4
;;;3840   }
00002a  bd38              POP      {r3-r5,pc}
;;;3841   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;4231   
;;;4232   FRESULT f_closedir (
000000  b538              PUSH     {r3-r5,lr}
;;;4233   	DIR *dp		/* Pointer to the directory object to be closed */
;;;4234   )
;;;4235   {
000002  4604              MOV      r4,r0
;;;4236   	FRESULT res;
;;;4237   	FATFS *fs;
;;;4238   
;;;4239   
;;;4240   	res = validate(&dp->obj, &fs);			/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4605              MOV      r5,r0
;;;4241   	if (res == FR_OK) {
00000e  b945              CBNZ     r5,|L18.34|
;;;4242   #if _FS_LOCK != 0
;;;4243   		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
000010  6920              LDR      r0,[r4,#0x10]
000012  b118              CBZ      r0,|L18.28|
;;;4244   			res = dec_lock(dp->obj.lockid);
000014  6920              LDR      r0,[r4,#0x10]
000016  f7fffffe          BL       dec_lock
00001a  4605              MOV      r5,r0
                  |L18.28|
;;;4245   		}
;;;4246   		if (res == FR_OK)
00001c  b90d              CBNZ     r5,|L18.34|
;;;4247   #endif
;;;4248   		{
;;;4249   			dp->obj.fs = 0;			/* Invalidate directory object */
00001e  2000              MOVS     r0,#0
000020  6020              STR      r0,[r4,#0]
                  |L18.34|
;;;4250   		}
;;;4251   #if _FS_REENTRANT
;;;4252   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;4253   #endif
;;;4254   	}
;;;4255   	return res;
000022  4628              MOV      r0,r5
;;;4256   }
000024  bd38              POP      {r3-r5,pc}
;;;4257   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;4000   
;;;4001   FRESULT f_lseek (
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;4002   	FIL* fp,		/* Pointer to the file object */
;;;4003   	FSIZE_t ofs		/* File pointer from top of file */
;;;4004   )
;;;4005   {
000004  b089              SUB      sp,sp,#0x24
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;4006   	FRESULT res;
;;;4007   	FATFS *fs;
;;;4008   	DWORD clst, bcs, nsect;
;;;4009   	FSIZE_t ifptr;
;;;4010   #if _USE_FASTSEEK
;;;4011   	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;4012   #endif
;;;4013   
;;;4014   	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
00000a  a907              ADD      r1,sp,#0x1c
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       validate
000012  9008              STR      r0,[sp,#0x20]
;;;4015   	if (res == FR_OK) res = (FRESULT)fp->err;
000014  9808              LDR      r0,[sp,#0x20]
000016  b908              CBNZ     r0,|L19.28|
000018  7d60              LDRB     r0,[r4,#0x15]
00001a  9008              STR      r0,[sp,#0x20]
                  |L19.28|
;;;4016   #if _FS_EXFAT && !_FS_READONLY
;;;4017   	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
;;;4018   		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
;;;4019   	}
;;;4020   #endif
;;;4021   	if (res != FR_OK) LEAVE_FF(fs, res);
00001c  9808              LDR      r0,[sp,#0x20]
00001e  b118              CBZ      r0,|L19.40|
000020  9808              LDR      r0,[sp,#0x20]
                  |L19.34|
;;;4022   
;;;4023   #if _USE_FASTSEEK
;;;4024   	if (fp->cltbl) {	/* Fast seek */
;;;4025   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;4026   			tbl = fp->cltbl;
;;;4027   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;4028   			cl = fp->obj.sclust;		/* Origin of the chain */
;;;4029   			if (cl) {
;;;4030   				do {
;;;4031   					/* Get a fragment */
;;;4032   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;4033   					do {
;;;4034   						pcl = cl; ncl++;
;;;4035   						cl = get_fat(&fp->obj, cl);
;;;4036   						if (cl <= 1) ABORT(fs, FR_INT_ERR);
;;;4037   						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;4038   					} while (cl == pcl + 1);
;;;4039   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;4040   						*tbl++ = ncl; *tbl++ = tcl;
;;;4041   					}
;;;4042   				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
;;;4043   			}
;;;4044   			*fp->cltbl = ulen;	/* Number of items used */
;;;4045   			if (ulen <= tlen) {
;;;4046   				*tbl = 0;		/* Terminate table */
;;;4047   			} else {
;;;4048   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;4049   			}
;;;4050   		} else {						/* Fast seek */
;;;4051   			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
;;;4052   			fp->fptr = ofs;				/* Set file pointer */
;;;4053   			if (ofs) {
;;;4054   				fp->clust = clmt_clust(fp, ofs - 1);
;;;4055   				dsc = clust2sect(fs, fp->clust);
;;;4056   				if (!dsc) ABORT(fs, FR_INT_ERR);
;;;4057   				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
;;;4058   				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
;;;4059   #if !_FS_TINY
;;;4060   #if !_FS_READONLY
;;;4061   					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
;;;4062   						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;4063   						fp->flag &= (BYTE)~FA_DIRTY;
;;;4064   					}
;;;4065   #endif
;;;4066   					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
;;;4067   #endif
;;;4068   					fp->sect = dsc;
;;;4069   				}
;;;4070   			}
;;;4071   		}
;;;4072   	} else
;;;4073   #endif
;;;4074   
;;;4075   	/* Normal Seek */
;;;4076   	{
;;;4077   #if _FS_EXFAT
;;;4078   		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4GiB-1 if at FATxx */
;;;4079   #endif
;;;4080   		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
;;;4081   			ofs = fp->obj.objsize;
;;;4082   		}
;;;4083   		ifptr = fp->fptr;
;;;4084   		fp->fptr = nsect = 0;
;;;4085   		if (ofs) {
;;;4086   			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
;;;4087   			if (ifptr > 0 &&
;;;4088   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;4089   				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
;;;4090   				ofs -= fp->fptr;
;;;4091   				clst = fp->clust;
;;;4092   			} else {									/* When seek to back cluster, */
;;;4093   				clst = fp->obj.sclust;					/* start from the first cluster */
;;;4094   #if !_FS_READONLY
;;;4095   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;4096   					clst = create_chain(&fp->obj, 0);
;;;4097   					if (clst == 1) ABORT(fs, FR_INT_ERR);
;;;4098   					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;4099   					fp->obj.sclust = clst;
;;;4100   				}
;;;4101   #endif
;;;4102   				fp->clust = clst;
;;;4103   			}
;;;4104   			if (clst != 0) {
;;;4105   				while (ofs > bcs) {						/* Cluster following loop */
;;;4106   					ofs -= bcs; fp->fptr += bcs;
;;;4107   #if !_FS_READONLY
;;;4108   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;4109   						if (_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
;;;4110   							fp->obj.objsize = fp->fptr;
;;;4111   							fp->flag |= FA_MODIFIED;
;;;4112   						}
;;;4113   						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
;;;4114   						if (clst == 0) {				/* Clip file size in case of disk full */
;;;4115   							ofs = 0; break;
;;;4116   						}
;;;4117   					} else
;;;4118   #endif
;;;4119   					{
;;;4120   						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
;;;4121   					}
;;;4122   					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;4123   					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
;;;4124   					fp->clust = clst;
;;;4125   				}
;;;4126   				fp->fptr += ofs;
;;;4127   				if (ofs % SS(fs)) {
;;;4128   					nsect = clust2sect(fs, clst);	/* Current sector */
;;;4129   					if (!nsect) ABORT(fs, FR_INT_ERR);
;;;4130   					nsect += (DWORD)(ofs / SS(fs));
;;;4131   				}
;;;4132   			}
;;;4133   		}
;;;4134   		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
;;;4135   			fp->obj.objsize = fp->fptr;
;;;4136   			fp->flag |= FA_MODIFIED;
;;;4137   		}
;;;4138   		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
;;;4139   #if !_FS_TINY
;;;4140   #if !_FS_READONLY
;;;4141   			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
;;;4142   				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;4143   				fp->flag &= (BYTE)~FA_DIRTY;
;;;4144   			}
;;;4145   #endif
;;;4146   			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
;;;4147   #endif
;;;4148   			fp->sect = nsect;
;;;4149   		}
;;;4150   	}
;;;4151   
;;;4152   	LEAVE_FF(fs, res);
;;;4153   }
000022  b009              ADD      sp,sp,#0x24
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L19.40|
000028  6ae0              LDR      r0,[r4,#0x2c]         ;4024
00002a  2800              CMP      r0,#0                 ;4024
00002c  d07c              BEQ      |L19.296|
00002e  1c68              ADDS     r0,r5,#1              ;4025
000030  2800              CMP      r0,#0                 ;4025
000032  d143              BNE      |L19.188|
000034  f8d4a02c          LDR      r10,[r4,#0x2c]        ;4026
000038  f85a0b04          LDR      r0,[r10],#4           ;4027
00003c  9002              STR      r0,[sp,#8]            ;4027
00003e  2002              MOVS     r0,#2                 ;4027
000040  9001              STR      r0,[sp,#4]            ;4027
000042  68a7              LDR      r7,[r4,#8]            ;4028
000044  b367              CBZ      r7,|L19.160|
000046  bf00              NOP                            ;4030
                  |L19.72|
000048  9703              STR      r7,[sp,#0xc]          ;4032
00004a  2000              MOVS     r0,#0                 ;4032
00004c  9004              STR      r0,[sp,#0x10]         ;4032
00004e  9801              LDR      r0,[sp,#4]            ;4032
000050  1c80              ADDS     r0,r0,#2              ;4032
000052  9001              STR      r0,[sp,#4]            ;4032
000054  bf00              NOP                            ;4033
                  |L19.86|
000056  9705              STR      r7,[sp,#0x14]         ;4034
000058  9804              LDR      r0,[sp,#0x10]         ;4034
00005a  1c40              ADDS     r0,r0,#1              ;4034
00005c  9004              STR      r0,[sp,#0x10]         ;4034
00005e  4639              MOV      r1,r7                 ;4035
000060  4620              MOV      r0,r4                 ;4035
000062  f7fffffe          BL       get_fat
000066  4607              MOV      r7,r0                 ;4035
000068  2f01              CMP      r7,#1                 ;4036
00006a  d802              BHI      |L19.114|
00006c  2002              MOVS     r0,#2                 ;4036
00006e  7560              STRB     r0,[r4,#0x15]         ;4036
000070  e7d7              B        |L19.34|
                  |L19.114|
000072  1c78              ADDS     r0,r7,#1              ;4037
000074  b910              CBNZ     r0,|L19.124|
000076  2001              MOVS     r0,#1                 ;4037
000078  7560              STRB     r0,[r4,#0x15]         ;4037
00007a  e7d2              B        |L19.34|
                  |L19.124|
00007c  9805              LDR      r0,[sp,#0x14]         ;4038
00007e  1c40              ADDS     r0,r0,#1              ;4038
000080  4287              CMP      r7,r0                 ;4038
000082  d0e8              BEQ      |L19.86|
000084  e9dd0101          LDRD     r0,r1,[sp,#4]         ;4039
000088  4288              CMP      r0,r1                 ;4039
00008a  d805              BHI      |L19.152|
00008c  9804              LDR      r0,[sp,#0x10]         ;4040
00008e  f84a0b04          STR      r0,[r10],#4           ;4040
000092  9803              LDR      r0,[sp,#0xc]          ;4040
000094  f84a0b04          STR      r0,[r10],#4           ;4040
                  |L19.152|
000098  9807              LDR      r0,[sp,#0x1c]         ;4042
00009a  6940              LDR      r0,[r0,#0x14]         ;4042
00009c  42b8              CMP      r0,r7                 ;4042
00009e  d8d3              BHI      |L19.72|
                  |L19.160|
0000a0  9801              LDR      r0,[sp,#4]            ;4044
0000a2  6ae1              LDR      r1,[r4,#0x2c]         ;4044
0000a4  6008              STR      r0,[r1,#0]            ;4044
0000a6  e9dd0101          LDRD     r0,r1,[sp,#4]         ;4045
0000aa  4288              CMP      r0,r1                 ;4045
0000ac  d803              BHI      |L19.182|
0000ae  2000              MOVS     r0,#0                 ;4046
0000b0  f8ca0000          STR      r0,[r10,#0]           ;4046
                  |L19.180|
0000b4  e0fa              B        |L19.684|
                  |L19.182|
0000b6  2011              MOVS     r0,#0x11              ;4048
0000b8  9008              STR      r0,[sp,#0x20]         ;4048
0000ba  e0f7              B        |L19.684|
                  |L19.188|
0000bc  68e0              LDR      r0,[r4,#0xc]          ;4051
0000be  42a8              CMP      r0,r5                 ;4051
0000c0  d200              BCS      |L19.196|
0000c2  68e5              LDR      r5,[r4,#0xc]          ;4051
                  |L19.196|
0000c4  61a5              STR      r5,[r4,#0x18]         ;4052
0000c6  2d00              CMP      r5,#0                 ;4053
0000c8  d0f4              BEQ      |L19.180|
0000ca  1e69              SUBS     r1,r5,#1              ;4054
0000cc  4620              MOV      r0,r4                 ;4054
0000ce  f7fffffe          BL       clmt_clust
0000d2  61e0              STR      r0,[r4,#0x1c]         ;4054
0000d4  69e1              LDR      r1,[r4,#0x1c]         ;4055
0000d6  9807              LDR      r0,[sp,#0x1c]         ;4055
0000d8  f7fffffe          BL       clust2sect
0000dc  4681              MOV      r9,r0                 ;4055
0000de  f1b90f00          CMP      r9,#0                 ;4056
0000e2  d102              BNE      |L19.234|
0000e4  2002              MOVS     r0,#2                 ;4056
0000e6  7560              STRB     r0,[r4,#0x15]         ;4056
0000e8  e79b              B        |L19.34|
                  |L19.234|
0000ea  9807              LDR      r0,[sp,#0x1c]         ;4057
0000ec  8940              LDRH     r0,[r0,#0xa]          ;4057
0000ee  1e40              SUBS     r0,r0,#1              ;4057
0000f0  1e69              SUBS     r1,r5,#1              ;4057
0000f2  ea002051          AND      r0,r0,r1,LSR #9       ;4057
0000f6  4481              ADD      r9,r9,r0              ;4057
0000f8  8b20              LDRH     r0,[r4,#0x18]         ;4058
0000fa  f3c00008          UBFX     r0,r0,#0,#9           ;4058
0000fe  2800              CMP      r0,#0                 ;4058
000100  d0d8              BEQ      |L19.180|
000102  6a20              LDR      r0,[r4,#0x20]         ;4058
000104  4548              CMP      r0,r9                 ;4058
000106  d0d5              BEQ      |L19.180|
000108  7d20              LDRB     r0,[r4,#0x14]         ;4061
00010a  f0000080          AND      r0,r0,#0x80           ;4061
00010e  b180              CBZ      r0,|L19.306|
000110  6a22              LDR      r2,[r4,#0x20]         ;4062
000112  9907              LDR      r1,[sp,#0x1c]         ;4062
000114  7848              LDRB     r0,[r1,#1]            ;4062
000116  2301              MOVS     r3,#1                 ;4062
000118  f1040130          ADD      r1,r4,#0x30           ;4062
00011c  f7fffffe          BL       disk_write
000120  b118              CBZ      r0,|L19.298|
000122  2001              MOVS     r0,#1                 ;4062
000124  7560              STRB     r0,[r4,#0x15]         ;4062
000126  e77c              B        |L19.34|
                  |L19.296|
000128  e012              B        |L19.336|
                  |L19.298|
00012a  7d20              LDRB     r0,[r4,#0x14]         ;4063
00012c  f000007f          AND      r0,r0,#0x7f           ;4063
000130  7520              STRB     r0,[r4,#0x14]         ;4063
                  |L19.306|
000132  9907              LDR      r1,[sp,#0x1c]         ;4066
000134  7848              LDRB     r0,[r1,#1]            ;4066
000136  2301              MOVS     r3,#1                 ;4066
000138  464a              MOV      r2,r9                 ;4066
00013a  f1040130          ADD      r1,r4,#0x30           ;4066
00013e  f7fffffe          BL       disk_read
000142  b110              CBZ      r0,|L19.330|
000144  2001              MOVS     r0,#1                 ;4066
000146  7560              STRB     r0,[r4,#0x15]         ;4066
000148  e76b              B        |L19.34|
                  |L19.330|
00014a  f8c49020          STR      r9,[r4,#0x20]         ;4068
00014e  e0ad              B        |L19.684|
                  |L19.336|
000150  68e0              LDR      r0,[r4,#0xc]          ;4080
000152  42a8              CMP      r0,r5                 ;4080
000154  d204              BCS      |L19.352|
000156  7d20              LDRB     r0,[r4,#0x14]         ;4080
000158  f0000002          AND      r0,r0,#2              ;4080
00015c  b900              CBNZ     r0,|L19.352|
00015e  68e5              LDR      r5,[r4,#0xc]          ;4081
                  |L19.352|
000160  69a0              LDR      r0,[r4,#0x18]         ;4083
000162  9006              STR      r0,[sp,#0x18]         ;4083
000164  f04f0b00          MOV      r11,#0                ;4084
000168  f8c4b018          STR      r11,[r4,#0x18]        ;4084
00016c  2d00              CMP      r5,#0                 ;4085
00016e  d06a              BEQ      |L19.582|
000170  9807              LDR      r0,[sp,#0x1c]         ;4086
000172  8940              LDRH     r0,[r0,#0xa]          ;4086
000174  ea4f2840          LSL      r8,r0,#9              ;4086
000178  9806              LDR      r0,[sp,#0x18]         ;4087
00017a  b190              CBZ      r0,|L19.418|
00017c  1e68              SUBS     r0,r5,#1              ;4088
00017e  fbb0f1f8          UDIV     r1,r0,r8              ;4088
000182  9806              LDR      r0,[sp,#0x18]         ;4088
000184  1e40              SUBS     r0,r0,#1              ;4088
000186  fbb0f0f8          UDIV     r0,r0,r8              ;4088
00018a  4281              CMP      r1,r0                 ;4088
00018c  d309              BCC      |L19.418|
00018e  9806              LDR      r0,[sp,#0x18]         ;4089
000190  1e40              SUBS     r0,r0,#1              ;4089
000192  f1a80101          SUB      r1,r8,#1              ;4089
000196  4388              BICS     r0,r0,r1              ;4089
000198  61a0              STR      r0,[r4,#0x18]         ;4089
00019a  69a0              LDR      r0,[r4,#0x18]         ;4090
00019c  1a2d              SUBS     r5,r5,r0              ;4090
00019e  69e6              LDR      r6,[r4,#0x1c]         ;4091
0001a0  e012              B        |L19.456|
                  |L19.418|
0001a2  68a6              LDR      r6,[r4,#8]            ;4093
0001a4  b97e              CBNZ     r6,|L19.454|
0001a6  2100              MOVS     r1,#0                 ;4096
0001a8  4620              MOV      r0,r4                 ;4096
0001aa  f7fffffe          BL       create_chain
0001ae  4606              MOV      r6,r0                 ;4096
0001b0  2e01              CMP      r6,#1                 ;4097
0001b2  d102              BNE      |L19.442|
0001b4  2002              MOVS     r0,#2                 ;4097
0001b6  7560              STRB     r0,[r4,#0x15]         ;4097
0001b8  e733              B        |L19.34|
                  |L19.442|
0001ba  1c70              ADDS     r0,r6,#1              ;4098
0001bc  b910              CBNZ     r0,|L19.452|
0001be  2001              MOVS     r0,#1                 ;4098
0001c0  7560              STRB     r0,[r4,#0x15]         ;4098
0001c2  e72e              B        |L19.34|
                  |L19.452|
0001c4  60a6              STR      r6,[r4,#8]            ;4099
                  |L19.454|
0001c6  61e6              STR      r6,[r4,#0x1c]         ;4102
                  |L19.456|
0001c8  b3d6              CBZ      r6,|L19.576|
0001ca  e025              B        |L19.536|
                  |L19.460|
0001cc  eba50508          SUB      r5,r5,r8              ;4106
0001d0  69a0              LDR      r0,[r4,#0x18]         ;4106
0001d2  4440              ADD      r0,r0,r8              ;4106
0001d4  61a0              STR      r0,[r4,#0x18]         ;4106
0001d6  7d20              LDRB     r0,[r4,#0x14]         ;4108
0001d8  f0000002          AND      r0,r0,#2              ;4108
0001dc  b140              CBZ      r0,|L19.496|
0001de  bf00              NOP                            ;4109
0001e0  4631              MOV      r1,r6                 ;4113
0001e2  4620              MOV      r0,r4                 ;4113
0001e4  f7fffffe          BL       create_chain
0001e8  4606              MOV      r6,r0                 ;4113
0001ea  b936              CBNZ     r6,|L19.506|
0001ec  2500              MOVS     r5,#0                 ;4115
0001ee  e015              B        |L19.540|
                  |L19.496|
0001f0  4631              MOV      r1,r6                 ;4120
0001f2  4620              MOV      r0,r4                 ;4120
0001f4  f7fffffe          BL       get_fat
0001f8  4606              MOV      r6,r0                 ;4120
                  |L19.506|
0001fa  1c70              ADDS     r0,r6,#1              ;4122
0001fc  b910              CBNZ     r0,|L19.516|
0001fe  2001              MOVS     r0,#1                 ;4122
000200  7560              STRB     r0,[r4,#0x15]         ;4122
000202  e70e              B        |L19.34|
                  |L19.516|
000204  2e01              CMP      r6,#1                 ;4123
000206  d903              BLS      |L19.528|
000208  9807              LDR      r0,[sp,#0x1c]         ;4123
00020a  6940              LDR      r0,[r0,#0x14]         ;4123
00020c  42b0              CMP      r0,r6                 ;4123
00020e  d802              BHI      |L19.534|
                  |L19.528|
000210  2002              MOVS     r0,#2                 ;4123
000212  7560              STRB     r0,[r4,#0x15]         ;4123
000214  e705              B        |L19.34|
                  |L19.534|
000216  61e6              STR      r6,[r4,#0x1c]         ;4124
                  |L19.536|
000218  4545              CMP      r5,r8                 ;4105
00021a  d8d7              BHI      |L19.460|
                  |L19.540|
00021c  bf00              NOP                            ;4115
00021e  69a0              LDR      r0,[r4,#0x18]         ;4126
000220  4428              ADD      r0,r0,r5              ;4126
000222  61a0              STR      r0,[r4,#0x18]         ;4126
000224  f3c50008          UBFX     r0,r5,#0,#9           ;4127
000228  b150              CBZ      r0,|L19.576|
00022a  4631              MOV      r1,r6                 ;4128
00022c  9807              LDR      r0,[sp,#0x1c]         ;4128
00022e  f7fffffe          BL       clust2sect
000232  4683              MOV      r11,r0                ;4128
000234  f1bb0f00          CMP      r11,#0                ;4129
000238  d103              BNE      |L19.578|
00023a  2002              MOVS     r0,#2                 ;4129
00023c  7560              STRB     r0,[r4,#0x15]         ;4129
00023e  e6f0              B        |L19.34|
                  |L19.576|
000240  e001              B        |L19.582|
                  |L19.578|
000242  eb0b2b55          ADD      r11,r11,r5,LSR #9     ;4130
                  |L19.582|
000246  68e1              LDR      r1,[r4,#0xc]          ;4134
000248  69a0              LDR      r0,[r4,#0x18]         ;4134
00024a  4288              CMP      r0,r1                 ;4134
00024c  d905              BLS      |L19.602|
00024e  69a0              LDR      r0,[r4,#0x18]         ;4135
000250  60e0              STR      r0,[r4,#0xc]          ;4135
000252  7d20              LDRB     r0,[r4,#0x14]         ;4136
000254  f0400040          ORR      r0,r0,#0x40           ;4136
000258  7520              STRB     r0,[r4,#0x14]         ;4136
                  |L19.602|
00025a  8b20              LDRH     r0,[r4,#0x18]         ;4138
00025c  f3c00008          UBFX     r0,r0,#0,#9           ;4138
000260  b320              CBZ      r0,|L19.684|
000262  6a20              LDR      r0,[r4,#0x20]         ;4138
000264  4558              CMP      r0,r11                ;4138
000266  d021              BEQ      |L19.684|
000268  7d20              LDRB     r0,[r4,#0x14]         ;4141
00026a  f0000080          AND      r0,r0,#0x80           ;4141
00026e  b178              CBZ      r0,|L19.656|
000270  6a22              LDR      r2,[r4,#0x20]         ;4142
000272  9907              LDR      r1,[sp,#0x1c]         ;4142
000274  7848              LDRB     r0,[r1,#1]            ;4142
000276  2301              MOVS     r3,#1                 ;4142
000278  f1040130          ADD      r1,r4,#0x30           ;4142
00027c  f7fffffe          BL       disk_write
000280  b110              CBZ      r0,|L19.648|
000282  2001              MOVS     r0,#1                 ;4142
000284  7560              STRB     r0,[r4,#0x15]         ;4142
000286  e6cc              B        |L19.34|
                  |L19.648|
000288  7d20              LDRB     r0,[r4,#0x14]         ;4143
00028a  f000007f          AND      r0,r0,#0x7f           ;4143
00028e  7520              STRB     r0,[r4,#0x14]         ;4143
                  |L19.656|
000290  9907              LDR      r1,[sp,#0x1c]         ;4146
000292  7848              LDRB     r0,[r1,#1]            ;4146
000294  2301              MOVS     r3,#1                 ;4146
000296  465a              MOV      r2,r11                ;4146
000298  f1040130          ADD      r1,r4,#0x30           ;4146
00029c  f7fffffe          BL       disk_read
0002a0  b110              CBZ      r0,|L19.680|
0002a2  2001              MOVS     r0,#1                 ;4146
0002a4  7560              STRB     r0,[r4,#0x15]         ;4146
0002a6  e6bc              B        |L19.34|
                  |L19.680|
0002a8  f8c4b020          STR      r11,[r4,#0x20]        ;4148
                  |L19.684|
0002ac  9808              LDR      r0,[sp,#0x20]         ;4152
0002ae  e6b8              B        |L19.34|
;;;4154   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;3259   
;;;3260   FRESULT f_mount (
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;3261   	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;;;3262   	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;;;3263   	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
;;;3264   )
;;;3265   {
000002  b082              SUB      sp,sp,#8
000004  4616              MOV      r6,r2
;;;3266   	FATFS *cfs;
;;;3267   	int vol;
;;;3268   	FRESULT res;
;;;3269   	const TCHAR *rp = path;
000006  9803              LDR      r0,[sp,#0xc]
000008  9001              STR      r0,[sp,#4]
;;;3270   
;;;3271   
;;;3272   	/* Get logical drive number */
;;;3273   	vol = get_ldnumber(&rp);
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       get_ldnumber
000010  4605              MOV      r5,r0
;;;3274   	if (vol < 0) return FR_INVALID_DRIVE;
000012  2d00              CMP      r5,#0
000014  da02              BGE      |L20.28|
000016  200b              MOVS     r0,#0xb
                  |L20.24|
;;;3275   	cfs = FatFs[vol];					/* Pointer to fs object */
;;;3276   
;;;3277   	if (cfs) {
;;;3278   #if _FS_LOCK != 0
;;;3279   		clear_lock(cfs);
;;;3280   #endif
;;;3281   #if _FS_REENTRANT						/* Discard sync object of the current volume */
;;;3282   		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;;;3283   #endif
;;;3284   		cfs->fs_type = 0;				/* Clear old fs object */
;;;3285   	}
;;;3286   
;;;3287   	if (fs) {
;;;3288   		fs->fs_type = 0;				/* Clear new fs object */
;;;3289   #if _FS_REENTRANT						/* Create sync object for the new volume */
;;;3290   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
;;;3291   #endif
;;;3292   	}
;;;3293   	FatFs[vol] = fs;					/* Register new fs object */
;;;3294   
;;;3295   	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;;;3296   
;;;3297   	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
;;;3298   	LEAVE_FF(fs, res);
;;;3299   }
000018  b005              ADD      sp,sp,#0x14
00001a  bdf0              POP      {r4-r7,pc}
                  |L20.28|
00001c  480f              LDR      r0,|L20.92|
00001e  f8504025          LDR      r4,[r0,r5,LSL #2]     ;3275
000022  b124              CBZ      r4,|L20.46|
000024  4620              MOV      r0,r4                 ;3279
000026  f7fffffe          BL       clear_lock
00002a  2000              MOVS     r0,#0                 ;3284
00002c  7020              STRB     r0,[r4,#0]            ;3284
                  |L20.46|
00002e  9802              LDR      r0,[sp,#8]            ;3287
000030  b110              CBZ      r0,|L20.56|
000032  2000              MOVS     r0,#0                 ;3288
000034  9902              LDR      r1,[sp,#8]            ;3288
000036  7008              STRB     r0,[r1,#0]            ;3288
                  |L20.56|
000038  4908              LDR      r1,|L20.92|
00003a  9802              LDR      r0,[sp,#8]            ;3293
00003c  f8410025          STR      r0,[r1,r5,LSL #2]     ;3293
000040  9802              LDR      r0,[sp,#8]            ;3295
000042  b108              CBZ      r0,|L20.72|
000044  2e01              CMP      r6,#1                 ;3295
000046  d001              BEQ      |L20.76|
                  |L20.72|
000048  2000              MOVS     r0,#0                 ;3295
00004a  e7e5              B        |L20.24|
                  |L20.76|
00004c  2200              MOVS     r2,#0                 ;3297
00004e  a902              ADD      r1,sp,#8              ;3297
000050  a803              ADD      r0,sp,#0xc            ;3297
000052  f7fffffe          BL       find_volume
000056  4607              MOV      r7,r0                 ;3297
000058  4638              MOV      r0,r7                 ;3298
00005a  e7dd              B        |L20.24|
;;;3300   
                          ENDP

                  |L20.92|
                          DCD      FatFs

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=2

                  f_open PROC
;;;3307   
;;;3308   FRESULT f_open (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3309   	FIL* fp,			/* Pointer to the blank file object */
;;;3310   	const TCHAR* path,	/* Pointer to the file name */
;;;3311   	BYTE mode			/* Access mode and file open mode flags */
;;;3312   )
;;;3313   {
000004  b08e              SUB      sp,sp,#0x38
000006  4604              MOV      r4,r0
000008  4616              MOV      r6,r2
;;;3314   	FRESULT res;
;;;3315   	DIR dj;
;;;3316   	FATFS *fs;
;;;3317   #if !_FS_READONLY
;;;3318   	DWORD dw, cl, bcs, clst, sc;
;;;3319   	FSIZE_t ofs;
;;;3320   #endif
;;;3321   	DEF_NAMBUF
;;;3322   
;;;3323   
;;;3324   	if (!fp) return FR_INVALID_OBJECT;
00000a  b91c              CBNZ     r4,|L21.20|
00000c  2009              MOVS     r0,#9
                  |L21.14|
;;;3325   
;;;3326   	/* Get logical drive */
;;;3327   	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
;;;3328   	res = find_volume(&path, &fs, mode);
;;;3329   	if (res == FR_OK) {
;;;3330   		dj.obj.fs = fs;
;;;3331   		INIT_NAMBUF(fs);
;;;3332   		res = follow_path(&dj, path);	/* Follow the file path */
;;;3333   #if !_FS_READONLY	/* R/W configuration */
;;;3334   		if (res == FR_OK) {
;;;3335   			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
;;;3336   				res = FR_INVALID_NAME;
;;;3337   			}
;;;3338   #if _FS_LOCK != 0
;;;3339   			else {
;;;3340   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;3341   			}
;;;3342   #endif
;;;3343   		}
;;;3344   		/* Create or Open a file */
;;;3345   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;3346   			if (res != FR_OK) {					/* No file, create new */
;;;3347   				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
;;;3348   #if _FS_LOCK != 0
;;;3349   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;3350   #else
;;;3351   					res = dir_register(&dj);
;;;3352   #endif
;;;3353   				}
;;;3354   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;3355   			}
;;;3356   			else {								/* Any object is already existing */
;;;3357   				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;3358   					res = FR_DENIED;
;;;3359   				} else {
;;;3360   					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
;;;3361   				}
;;;3362   			}
;;;3363   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;3364   				dw = GET_FATTIME();
;;;3365   #if _FS_EXFAT
;;;3366   				if (fs->fs_type == FS_EXFAT) {
;;;3367   					/* Get current allocation info */
;;;3368   					fp->obj.fs = fs;
;;;3369   					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
;;;3370   					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;3371   					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;3372   					fp->obj.n_frag = 0;
;;;3373   					/* Initialize directory entry block */
;;;3374   					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
;;;3375   					fs->dirbuf[XDIR_CrtTime10] = 0;
;;;3376   					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
;;;3377   					fs->dirbuf[XDIR_ModTime10] = 0;
;;;3378   					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
;;;3379   					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
;;;3380   					st_qword(fs->dirbuf + XDIR_FileSize, 0);
;;;3381   					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
;;;3382   					fs->dirbuf[XDIR_GenFlags] = 1;
;;;3383   					res = store_xdir(&dj);
;;;3384   					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
;;;3385   						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
;;;3386   						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
;;;3387   					}
;;;3388   				} else
;;;3389   #endif
;;;3390   				{
;;;3391   					/* Clean directory info */
;;;3392   					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
;;;3393   					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
;;;3394   					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
;;;3395   					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
;;;3396   					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
;;;3397   					st_dword(dj.dir + DIR_FileSize, 0);
;;;3398   					fs->wflag = 1;
;;;3399   
;;;3400   					if (cl) {							/* Remove the cluster chain if exist */
;;;3401   						dw = fs->winsect;
;;;3402   						res = remove_chain(&dj.obj, cl, 0);
;;;3403   						if (res == FR_OK) {
;;;3404   							res = move_window(fs, dw);
;;;3405   							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
;;;3406   						}
;;;3407   					}
;;;3408   				}
;;;3409   			}
;;;3410   		}
;;;3411   		else {	/* Open an existing file */
;;;3412   			if (res == FR_OK) {					/* Following succeeded */
;;;3413   				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
;;;3414   					res = FR_NO_FILE;
;;;3415   				} else {
;;;3416   					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
;;;3417   						res = FR_DENIED;
;;;3418   					}
;;;3419   				}
;;;3420   			}
;;;3421   		}
;;;3422   		if (res == FR_OK) {
;;;3423   			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;;;3424   				mode |= FA_MODIFIED;
;;;3425   			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
;;;3426   			fp->dir_ptr = dj.dir;
;;;3427   #if _FS_LOCK != 0
;;;3428   			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;3429   			if (!fp->obj.lockid) res = FR_INT_ERR;
;;;3430   #endif
;;;3431   		}
;;;3432   #else		/* R/O configuration */
;;;3433   		if (res == FR_OK) {
;;;3434   			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
;;;3435   				res = FR_INVALID_NAME;
;;;3436   			} else {
;;;3437   				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
;;;3438   					res = FR_NO_FILE;
;;;3439   				}
;;;3440   			}
;;;3441   		}
;;;3442   #endif
;;;3443   
;;;3444   		if (res == FR_OK) {
;;;3445   #if _FS_EXFAT
;;;3446   			if (fs->fs_type == FS_EXFAT) {
;;;3447   				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
;;;3448   				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
;;;3449   				fp->obj.c_ofs = dj.blk_ofs;
;;;3450   				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object allocation info */
;;;3451   				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;3452   				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;3453   			} else
;;;3454   #endif
;;;3455   			{
;;;3456   				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
;;;3457   				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
;;;3458   			}
;;;3459   #if _USE_FASTSEEK
;;;3460   			fp->cltbl = 0;			/* Disable fast seek mode */
;;;3461   #endif
;;;3462   			fp->obj.fs = fs;	 	/* Validate the file object */
;;;3463   			fp->obj.id = fs->id;
;;;3464   			fp->flag = mode;		/* Set file access mode */
;;;3465   			fp->err = 0;			/* Clear error flag */
;;;3466   			fp->sect = 0;			/* Invalidate current data sector */
;;;3467   			fp->fptr = 0;			/* Set file pointer top of the file */
;;;3468   #if !_FS_READONLY
;;;3469   #if !_FS_TINY
;;;3470   			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
;;;3471   #endif
;;;3472   			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
;;;3473   				fp->fptr = fp->obj.objsize;			/* Offset to seek */
;;;3474   				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
;;;3475   				clst = fp->obj.sclust;				/* Follow the cluster chain */
;;;3476   				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
;;;3477   					clst = get_fat(&fp->obj, clst);
;;;3478   					if (clst <= 1) res = FR_INT_ERR;
;;;3479   					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
;;;3480   				}
;;;3481   				fp->clust = clst;
;;;3482   				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
;;;3483   					if ((sc = clust2sect(fs, clst)) == 0) {
;;;3484   						res = FR_INT_ERR;
;;;3485   					} else {
;;;3486   						fp->sect = sc + (DWORD)(ofs / SS(fs));
;;;3487   #if !_FS_TINY
;;;3488   						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
;;;3489   #endif
;;;3490   					}
;;;3491   				}
;;;3492   			}
;;;3493   #endif
;;;3494   		}
;;;3495   
;;;3496   		FREE_NAMBUF();
;;;3497   	}
;;;3498   
;;;3499   	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
;;;3500   
;;;3501   	LEAVE_FF(fs, res);
;;;3502   }
00000e  b011              ADD      sp,sp,#0x44
000010  e8bd8ff0          POP      {r4-r11,pc}
                  |L21.20|
000014  f006063f          AND      r6,r6,#0x3f           ;3327
000018  4632              MOV      r2,r6                 ;3328
00001a  a901              ADD      r1,sp,#4              ;3328
00001c  a80f              ADD      r0,sp,#0x3c           ;3328
00001e  f7fffffe          BL       find_volume
000022  4605              MOV      r5,r0                 ;3328
000024  2d00              CMP      r5,#0                 ;3329
000026  d178              BNE      |L21.282|
000028  9801              LDR      r0,[sp,#4]            ;3330
00002a  9002              STR      r0,[sp,#8]            ;3330
00002c  a802              ADD      r0,sp,#8              ;3332
00002e  990f              LDR      r1,[sp,#0x3c]         ;3332
000030  f7fffffe          BL       follow_path
000034  4605              MOV      r5,r0                 ;3332
000036  b98d              CBNZ     r5,|L21.92|
000038  f89d0037          LDRB     r0,[sp,#0x37]         ;3335
00003c  f0000080          AND      r0,r0,#0x80           ;3335
000040  b108              CBZ      r0,|L21.70|
000042  2506              MOVS     r5,#6                 ;3336
000044  e00a              B        |L21.92|
                  |L21.70|
000046  f0260001          BIC      r0,r6,#1              ;3340
00004a  b108              CBZ      r0,|L21.80|
00004c  2001              MOVS     r0,#1                 ;3340
00004e  e000              B        |L21.82|
                  |L21.80|
000050  2000              MOVS     r0,#0                 ;3340
                  |L21.82|
000052  4601              MOV      r1,r0                 ;3340
000054  a802              ADD      r0,sp,#8              ;3340
000056  f7fffffe          BL       chk_lock
00005a  4605              MOV      r5,r0                 ;3340
                  |L21.92|
00005c  f006001c          AND      r0,r6,#0x1c           ;3345
000060  2800              CMP      r0,#0                 ;3345
000062  d05b              BEQ      |L21.284|
000064  b16d              CBZ      r5,|L21.130|
000066  2d04              CMP      r5,#4                 ;3347
000068  d108              BNE      |L21.124|
00006a  f7fffffe          BL       enq_lock
00006e  b118              CBZ      r0,|L21.120|
000070  a802              ADD      r0,sp,#8              ;3349
000072  f7fffffe          BL       dir_register
000076  e000              B        |L21.122|
                  |L21.120|
000078  2012              MOVS     r0,#0x12              ;3349
                  |L21.122|
00007a  4605              MOV      r5,r0                 ;3349
                  |L21.124|
00007c  f0460608          ORR      r6,r6,#8              ;3354
000080  e00a              B        |L21.152|
                  |L21.130|
000082  f89d000e          LDRB     r0,[sp,#0xe]          ;3357
000086  f0000011          AND      r0,r0,#0x11           ;3357
00008a  b108              CBZ      r0,|L21.144|
00008c  2507              MOVS     r5,#7                 ;3358
00008e  e003              B        |L21.152|
                  |L21.144|
000090  f0060004          AND      r0,r6,#4              ;3360
000094  b100              CBZ      r0,|L21.152|
000096  2508              MOVS     r5,#8                 ;3360
                  |L21.152|
000098  2d00              CMP      r5,#0                 ;3363
00009a  d150              BNE      |L21.318|
00009c  f0060008          AND      r0,r6,#8              ;3363
0000a0  2800              CMP      r0,#0                 ;3363
0000a2  d04c              BEQ      |L21.318|
0000a4  4862              LDR      r0,|L21.560|
0000a6  9000              STR      r0,[sp,#0]            ;3364
0000a8  990a              LDR      r1,[sp,#0x28]         ;3392
0000aa  f101000e          ADD      r0,r1,#0xe            ;3392
0000ae  9900              LDR      r1,[sp,#0]            ;3392
0000b0  f7fffffe          BL       st_dword
0000b4  990a              LDR      r1,[sp,#0x28]         ;3393
0000b6  f1010016          ADD      r0,r1,#0x16           ;3393
0000ba  9900              LDR      r1,[sp,#0]            ;3393
0000bc  f7fffffe          BL       st_dword
0000c0  2020              MOVS     r0,#0x20              ;3394
0000c2  990a              LDR      r1,[sp,#0x28]         ;3394
0000c4  72c8              STRB     r0,[r1,#0xb]          ;3394
0000c6  990a              LDR      r1,[sp,#0x28]         ;3395
0000c8  9801              LDR      r0,[sp,#4]            ;3395
0000ca  f7fffffe          BL       ld_clust
0000ce  4681              MOV      r9,r0                 ;3395
0000d0  2200              MOVS     r2,#0                 ;3396
0000d2  990a              LDR      r1,[sp,#0x28]         ;3396
0000d4  9801              LDR      r0,[sp,#4]            ;3396
0000d6  f7fffffe          BL       st_clust
0000da  990a              LDR      r1,[sp,#0x28]         ;3397
0000dc  f101001c          ADD      r0,r1,#0x1c           ;3397
0000e0  2100              MOVS     r1,#0                 ;3397
0000e2  f7fffffe          BL       st_dword
0000e6  2001              MOVS     r0,#1                 ;3398
0000e8  9901              LDR      r1,[sp,#4]            ;3398
0000ea  70c8              STRB     r0,[r1,#3]            ;3398
0000ec  f1b90f00          CMP      r9,#0                 ;3400
0000f0  d025              BEQ      |L21.318|
0000f2  9801              LDR      r0,[sp,#4]            ;3401
0000f4  6ac0              LDR      r0,[r0,#0x2c]         ;3401
0000f6  9000              STR      r0,[sp,#0]            ;3401
0000f8  2200              MOVS     r2,#0                 ;3402
0000fa  4649              MOV      r1,r9                 ;3402
0000fc  a802              ADD      r0,sp,#8              ;3402
0000fe  f7fffffe          BL       remove_chain
000102  4605              MOV      r5,r0                 ;3402
000104  b9dd              CBNZ     r5,|L21.318|
000106  e9dd1000          LDRD     r1,r0,[sp,#0]         ;3404
00010a  f7fffffe          BL       move_window
00010e  4605              MOV      r5,r0                 ;3404
000110  f1a90001          SUB      r0,r9,#1              ;3405
000114  9901              LDR      r1,[sp,#4]            ;3405
000116  60c8              STR      r0,[r1,#0xc]          ;3405
000118  e011              B        |L21.318|
                  |L21.282|
00011a  e075              B        |L21.520|
                  |L21.284|
00011c  b97d              CBNZ     r5,|L21.318|
00011e  f89d000e          LDRB     r0,[sp,#0xe]          ;3413
000122  f0000010          AND      r0,r0,#0x10           ;3413
000126  b108              CBZ      r0,|L21.300|
000128  2504              MOVS     r5,#4                 ;3414
00012a  e008              B        |L21.318|
                  |L21.300|
00012c  f0060002          AND      r0,r6,#2              ;3416
000130  b128              CBZ      r0,|L21.318|
000132  f89d000e          LDRB     r0,[sp,#0xe]          ;3416
000136  f0000001          AND      r0,r0,#1              ;3416
00013a  b100              CBZ      r0,|L21.318|
00013c  2507              MOVS     r5,#7                 ;3417
                  |L21.318|
00013e  b9bd              CBNZ     r5,|L21.368|
000140  f0060008          AND      r0,r6,#8              ;3423
000144  b108              CBZ      r0,|L21.330|
000146  f0460640          ORR      r6,r6,#0x40           ;3424
                  |L21.330|
00014a  9801              LDR      r0,[sp,#4]            ;3425
00014c  6ac0              LDR      r0,[r0,#0x2c]         ;3425
00014e  6260              STR      r0,[r4,#0x24]         ;3425
000150  980a              LDR      r0,[sp,#0x28]         ;3426
000152  62a0              STR      r0,[r4,#0x28]         ;3426
000154  f0260001          BIC      r0,r6,#1              ;3428
000158  b108              CBZ      r0,|L21.350|
00015a  2001              MOVS     r0,#1                 ;3428
00015c  e000              B        |L21.352|
                  |L21.350|
00015e  2000              MOVS     r0,#0                 ;3428
                  |L21.352|
000160  4601              MOV      r1,r0                 ;3428
000162  a802              ADD      r0,sp,#8              ;3428
000164  f7fffffe          BL       inc_lock
000168  6120              STR      r0,[r4,#0x10]         ;3428
00016a  6920              LDR      r0,[r4,#0x10]         ;3429
00016c  b900              CBNZ     r0,|L21.368|
00016e  2502              MOVS     r5,#2                 ;3429
                  |L21.368|
000170  2d00              CMP      r5,#0                 ;3444
000172  d157              BNE      |L21.548|
000174  990a              LDR      r1,[sp,#0x28]         ;3456
000176  9801              LDR      r0,[sp,#4]            ;3456
000178  f7fffffe          BL       ld_clust
00017c  60a0              STR      r0,[r4,#8]            ;3456
00017e  990a              LDR      r1,[sp,#0x28]         ;3457
000180  f101001c          ADD      r0,r1,#0x1c           ;3457
000184  f7fffffe          BL       ld_dword
000188  60e0              STR      r0,[r4,#0xc]          ;3457
00018a  2000              MOVS     r0,#0                 ;3460
00018c  62e0              STR      r0,[r4,#0x2c]         ;3460
00018e  9801              LDR      r0,[sp,#4]            ;3462
000190  6020              STR      r0,[r4,#0]            ;3462
000192  9801              LDR      r0,[sp,#4]            ;3463
000194  88c0              LDRH     r0,[r0,#6]            ;3463
000196  80a0              STRH     r0,[r4,#4]            ;3463
000198  7526              STRB     r6,[r4,#0x14]         ;3464
00019a  2000              MOVS     r0,#0                 ;3465
00019c  7560              STRB     r0,[r4,#0x15]         ;3465
00019e  6220              STR      r0,[r4,#0x20]         ;3466
0001a0  61a0              STR      r0,[r4,#0x18]         ;3467
0001a2  f44f7200          MOV      r2,#0x200             ;3470
0001a6  2100              MOVS     r1,#0                 ;3470
0001a8  f1040030          ADD      r0,r4,#0x30           ;3470
0001ac  f7fffffe          BL       mem_set
0001b0  f0060020          AND      r0,r6,#0x20           ;3472
0001b4  b340              CBZ      r0,|L21.520|
0001b6  68e0              LDR      r0,[r4,#0xc]          ;3472
0001b8  b330              CBZ      r0,|L21.520|
0001ba  68e0              LDR      r0,[r4,#0xc]          ;3473
0001bc  61a0              STR      r0,[r4,#0x18]         ;3473
0001be  9801              LDR      r0,[sp,#4]            ;3474
0001c0  8940              LDRH     r0,[r0,#0xa]          ;3474
0001c2  ea4f2a40          LSL      r10,r0,#9             ;3474
0001c6  68a7              LDR      r7,[r4,#8]            ;3475
0001c8  f8d4800c          LDR      r8,[r4,#0xc]          ;3476
0001cc  e00c              B        |L21.488|
                  |L21.462|
0001ce  4639              MOV      r1,r7                 ;3477
0001d0  4620              MOV      r0,r4                 ;3477
0001d2  f7fffffe          BL       get_fat
0001d6  4607              MOV      r7,r0                 ;3477
0001d8  2f01              CMP      r7,#1                 ;3478
0001da  d800              BHI      |L21.478|
0001dc  2502              MOVS     r5,#2                 ;3478
                  |L21.478|
0001de  1c78              ADDS     r0,r7,#1              ;3479
0001e0  b900              CBNZ     r0,|L21.484|
0001e2  2501              MOVS     r5,#1                 ;3479
                  |L21.484|
0001e4  eba8080a          SUB      r8,r8,r10             ;3476
                  |L21.488|
0001e8  b90d              CBNZ     r5,|L21.494|
0001ea  45d0              CMP      r8,r10                ;3476
0001ec  d8ef              BHI      |L21.462|
                  |L21.494|
0001ee  61e7              STR      r7,[r4,#0x1c]         ;3481
0001f0  b955              CBNZ     r5,|L21.520|
0001f2  f3c80008          UBFX     r0,r8,#0,#9           ;3482
0001f6  b138              CBZ      r0,|L21.520|
0001f8  4639              MOV      r1,r7                 ;3483
0001fa  9801              LDR      r0,[sp,#4]            ;3483
0001fc  f7fffffe          BL       clust2sect
000200  f1b00b00          SUBS     r11,r0,#0             ;3483
000204  d101              BNE      |L21.522|
000206  2502              MOVS     r5,#2                 ;3484
                  |L21.520|
000208  e00c              B        |L21.548|
                  |L21.522|
00020a  eb0b2058          ADD      r0,r11,r8,LSR #9      ;3486
00020e  6220              STR      r0,[r4,#0x20]         ;3486
000210  6a22              LDR      r2,[r4,#0x20]         ;3488
000212  9901              LDR      r1,[sp,#4]            ;3488
000214  7848              LDRB     r0,[r1,#1]            ;3488
000216  2301              MOVS     r3,#1                 ;3488
000218  f1040130          ADD      r1,r4,#0x30           ;3488
00021c  f7fffffe          BL       disk_read
000220  b100              CBZ      r0,|L21.548|
000222  2501              MOVS     r5,#1                 ;3488
                  |L21.548|
000224  b10d              CBZ      r5,|L21.554|
000226  2000              MOVS     r0,#0                 ;3499
000228  6020              STR      r0,[r4,#0]            ;3499
                  |L21.554|
00022a  4628              MOV      r0,r5                 ;3501
00022c  e6ef              B        |L21.14|
;;;3503   
                          ENDP

00022e  0000              DCW      0x0000
                  |L21.560|
                          DCD      0x46c40000

                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;4161   
;;;4162   FRESULT f_opendir (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;4163   	DIR* dp,			/* Pointer to directory object to create */
;;;4164   	const TCHAR* path	/* Pointer to the directory path */
;;;4165   )
;;;4166   {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
;;;4167   	FRESULT res;
;;;4168   	FATFS *fs;
;;;4169   	_FDID *obj;
;;;4170   	DEF_NAMBUF
;;;4171   
;;;4172   
;;;4173   	if (!dp) return FR_INVALID_OBJECT;
000006  b916              CBNZ     r6,|L22.14|
000008  2009              MOVS     r0,#9
                  |L22.10|
;;;4174   
;;;4175   	/* Get logical drive */
;;;4176   	obj = &dp->obj;
;;;4177   	res = find_volume(&path, &fs, 0);
;;;4178   	if (res == FR_OK) {
;;;4179   		obj->fs = fs;
;;;4180   		INIT_NAMBUF(fs);
;;;4181   		res = follow_path(dp, path);			/* Follow the path to the directory */
;;;4182   		if (res == FR_OK) {						/* Follow completed */
;;;4183   			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
;;;4184   				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
;;;4185   #if _FS_EXFAT
;;;4186   					if (fs->fs_type == FS_EXFAT) {
;;;4187   						obj->c_scl = obj->sclust;							/* Get containing directory inforamation */
;;;4188   						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
;;;4189   						obj->c_ofs = dp->blk_ofs;
;;;4190   						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object allocation info */
;;;4191   						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;4192   						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;4193   					} else
;;;4194   #endif
;;;4195   					{
;;;4196   						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
;;;4197   					}
;;;4198   				} else {						/* This object is a file */
;;;4199   					res = FR_NO_PATH;
;;;4200   				}
;;;4201   			}
;;;4202   			if (res == FR_OK) {
;;;4203   				obj->id = fs->id;
;;;4204   				res = dir_sdi(dp, 0);			/* Rewind directory */
;;;4205   #if _FS_LOCK != 0
;;;4206   				if (res == FR_OK) {
;;;4207   					if (obj->sclust) {
;;;4208   						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;4209   						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
;;;4210   					} else {
;;;4211   						obj->lockid = 0;	/* Root directory need not to be locked */
;;;4212   					}
;;;4213   				}
;;;4214   #endif
;;;4215   			}
;;;4216   		}
;;;4217   		FREE_NAMBUF();
;;;4218   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;4219   	}
;;;4220   	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
;;;4221   
;;;4222   	LEAVE_FF(fs, res);
;;;4223   }
00000a  b004              ADD      sp,sp,#0x10
00000c  bd70              POP      {r4-r6,pc}
                  |L22.14|
00000e  4634              MOV      r4,r6                 ;4176
000010  2200              MOVS     r2,#0                 ;4177
000012  a901              ADD      r1,sp,#4              ;4177
000014  a803              ADD      r0,sp,#0xc            ;4177
000016  f7fffffe          BL       find_volume
00001a  4605              MOV      r5,r0                 ;4177
00001c  2d00              CMP      r5,#0                 ;4178
00001e  d131              BNE      |L22.132|
000020  9801              LDR      r0,[sp,#4]            ;4179
000022  6020              STR      r0,[r4,#0]            ;4179
000024  4630              MOV      r0,r6                 ;4181
000026  9903              LDR      r1,[sp,#0xc]          ;4181
000028  f7fffffe          BL       follow_path
00002c  4605              MOV      r5,r0                 ;4181
00002e  bb1d              CBNZ     r5,|L22.120|
000030  202f              MOVS     r0,#0x2f              ;4183
000032  5d80              LDRB     r0,[r0,r6]            ;4183
000034  f0000080          AND      r0,r0,#0x80           ;4183
000038  b950              CBNZ     r0,|L22.80|
00003a  79a0              LDRB     r0,[r4,#6]            ;4184
00003c  f0000010          AND      r0,r0,#0x10           ;4184
000040  b128              CBZ      r0,|L22.78|
000042  6a31              LDR      r1,[r6,#0x20]         ;4196
000044  9801              LDR      r0,[sp,#4]            ;4196
000046  f7fffffe          BL       ld_clust
00004a  60a0              STR      r0,[r4,#8]            ;4196
00004c  e000              B        |L22.80|
                  |L22.78|
00004e  2505              MOVS     r5,#5                 ;4199
                  |L22.80|
000050  b995              CBNZ     r5,|L22.120|
000052  9801              LDR      r0,[sp,#4]            ;4203
000054  88c0              LDRH     r0,[r0,#6]            ;4203
000056  80a0              STRH     r0,[r4,#4]            ;4203
000058  2100              MOVS     r1,#0                 ;4204
00005a  4630              MOV      r0,r6                 ;4204
00005c  f7fffffe          BL       dir_sdi
000060  4605              MOV      r5,r0                 ;4204
000062  b94d              CBNZ     r5,|L22.120|
000064  68a0              LDR      r0,[r4,#8]            ;4207
000066  b140              CBZ      r0,|L22.122|
000068  2100              MOVS     r1,#0                 ;4208
00006a  4630              MOV      r0,r6                 ;4208
00006c  f7fffffe          BL       inc_lock
000070  6120              STR      r0,[r4,#0x10]         ;4208
000072  6920              LDR      r0,[r4,#0x10]         ;4209
000074  b900              CBNZ     r0,|L22.120|
000076  2512              MOVS     r5,#0x12              ;4209
                  |L22.120|
000078  e001              B        |L22.126|
                  |L22.122|
00007a  2000              MOVS     r0,#0                 ;4211
00007c  6120              STR      r0,[r4,#0x10]         ;4211
                  |L22.126|
00007e  2d04              CMP      r5,#4                 ;4218
000080  d100              BNE      |L22.132|
000082  2505              MOVS     r5,#5                 ;4218
                  |L22.132|
000084  b10d              CBZ      r5,|L22.138|
000086  2000              MOVS     r0,#0                 ;4220
000088  6020              STR      r0,[r4,#0]            ;4220
                  |L22.138|
00008a  4628              MOV      r0,r5                 ;4222
00008c  e7bd              B        |L22.10|
;;;4224   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;3510   
;;;3511   FRESULT f_read (
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3512   	FIL* fp, 	/* Pointer to the file object */
;;;3513   	void* buff,	/* Pointer to data buffer */
;;;3514   	UINT btr,	/* Number of bytes to read */
;;;3515   	UINT* br	/* Pointer to number of bytes read */
;;;3516   )
;;;3517   {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
;;;3518   	FRESULT res;
;;;3519   	FATFS *fs;
;;;3520   	DWORD clst, sect;
;;;3521   	FSIZE_t remain;
;;;3522   	UINT rcnt, cc, csect;
;;;3523   	BYTE *rbuff = (BYTE*)buff;
00000c  f8ddb018          LDR      r11,[sp,#0x18]
;;;3524   
;;;3525   
;;;3526   	*br = 0;	/* Clear read byte counter */
000010  2000              MOVS     r0,#0
000012  f8ca0000          STR      r0,[r10,#0]
;;;3527   	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
000016  a903              ADD      r1,sp,#0xc
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       validate
00001e  9004              STR      r0,[sp,#0x10]
;;;3528   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
000020  9804              LDR      r0,[sp,#0x10]
000022  b910              CBNZ     r0,|L23.42|
000024  7d60              LDRB     r0,[r4,#0x15]
000026  9004              STR      r0,[sp,#0x10]
000028  b118              CBZ      r0,|L23.50|
                  |L23.42|
00002a  9804              LDR      r0,[sp,#0x10]
                  |L23.44|
;;;3529   	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
;;;3530   	remain = fp->obj.objsize - fp->fptr;
;;;3531   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;3532   
;;;3533   	for ( ;  btr;								/* Repeat until all data read */
;;;3534   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;3535   		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
;;;3536   			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
;;;3537   			if (csect == 0) {					/* On the cluster boundary? */
;;;3538   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;3539   					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
;;;3540   				} else {						/* Middle or end of the file */
;;;3541   #if _USE_FASTSEEK
;;;3542   					if (fp->cltbl) {
;;;3543   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;3544   					} else
;;;3545   #endif
;;;3546   					{
;;;3547   						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
;;;3548   					}
;;;3549   				}
;;;3550   				if (clst < 2) ABORT(fs, FR_INT_ERR);
;;;3551   				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;3552   				fp->clust = clst;				/* Update current cluster */
;;;3553   			}
;;;3554   			sect = clust2sect(fs, fp->clust);	/* Get current sector */
;;;3555   			if (!sect) ABORT(fs, FR_INT_ERR);
;;;3556   			sect += csect;
;;;3557   			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
;;;3558   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;3559   				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
;;;3560   					cc = fs->csize - csect;
;;;3561   				}
;;;3562   				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3563   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;3564   #if _FS_TINY
;;;3565   				if (fs->wflag && fs->winsect - sect < cc) {
;;;3566   					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
;;;3567   				}
;;;3568   #else
;;;3569   				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
;;;3570   					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
;;;3571   				}
;;;3572   #endif
;;;3573   #endif
;;;3574   				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
;;;3575   				continue;
;;;3576   			}
;;;3577   #if !_FS_TINY
;;;3578   			if (fp->sect != sect) {			/* Load data sector if not in cache */
;;;3579   #if !_FS_READONLY
;;;3580   				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
;;;3581   					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3582   					fp->flag &= (BYTE)~FA_DIRTY;
;;;3583   				}
;;;3584   #endif
;;;3585   				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
;;;3586   			}
;;;3587   #endif
;;;3588   			fp->sect = sect;
;;;3589   		}
;;;3590   		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
;;;3591   		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
;;;3592   #if _FS_TINY
;;;3593   		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
;;;3594   		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
;;;3595   #else
;;;3596   		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
;;;3597   #endif
;;;3598   	}
;;;3599   
;;;3600   	LEAVE_FF(fs, FR_OK);
;;;3601   }
00002c  b009              ADD      sp,sp,#0x24
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.50|
000032  7d20              LDRB     r0,[r4,#0x14]         ;3529
000034  f0000001          AND      r0,r0,#1              ;3529
000038  b908              CBNZ     r0,|L23.62|
00003a  2007              MOVS     r0,#7                 ;3529
00003c  e7f6              B        |L23.44|
                  |L23.62|
00003e  69a1              LDR      r1,[r4,#0x18]         ;3530
000040  68e0              LDR      r0,[r4,#0xc]          ;3530
000042  1a40              SUBS     r0,r0,r1              ;3530
000044  9001              STR      r0,[sp,#4]            ;3530
000046  9801              LDR      r0,[sp,#4]            ;3531
000048  4285              CMP      r5,r0                 ;3531
00004a  d900              BLS      |L23.78|
00004c  9d01              LDR      r5,[sp,#4]            ;3531
                  |L23.78|
00004e  e0a8              B        |L23.418|
                  |L23.80|
000050  8b20              LDRH     r0,[r4,#0x18]         ;3535
000052  f3c00008          UBFX     r0,r0,#0,#9           ;3535
000056  2800              CMP      r0,#0                 ;3535
000058  d174              BNE      |L23.324|
00005a  9803              LDR      r0,[sp,#0xc]          ;3536
00005c  8940              LDRH     r0,[r0,#0xa]          ;3536
00005e  1e40              SUBS     r0,r0,#1              ;3536
000060  69a1              LDR      r1,[r4,#0x18]         ;3536
000062  ea002951          AND      r9,r0,r1,LSR #9       ;3536
000066  f1b90f00          CMP      r9,#0                 ;3537
00006a  d11f              BNE      |L23.172|
00006c  69a0              LDR      r0,[r4,#0x18]         ;3538
00006e  b910              CBNZ     r0,|L23.118|
000070  68a0              LDR      r0,[r4,#8]            ;3539
000072  9002              STR      r0,[sp,#8]            ;3539
000074  e00c              B        |L23.144|
                  |L23.118|
000076  6ae0              LDR      r0,[r4,#0x2c]         ;3542
000078  b128              CBZ      r0,|L23.134|
00007a  4620              MOV      r0,r4                 ;3543
00007c  69a1              LDR      r1,[r4,#0x18]         ;3543
00007e  f7fffffe          BL       clmt_clust
000082  9002              STR      r0,[sp,#8]            ;3543
000084  e004              B        |L23.144|
                  |L23.134|
000086  4620              MOV      r0,r4                 ;3547
000088  69e1              LDR      r1,[r4,#0x1c]         ;3547
00008a  f7fffffe          BL       get_fat
00008e  9002              STR      r0,[sp,#8]            ;3547
                  |L23.144|
000090  9802              LDR      r0,[sp,#8]            ;3550
000092  2802              CMP      r0,#2                 ;3550
000094  d202              BCS      |L23.156|
000096  2002              MOVS     r0,#2                 ;3550
000098  7560              STRB     r0,[r4,#0x15]         ;3550
00009a  e7c7              B        |L23.44|
                  |L23.156|
00009c  9802              LDR      r0,[sp,#8]            ;3551
00009e  1c40              ADDS     r0,r0,#1              ;3551
0000a0  b910              CBNZ     r0,|L23.168|
0000a2  2001              MOVS     r0,#1                 ;3551
0000a4  7560              STRB     r0,[r4,#0x15]         ;3551
0000a6  e7c1              B        |L23.44|
                  |L23.168|
0000a8  9802              LDR      r0,[sp,#8]            ;3552
0000aa  61e0              STR      r0,[r4,#0x1c]         ;3552
                  |L23.172|
0000ac  69e1              LDR      r1,[r4,#0x1c]         ;3554
0000ae  9803              LDR      r0,[sp,#0xc]          ;3554
0000b0  f7fffffe          BL       clust2sect
0000b4  4606              MOV      r6,r0                 ;3554
0000b6  b916              CBNZ     r6,|L23.190|
0000b8  2002              MOVS     r0,#2                 ;3555
0000ba  7560              STRB     r0,[r4,#0x15]         ;3555
0000bc  e7b6              B        |L23.44|
                  |L23.190|
0000be  444e              ADD      r6,r6,r9              ;3556
0000c0  ea4f2855          LSR      r8,r5,#9              ;3557
0000c4  f1b80f00          CMP      r8,#0                 ;3558
0000c8  d029              BEQ      |L23.286|
0000ca  eb090008          ADD      r0,r9,r8              ;3559
0000ce  9903              LDR      r1,[sp,#0xc]          ;3559
0000d0  8949              LDRH     r1,[r1,#0xa]          ;3559
0000d2  4288              CMP      r0,r1                 ;3559
0000d4  d903              BLS      |L23.222|
0000d6  9803              LDR      r0,[sp,#0xc]          ;3560
0000d8  8940              LDRH     r0,[r0,#0xa]          ;3560
0000da  eba00809          SUB      r8,r0,r9              ;3560
                  |L23.222|
0000de  9903              LDR      r1,[sp,#0xc]          ;3562
0000e0  7848              LDRB     r0,[r1,#1]            ;3562
0000e2  4643              MOV      r3,r8                 ;3562
0000e4  4632              MOV      r2,r6                 ;3562
0000e6  4659              MOV      r1,r11                ;3562
0000e8  f7fffffe          BL       disk_read
0000ec  b110              CBZ      r0,|L23.244|
0000ee  2001              MOVS     r0,#1                 ;3562
0000f0  7560              STRB     r0,[r4,#0x15]         ;3562
0000f2  e79b              B        |L23.44|
                  |L23.244|
0000f4  7d20              LDRB     r0,[r4,#0x14]         ;3569
0000f6  f0000080          AND      r0,r0,#0x80           ;3569
0000fa  b168              CBZ      r0,|L23.280|
0000fc  6a20              LDR      r0,[r4,#0x20]         ;3569
0000fe  1b80              SUBS     r0,r0,r6              ;3569
000100  4540              CMP      r0,r8                 ;3569
000102  d209              BCS      |L23.280|
000104  6a21              LDR      r1,[r4,#0x20]         ;3570
000106  1b89              SUBS     r1,r1,r6              ;3570
000108  eb0b2041          ADD      r0,r11,r1,LSL #9      ;3570
00010c  f44f7200          MOV      r2,#0x200             ;3570
000110  f1040130          ADD      r1,r4,#0x30           ;3570
000114  f7fffffe          BL       mem_cpy
                  |L23.280|
000118  ea4f2748          LSL      r7,r8,#9              ;3574
00011c  e037              B        |L23.398|
                  |L23.286|
00011e  6a20              LDR      r0,[r4,#0x20]         ;3578
000120  42b0              CMP      r0,r6                 ;3578
000122  d020              BEQ      |L23.358|
000124  7d20              LDRB     r0,[r4,#0x14]         ;3580
000126  f0000080          AND      r0,r0,#0x80           ;3580
00012a  b180              CBZ      r0,|L23.334|
00012c  6a22              LDR      r2,[r4,#0x20]         ;3581
00012e  9903              LDR      r1,[sp,#0xc]          ;3581
000130  7848              LDRB     r0,[r1,#1]            ;3581
000132  2301              MOVS     r3,#1                 ;3581
000134  f1040130          ADD      r1,r4,#0x30           ;3581
000138  f7fffffe          BL       disk_write
00013c  b118              CBZ      r0,|L23.326|
00013e  2001              MOVS     r0,#1                 ;3581
000140  7560              STRB     r0,[r4,#0x15]         ;3581
000142  e773              B        |L23.44|
                  |L23.324|
000144  e010              B        |L23.360|
                  |L23.326|
000146  7d20              LDRB     r0,[r4,#0x14]         ;3582
000148  f000007f          AND      r0,r0,#0x7f           ;3582
00014c  7520              STRB     r0,[r4,#0x14]         ;3582
                  |L23.334|
00014e  9903              LDR      r1,[sp,#0xc]          ;3585
000150  7848              LDRB     r0,[r1,#1]            ;3585
000152  2301              MOVS     r3,#1                 ;3585
000154  4632              MOV      r2,r6                 ;3585
000156  f1040130          ADD      r1,r4,#0x30           ;3585
00015a  f7fffffe          BL       disk_read
00015e  b110              CBZ      r0,|L23.358|
000160  2001              MOVS     r0,#1                 ;3585
000162  7560              STRB     r0,[r4,#0x15]         ;3585
000164  e762              B        |L23.44|
                  |L23.358|
000166  6226              STR      r6,[r4,#0x20]         ;3588
                  |L23.360|
000168  8b20              LDRH     r0,[r4,#0x18]         ;3590
00016a  f3c00008          UBFX     r0,r0,#0,#9           ;3590
00016e  f5c07700          RSB      r7,r0,#0x200          ;3590
000172  42af              CMP      r7,r5                 ;3591
000174  d900              BLS      |L23.376|
000176  462f              MOV      r7,r5                 ;3591
                  |L23.376|
000178  8b20              LDRH     r0,[r4,#0x18]         ;3596
00017a  f3c00208          UBFX     r2,r0,#0,#9           ;3596
00017e  f1040030          ADD      r0,r4,#0x30           ;3596
000182  1811              ADDS     r1,r2,r0              ;3596
000184  463a              MOV      r2,r7                 ;3596
000186  4658              MOV      r0,r11                ;3596
000188  f7fffffe          BL       mem_cpy
00018c  bf00              NOP                            ;3575
                  |L23.398|
00018e  44bb              ADD      r11,r11,r7            ;3534
000190  69a0              LDR      r0,[r4,#0x18]         ;3534
000192  4438              ADD      r0,r0,r7              ;3534
000194  61a0              STR      r0,[r4,#0x18]         ;3534
000196  f8da0000          LDR      r0,[r10,#0]           ;3534
00019a  4438              ADD      r0,r0,r7              ;3534
00019c  f8ca0000          STR      r0,[r10,#0]           ;3534
0001a0  1bed              SUBS     r5,r5,r7              ;3534
                  |L23.418|
0001a2  2d00              CMP      r5,#0                 ;3533
0001a4  f47faf54          BNE      |L23.80|
0001a8  2000              MOVS     r0,#0                 ;3600
0001aa  e73f              B        |L23.44|
;;;3602   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;4264   
;;;4265   FRESULT f_readdir (
000000  b5f8              PUSH     {r3-r7,lr}
;;;4266   	DIR* dp,			/* Pointer to the open directory object */
;;;4267   	FILINFO* fno		/* Pointer to file information to return */
;;;4268   )
;;;4269   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4270   	FRESULT res;
;;;4271   	FATFS *fs;
;;;4272   	DEF_NAMBUF
;;;4273   
;;;4274   
;;;4275   	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
000006  4669              MOV      r1,sp
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       validate
00000e  4604              MOV      r4,r0
;;;4276   	if (res == FR_OK) {
000010  b9dc              CBNZ     r4,|L24.74|
;;;4277   		if (!fno) {
000012  b92d              CBNZ     r5,|L24.32|
;;;4278   			res = dir_sdi(dp, 0);			/* Rewind the directory object */
000014  2100              MOVS     r1,#0
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       dir_sdi
00001c  4604              MOV      r4,r0
00001e  e014              B        |L24.74|
                  |L24.32|
;;;4279   		} else {
;;;4280   			INIT_NAMBUF(fs);
;;;4281   			res = dir_read(dp, 0);			/* Read an item */
000020  2100              MOVS     r1,#0
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       dir_read
000028  4604              MOV      r4,r0
;;;4282   			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
00002a  2c04              CMP      r4,#4
00002c  d100              BNE      |L24.48|
00002e  2400              MOVS     r4,#0
                  |L24.48|
;;;4283   			if (res == FR_OK) {				/* A valid entry is found */
000030  b95c              CBNZ     r4,|L24.74|
;;;4284   				get_fileinfo(dp, fno);		/* Get the object information */
000032  4629              MOV      r1,r5
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       get_fileinfo
;;;4285   				res = dir_next(dp, 0);		/* Increment index for next */
00003a  2100              MOVS     r1,#0
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       dir_next
000042  4604              MOV      r4,r0
;;;4286   				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
000044  2c04              CMP      r4,#4
000046  d100              BNE      |L24.74|
000048  2400              MOVS     r4,#0
                  |L24.74|
;;;4287   			}
;;;4288   			FREE_NAMBUF();
;;;4289   		}
;;;4290   	}
;;;4291   	LEAVE_FF(fs, res);
00004a  4620              MOV      r0,r4
;;;4292   }
00004c  bdf8              POP      {r3-r7,pc}
;;;4293   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=2

                  f_sync PROC
;;;3731   
;;;3732   FRESULT f_sync (
000000  b5f8              PUSH     {r3-r7,lr}
;;;3733   	FIL* fp		/* Pointer to the file object */
;;;3734   )
;;;3735   {
000002  4604              MOV      r4,r0
;;;3736   	FRESULT res;
;;;3737   	FATFS *fs;
;;;3738   	DWORD tm;
;;;3739   	BYTE *dir;
;;;3740   #if _FS_EXFAT
;;;3741   	DIR dj;
;;;3742   	DEF_NAMBUF
;;;3743   #endif
;;;3744   
;;;3745   	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4606              MOV      r6,r0
;;;3746   	if (res == FR_OK) {
00000e  2e00              CMP      r6,#0
000010  d142              BNE      |L25.152|
;;;3747   		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
000012  7d20              LDRB     r0,[r4,#0x14]
000014  f0000040          AND      r0,r0,#0x40
000018  2800              CMP      r0,#0
00001a  d03d              BEQ      |L25.152|
;;;3748   #if !_FS_TINY
;;;3749   			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
00001c  7d20              LDRB     r0,[r4,#0x14]
00001e  f0000080          AND      r0,r0,#0x80
000022  b170              CBZ      r0,|L25.66|
;;;3750   				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
000024  6a22              LDR      r2,[r4,#0x20]
000026  9900              LDR      r1,[sp,#0]
000028  7848              LDRB     r0,[r1,#1]
00002a  2301              MOVS     r3,#1
00002c  f1040130          ADD      r1,r4,#0x30
000030  f7fffffe          BL       disk_write
000034  b108              CBZ      r0,|L25.58|
000036  2001              MOVS     r0,#1
                  |L25.56|
;;;3751   				fp->flag &= (BYTE)~FA_DIRTY;
;;;3752   			}
;;;3753   #endif
;;;3754   			/* Update the directory entry */
;;;3755   			tm = GET_FATTIME();				/* Modified time */
;;;3756   #if _FS_EXFAT
;;;3757   			if (fs->fs_type == FS_EXFAT) {
;;;3758   				res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
;;;3759   				if (res == FR_OK) {
;;;3760   					res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
;;;3761   				}
;;;3762   				if (res == FR_OK) {
;;;3763   					INIT_NAMBUF(fs);
;;;3764   					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
;;;3765   					if (res == FR_OK) {
;;;3766   						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive bit */
;;;3767   						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation info */
;;;3768   						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
;;;3769   						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
;;;3770   						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
;;;3771   						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
;;;3772   						fs->dirbuf[XDIR_ModTime10] = 0;
;;;3773   						st_dword(fs->dirbuf + XDIR_AccTime, 0);
;;;3774   						res = store_xdir(&dj);	/* Restore it to the directory */
;;;3775   						if (res == FR_OK) {
;;;3776   							res = sync_fs(fs);
;;;3777   							fp->flag &= (BYTE)~FA_MODIFIED;
;;;3778   						}
;;;3779   					}
;;;3780   					FREE_NAMBUF();
;;;3781   				}
;;;3782   			} else
;;;3783   #endif
;;;3784   			{
;;;3785   				res = move_window(fs, fp->dir_sect);
;;;3786   				if (res == FR_OK) {
;;;3787   					dir = fp->dir_ptr;
;;;3788   					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
;;;3789   					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
;;;3790   					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
;;;3791   					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
;;;3792   					st_word(dir + DIR_LstAccDate, 0);
;;;3793   					fs->wflag = 1;
;;;3794   					res = sync_fs(fs);					/* Restore it to the directory */
;;;3795   					fp->flag &= (BYTE)~FA_MODIFIED;
;;;3796   				}
;;;3797   			}
;;;3798   		}
;;;3799   	}
;;;3800   
;;;3801   	LEAVE_FF(fs, res);
;;;3802   }
000038  bdf8              POP      {r3-r7,pc}
                  |L25.58|
00003a  7d20              LDRB     r0,[r4,#0x14]         ;3751
00003c  f000007f          AND      r0,r0,#0x7f           ;3751
000040  7520              STRB     r0,[r4,#0x14]         ;3751
                  |L25.66|
000042  4f16              LDR      r7,|L25.156|
000044  6a61              LDR      r1,[r4,#0x24]         ;3785
000046  9800              LDR      r0,[sp,#0]            ;3785
000048  f7fffffe          BL       move_window
00004c  4606              MOV      r6,r0                 ;3785
00004e  bb1e              CBNZ     r6,|L25.152|
000050  6aa5              LDR      r5,[r4,#0x28]         ;3787
000052  7ae8              LDRB     r0,[r5,#0xb]          ;3788
000054  f0400020          ORR      r0,r0,#0x20           ;3788
000058  72e8              STRB     r0,[r5,#0xb]          ;3788
00005a  4629              MOV      r1,r5                 ;3789
00005c  68a2              LDR      r2,[r4,#8]            ;3789
00005e  6820              LDR      r0,[r4,#0]            ;3789
000060  f7fffffe          BL       st_clust
000064  f105001c          ADD      r0,r5,#0x1c           ;3790
000068  68e1              LDR      r1,[r4,#0xc]          ;3790
00006a  f7fffffe          BL       st_dword
00006e  4639              MOV      r1,r7                 ;3791
000070  f1050016          ADD      r0,r5,#0x16           ;3791
000074  f7fffffe          BL       st_dword
000078  2100              MOVS     r1,#0                 ;3792
00007a  f1050012          ADD      r0,r5,#0x12           ;3792
00007e  f7fffffe          BL       st_word
000082  2001              MOVS     r0,#1                 ;3793
000084  9900              LDR      r1,[sp,#0]            ;3793
000086  70c8              STRB     r0,[r1,#3]            ;3793
000088  9800              LDR      r0,[sp,#0]            ;3794
00008a  f7fffffe          BL       sync_fs
00008e  4606              MOV      r6,r0                 ;3794
000090  7d20              LDRB     r0,[r4,#0x14]         ;3795
000092  f00000bf          AND      r0,r0,#0xbf           ;3795
000096  7520              STRB     r0,[r4,#0x14]         ;3795
                  |L25.152|
000098  4630              MOV      r0,r6                 ;3801
00009a  e7cd              B        |L25.56|
;;;3803   
                          ENDP

                  |L25.156|
                          DCD      0x46c40000

                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;3610   
;;;3611   FRESULT f_write (
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3612   	FIL* fp,			/* Pointer to the file object */
;;;3613   	const void* buff,	/* Pointer to the data to be written */
;;;3614   	UINT btw,			/* Number of bytes to write */
;;;3615   	UINT* bw			/* Pointer to number of bytes written */
;;;3616   )
;;;3617   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  469b              MOV      r11,r3
;;;3618   	FRESULT res;
;;;3619   	FATFS *fs;
;;;3620   	DWORD clst, sect;
;;;3621   	UINT wcnt, cc, csect;
;;;3622   	const BYTE *wbuff = (const BYTE*)buff;
00000c  9804              LDR      r0,[sp,#0x10]
00000e  9000              STR      r0,[sp,#0]
;;;3623   
;;;3624   
;;;3625   	*bw = 0;	/* Clear write byte counter */
000010  2000              MOVS     r0,#0
000012  f8cb0000          STR      r0,[r11,#0]
;;;3626   	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
000016  a901              ADD      r1,sp,#4
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       validate
00001e  9002              STR      r0,[sp,#8]
;;;3627   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
000020  9802              LDR      r0,[sp,#8]
000022  b910              CBNZ     r0,|L26.42|
000024  7d60              LDRB     r0,[r4,#0x15]
000026  9002              STR      r0,[sp,#8]
000028  b118              CBZ      r0,|L26.50|
                  |L26.42|
00002a  9802              LDR      r0,[sp,#8]
                  |L26.44|
;;;3628   	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
;;;3629   
;;;3630   	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
;;;3631   	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
;;;3632   		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
;;;3633   	}
;;;3634   
;;;3635   	for ( ;  btw;							/* Repeat until all data written */
;;;3636   		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
;;;3637   		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
;;;3638   			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
;;;3639   			if (csect == 0) {				/* On the cluster boundary? */
;;;3640   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;3641   					clst = fp->obj.sclust;	/* Follow from the origin */
;;;3642   					if (clst == 0) {		/* If no cluster is allocated, */
;;;3643   						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
;;;3644   					}
;;;3645   				} else {					/* On the middle or end of the file */
;;;3646   #if _USE_FASTSEEK
;;;3647   					if (fp->cltbl) {
;;;3648   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;3649   					} else
;;;3650   #endif
;;;3651   					{
;;;3652   						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;3653   					}
;;;3654   				}
;;;3655   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;3656   				if (clst == 1) ABORT(fs, FR_INT_ERR);
;;;3657   				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;3658   				fp->clust = clst;			/* Update current cluster */
;;;3659   				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
;;;3660   			}
;;;3661   #if _FS_TINY
;;;3662   			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
;;;3663   #else
;;;3664   			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
;;;3665   				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3666   				fp->flag &= (BYTE)~FA_DIRTY;
;;;3667   			}
;;;3668   #endif
;;;3669   			sect = clust2sect(fs, fp->clust);	/* Get current sector */
;;;3670   			if (!sect) ABORT(fs, FR_INT_ERR);
;;;3671   			sect += csect;
;;;3672   			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
;;;3673   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;3674   				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
;;;3675   					cc = fs->csize - csect;
;;;3676   				}
;;;3677   				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3678   #if _FS_MINIMIZE <= 2
;;;3679   #if _FS_TINY
;;;3680   				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;3681   					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
;;;3682   					fs->wflag = 0;
;;;3683   				}
;;;3684   #else
;;;3685   				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;3686   					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
;;;3687   					fp->flag &= (BYTE)~FA_DIRTY;
;;;3688   				}
;;;3689   #endif
;;;3690   #endif
;;;3691   				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
;;;3692   				continue;
;;;3693   			}
;;;3694   #if _FS_TINY
;;;3695   			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
;;;3696   				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
;;;3697   				fs->winsect = sect;
;;;3698   			}
;;;3699   #else
;;;3700   			if (fp->sect != sect && 		/* Fill sector cache with file data */
;;;3701   				fp->fptr < fp->obj.objsize &&
;;;3702   				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
;;;3703   					ABORT(fs, FR_DISK_ERR);
;;;3704   			}
;;;3705   #endif
;;;3706   			fp->sect = sect;
;;;3707   		}
;;;3708   		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
;;;3709   		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
;;;3710   #if _FS_TINY
;;;3711   		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
;;;3712   		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
;;;3713   		fs->wflag = 1;
;;;3714   #else
;;;3715   		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
;;;3716   		fp->flag |= FA_DIRTY;
;;;3717   #endif
;;;3718   	}
;;;3719   
;;;3720   	fp->flag |= FA_MODIFIED;				/* Set file change flag */
;;;3721   
;;;3722   	LEAVE_FF(fs, FR_OK);
;;;3723   }
00002c  b007              ADD      sp,sp,#0x1c
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L26.50|
000032  7d20              LDRB     r0,[r4,#0x14]         ;3628
000034  f0000002          AND      r0,r0,#2              ;3628
000038  b908              CBNZ     r0,|L26.62|
00003a  2007              MOVS     r0,#7                 ;3628
00003c  e7f6              B        |L26.44|
                  |L26.62|
00003e  bf00              NOP                            ;3631
000040  69a0              LDR      r0,[r4,#0x18]         ;3631
000042  4428              ADD      r0,r0,r5              ;3631
000044  69a1              LDR      r1,[r4,#0x18]         ;3631
000046  4288              CMP      r0,r1                 ;3631
000048  d202              BCS      |L26.80|
00004a  69a0              LDR      r0,[r4,#0x18]         ;3632
00004c  f1c035ff          RSB      r5,r0,#0xffffffff     ;3632
                  |L26.80|
000050  e0c3              B        |L26.474|
                  |L26.82|
000052  8b20              LDRH     r0,[r4,#0x18]         ;3637
000054  f3c00008          UBFX     r0,r0,#0,#9           ;3637
000058  2800              CMP      r0,#0                 ;3637
00005a  d17d              BNE      |L26.344|
00005c  9801              LDR      r0,[sp,#4]            ;3638
00005e  8940              LDRH     r0,[r0,#0xa]          ;3638
000060  1e40              SUBS     r0,r0,#1              ;3638
000062  69a1              LDR      r1,[r4,#0x18]         ;3638
000064  ea002a51          AND      r10,r0,r1,LSR #9      ;3638
000068  f1ba0f00          CMP      r10,#0                ;3639
00006c  d126              BNE      |L26.188|
00006e  69a0              LDR      r0,[r4,#0x18]         ;3640
000070  b938              CBNZ     r0,|L26.130|
000072  68a7              LDR      r7,[r4,#8]            ;3641
000074  b997              CBNZ     r7,|L26.156|
000076  2100              MOVS     r1,#0                 ;3643
000078  4620              MOV      r0,r4                 ;3643
00007a  f7fffffe          BL       create_chain
00007e  4607              MOV      r7,r0                 ;3643
000080  e00c              B        |L26.156|
                  |L26.130|
000082  6ae0              LDR      r0,[r4,#0x2c]         ;3647
000084  b128              CBZ      r0,|L26.146|
000086  4620              MOV      r0,r4                 ;3648
000088  69a1              LDR      r1,[r4,#0x18]         ;3648
00008a  f7fffffe          BL       clmt_clust
00008e  4607              MOV      r7,r0                 ;3648
000090  e004              B        |L26.156|
                  |L26.146|
000092  4620              MOV      r0,r4                 ;3652
000094  69e1              LDR      r1,[r4,#0x1c]         ;3652
000096  f7fffffe          BL       create_chain
00009a  4607              MOV      r7,r0                 ;3652
                  |L26.156|
00009c  b907              CBNZ     r7,|L26.160|
00009e  e09f              B        |L26.480|
                  |L26.160|
0000a0  2f01              CMP      r7,#1                 ;3656
0000a2  d102              BNE      |L26.170|
0000a4  2002              MOVS     r0,#2                 ;3656
0000a6  7560              STRB     r0,[r4,#0x15]         ;3656
0000a8  e7c0              B        |L26.44|
                  |L26.170|
0000aa  1c78              ADDS     r0,r7,#1              ;3657
0000ac  b910              CBNZ     r0,|L26.180|
0000ae  2001              MOVS     r0,#1                 ;3657
0000b0  7560              STRB     r0,[r4,#0x15]         ;3657
0000b2  e7bb              B        |L26.44|
                  |L26.180|
0000b4  61e7              STR      r7,[r4,#0x1c]         ;3658
0000b6  68a0              LDR      r0,[r4,#8]            ;3659
0000b8  b900              CBNZ     r0,|L26.188|
0000ba  60a7              STR      r7,[r4,#8]            ;3659
                  |L26.188|
0000bc  7d20              LDRB     r0,[r4,#0x14]         ;3664
0000be  f0000080          AND      r0,r0,#0x80           ;3664
0000c2  b178              CBZ      r0,|L26.228|
0000c4  6a22              LDR      r2,[r4,#0x20]         ;3665
0000c6  9901              LDR      r1,[sp,#4]            ;3665
0000c8  7848              LDRB     r0,[r1,#1]            ;3665
0000ca  2301              MOVS     r3,#1                 ;3665
0000cc  f1040130          ADD      r1,r4,#0x30           ;3665
0000d0  f7fffffe          BL       disk_write
0000d4  b110              CBZ      r0,|L26.220|
0000d6  2001              MOVS     r0,#1                 ;3665
0000d8  7560              STRB     r0,[r4,#0x15]         ;3665
0000da  e7a7              B        |L26.44|
                  |L26.220|
0000dc  7d20              LDRB     r0,[r4,#0x14]         ;3666
0000de  f000007f          AND      r0,r0,#0x7f           ;3666
0000e2  7520              STRB     r0,[r4,#0x14]         ;3666
                  |L26.228|
0000e4  69e1              LDR      r1,[r4,#0x1c]         ;3669
0000e6  9801              LDR      r0,[sp,#4]            ;3669
0000e8  f7fffffe          BL       clust2sect
0000ec  4606              MOV      r6,r0                 ;3669
0000ee  b916              CBNZ     r6,|L26.246|
0000f0  2002              MOVS     r0,#2                 ;3670
0000f2  7560              STRB     r0,[r4,#0x15]         ;3670
0000f4  e79a              B        |L26.44|
                  |L26.246|
0000f6  4456              ADD      r6,r6,r10             ;3671
0000f8  ea4f2955          LSR      r9,r5,#9              ;3672
0000fc  f1b90f00          CMP      r9,#0                 ;3673
000100  d02b              BEQ      |L26.346|
000102  eb0a0009          ADD      r0,r10,r9             ;3674
000106  9901              LDR      r1,[sp,#4]            ;3674
000108  8949              LDRH     r1,[r1,#0xa]          ;3674
00010a  4288              CMP      r0,r1                 ;3674
00010c  d903              BLS      |L26.278|
00010e  9801              LDR      r0,[sp,#4]            ;3675
000110  8940              LDRH     r0,[r0,#0xa]          ;3675
000112  eba0090a          SUB      r9,r0,r10             ;3675
                  |L26.278|
000116  9901              LDR      r1,[sp,#4]            ;3677
000118  7848              LDRB     r0,[r1,#1]            ;3677
00011a  464b              MOV      r3,r9                 ;3677
00011c  4632              MOV      r2,r6                 ;3677
00011e  9900              LDR      r1,[sp,#0]            ;3677
000120  f7fffffe          BL       disk_write
000124  b110              CBZ      r0,|L26.300|
000126  2001              MOVS     r0,#1                 ;3677
000128  7560              STRB     r0,[r4,#0x15]         ;3677
00012a  e77f              B        |L26.44|
                  |L26.300|
00012c  6a20              LDR      r0,[r4,#0x20]         ;3685
00012e  1b80              SUBS     r0,r0,r6              ;3685
000130  4548              CMP      r0,r9                 ;3685
000132  d20e              BCS      |L26.338|
000134  6a20              LDR      r0,[r4,#0x20]         ;3686
000136  1b80              SUBS     r0,r0,r6              ;3686
000138  9a00              LDR      r2,[sp,#0]            ;3686
00013a  eb022140          ADD      r1,r2,r0,LSL #9       ;3686
00013e  f44f7200          MOV      r2,#0x200             ;3686
000142  f1040030          ADD      r0,r4,#0x30           ;3686
000146  f7fffffe          BL       mem_cpy
00014a  7d20              LDRB     r0,[r4,#0x14]         ;3687
00014c  f000007f          AND      r0,r0,#0x7f           ;3687
000150  7520              STRB     r0,[r4,#0x14]         ;3687
                  |L26.338|
000152  ea4f2849          LSL      r8,r9,#9              ;3691
000156  e02b              B        |L26.432|
                  |L26.344|
000158  e013              B        |L26.386|
                  |L26.346|
00015a  6a20              LDR      r0,[r4,#0x20]         ;3700
00015c  42b0              CMP      r0,r6                 ;3700
00015e  d00f              BEQ      |L26.384|
000160  68e1              LDR      r1,[r4,#0xc]          ;3701
000162  69a0              LDR      r0,[r4,#0x18]         ;3701
000164  4288              CMP      r0,r1                 ;3701
000166  d20b              BCS      |L26.384|
000168  9901              LDR      r1,[sp,#4]            ;3702
00016a  7848              LDRB     r0,[r1,#1]            ;3702
00016c  2301              MOVS     r3,#1                 ;3702
00016e  4632              MOV      r2,r6                 ;3702
000170  f1040130          ADD      r1,r4,#0x30           ;3702
000174  f7fffffe          BL       disk_read
000178  b110              CBZ      r0,|L26.384|
00017a  2001              MOVS     r0,#1                 ;3703
00017c  7560              STRB     r0,[r4,#0x15]         ;3703
00017e  e755              B        |L26.44|
                  |L26.384|
000180  6226              STR      r6,[r4,#0x20]         ;3706
                  |L26.386|
000182  8b20              LDRH     r0,[r4,#0x18]         ;3708
000184  f3c00008          UBFX     r0,r0,#0,#9           ;3708
000188  f5c07800          RSB      r8,r0,#0x200          ;3708
00018c  45a8              CMP      r8,r5                 ;3709
00018e  d900              BLS      |L26.402|
000190  46a8              MOV      r8,r5                 ;3709
                  |L26.402|
000192  8b21              LDRH     r1,[r4,#0x18]         ;3715
000194  f3c10208          UBFX     r2,r1,#0,#9           ;3715
000198  f1040130          ADD      r1,r4,#0x30           ;3715
00019c  1850              ADDS     r0,r2,r1              ;3715
00019e  4642              MOV      r2,r8                 ;3715
0001a0  9900              LDR      r1,[sp,#0]            ;3715
0001a2  f7fffffe          BL       mem_cpy
0001a6  7d20              LDRB     r0,[r4,#0x14]         ;3716
0001a8  f0400080          ORR      r0,r0,#0x80           ;3716
0001ac  7520              STRB     r0,[r4,#0x14]         ;3716
0001ae  bf00              NOP                            ;3692
                  |L26.432|
0001b0  9800              LDR      r0,[sp,#0]            ;3636
0001b2  4440              ADD      r0,r0,r8              ;3636
0001b4  9000              STR      r0,[sp,#0]            ;3636
0001b6  69a0              LDR      r0,[r4,#0x18]         ;3636
0001b8  4440              ADD      r0,r0,r8              ;3636
0001ba  61a0              STR      r0,[r4,#0x18]         ;3636
0001bc  68e1              LDR      r1,[r4,#0xc]          ;3636
0001be  69a0              LDR      r0,[r4,#0x18]         ;3636
0001c0  4288              CMP      r0,r1                 ;3636
0001c2  d901              BLS      |L26.456|
0001c4  69a0              LDR      r0,[r4,#0x18]         ;3636
0001c6  e000              B        |L26.458|
                  |L26.456|
0001c8  68e0              LDR      r0,[r4,#0xc]          ;3636
                  |L26.458|
0001ca  60e0              STR      r0,[r4,#0xc]          ;3636
0001cc  f8db0000          LDR      r0,[r11,#0]           ;3636
0001d0  4440              ADD      r0,r0,r8              ;3636
0001d2  f8cb0000          STR      r0,[r11,#0]           ;3636
0001d6  eba50508          SUB      r5,r5,r8              ;3636
                  |L26.474|
0001da  2d00              CMP      r5,#0                 ;3635
0001dc  f47faf39          BNE      |L26.82|
                  |L26.480|
0001e0  bf00              NOP                            ;3655
0001e2  7d20              LDRB     r0,[r4,#0x14]         ;3720
0001e4  f0400040          ORR      r0,r0,#0x40           ;3720
0001e8  7520              STRB     r0,[r4,#0x14]         ;3720
0001ea  2000              MOVS     r0,#0                 ;3722
0001ec  e71e              B        |L26.44|
;;;3724   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;2992   static
;;;2993   FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;2994   	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;;;2995   	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;;;2996   	BYTE mode			/* !=0: Check write protection for write access */
;;;2997   )
;;;2998   {
000004  b08a              SUB      sp,sp,#0x28
;;;2999   	BYTE fmt, *pt;
;;;3000   	int vol;
;;;3001   	DSTATUS stat;
;;;3002   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
;;;3003   	WORD nrsv;
;;;3004   	FATFS *fs;
;;;3005   	UINT i;
;;;3006   
;;;3007   
;;;3008   	/* Get logical drive number */
;;;3009   	*rfs = 0;
000006  2100              MOVS     r1,#0
000008  980b              LDR      r0,[sp,#0x2c]
00000a  6001              STR      r1,[r0,#0]
;;;3010   	vol = get_ldnumber(path);
00000c  980a              LDR      r0,[sp,#0x28]
00000e  f7fffffe          BL       get_ldnumber
000012  9008              STR      r0,[sp,#0x20]
;;;3011   	if (vol < 0) return FR_INVALID_DRIVE;
000014  9808              LDR      r0,[sp,#0x20]
000016  2800              CMP      r0,#0
000018  da03              BGE      |L27.34|
00001a  200b              MOVS     r0,#0xb
                  |L27.28|
;;;3012   
;;;3013   	/* Check if the file system object is valid or not */
;;;3014   	fs = FatFs[vol];					/* Get pointer to the file system object */
;;;3015   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;3016   
;;;3017   	ENTER_FF(fs);						/* Lock the volume */
;;;3018   	*rfs = fs;							/* Return pointer to the file system object */
;;;3019   
;;;3020   	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
;;;3021   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;3022   		stat = disk_status(fs->drv);
;;;3023   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;;;3024   			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
;;;3025   				return FR_WRITE_PROTECTED;
;;;3026   			}
;;;3027   			return FR_OK;				/* The file system object is valid */
;;;3028   		}
;;;3029   	}
;;;3030   
;;;3031   	/* The file system object is not valid. */
;;;3032   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;3033   
;;;3034   	fs->fs_type = 0;					/* Clear the file system object */
;;;3035   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;3036   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;3037   	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
;;;3038   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;3039   	}
;;;3040   	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
;;;3041   		return FR_WRITE_PROTECTED;
;;;3042   	}
;;;3043   #if _MAX_SS != _MIN_SS					/* Get sector size (multiple sector size cfg only) */
;;;3044   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
;;;3045   	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
;;;3046   #endif
;;;3047   
;;;3048   	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
;;;3049   	bsect = 0;
;;;3050   	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
;;;3051   	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
;;;3052   		for (i = 0; i < 4; i++) {		/* Get partition offset */
;;;3053   			pt = fs->win + (MBR_Table + i * SZ_PTE);
;;;3054   			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
;;;3055   		}
;;;3056   		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
;;;3057   		if (i) i--;
;;;3058   		do {							/* Find an FAT volume */
;;;3059   			bsect = br[i];
;;;3060   			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
;;;3061   		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
;;;3062   	}
;;;3063   	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;3064   	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
;;;3065   
;;;3066   	/* An FAT volume is found (bsect). Following code initializes the file system object */
;;;3067   
;;;3068   #if _FS_EXFAT
;;;3069   	if (fmt == 1) {
;;;3070   		QWORD maxlba;
;;;3071   
;;;3072   		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
;;;3073   		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
;;;3074   
;;;3075   		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
;;;3076   
;;;3077   		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
;;;3078   			return FR_NO_FILESYSTEM;
;;;3079   		}
;;;3080   
;;;3081   		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
;;;3082   		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
;;;3083   
;;;3084   		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
;;;3085   
;;;3086   		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
;;;3087   		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
;;;3088   
;;;3089   		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
;;;3090   		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
;;;3091   
;;;3092   		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
;;;3093   		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
;;;3094   		fs->n_fatent = nclst + 2;
;;;3095   
;;;3096   		/* Boundaries and Limits */
;;;3097   		fs->volbase = bsect;
;;;3098   		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
;;;3099   		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
;;;3100   		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
;;;3101   		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
;;;3102   
;;;3103   		/* Check if bitmap location is in assumption (at the first cluster) */
;;;3104   		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
;;;3105   		for (i = 0; i < SS(fs); i += SZDIRE) {
;;;3106   			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
;;;3107   		}
;;;3108   		if (i == SS(fs)) return FR_NO_FILESYSTEM;
;;;3109   #if !_FS_READONLY
;;;3110   		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
;;;3111   #endif
;;;3112   		fmt = FS_EXFAT;			/* FAT sub-type */
;;;3113   	} else
;;;3114   #endif	/* _FS_EXFAT */
;;;3115   	{
;;;3116   		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;3117   
;;;3118   		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
;;;3119   		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
;;;3120   		fs->fsize = fasize;
;;;3121   
;;;3122   		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
;;;3123   		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
;;;3124   		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
;;;3125   
;;;3126   		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
;;;3127   		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
;;;3128   
;;;3129   		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
;;;3130   		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
;;;3131   
;;;3132   		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
;;;3133   		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
;;;3134   
;;;3135   		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
;;;3136   		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
;;;3137   
;;;3138   		/* Determine the FAT sub type */
;;;3139   		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
;;;3140   		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
;;;3141   		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
;;;3142   		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;3143   		fmt = FS_FAT32;
;;;3144   		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
;;;3145   		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
;;;3146   
;;;3147   		/* Boundaries and Limits */
;;;3148   		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
;;;3149   		fs->volbase = bsect;							/* Volume start sector */
;;;3150   		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
;;;3151   		fs->database = bsect + sysect;					/* Data start sector */
;;;3152   		if (fmt == FS_FAT32) {
;;;3153   			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
;;;3154   			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
;;;3155   			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
;;;3156   			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
;;;3157   		} else {
;;;3158   			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
;;;3159   			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
;;;3160   			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
;;;3161   				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;3162   		}
;;;3163   		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
;;;3164   
;;;3165   #if !_FS_READONLY
;;;3166   		/* Get FSINFO if available */
;;;3167   		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
;;;3168   		fs->fsi_flag = 0x80;
;;;3169   #if (_FS_NOFSINFO & 3) != 3
;;;3170   		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
;;;3171   			&& ld_word(fs->win + BPB_FSInfo32) == 1
;;;3172   			&& move_window(fs, bsect + 1) == FR_OK)
;;;3173   		{
;;;3174   			fs->fsi_flag = 0;
;;;3175   			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;;;3176   				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
;;;3177   				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
;;;3178   			{
;;;3179   #if (_FS_NOFSINFO & 1) == 0
;;;3180   				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
;;;3181   #endif
;;;3182   #if (_FS_NOFSINFO & 2) == 0
;;;3183   				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
;;;3184   #endif
;;;3185   			}
;;;3186   		}
;;;3187   #endif	/* (_FS_NOFSINFO & 3) != 3 */
;;;3188   #endif	/* !_FS_READONLY */
;;;3189   	}
;;;3190   
;;;3191   	fs->fs_type = fmt;		/* FAT sub-type */
;;;3192   	fs->id = ++Fsid;		/* File system mount ID */
;;;3193   #if _USE_LFN == 1
;;;3194   	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
;;;3195   #if _FS_EXFAT
;;;3196   	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
;;;3197   #endif
;;;3198   #endif
;;;3199   #if _FS_RPATH != 0
;;;3200   	fs->cdir = 0;			/* Initialize current directory */
;;;3201   #endif
;;;3202   #if _FS_LOCK != 0			/* Clear file lock semaphores */
;;;3203   	clear_lock(fs);
;;;3204   #endif
;;;3205   	return FR_OK;
;;;3206   }
00001c  b00d              ADD      sp,sp,#0x34
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L27.34|
000022  49b3              LDR      r1,|L27.752|
000024  9808              LDR      r0,[sp,#0x20]         ;3014
000026  f8514020          LDR      r4,[r1,r0,LSL #2]     ;3014
00002a  b90c              CBNZ     r4,|L27.48|
00002c  200c              MOVS     r0,#0xc               ;3015
00002e  e7f5              B        |L27.28|
                  |L27.48|
000030  980b              LDR      r0,[sp,#0x2c]         ;3018
000032  6004              STR      r4,[r0,#0]            ;3018
000034  980c              LDR      r0,[sp,#0x30]         ;3020
000036  f00000fe          AND      r0,r0,#0xfe           ;3020
00003a  900c              STR      r0,[sp,#0x30]         ;3020
00003c  7820              LDRB     r0,[r4,#0]            ;3021
00003e  b178              CBZ      r0,|L27.96|
000040  7860              LDRB     r0,[r4,#1]            ;3022
000042  f7fffffe          BL       disk_status
000046  4681              MOV      r9,r0                 ;3022
000048  f0090001          AND      r0,r9,#1              ;3023
00004c  b940              CBNZ     r0,|L27.96|
00004e  980c              LDR      r0,[sp,#0x30]         ;3024
000050  b120              CBZ      r0,|L27.92|
000052  f0090004          AND      r0,r9,#4              ;3024
000056  b108              CBZ      r0,|L27.92|
000058  200a              MOVS     r0,#0xa               ;3025
00005a  e7df              B        |L27.28|
                  |L27.92|
00005c  2000              MOVS     r0,#0                 ;3027
00005e  e7dd              B        |L27.28|
                  |L27.96|
000060  2000              MOVS     r0,#0                 ;3034
000062  7020              STRB     r0,[r4,#0]            ;3034
000064  9808              LDR      r0,[sp,#0x20]         ;3035
000066  7060              STRB     r0,[r4,#1]            ;3035
000068  7860              LDRB     r0,[r4,#1]            ;3036
00006a  f7fffffe          BL       disk_initialize
00006e  4681              MOV      r9,r0                 ;3036
000070  f0090001          AND      r0,r9,#1              ;3037
000074  b108              CBZ      r0,|L27.122|
000076  2003              MOVS     r0,#3                 ;3038
000078  e7d0              B        |L27.28|
                  |L27.122|
00007a  980c              LDR      r0,[sp,#0x30]         ;3040
00007c  b120              CBZ      r0,|L27.136|
00007e  f0090004          AND      r0,r9,#4              ;3040
000082  b108              CBZ      r0,|L27.136|
000084  200a              MOVS     r0,#0xa               ;3041
000086  e7c9              B        |L27.28|
                  |L27.136|
000088  2700              MOVS     r7,#0                 ;3049
00008a  4639              MOV      r1,r7                 ;3050
00008c  4620              MOV      r0,r4                 ;3050
00008e  f7fffffe          BL       check_fs
000092  4605              MOV      r5,r0                 ;3050
000094  2d02              CMP      r5,#2                 ;3051
000096  d001              BEQ      |L27.156|
000098  da2e              BGE      |L27.248|
00009a  e02d              B        |L27.248|
                  |L27.156|
00009c  2600              MOVS     r6,#0                 ;3052
00009e  e014              B        |L27.202|
                  |L27.160|
0000a0  f44f70df          MOV      r0,#0x1be             ;3053
0000a4  eb001106          ADD      r1,r0,r6,LSL #4       ;3053
0000a8  f1040030          ADD      r0,r4,#0x30           ;3053
0000ac  4408              ADD      r0,r0,r1              ;3053
0000ae  9009              STR      r0,[sp,#0x24]         ;3053
0000b0  9809              LDR      r0,[sp,#0x24]         ;3054
0000b2  7900              LDRB     r0,[r0,#4]            ;3054
0000b4  b120              CBZ      r0,|L27.192|
0000b6  9809              LDR      r0,[sp,#0x24]         ;3054
0000b8  3008              ADDS     r0,r0,#8              ;3054
0000ba  f7fffffe          BL       ld_dword
0000be  e000              B        |L27.194|
                  |L27.192|
0000c0  2000              MOVS     r0,#0                 ;3054
                  |L27.194|
0000c2  a902              ADD      r1,sp,#8              ;3054
0000c4  f8410026          STR      r0,[r1,r6,LSL #2]     ;3054
0000c8  1c76              ADDS     r6,r6,#1              ;3052
                  |L27.202|
0000ca  2e04              CMP      r6,#4                 ;3052
0000cc  d3e8              BCC      |L27.160|
0000ce  2600              MOVS     r6,#0                 ;3056
0000d0  b106              CBZ      r6,|L27.212|
0000d2  1e76              SUBS     r6,r6,#1              ;3057
                  |L27.212|
0000d4  bf00              NOP                            ;3058
                  |L27.214|
0000d6  a802              ADD      r0,sp,#8              ;3059
0000d8  f8507026          LDR      r7,[r0,r6,LSL #2]     ;3059
0000dc  b127              CBZ      r7,|L27.232|
0000de  4639              MOV      r1,r7                 ;3060
0000e0  4620              MOV      r0,r4                 ;3060
0000e2  f7fffffe          BL       check_fs
0000e6  e000              B        |L27.234|
                  |L27.232|
0000e8  2003              MOVS     r0,#3                 ;3060
                  |L27.234|
0000ea  4605              MOV      r5,r0                 ;3060
0000ec  2d02              CMP      r5,#2                 ;3061
0000ee  db03              BLT      |L27.248|
0000f0  1c70              ADDS     r0,r6,#1              ;3061
0000f2  4606              MOV      r6,r0                 ;3061
0000f4  2804              CMP      r0,#4                 ;3061
0000f6  d3ee              BCC      |L27.214|
                  |L27.248|
0000f8  2d04              CMP      r5,#4                 ;3063
0000fa  d101              BNE      |L27.256|
0000fc  2001              MOVS     r0,#1                 ;3063
0000fe  e78d              B        |L27.28|
                  |L27.256|
000100  2d02              CMP      r5,#2                 ;3064
000102  db01              BLT      |L27.264|
000104  200d              MOVS     r0,#0xd               ;3064
000106  e789              B        |L27.28|
                  |L27.264|
000108  f104003b          ADD      r0,r4,#0x3b           ;3116
00010c  f7fffffe          BL       ld_word
000110  f5b07f00          CMP      r0,#0x200             ;3116
000114  d001              BEQ      |L27.282|
000116  200d              MOVS     r0,#0xd               ;3116
000118  e780              B        |L27.28|
                  |L27.282|
00011a  f1040046          ADD      r0,r4,#0x46           ;3118
00011e  f7fffffe          BL       ld_word
000122  4680              MOV      r8,r0                 ;3118
000124  f1b80f00          CMP      r8,#0                 ;3119
000128  d104              BNE      |L27.308|
00012a  f1040054          ADD      r0,r4,#0x54           ;3119
00012e  f7fffffe          BL       ld_dword
000132  4680              MOV      r8,r0                 ;3119
                  |L27.308|
000134  f8c48018          STR      r8,[r4,#0x18]         ;3120
000138  2040              MOVS     r0,#0x40              ;3122
00013a  5d00              LDRB     r0,[r0,r4]            ;3122
00013c  70a0              STRB     r0,[r4,#2]            ;3122
00013e  78a0              LDRB     r0,[r4,#2]            ;3123
000140  2801              CMP      r0,#1                 ;3123
000142  d004              BEQ      |L27.334|
000144  78a0              LDRB     r0,[r4,#2]            ;3123
000146  2802              CMP      r0,#2                 ;3123
000148  d001              BEQ      |L27.334|
00014a  200d              MOVS     r0,#0xd               ;3123
00014c  e766              B        |L27.28|
                  |L27.334|
00014e  78a0              LDRB     r0,[r4,#2]            ;3124
000150  fb08f800          MUL      r8,r8,r0              ;3124
000154  203d              MOVS     r0,#0x3d              ;3126
000156  5d00              LDRB     r0,[r0,r4]            ;3126
000158  8160              STRH     r0,[r4,#0xa]          ;3126
00015a  8960              LDRH     r0,[r4,#0xa]          ;3127
00015c  b118              CBZ      r0,|L27.358|
00015e  8960              LDRH     r0,[r4,#0xa]          ;3127
000160  1e41              SUBS     r1,r0,#1              ;3127
000162  4008              ANDS     r0,r0,r1              ;3127
000164  b108              CBZ      r0,|L27.362|
                  |L27.358|
000166  200d              MOVS     r0,#0xd               ;3127
000168  e758              B        |L27.28|
                  |L27.362|
00016a  f1040041          ADD      r0,r4,#0x41           ;3129
00016e  f7fffffe          BL       ld_word
000172  8120              STRH     r0,[r4,#8]            ;3129
000174  7a20              LDRB     r0,[r4,#8]            ;3130
000176  f000000f          AND      r0,r0,#0xf            ;3130
00017a  b108              CBZ      r0,|L27.384|
00017c  200d              MOVS     r0,#0xd               ;3130
00017e  e74d              B        |L27.28|
                  |L27.384|
000180  f1040043          ADD      r0,r4,#0x43           ;3132
000184  f7fffffe          BL       ld_word
000188  4682              MOV      r10,r0                ;3132
00018a  f1ba0f00          CMP      r10,#0                ;3133
00018e  d104              BNE      |L27.410|
000190  f1040050          ADD      r0,r4,#0x50           ;3133
000194  f7fffffe          BL       ld_dword
000198  4682              MOV      r10,r0                ;3133
                  |L27.410|
00019a  f104003e          ADD      r0,r4,#0x3e           ;3135
00019e  f7fffffe          BL       ld_word
0001a2  9001              STR      r0,[sp,#4]            ;3135
0001a4  9801              LDR      r0,[sp,#4]            ;3136
0001a6  b908              CBNZ     r0,|L27.428|
0001a8  200d              MOVS     r0,#0xd               ;3136
0001aa  e737              B        |L27.28|
                  |L27.428|
0001ac  9801              LDR      r0,[sp,#4]            ;3139
0001ae  4440              ADD      r0,r0,r8              ;3139
0001b0  8921              LDRH     r1,[r4,#8]            ;3139
0001b2  eb001011          ADD      r0,r0,r1,LSR #4       ;3139
0001b6  9007              STR      r0,[sp,#0x1c]         ;3139
0001b8  9807              LDR      r0,[sp,#0x1c]         ;3140
0001ba  4582              CMP      r10,r0                ;3140
0001bc  d201              BCS      |L27.450|
0001be  200d              MOVS     r0,#0xd               ;3140
0001c0  e72c              B        |L27.28|
                  |L27.450|
0001c2  9807              LDR      r0,[sp,#0x1c]         ;3141
0001c4  ebaa0000          SUB      r0,r10,r0             ;3141
0001c8  8961              LDRH     r1,[r4,#0xa]          ;3141
0001ca  fbb0fbf1          UDIV     r11,r0,r1             ;3141
0001ce  f1bb0f00          CMP      r11,#0                ;3142
0001d2  d101              BNE      |L27.472|
0001d4  200d              MOVS     r0,#0xd               ;3142
0001d6  e721              B        |L27.28|
                  |L27.472|
0001d8  2503              MOVS     r5,#3                 ;3143
0001da  f64f70f5          MOV      r0,#0xfff5            ;3144
0001de  4583              CMP      r11,r0                ;3144
0001e0  d800              BHI      |L27.484|
0001e2  2502              MOVS     r5,#2                 ;3144
                  |L27.484|
0001e4  f64070f5          MOV      r0,#0xff5             ;3145
0001e8  4583              CMP      r11,r0                ;3145
0001ea  d800              BHI      |L27.494|
0001ec  2501              MOVS     r5,#1                 ;3145
                  |L27.494|
0001ee  f10b0002          ADD      r0,r11,#2             ;3148
0001f2  6160              STR      r0,[r4,#0x14]         ;3148
0001f4  61e7              STR      r7,[r4,#0x1c]         ;3149
0001f6  9801              LDR      r0,[sp,#4]            ;3150
0001f8  4438              ADD      r0,r0,r7              ;3150
0001fa  6220              STR      r0,[r4,#0x20]         ;3150
0001fc  9807              LDR      r0,[sp,#0x1c]         ;3151
0001fe  4438              ADD      r0,r0,r7              ;3151
000200  62a0              STR      r0,[r4,#0x28]         ;3151
000202  2d03              CMP      r5,#3                 ;3152
000204  d113              BNE      |L27.558|
000206  f104005a          ADD      r0,r4,#0x5a           ;3153
00020a  f7fffffe          BL       ld_word
00020e  b108              CBZ      r0,|L27.532|
000210  200d              MOVS     r0,#0xd               ;3153
000212  e703              B        |L27.28|
                  |L27.532|
000214  8920              LDRH     r0,[r4,#8]            ;3154
000216  b108              CBZ      r0,|L27.540|
000218  200d              MOVS     r0,#0xd               ;3154
00021a  e6ff              B        |L27.28|
                  |L27.540|
00021c  f104005c          ADD      r0,r4,#0x5c           ;3155
000220  f7fffffe          BL       ld_dword
000224  6260              STR      r0,[r4,#0x24]         ;3155
000226  6960              LDR      r0,[r4,#0x14]         ;3156
000228  0080              LSLS     r0,r0,#2              ;3156
00022a  9006              STR      r0,[sp,#0x18]         ;3156
00022c  e014              B        |L27.600|
                  |L27.558|
00022e  8920              LDRH     r0,[r4,#8]            ;3158
000230  b908              CBNZ     r0,|L27.566|
000232  200d              MOVS     r0,#0xd               ;3158
000234  e6f2              B        |L27.28|
                  |L27.566|
000236  6a20              LDR      r0,[r4,#0x20]         ;3159
000238  4440              ADD      r0,r0,r8              ;3159
00023a  6260              STR      r0,[r4,#0x24]         ;3159
00023c  2d02              CMP      r5,#2                 ;3160
00023e  d102              BNE      |L27.582|
000240  6960              LDR      r0,[r4,#0x14]         ;3161
000242  0040              LSLS     r0,r0,#1              ;3161
000244  e007              B        |L27.598|
                  |L27.582|
000246  7d20              LDRB     r0,[r4,#0x14]         ;3161
000248  f0000001          AND      r0,r0,#1              ;3161
00024c  6961              LDR      r1,[r4,#0x14]         ;3161
00024e  eb010141          ADD      r1,r1,r1,LSL #1       ;3161
000252  eb000051          ADD      r0,r0,r1,LSR #1       ;3161
                  |L27.598|
000256  9006              STR      r0,[sp,#0x18]         ;3161
                  |L27.600|
000258  69a1              LDR      r1,[r4,#0x18]         ;3163
00025a  9806              LDR      r0,[sp,#0x18]         ;3163
00025c  f20010ff          ADD      r0,r0,#0x1ff          ;3163
000260  ebb12f50          CMP      r1,r0,LSR #9          ;3163
000264  d201              BCS      |L27.618|
000266  200d              MOVS     r0,#0xd               ;3163
000268  e6d8              B        |L27.28|
                  |L27.618|
00026a  f04f30ff          MOV      r0,#0xffffffff        ;3167
00026e  6120              STR      r0,[r4,#0x10]         ;3167
000270  60e0              STR      r0,[r4,#0xc]          ;3167
000272  2080              MOVS     r0,#0x80              ;3168
000274  7120              STRB     r0,[r4,#4]            ;3168
000276  2d03              CMP      r5,#3                 ;3170
000278  d12c              BNE      |L27.724|
00027a  f1040060          ADD      r0,r4,#0x60           ;3171
00027e  f7fffffe          BL       ld_word
000282  2801              CMP      r0,#1                 ;3171
000284  d126              BNE      |L27.724|
000286  1c79              ADDS     r1,r7,#1              ;3172
000288  4620              MOV      r0,r4                 ;3172
00028a  f7fffffe          BL       move_window
00028e  bb08              CBNZ     r0,|L27.724|
000290  2000              MOVS     r0,#0                 ;3174
000292  7120              STRB     r0,[r4,#4]            ;3174
000294  f204202e          ADD      r0,r4,#0x22e          ;3175
000298  f7fffffe          BL       ld_word
00029c  f64a2155          MOV      r1,#0xaa55            ;3175
0002a0  4288              CMP      r0,r1                 ;3175
0002a2  d117              BNE      |L27.724|
0002a4  f1040030          ADD      r0,r4,#0x30           ;3176
0002a8  f7fffffe          BL       ld_dword
0002ac  4911              LDR      r1,|L27.756|
0002ae  4288              CMP      r0,r1                 ;3176
0002b0  d110              BNE      |L27.724|
0002b2  f5047005          ADD      r0,r4,#0x214          ;3177
0002b6  f7fffffe          BL       ld_dword
0002ba  490f              LDR      r1,|L27.760|
0002bc  4288              CMP      r0,r1                 ;3177
0002be  d109              BNE      |L27.724|
0002c0  f5047006          ADD      r0,r4,#0x218          ;3180
0002c4  f7fffffe          BL       ld_dword
0002c8  6120              STR      r0,[r4,#0x10]         ;3180
0002ca  f5047007          ADD      r0,r4,#0x21c          ;3183
0002ce  f7fffffe          BL       ld_dword
0002d2  60e0              STR      r0,[r4,#0xc]          ;3183
                  |L27.724|
0002d4  7025              STRB     r5,[r4,#0]            ;3191
0002d6  4809              LDR      r0,|L27.764|
0002d8  8800              LDRH     r0,[r0,#0]            ;3192  ; Fsid
0002da  1c40              ADDS     r0,r0,#1              ;3192
0002dc  b280              UXTH     r0,r0                 ;3192
0002de  4907              LDR      r1,|L27.764|
0002e0  8008              STRH     r0,[r1,#0]            ;3192
0002e2  80e0              STRH     r0,[r4,#6]            ;3192
0002e4  4620              MOV      r0,r4                 ;3203
0002e6  f7fffffe          BL       clear_lock
0002ea  2000              MOVS     r0,#0                 ;3205
0002ec  e696              B        |L27.28|
;;;3207   
                          ENDP

0002ee  0000              DCW      0x0000
                  |L27.752|
                          DCD      FatFs
                  |L27.756|
                          DCD      0x41615252
                  |L27.760|
                          DCD      0x61417272
                  |L27.764|
                          DCD      Fsid

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;2812   static
;;;2813   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;2814   	DIR* dp,			/* Directory object to return last directory and found object */
;;;2815   	const TCHAR* path	/* Full-path string to find a file or directory */
;;;2816   )
;;;2817   {
000004  4604              MOV      r4,r0
;;;2818   	FRESULT res;
;;;2819   	BYTE ns;
;;;2820   	_FDID *obj = &dp->obj;
000006  4626              MOV      r6,r4
;;;2821   	FATFS *fs = obj->fs;
000008  f8d68000          LDR      r8,[r6,#0]
;;;2822   
;;;2823   
;;;2824   #if _FS_RPATH != 0
;;;2825   	if (*path != '/' && *path != '\\') {	/* Without heading separator */
;;;2826   		obj->sclust = fs->cdir;				/* Start from current directory */
;;;2827   	} else
;;;2828   #endif
;;;2829   	{										/* With heading separator */
;;;2830   		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
00000c  e002              B        |L28.20|
                  |L28.14|
00000e  9801              LDR      r0,[sp,#4]
000010  1c40              ADDS     r0,r0,#1
000012  9001              STR      r0,[sp,#4]
                  |L28.20|
000014  9801              LDR      r0,[sp,#4]
000016  7800              LDRB     r0,[r0,#0]
000018  282f              CMP      r0,#0x2f
00001a  d0f8              BEQ      |L28.14|
00001c  9801              LDR      r0,[sp,#4]
00001e  7800              LDRB     r0,[r0,#0]
000020  285c              CMP      r0,#0x5c
000022  d0f4              BEQ      |L28.14|
;;;2831   		obj->sclust = 0;					/* Start from root directory */
000024  2000              MOVS     r0,#0
000026  60b0              STR      r0,[r6,#8]
;;;2832   	}
;;;2833   #if _FS_EXFAT
;;;2834   	obj->n_frag = 0;	/* Invalidate last fragment counter of the object */
;;;2835   #if _FS_RPATH != 0
;;;2836   	if (fs->fs_type == FS_EXFAT && obj->sclust) {	/* Retrieve the sub-directory status if needed */
;;;2837   		DIR dj;
;;;2838   
;;;2839   		obj->c_scl = fs->cdc_scl;
;;;2840   		obj->c_size = fs->cdc_size;
;;;2841   		obj->c_ofs = fs->cdc_ofs;
;;;2842   		res = load_obj_dir(&dj, obj);
;;;2843   		if (res != FR_OK) return res;
;;;2844   		obj->objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
;;;2845   		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;2846   	}
;;;2847   #endif
;;;2848   #endif
;;;2849   
;;;2850   	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
000028  9801              LDR      r0,[sp,#4]
00002a  7800              LDRB     r0,[r0,#0]
00002c  2820              CMP      r0,#0x20
00002e  d208              BCS      |L28.66|
;;;2851   		dp->fn[NSFLAG] = NS_NONAME;
000030  2180              MOVS     r1,#0x80
000032  202f              MOVS     r0,#0x2f
000034  5501              STRB     r1,[r0,r4]
;;;2852   		res = dir_sdi(dp, 0);
000036  2100              MOVS     r1,#0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       dir_sdi
00003e  4605              MOV      r5,r0
000040  e02c              B        |L28.156|
                  |L28.66|
;;;2853   
;;;2854   	} else {								/* Follow path */
;;;2855   		for (;;) {
000042  bf00              NOP      
                  |L28.68|
;;;2856   			res = create_name(dp, &path);	/* Get a segment name of the path */
000044  a901              ADD      r1,sp,#4
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       create_name
00004c  4605              MOV      r5,r0
;;;2857   			if (res != FR_OK) break;
00004e  b105              CBZ      r5,|L28.82|
000050  e023              B        |L28.154|
                  |L28.82|
;;;2858   			res = dir_find(dp);				/* Find an object with the segment name */
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       dir_find
000058  4605              MOV      r5,r0
;;;2859   			ns = dp->fn[NSFLAG];
00005a  202f              MOVS     r0,#0x2f
00005c  5d07              LDRB     r7,[r0,r4]
;;;2860   			if (res != FR_OK) {				/* Failed to find the object */
00005e  b13d              CBZ      r5,|L28.112|
;;;2861   				if (res == FR_NO_FILE) {	/* Object is not found */
000060  2d04              CMP      r5,#4
000062  d104              BNE      |L28.110|
;;;2862   					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
000064  bf00              NOP      
;;;2863   						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;;;2864   						dp->fn[NSFLAG] = NS_NONAME;
;;;2865   						res = FR_OK;
;;;2866   					} else {							/* Could not find the object */
;;;2867   						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
000066  f0070004          AND      r0,r7,#4
00006a  b900              CBNZ     r0,|L28.110|
00006c  2505              MOVS     r5,#5
                  |L28.110|
;;;2868   					}
;;;2869   				}
;;;2870   				break;
00006e  e014              B        |L28.154|
                  |L28.112|
;;;2871   			}
;;;2872   			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
000070  f0070004          AND      r0,r7,#4
000074  b100              CBZ      r0,|L28.120|
000076  e010              B        |L28.154|
                  |L28.120|
;;;2873   			/* Get into the sub-directory */
;;;2874   			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
000078  79b0              LDRB     r0,[r6,#6]
00007a  f0000010          AND      r0,r0,#0x10
00007e  b908              CBNZ     r0,|L28.132|
;;;2875   				res = FR_NO_PATH; break;
000080  2505              MOVS     r5,#5
000082  e00a              B        |L28.154|
                  |L28.132|
;;;2876   			}
;;;2877   #if _FS_EXFAT
;;;2878   			if (fs->fs_type == FS_EXFAT) {		/* Save containing directory information for next dir */
;;;2879   				obj->c_scl = obj->sclust;
;;;2880   				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
;;;2881   				obj->c_ofs = dp->blk_ofs;
;;;2882   				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
;;;2883   				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;2884   				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;2885   			} else
;;;2886   #endif
;;;2887   			{
;;;2888   				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
000084  8aa0              LDRH     r0,[r4,#0x14]
000086  f3c00208          UBFX     r2,r0,#0,#9
00008a  f1080030          ADD      r0,r8,#0x30
00008e  1811              ADDS     r1,r2,r0
000090  4640              MOV      r0,r8
000092  f7fffffe          BL       ld_clust
000096  60b0              STR      r0,[r6,#8]
000098  e7d4              B        |L28.68|
                  |L28.154|
00009a  bf00              NOP                            ;2857
                  |L28.156|
;;;2889   			}
;;;2890   		}
;;;2891   	}
;;;2892   
;;;2893   	return res;
00009c  4628              MOV      r0,r5
;;;2894   }
00009e  e8bd81fc          POP      {r2-r8,pc}
;;;2895   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;1000   static
;;;1001   DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1002   	_FDID* obj,	/* Corresponding object */
;;;1003   	DWORD clst	/* Cluster number to get the value */
;;;1004   )
;;;1005   {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;1006   	UINT wc, bc;
;;;1007   	DWORD val;
;;;1008   	FATFS *fs = obj->fs;
000008  f8d95000          LDR      r5,[r9,#0]
;;;1009   
;;;1010   
;;;1011   	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
00000c  2c02              CMP      r4,#2
00000e  d302              BCC      |L29.22|
000010  6968              LDR      r0,[r5,#0x14]
000012  42a0              CMP      r0,r4
000014  d802              BHI      |L29.28|
                  |L29.22|
;;;1012   		val = 1;	/* Internal error */
000016  f04f0801          MOV      r8,#1
00001a  e05e              B        |L29.218|
                  |L29.28|
;;;1013   
;;;1014   	} else {
;;;1015   		val = 0xFFFFFFFF;	/* Default value falls on disk error */
00001c  f04f38ff          MOV      r8,#0xffffffff
;;;1016   
;;;1017   		switch (fs->fs_type) {
000020  7828              LDRB     r0,[r5,#0]
000022  2801              CMP      r0,#1
000024  d004              BEQ      |L29.48|
000026  2802              CMP      r0,#2
000028  d02c              BEQ      |L29.132|
00002a  2803              CMP      r0,#3
00002c  d151              BNE      |L29.210|
00002e  e03c              B        |L29.170|
                  |L29.48|
;;;1018   		case FS_FAT12 :
;;;1019   			bc = (UINT)clst; bc += bc / 2;
000030  4626              MOV      r6,r4
000032  eb060656          ADD      r6,r6,r6,LSR #1
;;;1020   			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
000036  6a28              LDR      r0,[r5,#0x20]
000038  eb002156          ADD      r1,r0,r6,LSR #9
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       move_window
000042  b100              CBZ      r0,|L29.70|
000044  e048              B        |L29.216|
                  |L29.70|
;;;1021   			wc = fs->win[bc++ % SS(fs)];
000046  4630              MOV      r0,r6
000048  1c76              ADDS     r6,r6,#1
00004a  f3c00108          UBFX     r1,r0,#0,#9
00004e  f1050030          ADD      r0,r5,#0x30
000052  5c47              LDRB     r7,[r0,r1]
;;;1022   			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
000054  6a28              LDR      r0,[r5,#0x20]
000056  eb002156          ADD      r1,r0,r6,LSR #9
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       move_window
000060  b100              CBZ      r0,|L29.100|
000062  e039              B        |L29.216|
                  |L29.100|
;;;1023   			wc |= fs->win[bc % SS(fs)] << 8;
000064  f3c60108          UBFX     r1,r6,#0,#9
000068  f1050030          ADD      r0,r5,#0x30
00006c  5c40              LDRB     r0,[r0,r1]
00006e  ea472700          ORR      r7,r7,r0,LSL #8
;;;1024   			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
000072  f0040001          AND      r0,r4,#1
000076  b108              CBZ      r0,|L29.124|
000078  0938              LSRS     r0,r7,#4
00007a  e001              B        |L29.128|
                  |L29.124|
00007c  f3c7000b          UBFX     r0,r7,#0,#12
                  |L29.128|
000080  4680              MOV      r8,r0
;;;1025   			break;
000082  e029              B        |L29.216|
                  |L29.132|
;;;1026   
;;;1027   		case FS_FAT16 :
;;;1028   			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
000084  6a28              LDR      r0,[r5,#0x20]
000086  eb002114          ADD      r1,r0,r4,LSR #8
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       move_window
000090  b100              CBZ      r0,|L29.148|
000092  e021              B        |L29.216|
                  |L29.148|
;;;1029   			val = ld_word(fs->win + clst * 2 % SS(fs));
000094  f24011ff          MOV      r1,#0x1ff
000098  ea010244          AND      r2,r1,r4,LSL #1
00009c  f1050130          ADD      r1,r5,#0x30
0000a0  1850              ADDS     r0,r2,r1
0000a2  f7fffffe          BL       ld_word
0000a6  4680              MOV      r8,r0
;;;1030   			break;
0000a8  e016              B        |L29.216|
                  |L29.170|
;;;1031   
;;;1032   		case FS_FAT32 :
;;;1033   			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
0000aa  6a28              LDR      r0,[r5,#0x20]
0000ac  eb0011d4          ADD      r1,r0,r4,LSR #7
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       move_window
0000b6  b100              CBZ      r0,|L29.186|
0000b8  e00e              B        |L29.216|
                  |L29.186|
;;;1034   			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
0000ba  f24011ff          MOV      r1,#0x1ff
0000be  ea010284          AND      r2,r1,r4,LSL #2
0000c2  f1050130          ADD      r1,r5,#0x30
0000c6  1850              ADDS     r0,r2,r1
0000c8  f7fffffe          BL       ld_dword
0000cc  f0204870          BIC      r8,r0,#0xf0000000
;;;1035   			break;
0000d0  e002              B        |L29.216|
                  |L29.210|
;;;1036   #if _FS_EXFAT
;;;1037   		case FS_EXFAT :
;;;1038   			if (obj->objsize) {
;;;1039   				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
;;;1040   				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
;;;1041   
;;;1042   				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
;;;1043   					if (cofs <= clen) {
;;;1044   						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
;;;1045   						break;
;;;1046   					}
;;;1047   				}
;;;1048   				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
;;;1049   					val = clst + 1; 	/* Generate the value */
;;;1050   					break;
;;;1051   				}
;;;1052   				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
;;;1053   					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
;;;1054   						val = 0x7FFFFFFF;	/* Generate EOC */
;;;1055   					} else {
;;;1056   						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
;;;1057   						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
;;;1058   					}
;;;1059   					break;
;;;1060   				}
;;;1061   			}
;;;1062   			/* go to default */
;;;1063   #endif
;;;1064   		default:
;;;1065   			val = 1;	/* Internal error */
0000d2  f04f0801          MOV      r8,#1
0000d6  bf00              NOP                            ;1017
                  |L29.216|
0000d8  bf00              NOP                            ;1020
                  |L29.218|
;;;1066   		}
;;;1067   	}
;;;1068   
;;;1069   	return val;
0000da  4640              MOV      r0,r8
;;;1070   }
0000dc  e8bd87f0          POP      {r4-r10,pc}
;;;1071   
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;2443   static
;;;2444   void get_fileinfo (		/* No return code */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2445   	DIR* dp,			/* Pointer to the directory object */
;;;2446   	FILINFO* fno	 	/* Pointer to the file information to be filled */
;;;2447   )
;;;2448   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;2449   	UINT i, j;
;;;2450   	TCHAR c;
;;;2451   	DWORD tm;
;;;2452   #if _USE_LFN != 0
;;;2453   	WCHAR w, lfv;
;;;2454   	FATFS *fs = dp->obj.fs;
;;;2455   #endif
;;;2456   
;;;2457   
;;;2458   	fno->fname[0] = 0;		/* Invaidate file info */
000008  2000              MOVS     r0,#0
00000a  7260              STRB     r0,[r4,#9]
;;;2459   	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
00000c  69e8              LDR      r0,[r5,#0x1c]
00000e  b908              CBNZ     r0,|L30.20|
                  |L30.16|
;;;2460   
;;;2461   #if _USE_LFN != 0	/* LFN configuration */
;;;2462   #if _FS_EXFAT
;;;2463   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2464   		get_xdir_info(fs->dirbuf, fno);
;;;2465   		return;
;;;2466   	} else
;;;2467   #endif
;;;2468   	{	/* On the FAT12/16/32 volume */
;;;2469   		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
;;;2470   			i = j = 0;
;;;2471   			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
;;;2472   #if !_LFN_UNICODE
;;;2473   				w = ff_convert(w, 0);		/* Unicode -> OEM */
;;;2474   				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
;;;2475   				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
;;;2476   					fno->fname[i++] = (char)(w >> 8);
;;;2477   				}
;;;2478   #endif
;;;2479   				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
;;;2480   				fno->fname[i++] = (TCHAR)w;
;;;2481   			}
;;;2482   			fno->fname[i] = 0;	/* Terminate the LFN */
;;;2483   		}
;;;2484   	}
;;;2485   
;;;2486   	i = j = 0;
;;;2487   	lfv = fno->fname[i];	/* LFN is exist if non-zero */
;;;2488   	while (i < 11) {		/* Copy name body and extension */
;;;2489   		c = (TCHAR)dp->dir[i++];
;;;2490   		if (c == ' ') continue;				/* Skip padding spaces */
;;;2491   		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
;;;2492   		if (i == 9) {						/* Insert a . if extension is exist */
;;;2493   			if (!lfv) fno->fname[j] = '.';
;;;2494   			fno->altname[j++] = '.';
;;;2495   		}
;;;2496   #if _LFN_UNICODE
;;;2497   		if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dp->dir[i])) {
;;;2498   			c = c << 8 | dp->dir[i++];
;;;2499   		}
;;;2500   		c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;2501   		if (!c) c = '?';
;;;2502   #endif
;;;2503   		fno->altname[j] = c;
;;;2504   		if (!lfv) {
;;;2505   			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
;;;2506   				c += 0x20;			/* To lower */
;;;2507   			}
;;;2508   			fno->fname[j] = c;
;;;2509   		}
;;;2510   		j++;
;;;2511   	}
;;;2512   	if (!lfv) {
;;;2513   		fno->fname[j] = 0;
;;;2514   		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
;;;2515   	}
;;;2516   	fno->altname[j] = 0;	/* Terminate the SFN */
;;;2517   
;;;2518   #else	/* Non-LFN configuration */
;;;2519   	i = j = 0;
;;;2520   	while (i < 11) {		/* Copy name body and extension */
;;;2521   		c = (TCHAR)dp->dir[i++];
;;;2522   		if (c == ' ') continue;				/* Skip padding spaces */
;;;2523   		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
;;;2524   		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
;;;2525   		fno->fname[j++] = c;
;;;2526   	}
;;;2527   	fno->fname[j] = 0;
;;;2528   #endif
;;;2529   
;;;2530   	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
;;;2531   	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
;;;2532   	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
;;;2533   	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
;;;2534   }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L30.20|
000014  2600              MOVS     r6,#0                 ;2519
000016  4637              MOV      r7,r6                 ;2519
000018  e01c              B        |L30.84|
                  |L30.26|
00001a  4630              MOV      r0,r6                 ;2521
00001c  1c76              ADDS     r6,r6,#1              ;2521
00001e  6a2a              LDR      r2,[r5,#0x20]         ;2521
000020  f8129000          LDRB     r9,[r2,r0]            ;2521
000024  f1b90f20          CMP      r9,#0x20              ;2522
000028  d100              BNE      |L30.44|
00002a  e013              B        |L30.84|
                  |L30.44|
00002c  f1b90f05          CMP      r9,#5                 ;2523
000030  d101              BNE      |L30.54|
000032  f04f09e5          MOV      r9,#0xe5              ;2523
                  |L30.54|
000036  2e09              CMP      r6,#9                 ;2524
000038  d105              BNE      |L30.70|
00003a  222e              MOVS     r2,#0x2e              ;2524
00003c  4638              MOV      r0,r7                 ;2524
00003e  1c7f              ADDS     r7,r7,#1              ;2524
000040  f1040109          ADD      r1,r4,#9              ;2524
000044  540a              STRB     r2,[r1,r0]            ;2524
                  |L30.70|
000046  4638              MOV      r0,r7                 ;2525
000048  1c7f              ADDS     r7,r7,#1              ;2525
00004a  f1040109          ADD      r1,r4,#9              ;2525
00004e  f8019000          STRB     r9,[r1,r0]            ;2525
000052  bf00              NOP                            ;2522
                  |L30.84|
000054  2e0b              CMP      r6,#0xb               ;2520
000056  d3e0              BCC      |L30.26|
000058  2100              MOVS     r1,#0                 ;2527
00005a  f1040009          ADD      r0,r4,#9              ;2527
00005e  55c1              STRB     r1,[r0,r7]            ;2527
000060  6a28              LDR      r0,[r5,#0x20]         ;2530
000062  7ac0              LDRB     r0,[r0,#0xb]          ;2530
000064  7220              STRB     r0,[r4,#8]            ;2530
000066  6a29              LDR      r1,[r5,#0x20]         ;2531
000068  f101001c          ADD      r0,r1,#0x1c           ;2531
00006c  f7fffffe          BL       ld_dword
000070  6020              STR      r0,[r4,#0]            ;2531
000072  6a29              LDR      r1,[r5,#0x20]         ;2532
000074  f1010016          ADD      r0,r1,#0x16           ;2532
000078  f7fffffe          BL       ld_dword
00007c  4680              MOV      r8,r0                 ;2532
00007e  f8a48006          STRH     r8,[r4,#6]            ;2533
000082  ea4f4018          LSR      r0,r8,#16             ;2533
000086  80a0              STRH     r0,[r4,#4]            ;2533
000088  bf00              NOP      
00008a  e7c1              B        |L30.16|
;;;2535   
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=1

                  get_ldnumber PROC
;;;2903   static
;;;2904   int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
000000  b570              PUSH     {r4-r6,lr}
;;;2905   	const TCHAR** path	/* Pointer to pointer to the path name */
;;;2906   )
;;;2907   {
000002  4602              MOV      r2,r0
;;;2908   	const TCHAR *tp, *tt;
;;;2909   	UINT i;
;;;2910   	int vol = -1;
000004  f04f30ff          MOV      r0,#0xffffffff
;;;2911   #if _STR_VOLUME_ID		/* Find string drive id */
;;;2912   	static const char* const volid[] = {_VOLUME_STRS};
;;;2913   	const char *sp;
;;;2914   	char c;
;;;2915   	TCHAR tc;
;;;2916   #endif
;;;2917   
;;;2918   
;;;2919   	if (*path) {	/* If the pointer is not a null */
000008  6815              LDR      r5,[r2,#0]
00000a  b1dd              CBZ      r5,|L31.68|
;;;2920   		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
00000c  6811              LDR      r1,[r2,#0]
00000e  e000              B        |L31.18|
                  |L31.16|
000010  1c49              ADDS     r1,r1,#1
                  |L31.18|
000012  780d              LDRB     r5,[r1,#0]
000014  2d21              CMP      r5,#0x21
000016  d302              BCC      |L31.30|
000018  780d              LDRB     r5,[r1,#0]
00001a  2d3a              CMP      r5,#0x3a
00001c  d1f8              BNE      |L31.16|
                  |L31.30|
;;;2921   		if (*tt == ':') {	/* If a ':' is exist in the path name */
00001e  780d              LDRB     r5,[r1,#0]
000020  2d3a              CMP      r5,#0x3a
000022  d10e              BNE      |L31.66|
;;;2922   			tp = *path;
000024  6814              LDR      r4,[r2,#0]
;;;2923   			i = *tp++ - '0';
000026  f8145b01          LDRB     r5,[r4],#1
00002a  f1a50330          SUB      r3,r5,#0x30
;;;2924   			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
00002e  2b0a              CMP      r3,#0xa
000030  d206              BCS      |L31.64|
000032  428c              CMP      r4,r1
000034  d104              BNE      |L31.64|
;;;2925   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
000036  b91b              CBNZ     r3,|L31.64|
;;;2926   					vol = (int)i;
000038  4618              MOV      r0,r3
;;;2927   					*path = ++tt;
00003a  1c4d              ADDS     r5,r1,#1
00003c  4629              MOV      r1,r5
00003e  6015              STR      r5,[r2,#0]
                  |L31.64|
;;;2928   				}
;;;2929   			}
;;;2930   #if _STR_VOLUME_ID
;;;2931   			 else {	/* No numeric drive number, find string drive id */
;;;2932   				i = 0; tt++;
;;;2933   				do {
;;;2934   					sp = volid[i]; tp = *path;
;;;2935   					do {	/* Compare a string drive id with path name */
;;;2936   						c = *sp++; tc = *tp++;
;;;2937   						if (IsLower(tc)) tc -= 0x20;
;;;2938   					} while (c && (TCHAR)c == tc);
;;;2939   				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
;;;2940   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2941   					vol = (int)i;
;;;2942   					*path = tt;
;;;2943   				}
;;;2944   			}
;;;2945   #endif
;;;2946   			return vol;
;;;2947   		}
;;;2948   #if _FS_RPATH != 0 && _VOLUMES >= 2
;;;2949   		vol = CurrVol;	/* Current drive */
;;;2950   #else
;;;2951   		vol = 0;		/* Drive 0 */
;;;2952   #endif
;;;2953   	}
;;;2954   	return vol;
;;;2955   }
000040  bd70              POP      {r4-r6,pc}
                  |L31.66|
000042  2000              MOVS     r0,#0                 ;2951
                  |L31.68|
000044  bf00              NOP                            ;2954
000046  e7fb              B        |L31.64|
;;;2956   
                          ENDP


                          AREA ||i.inc_lock||, CODE, READONLY, ALIGN=2

                  inc_lock PROC
;;;807    static
;;;808    UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
000000  b510              PUSH     {r4,lr}
;;;809    	DIR* dp,	/* Directory object pointing the file to register or increment */
;;;810    	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;;;811    )
;;;812    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;813    	UINT i;
;;;814    
;;;815    
;;;816    	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
000006  2100              MOVS     r1,#0
000008  e016              B        |L32.56|
                  |L32.10|
;;;817    		if (Files[i].fs == dp->obj.fs &&
00000a  482b              LDR      r0,|L32.184|
00000c  eb001001          ADD      r0,r0,r1,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  6814              LDR      r4,[r2,#0]
000014  42a0              CMP      r0,r4
000016  d10e              BNE      |L32.54|
;;;818    			Files[i].clu == dp->obj.sclust &&
000018  4827              LDR      r0,|L32.184|
00001a  eb001001          ADD      r0,r0,r1,LSL #4
00001e  6840              LDR      r0,[r0,#4]
000020  6894              LDR      r4,[r2,#8]
000022  42a0              CMP      r0,r4
000024  d107              BNE      |L32.54|
;;;819    			Files[i].ofs == dp->dptr) break;
000026  4824              LDR      r0,|L32.184|
000028  eb001001          ADD      r0,r0,r1,LSL #4
00002c  6880              LDR      r0,[r0,#8]
00002e  6954              LDR      r4,[r2,#0x14]
000030  42a0              CMP      r0,r4
000032  d100              BNE      |L32.54|
000034  e002              B        |L32.60|
                  |L32.54|
000036  1c49              ADDS     r1,r1,#1              ;816
                  |L32.56|
000038  290a              CMP      r1,#0xa               ;816
00003a  d3e6              BCC      |L32.10|
                  |L32.60|
00003c  bf00              NOP      
;;;820    	}
;;;821    
;;;822    	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
00003e  290a              CMP      r1,#0xa
000040  d122              BNE      |L32.136|
;;;823    		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
000042  2100              MOVS     r1,#0
000044  e000              B        |L32.72|
                  |L32.70|
000046  1c49              ADDS     r1,r1,#1
                  |L32.72|
000048  290a              CMP      r1,#0xa
00004a  d205              BCS      |L32.88|
00004c  481a              LDR      r0,|L32.184|
00004e  eb001001          ADD      r0,r0,r1,LSL #4
000052  6800              LDR      r0,[r0,#0]
000054  2800              CMP      r0,#0
000056  d1f6              BNE      |L32.70|
                  |L32.88|
;;;824    		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
000058  290a              CMP      r1,#0xa
00005a  d101              BNE      |L32.96|
00005c  2000              MOVS     r0,#0
                  |L32.94|
;;;825    		Files[i].fs = dp->obj.fs;
;;;826    		Files[i].clu = dp->obj.sclust;
;;;827    		Files[i].ofs = dp->dptr;
;;;828    		Files[i].ctr = 0;
;;;829    	}
;;;830    
;;;831    	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
;;;832    
;;;833    	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
;;;834    
;;;835    	return i + 1;
;;;836    }
00005e  bd10              POP      {r4,pc}
                  |L32.96|
000060  4c15              LDR      r4,|L32.184|
000062  eb041401          ADD      r4,r4,r1,LSL #4       ;825
000066  6810              LDR      r0,[r2,#0]            ;825
000068  6020              STR      r0,[r4,#0]            ;825
00006a  4c13              LDR      r4,|L32.184|
00006c  eb041401          ADD      r4,r4,r1,LSL #4       ;826
000070  6890              LDR      r0,[r2,#8]            ;826
000072  6060              STR      r0,[r4,#4]            ;826
000074  4c10              LDR      r4,|L32.184|
000076  eb041401          ADD      r4,r4,r1,LSL #4       ;827
00007a  6950              LDR      r0,[r2,#0x14]         ;827
00007c  60a0              STR      r0,[r4,#8]            ;827
00007e  2000              MOVS     r0,#0                 ;828
000080  4c0d              LDR      r4,|L32.184|
000082  eb041401          ADD      r4,r4,r1,LSL #4       ;828
000086  81a0              STRH     r0,[r4,#0xc]          ;828
                  |L32.136|
000088  b133              CBZ      r3,|L32.152|
00008a  480b              LDR      r0,|L32.184|
00008c  eb001001          ADD      r0,r0,r1,LSL #4       ;831
000090  8980              LDRH     r0,[r0,#0xc]          ;831
000092  b108              CBZ      r0,|L32.152|
000094  2000              MOVS     r0,#0                 ;831
000096  e7e2              B        |L32.94|
                  |L32.152|
000098  b113              CBZ      r3,|L32.160|
00009a  f44f7080          MOV      r0,#0x100             ;833
00009e  e004              B        |L32.170|
                  |L32.160|
0000a0  4805              LDR      r0,|L32.184|
0000a2  eb001001          ADD      r0,r0,r1,LSL #4       ;833
0000a6  8980              LDRH     r0,[r0,#0xc]          ;833
0000a8  1c40              ADDS     r0,r0,#1              ;833
                  |L32.170|
0000aa  4c03              LDR      r4,|L32.184|
0000ac  eb041401          ADD      r4,r4,r1,LSL #4       ;833
0000b0  81a0              STRH     r0,[r4,#0xc]          ;833
0000b2  1c48              ADDS     r0,r1,#1              ;835
0000b4  e7d3              B        |L32.94|
;;;837    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L32.184|
                          DCD      Files

                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1631   static
;;;1632   DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
000000  b570              PUSH     {r4-r6,lr}
;;;1633   	FATFS* fs,		/* Pointer to the fs object */
;;;1634   	const BYTE* dir	/* Pointer to the key entry */
;;;1635   )
;;;1636   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1637   	DWORD cl;
;;;1638   
;;;1639   	cl = ld_word(dir + DIR_FstClusLO);
000006  f104001a          ADD      r0,r4,#0x1a
00000a  f7fffffe          BL       ld_word
00000e  4606              MOV      r6,r0
;;;1640   	if (fs->fs_type == FS_FAT32) {
000010  7828              LDRB     r0,[r5,#0]
000012  2803              CMP      r0,#3
000014  d105              BNE      |L33.34|
;;;1641   		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
000016  f1040014          ADD      r0,r4,#0x14
00001a  f7fffffe          BL       ld_word
00001e  ea464600          ORR      r6,r6,r0,LSL #16
                  |L33.34|
;;;1642   	}
;;;1643   
;;;1644   	return cl;
000022  4630              MOV      r0,r6
;;;1645   }
000024  bd70              POP      {r4-r6,pc}
;;;1646   
                          ENDP


                          AREA ||i.ld_dword||, CODE, READONLY, ALIGN=1

                  ld_dword PROC
;;;622    static
;;;623    DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
000000  4601              MOV      r1,r0
;;;624    {
;;;625    	DWORD rv;
;;;626    
;;;627    	rv = ptr[3];
000002  78c8              LDRB     r0,[r1,#3]
;;;628    	rv = rv << 8 | ptr[2];
000004  788a              LDRB     r2,[r1,#2]
000006  ea422000          ORR      r0,r2,r0,LSL #8
;;;629    	rv = rv << 8 | ptr[1];
00000a  784a              LDRB     r2,[r1,#1]
00000c  ea422000          ORR      r0,r2,r0,LSL #8
;;;630    	rv = rv << 8 | ptr[0];
000010  780a              LDRB     r2,[r1,#0]
000012  ea422000          ORR      r0,r2,r0,LSL #8
;;;631    	return rv;
;;;632    }
000016  4770              BX       lr
;;;633    
                          ENDP


                          AREA ||i.ld_word||, CODE, READONLY, ALIGN=1

                  ld_word PROC
;;;612    static
;;;613    WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
000000  4601              MOV      r1,r0
;;;614    {
;;;615    	WORD rv;
;;;616    
;;;617    	rv = ptr[1];
000002  7848              LDRB     r0,[r1,#1]
;;;618    	rv = rv << 8 | ptr[0];
000004  780a              LDRB     r2,[r1,#0]
000006  ea422000          ORR      r0,r2,r0,LSL #8
;;;619    	return rv;
;;;620    }
00000a  4770              BX       lr
;;;621    
                          ENDP


                          AREA ||i.mem_cmp||, CODE, READONLY, ALIGN=1

                  mem_cmp PROC
;;;715    static
;;;716    int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
000000  b5f0              PUSH     {r4-r7,lr}
000002  4603              MOV      r3,r0
;;;717    	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
000004  461d              MOV      r5,r3
000006  460c              MOV      r4,r1
;;;718    	int r = 0;
000008  2000              MOVS     r0,#0
;;;719    
;;;720    	do {
00000a  bf00              NOP      
                  |L36.12|
;;;721    		r = *d++ - *s++;
00000c  f8157b01          LDRB     r7,[r5],#1
000010  f814cb01          LDRB     r12,[r4],#1
000014  eba7000c          SUB      r0,r7,r12
;;;722    	} while (--cnt && r == 0);
000018  1e56              SUBS     r6,r2,#1
00001a  1e32              SUBS     r2,r6,#0
00001c  d001              BEQ      |L36.34|
00001e  2800              CMP      r0,#0
000020  d0f4              BEQ      |L36.12|
                  |L36.34|
;;;723    
;;;724    	return r;
;;;725    }
000022  bdf0              POP      {r4-r7,pc}
;;;726    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;692    static
;;;693    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  b530              PUSH     {r4,r5,lr}
;;;694    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;695    	const BYTE *s = (const BYTE*)src;
000004  460c              MOV      r4,r1
;;;696    
;;;697    	if (cnt) {
000006  b13a              CBZ      r2,|L37.24|
;;;698    		do {
000008  bf00              NOP      
                  |L37.10|
;;;699    			*d++ = *s++;
00000a  f8145b01          LDRB     r5,[r4],#1
00000e  f8035b01          STRB     r5,[r3],#1
;;;700    		} while (--cnt);
000012  1e55              SUBS     r5,r2,#1
000014  1e2a              SUBS     r2,r5,#0
000016  d1f8              BNE      |L37.10|
                  |L37.24|
;;;701    	}
;;;702    }
000018  bd30              POP      {r4,r5,pc}
;;;703    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;705    static
;;;706    void mem_set (void* dst, int val, UINT cnt) {
000000  b510              PUSH     {r4,lr}
;;;707    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;708    
;;;709    	do {
000004  bf00              NOP      
                  |L38.6|
;;;710    		*d++ = (BYTE)val;
000006  f8031b01          STRB     r1,[r3],#1
;;;711    	} while (--cnt);
00000a  1e54              SUBS     r4,r2,#1
00000c  1e22              SUBS     r2,r4,#0
00000e  d1fa              BNE      |L38.6|
;;;712    }
000010  bd10              POP      {r4,pc}
;;;713    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;911    static
;;;912    FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
000000  b570              PUSH     {r4-r6,lr}
;;;913    	FATFS* fs,			/* File system object */
;;;914    	DWORD sector		/* Sector number to make appearance in the fs->win[] */
;;;915    )
;;;916    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;917    	FRESULT res = FR_OK;
000006  2600              MOVS     r6,#0
;;;918    
;;;919    
;;;920    	if (sector != fs->winsect) {	/* Window offset changed? */
000008  6ae0              LDR      r0,[r4,#0x2c]
00000a  42a8              CMP      r0,r5
00000c  d010              BEQ      |L39.48|
;;;921    #if !_FS_READONLY
;;;922    		res = sync_window(fs);		/* Write-back changes */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sync_window
000014  4606              MOV      r6,r0
;;;923    #endif
;;;924    		if (res == FR_OK) {			/* Fill sector window with new data */
000016  b95e              CBNZ     r6,|L39.48|
;;;925    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
000018  7860              LDRB     r0,[r4,#1]
00001a  2301              MOVS     r3,#1
00001c  462a              MOV      r2,r5
00001e  f1040130          ADD      r1,r4,#0x30
000022  f7fffffe          BL       disk_read
000026  b110              CBZ      r0,|L39.46|
;;;926    				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
000028  f04f35ff          MOV      r5,#0xffffffff
;;;927    				res = FR_DISK_ERR;
00002c  2601              MOVS     r6,#1
                  |L39.46|
;;;928    			}
;;;929    			fs->winsect = sector;
00002e  62e5              STR      r5,[r4,#0x2c]
                  |L39.48|
;;;930    		}
;;;931    	}
;;;932    	return res;
000030  4630              MOV      r0,r6
;;;933    }
000032  bd70              POP      {r4-r6,pc}
;;;934    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;1080   static
;;;1081   FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1082   	FATFS* fs,		/* Corresponding file system object */
;;;1083   	DWORD clst,		/* FAT index number (cluster number) to be changed */
;;;1084   	DWORD val		/* New value to be set to the entry */
;;;1085   )
;;;1086   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1087   	UINT bc;
;;;1088   	BYTE *p;
;;;1089   	FRESULT res = FR_INT_ERR;
00000a  f04f0902          MOV      r9,#2
;;;1090   
;;;1091   	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
00000e  2d02              CMP      r5,#2
000010  d374              BCC      |L40.252|
000012  6960              LDR      r0,[r4,#0x14]
000014  42a8              CMP      r0,r5
000016  d971              BLS      |L40.252|
;;;1092   		switch (fs->fs_type) {
000018  7820              LDRB     r0,[r4,#0]
00001a  2801              CMP      r0,#1
00001c  d004              BEQ      |L40.40|
00001e  2802              CMP      r0,#2
000020  d049              BEQ      |L40.182|
000022  2803              CMP      r0,#3
000024  d10d              BNE      |L40.66|
000026  e05e              B        |L40.230|
                  |L40.40|
;;;1093   		case FS_FAT12 :	/* Bitfield items */
;;;1094   			bc = (UINT)clst; bc += bc / 2;
000028  462f              MOV      r7,r5
00002a  eb070757          ADD      r7,r7,r7,LSR #1
;;;1095   			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
00002e  6a20              LDR      r0,[r4,#0x20]
000030  eb002157          ADD      r1,r0,r7,LSR #9
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       move_window
00003a  4681              MOV      r9,r0
;;;1096   			if (res != FR_OK) break;
00003c  f1b90f00          CMP      r9,#0
000040  d000              BEQ      |L40.68|
                  |L40.66|
000042  e075              B        |L40.304|
                  |L40.68|
;;;1097   			p = fs->win + bc++ % SS(fs);
000044  4638              MOV      r0,r7
000046  1c7f              ADDS     r7,r7,#1
000048  f3c00108          UBFX     r1,r0,#0,#9
00004c  f1040030          ADD      r0,r4,#0x30
000050  eb010800          ADD      r8,r1,r0
;;;1098   			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
000054  f0050001          AND      r0,r5,#1
000058  b128              CBZ      r0,|L40.102|
00005a  b2f1              UXTB     r1,r6
00005c  f8980000          LDRB     r0,[r8,#0]
000060  f361101f          BFI      r0,r1,#4,#28
000064  e000              B        |L40.104|
                  |L40.102|
000066  4630              MOV      r0,r6
                  |L40.104|
000068  f8880000          STRB     r0,[r8,#0]
;;;1099   			fs->wflag = 1;
00006c  2001              MOVS     r0,#1
00006e  70e0              STRB     r0,[r4,#3]
;;;1100   			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
000070  6a20              LDR      r0,[r4,#0x20]
000072  eb002157          ADD      r1,r0,r7,LSR #9
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       move_window
00007c  4681              MOV      r9,r0
;;;1101   			if (res != FR_OK) break;
00007e  f1b90f00          CMP      r9,#0
000082  d000              BEQ      |L40.134|
000084  e054              B        |L40.304|
                  |L40.134|
;;;1102   			p = fs->win + bc % SS(fs);
000086  f3c70108          UBFX     r1,r7,#0,#9
00008a  f1040030          ADD      r0,r4,#0x30
00008e  eb010800          ADD      r8,r1,r0
;;;1103   			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
000092  f0050001          AND      r0,r5,#1
000096  b110              CBZ      r0,|L40.158|
000098  f3c61007          UBFX     r0,r6,#4,#8
00009c  e006              B        |L40.172|
                  |L40.158|
00009e  f8980000          LDRB     r0,[r8,#0]
0000a2  f00000f0          AND      r0,r0,#0xf0
0000a6  f3c62103          UBFX     r1,r6,#8,#4
0000aa  4308              ORRS     r0,r0,r1
                  |L40.172|
0000ac  f8880000          STRB     r0,[r8,#0]
;;;1104   			fs->wflag = 1;
0000b0  2001              MOVS     r0,#1
0000b2  70e0              STRB     r0,[r4,#3]
;;;1105   			break;
0000b4  e03c              B        |L40.304|
                  |L40.182|
;;;1106   
;;;1107   		case FS_FAT16 :	/* WORD aligned items */
;;;1108   			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  eb002115          ADD      r1,r0,r5,LSR #8
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       move_window
0000c2  4681              MOV      r9,r0
;;;1109   			if (res != FR_OK) break;
0000c4  f1b90f00          CMP      r9,#0
0000c8  d000              BEQ      |L40.204|
0000ca  e031              B        |L40.304|
                  |L40.204|
;;;1110   			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
0000cc  b2b1              UXTH     r1,r6
0000ce  f24012ff          MOV      r2,#0x1ff
0000d2  ea020345          AND      r3,r2,r5,LSL #1
0000d6  f1040230          ADD      r2,r4,#0x30
0000da  1898              ADDS     r0,r3,r2
0000dc  f7fffffe          BL       st_word
;;;1111   			fs->wflag = 1;
0000e0  2001              MOVS     r0,#1
0000e2  70e0              STRB     r0,[r4,#3]
;;;1112   			break;
0000e4  e024              B        |L40.304|
                  |L40.230|
;;;1113   
;;;1114   		case FS_FAT32 :	/* DWORD aligned items */
;;;1115   #if _FS_EXFAT
;;;1116   		case FS_EXFAT :
;;;1117   #endif
;;;1118   			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
0000e6  6a20              LDR      r0,[r4,#0x20]
0000e8  eb0011d5          ADD      r1,r0,r5,LSR #7
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       move_window
0000f2  4681              MOV      r9,r0
;;;1119   			if (res != FR_OK) break;
0000f4  f1b90f00          CMP      r9,#0
0000f8  d001              BEQ      |L40.254|
0000fa  e019              B        |L40.304|
                  |L40.252|
0000fc  e019              B        |L40.306|
                  |L40.254|
;;;1120   			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
;;;1121   				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
0000fe  f24011ff          MOV      r1,#0x1ff
000102  ea010285          AND      r2,r1,r5,LSL #2
000106  f1040130          ADD      r1,r4,#0x30
00010a  1850              ADDS     r0,r2,r1
00010c  f7fffffe          BL       ld_dword
000110  f366001b          BFI      r0,r6,#0,#28
000114  4606              MOV      r6,r0
;;;1122   			}
;;;1123   			st_dword(fs->win + clst * 4 % SS(fs), val);
000116  f24011ff          MOV      r1,#0x1ff
00011a  ea010285          AND      r2,r1,r5,LSL #2
00011e  f1040130          ADD      r1,r4,#0x30
000122  1850              ADDS     r0,r2,r1
000124  4631              MOV      r1,r6
000126  f7fffffe          BL       st_dword
;;;1124   			fs->wflag = 1;
00012a  2001              MOVS     r0,#1
00012c  70e0              STRB     r0,[r4,#3]
;;;1125   			break;
00012e  bf00              NOP      
                  |L40.304|
000130  bf00              NOP                            ;1096
                  |L40.306|
;;;1126   		}
;;;1127   	}
;;;1128   	return res;
000132  4648              MOV      r0,r9
;;;1129   }
000134  e8bd87f0          POP      {r4-r10,pc}
;;;1130   
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;1270   static
;;;1271   FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1272   	_FDID* obj,			/* Corresponding object */
;;;1273   	DWORD clst,			/* Cluster to remove a chain from */
;;;1274   	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
;;;1275   )
;;;1276   {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1277   	FRESULT res = FR_OK;
00000a  f04f0800          MOV      r8,#0
;;;1278   	DWORD nxt;
;;;1279   	FATFS *fs = obj->fs;
00000e  f8d94000          LDR      r4,[r9,#0]
;;;1280   #if _FS_EXFAT || _USE_TRIM
;;;1281   	DWORD scl = clst, ecl = clst;
;;;1282   #endif
;;;1283   #if _USE_TRIM
;;;1284   	DWORD rt[2];
;;;1285   #endif
;;;1286   
;;;1287   	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
000012  2e02              CMP      r6,#2
000014  d302              BCC      |L41.28|
000016  6960              LDR      r0,[r4,#0x14]
000018  42b0              CMP      r0,r6
00001a  d802              BHI      |L41.34|
                  |L41.28|
00001c  2002              MOVS     r0,#2
                  |L41.30|
;;;1288   
;;;1289   	/* Mark the previous cluster 'EOC' on the FAT if it exists */
;;;1290   	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
;;;1291   		res = put_fat(fs, pclst, 0xFFFFFFFF);
;;;1292   		if (res != FR_OK) return res;
;;;1293   	}
;;;1294   
;;;1295   	/* Remove the chain */
;;;1296   	do {
;;;1297   		nxt = get_fat(obj, clst);			/* Get cluster status */
;;;1298   		if (nxt == 0) break;				/* Empty cluster? */
;;;1299   		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
;;;1300   		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
;;;1301   		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
;;;1302   			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
;;;1303   			if (res != FR_OK) return res;
;;;1304   		}
;;;1305   		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
;;;1306   			fs->free_clst++;
;;;1307   			fs->fsi_flag |= 1;
;;;1308   		}
;;;1309   #if _FS_EXFAT || _USE_TRIM
;;;1310   		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;;;1311   			ecl = nxt;
;;;1312   		} else {				/* End of contiguous cluster block */
;;;1313   #if _FS_EXFAT
;;;1314   			if (fs->fs_type == FS_EXFAT) {
;;;1315   				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
;;;1316   				if (res != FR_OK) return res;
;;;1317   			}
;;;1318   #endif
;;;1319   #if _USE_TRIM
;;;1320   			rt[0] = clust2sect(fs, scl);					/* Start sector */
;;;1321   			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;1322   			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
;;;1323   #endif
;;;1324   			scl = ecl = nxt;
;;;1325   		}
;;;1326   #endif
;;;1327   		clst = nxt;					/* Next cluster */
;;;1328   	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
;;;1329   
;;;1330   #if _FS_EXFAT
;;;1331   	if (fs->fs_type == FS_EXFAT) {
;;;1332   		if (pclst == 0) {	/* Does the object have no chain? */
;;;1333   			obj->stat = 0;		/* Change the object status 'initial' */
;;;1334   		} else {
;;;1335   			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain get contiguous? */
;;;1336   				obj->stat = 2;	/* Change the object status 'contiguous' */
;;;1337   			}
;;;1338   		}
;;;1339   	}
;;;1340   #endif
;;;1341   	return FR_OK;
;;;1342   }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L41.34|
000022  b167              CBZ      r7,|L41.62|
000024  bf00              NOP                            ;1290
000026  f04f32ff          MOV      r2,#0xffffffff        ;1291
00002a  4639              MOV      r1,r7                 ;1291
00002c  4620              MOV      r0,r4                 ;1291
00002e  f7fffffe          BL       put_fat
000032  4680              MOV      r8,r0                 ;1291
000034  f1b80f00          CMP      r8,#0                 ;1292
000038  d001              BEQ      |L41.62|
00003a  4640              MOV      r0,r8                 ;1292
00003c  e7ef              B        |L41.30|
                  |L41.62|
00003e  bf00              NOP                            ;1296
                  |L41.64|
000040  4631              MOV      r1,r6                 ;1297
000042  4648              MOV      r0,r9                 ;1297
000044  f7fffffe          BL       get_fat
000048  4605              MOV      r5,r0                 ;1297
00004a  b905              CBNZ     r5,|L41.78|
00004c  e022              B        |L41.148|
                  |L41.78|
00004e  2d01              CMP      r5,#1                 ;1299
000050  d101              BNE      |L41.86|
000052  2002              MOVS     r0,#2                 ;1299
000054  e7e3              B        |L41.30|
                  |L41.86|
000056  1c68              ADDS     r0,r5,#1              ;1300
000058  b908              CBNZ     r0,|L41.94|
00005a  2001              MOVS     r0,#1                 ;1300
00005c  e7df              B        |L41.30|
                  |L41.94|
00005e  2200              MOVS     r2,#0                 ;1302
000060  4631              MOV      r1,r6                 ;1302
000062  4620              MOV      r0,r4                 ;1302
000064  f7fffffe          BL       put_fat
000068  4680              MOV      r8,r0                 ;1302
00006a  f1b80f00          CMP      r8,#0                 ;1303
00006e  d001              BEQ      |L41.116|
000070  4640              MOV      r0,r8                 ;1303
000072  e7d4              B        |L41.30|
                  |L41.116|
000074  e9d41004          LDRD     r1,r0,[r4,#0x10]      ;1305
000078  1e80              SUBS     r0,r0,#2              ;1305
00007a  4281              CMP      r1,r0                 ;1305
00007c  d206              BCS      |L41.140|
00007e  6920              LDR      r0,[r4,#0x10]         ;1306
000080  1c40              ADDS     r0,r0,#1              ;1306
000082  6120              STR      r0,[r4,#0x10]         ;1306
000084  7920              LDRB     r0,[r4,#4]            ;1307
000086  f0400001          ORR      r0,r0,#1              ;1307
00008a  7120              STRB     r0,[r4,#4]            ;1307
                  |L41.140|
00008c  462e              MOV      r6,r5                 ;1327
00008e  6960              LDR      r0,[r4,#0x14]         ;1328
000090  42b0              CMP      r0,r6                 ;1328
000092  d8d5              BHI      |L41.64|
                  |L41.148|
000094  bf00              NOP                            ;1298
000096  2000              MOVS     r0,#0                 ;1341
000098  e7c1              B        |L41.30|
;;;1343   
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;1649   static
;;;1650   void st_clust (
000000  b570              PUSH     {r4-r6,lr}
;;;1651   	FATFS* fs,	/* Pointer to the fs object */
;;;1652   	BYTE* dir,	/* Pointer to the key entry */
;;;1653   	DWORD cl	/* Value to be set */
;;;1654   )
;;;1655   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1656   	st_word(dir + DIR_FstClusLO, (WORD)cl);
000008  b2a9              UXTH     r1,r5
00000a  f104001a          ADD      r0,r4,#0x1a
00000e  f7fffffe          BL       st_word
;;;1657   	if (fs->fs_type == FS_FAT32) {
000012  7830              LDRB     r0,[r6,#0]
000014  2803              CMP      r0,#3
000016  d104              BNE      |L42.34|
;;;1658   		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
000018  0c29              LSRS     r1,r5,#16
00001a  f1040014          ADD      r0,r4,#0x14
00001e  f7fffffe          BL       st_word
                  |L42.34|
;;;1659   	}
;;;1660   }
000022  bd70              POP      {r4-r6,pc}
;;;1661   #endif
                          ENDP


                          AREA ||i.st_dword||, CODE, READONLY, ALIGN=1

                  st_dword PROC
;;;660    static
;;;661    void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
000000  f8001b01          STRB     r1,[r0],#1
;;;662    {
;;;663    	*ptr++ = (BYTE)val; val >>= 8;
000004  0a09              LSRS     r1,r1,#8
;;;664    	*ptr++ = (BYTE)val; val >>= 8;
000006  f8001b01          STRB     r1,[r0],#1
00000a  0a09              LSRS     r1,r1,#8
;;;665    	*ptr++ = (BYTE)val; val >>= 8;
00000c  f8001b01          STRB     r1,[r0],#1
000010  0a09              LSRS     r1,r1,#8
;;;666    	*ptr++ = (BYTE)val;
000012  f8001b01          STRB     r1,[r0],#1
;;;667    }
000016  4770              BX       lr
;;;668    
                          ENDP


                          AREA ||i.st_word||, CODE, READONLY, ALIGN=1

                  st_word PROC
;;;653    static
;;;654    void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
000000  f8001b01          STRB     r1,[r0],#1
;;;655    {
;;;656    	*ptr++ = (BYTE)val; val >>= 8;
000004  1209              ASRS     r1,r1,#8
;;;657    	*ptr++ = (BYTE)val;
000006  f8001b01          STRB     r1,[r0],#1
;;;658    }
00000a  4770              BX       lr
;;;659    
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=2

                  sync_fs PROC
;;;943    static
;;;944    FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;945    	FATFS* fs		/* File system object */
;;;946    )
;;;947    {
000002  4604              MOV      r4,r0
;;;948    	FRESULT res;
;;;949    
;;;950    
;;;951    	res = sync_window(fs);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       sync_window
00000a  4605              MOV      r5,r0
;;;952    	if (res == FR_OK) {
00000c  2d00              CMP      r5,#0
00000e  d138              BNE      |L45.130|
;;;953    		/* Update FSInfo sector if needed */
;;;954    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
000010  7820              LDRB     r0,[r4,#0]
000012  2803              CMP      r0,#3
000014  d12e              BNE      |L45.116|
000016  7920              LDRB     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d12b              BNE      |L45.116|
;;;955    			/* Create FSInfo structure */
;;;956    			mem_set(fs->win, 0, SS(fs));
00001c  0242              LSLS     r2,r0,#9
00001e  2100              MOVS     r1,#0
000020  f1040030          ADD      r0,r4,#0x30
000024  f7fffffe          BL       mem_set
;;;957    			st_word(fs->win + BS_55AA, 0xAA55);
000028  f64a2155          MOV      r1,#0xaa55
00002c  f204202e          ADD      r0,r4,#0x22e
000030  f7fffffe          BL       st_word
;;;958    			st_dword(fs->win + FSI_LeadSig, 0x41615252);
000034  4914              LDR      r1,|L45.136|
000036  f1040030          ADD      r0,r4,#0x30
00003a  f7fffffe          BL       st_dword
;;;959    			st_dword(fs->win + FSI_StrucSig, 0x61417272);
00003e  4913              LDR      r1,|L45.140|
000040  f5047005          ADD      r0,r4,#0x214
000044  f7fffffe          BL       st_dword
;;;960    			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
000048  f5047006          ADD      r0,r4,#0x218
00004c  6921              LDR      r1,[r4,#0x10]
00004e  f7fffffe          BL       st_dword
;;;961    			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
000052  f5047007          ADD      r0,r4,#0x21c
000056  68e1              LDR      r1,[r4,#0xc]
000058  f7fffffe          BL       st_dword
;;;962    			/* Write it into the FSInfo sector */
;;;963    			fs->winsect = fs->volbase + 1;
00005c  69e0              LDR      r0,[r4,#0x1c]
00005e  1c40              ADDS     r0,r0,#1
000060  62e0              STR      r0,[r4,#0x2c]
;;;964    			disk_write(fs->drv, fs->win, fs->winsect, 1);
000062  7860              LDRB     r0,[r4,#1]
000064  2301              MOVS     r3,#1
000066  f1040130          ADD      r1,r4,#0x30
00006a  6ae2              LDR      r2,[r4,#0x2c]
00006c  f7fffffe          BL       disk_write
;;;965    			fs->fsi_flag = 0;
000070  2000              MOVS     r0,#0
000072  7120              STRB     r0,[r4,#4]
                  |L45.116|
;;;966    		}
;;;967    		/* Make sure that no pending write process in the physical drive */
;;;968    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
000074  7860              LDRB     r0,[r4,#1]
000076  2200              MOVS     r2,#0
000078  4611              MOV      r1,r2
00007a  f7fffffe          BL       disk_ioctl
00007e  b100              CBZ      r0,|L45.130|
000080  2501              MOVS     r5,#1
                  |L45.130|
;;;969    	}
;;;970    
;;;971    	return res;
000082  4628              MOV      r0,r5
;;;972    }
000084  bd70              POP      {r4-r6,pc}
;;;973    
                          ENDP

000086  0000              DCW      0x0000
                  |L45.136|
                          DCD      0x41615252
                  |L45.140|
                          DCD      0x61417272

                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;882    static
;;;883    FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;884    	FATFS* fs			/* File system object */
;;;885    )
;;;886    {
000004  4604              MOV      r4,r0
;;;887    	DWORD wsect;
;;;888    	UINT nf;
;;;889    	FRESULT res = FR_OK;
000006  2700              MOVS     r7,#0
;;;890    
;;;891    
;;;892    	if (fs->wflag) {	/* Write back the sector if it is dirty */
000008  78e0              LDRB     r0,[r4,#3]
00000a  b1f8              CBZ      r0,|L46.76|
;;;893    		wsect = fs->winsect;	/* Current sector number */
00000c  6ae5              LDR      r5,[r4,#0x2c]
;;;894    		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
00000e  7860              LDRB     r0,[r4,#1]
000010  2301              MOVS     r3,#1
000012  462a              MOV      r2,r5
000014  f1040130          ADD      r1,r4,#0x30
000018  f7fffffe          BL       disk_write
00001c  b108              CBZ      r0,|L46.34|
;;;895    			res = FR_DISK_ERR;
00001e  2701              MOVS     r7,#1
000020  e014              B        |L46.76|
                  |L46.34|
;;;896    		} else {
;;;897    			fs->wflag = 0;
000022  2000              MOVS     r0,#0
000024  70e0              STRB     r0,[r4,#3]
;;;898    			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
000026  6a20              LDR      r0,[r4,#0x20]
000028  1a28              SUBS     r0,r5,r0
00002a  69a1              LDR      r1,[r4,#0x18]
00002c  4288              CMP      r0,r1
00002e  d20d              BCS      |L46.76|
;;;899    				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
000030  78a6              LDRB     r6,[r4,#2]
000032  e009              B        |L46.72|
                  |L46.52|
;;;900    					wsect += fs->fsize;
000034  69a0              LDR      r0,[r4,#0x18]
000036  4405              ADD      r5,r5,r0
;;;901    					disk_write(fs->drv, fs->win, wsect, 1);
000038  7860              LDRB     r0,[r4,#1]
00003a  2301              MOVS     r3,#1
00003c  462a              MOV      r2,r5
00003e  f1040130          ADD      r1,r4,#0x30
000042  f7fffffe          BL       disk_write
000046  1e76              SUBS     r6,r6,#1              ;899
                  |L46.72|
000048  2e02              CMP      r6,#2                 ;899
00004a  d2f3              BCS      |L46.52|
                  |L46.76|
;;;902    				}
;;;903    			}
;;;904    		}
;;;905    	}
;;;906    	return res;
00004c  4638              MOV      r0,r7
;;;907    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;908    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;3215   static
;;;3216   FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
000000  b570              PUSH     {r4-r6,lr}
;;;3217   	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
;;;3218   	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
;;;3219   )
;;;3220   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3221   	FRESULT res = FR_INVALID_OBJECT;
000006  2609              MOVS     r6,#9
;;;3222   
;;;3223   
;;;3224   	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
000008  b18c              CBZ      r4,|L47.46|
00000a  6820              LDR      r0,[r4,#0]
00000c  b178              CBZ      r0,|L47.46|
00000e  6820              LDR      r0,[r4,#0]
000010  7800              LDRB     r0,[r0,#0]
000012  b160              CBZ      r0,|L47.46|
000014  88a0              LDRH     r0,[r4,#4]
000016  6821              LDR      r1,[r4,#0]
000018  88c9              LDRH     r1,[r1,#6]
00001a  4288              CMP      r0,r1
00001c  d107              BNE      |L47.46|
;;;3225   #if _FS_REENTRANT
;;;3226   		if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
;;;3227   			if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
;;;3228   				res = FR_OK;
;;;3229   			} else {
;;;3230   				unlock_fs(obj->fs, FR_OK);
;;;3231   			}
;;;3232   		} else {
;;;3233   			res = FR_TIMEOUT;
;;;3234   		}
;;;3235   #else
;;;3236   		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
00001e  6821              LDR      r1,[r4,#0]
000020  7848              LDRB     r0,[r1,#1]
000022  f7fffffe          BL       disk_status
000026  f0000001          AND      r0,r0,#1
00002a  b900              CBNZ     r0,|L47.46|
;;;3237   			res = FR_OK;
00002c  2600              MOVS     r6,#0
                  |L47.46|
;;;3238   		}
;;;3239   #endif
;;;3240   	}
;;;3241   	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
00002e  b90e              CBNZ     r6,|L47.52|
000030  6820              LDR      r0,[r4,#0]
000032  e000              B        |L47.54|
                  |L47.52|
000034  2000              MOVS     r0,#0
                  |L47.54|
000036  6028              STR      r0,[r5,#0]
;;;3242   	return res;
000038  4630              MOV      r0,r6
;;;3243   }
00003a  bd70              POP      {r4-r6,pc}
;;;3244   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Files
                          %        160

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ExCvt
000000  809a4541          DCB      0x80,0x9a,0x45,0x41
000004  8e418f80          DCB      0x8e,0x41,0x8f,0x80
000008  45454549          DCB      0x45,0x45,0x45,0x49
00000c  49498e8f          DCB      0x49,0x49,0x8e,0x8f
000010  9092924f          DCB      0x90,0x92,0x92,0x4f
000014  994f5555          DCB      0x99,0x4f,0x55,0x55
000018  59999a9b          DCB      0x59,0x99,0x9a,0x9b
00001c  9c9d9e9f          DCB      0x9c,0x9d,0x9e,0x9f
000020  41494f55          DCB      0x41,0x49,0x4f,0x55
000024  a5a5a6a7          DCB      0xa5,0xa5,0xa6,0xa7
000028  a8a9aaab          DCB      0xa8,0xa9,0xaa,0xab
00002c  acadaeaf          DCB      0xac,0xad,0xae,0xaf
000030  b0b1b2b3          DCB      0xb0,0xb1,0xb2,0xb3
000034  b4b5b6b7          DCB      0xb4,0xb5,0xb6,0xb7
000038  b8b9babb          DCB      0xb8,0xb9,0xba,0xbb
00003c  bcbdbebf          DCB      0xbc,0xbd,0xbe,0xbf
000040  c0c1c2c3          DCB      0xc0,0xc1,0xc2,0xc3
000044  c4c5c6c7          DCB      0xc4,0xc5,0xc6,0xc7
000048  c8c9cacb          DCB      0xc8,0xc9,0xca,0xcb
00004c  cccdcecf          DCB      0xcc,0xcd,0xce,0xcf
000050  d0d1d2d3          DCB      0xd0,0xd1,0xd2,0xd3
000054  d4d5d6d7          DCB      0xd4,0xd5,0xd6,0xd7
000058  d8d9dadb          DCB      0xd8,0xd9,0xda,0xdb
00005c  dcdddedf          DCB      0xdc,0xdd,0xde,0xdf
000060  e0e1e2e3          DCB      0xe0,0xe1,0xe2,0xe3
000064  e4e5e6e7          DCB      0xe4,0xe5,0xe6,0xe7
000068  e8e9eaeb          DCB      0xe8,0xe9,0xea,0xeb
00006c  ecedeeef          DCB      0xec,0xed,0xee,0xef
000070  f0f1f2f3          DCB      0xf0,0xf1,0xf2,0xf3
000074  f4f5f6f7          DCB      0xf4,0xf5,0xf6,0xf7
000078  f8f9fafb          DCB      0xf8,0xf9,0xfa,0xfb
00007c  fcfdfeff          DCB      0xfc,0xfd,0xfe,0xff

                          AREA ||.data||, DATA, ALIGN=2

                  FatFs
                          DCD      0x00000000
                  Fsid
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "../Middlewares/Third_Party/FatFs/src/ff.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_ff_c_f_mount____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___4_ff_c_f_mount____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_ff_c_f_mount____REVSH|
#line 478
|__asm___4_ff_c_f_mount____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___4_ff_c_f_mount____RRX|
#line 665
|__asm___4_ff_c_f_mount____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
