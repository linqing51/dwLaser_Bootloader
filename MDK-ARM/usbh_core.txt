; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\usbh_core.o --asm_dir=./ --list_dir=--list --depend=mcu_application\usbh_core.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\usbh_core.crf ../Middlewares/ST/STM32_USB_Host_Library/Core/Src/usbh_core.c]
                          THUMB

                          AREA ||i.DeInitStateMachine||, CODE, READONLY, ALIGN=1

                  DeInitStateMachine PROC
;;;204      */
;;;205    static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
000000  4601              MOV      r1,r0
;;;206    {
;;;207      uint32_t i = 0U;
000002  2200              MOVS     r2,#0
;;;208    
;;;209      /* Clear Pipes flags*/
;;;210      for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
000004  bf00              NOP      
000006  e005              B        |L1.20|
                  |L1.8|
;;;211      {
;;;212        phost->Pipes[i] = 0U;
000008  2300              MOVS     r3,#0
00000a  f5017061          ADD      r0,r1,#0x384
00000e  f8403022          STR      r3,[r0,r2,LSL #2]
000012  1c52              ADDS     r2,r2,#1              ;210
                  |L1.20|
000014  2a0f              CMP      r2,#0xf               ;210
000016  d3f7              BCC      |L1.8|
;;;213      }
;;;214    
;;;215      for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
000018  2200              MOVS     r2,#0
00001a  e004              B        |L1.38|
                  |L1.28|
;;;216      {
;;;217        phost->device.Data[i] = 0U;
00001c  2300              MOVS     r3,#0
00001e  f501708e          ADD      r0,r1,#0x11c
000022  5483              STRB     r3,[r0,r2]
000024  1c52              ADDS     r2,r2,#1              ;215
                  |L1.38|
000026  f5b27f00          CMP      r2,#0x200             ;215
00002a  d3f7              BCC      |L1.28|
;;;218      }
;;;219    
;;;220      phost->gState = HOST_IDLE;
00002c  2000              MOVS     r0,#0
00002e  7008              STRB     r0,[r1,#0]
;;;221      phost->EnumState = ENUM_IDLE;
000030  7048              STRB     r0,[r1,#1]
;;;222      phost->RequestState = CMD_SEND;
000032  2001              MOVS     r0,#1
000034  7088              STRB     r0,[r1,#2]
;;;223      phost->Timer = 0U;
000036  2000              MOVS     r0,#0
000038  f8c103c4          STR      r0,[r1,#0x3c4]
;;;224    
;;;225      phost->Control.state = CTRL_SETUP;
00003c  2301              MOVS     r3,#1
00003e  760b              STRB     r3,[r1,#0x18]
;;;226      phost->Control.pipe_size = USBH_MPS_DEFAULT;
000040  2340              MOVS     r3,#0x40
000042  718b              STRB     r3,[r1,#6]
;;;227      phost->Control.errorcount = 0U;
000044  2300              MOVS     r3,#0
000046  764b              STRB     r3,[r1,#0x19]
;;;228    
;;;229      phost->device.address = USBH_ADDRESS_DEFAULT;
000048  f881331c          STRB     r3,[r1,#0x31c]
;;;230      phost->device.speed = USBH_SPEED_FULL;
00004c  2301              MOVS     r3,#1
00004e  f881331d          STRB     r3,[r1,#0x31d]
;;;231      phost->device.RstCnt = 0U;
000052  2300              MOVS     r3,#0
000054  f881331f          STRB     r3,[r1,#0x31f]
;;;232      phost->device.EnumCnt = 0U;
000058  f881331e          STRB     r3,[r1,#0x31e]
;;;233    
;;;234      return USBH_OK;
;;;235    }
00005c  4770              BX       lr
;;;236    
                          ENDP


                          AREA ||i.USBH_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_DeInit PROC
;;;177      */
;;;178    USBH_StatusTypeDef USBH_DeInit(USBH_HandleTypeDef *phost)
000000  b510              PUSH     {r4,lr}
;;;179    {
000002  4604              MOV      r4,r0
;;;180      DeInitStateMachine(phost);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       DeInitStateMachine
;;;181    
;;;182      /* Restore default Device connection states */
;;;183      phost->device.PortEnabled = 0U;
00000a  2100              MOVS     r1,#0
00000c  f8841323          STRB     r1,[r4,#0x323]
;;;184      phost->device.is_connected = 0U;
000010  f8841320          STRB     r1,[r4,#0x320]
;;;185      phost->device.is_disconnected = 0U;
000014  f8841321          STRB     r1,[r4,#0x321]
;;;186      phost->device.is_ReEnumerated = 0U;
000018  f8841322          STRB     r1,[r4,#0x322]
;;;187      phost->device.RstCnt = 0U;
00001c  f884131f          STRB     r1,[r4,#0x31f]
;;;188      phost->device.EnumCnt = 0U;
000020  f884131e          STRB     r1,[r4,#0x31e]
;;;189    
;;;190      if (phost->pData != NULL)
000024  f8d403d0          LDR      r0,[r4,#0x3d0]
000028  b110              CBZ      r0,|L2.48|
;;;191      {
;;;192        USBH_LL_Stop(phost);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       USBH_LL_Stop
                  |L2.48|
;;;193      }
;;;194    
;;;195      return USBH_OK;
000030  2000              MOVS     r0,#0
;;;196    }
000032  bd10              POP      {r4,pc}
;;;197    
                          ENDP


                          AREA ||i.USBH_FindInterface||, CODE, READONLY, ALIGN=1

                  USBH_FindInterface PROC
;;;324      */
;;;325    uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
000000  b5f0              PUSH     {r4-r7,lr}
;;;326    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;327      USBH_InterfaceDescTypeDef *pif;
;;;328      USBH_CfgDescTypeDef *pcfg;
;;;329      uint8_t if_ix = 0U;
000008  2200              MOVS     r2,#0
;;;330    
;;;331      pif = (USBH_InterfaceDescTypeDef *)0;
00000a  2100              MOVS     r1,#0
;;;332      pcfg = &phost->device.CfgDesc;
00000c  f506774e          ADD      r7,r6,#0x338
;;;333    
;;;334      while (if_ix < USBH_MAX_NUM_INTERFACES)
000010  e01a              B        |L3.72|
                  |L3.18|
;;;335      {
;;;336        pif = &pcfg->Itf_Desc[if_ix];
000012  eb020082          ADD      r0,r2,r2,LSL #2
000016  eb000cc2          ADD      r12,r0,r2,LSL #3
00001a  f107000a          ADD      r0,r7,#0xa
00001e  eb00014c          ADD      r1,r0,r12,LSL #1
;;;337        if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
000022  7948              LDRB     r0,[r1,#5]
000024  42a0              CMP      r0,r4
000026  d001              BEQ      |L3.44|
000028  2cff              CMP      r4,#0xff
00002a  d10b              BNE      |L3.68|
                  |L3.44|
;;;338            ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
00002c  7988              LDRB     r0,[r1,#6]
00002e  42a8              CMP      r0,r5
000030  d001              BEQ      |L3.54|
000032  2dff              CMP      r5,#0xff
000034  d106              BNE      |L3.68|
                  |L3.54|
;;;339            ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
000036  79c8              LDRB     r0,[r1,#7]
000038  4298              CMP      r0,r3
00003a  d001              BEQ      |L3.64|
00003c  2bff              CMP      r3,#0xff
00003e  d101              BNE      |L3.68|
                  |L3.64|
;;;340        {
;;;341          return  if_ix;
000040  4610              MOV      r0,r2
                  |L3.66|
;;;342        }
;;;343        if_ix++;
;;;344      }
;;;345      return 0xFFU;
;;;346    }
000042  bdf0              POP      {r4-r7,pc}
                  |L3.68|
000044  1c50              ADDS     r0,r2,#1              ;343
000046  b2c2              UXTB     r2,r0                 ;343
                  |L3.72|
000048  2a02              CMP      r2,#2                 ;334
00004a  d3e2              BCC      |L3.18|
00004c  20ff              MOVS     r0,#0xff              ;345
00004e  e7f8              B        |L3.66|
;;;347    
                          ENDP


                          AREA ||i.USBH_FindInterfaceIndex||, CODE, READONLY, ALIGN=1

                  USBH_FindInterfaceIndex PROC
;;;357      */
;;;358    uint8_t  USBH_FindInterfaceIndex(USBH_HandleTypeDef *phost, uint8_t interface_number, uint8_t alt_settings)
000000  b5f0              PUSH     {r4-r7,lr}
;;;359    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;360      USBH_InterfaceDescTypeDef *pif;
;;;361      USBH_CfgDescTypeDef *pcfg;
;;;362      uint8_t if_ix = 0U;
000008  2100              MOVS     r1,#0
;;;363    
;;;364      pif = (USBH_InterfaceDescTypeDef *)0;
00000a  2200              MOVS     r2,#0
;;;365      pcfg = &phost->device.CfgDesc;
00000c  f503764e          ADD      r6,r3,#0x338
;;;366    
;;;367      while (if_ix < USBH_MAX_NUM_INTERFACES)
000010  e011              B        |L4.54|
                  |L4.18|
;;;368      {
;;;369        pif = &pcfg->Itf_Desc[if_ix];
000012  eb010081          ADD      r0,r1,r1,LSL #2
000016  eb0007c1          ADD      r7,r0,r1,LSL #3
00001a  f106000a          ADD      r0,r6,#0xa
00001e  eb000247          ADD      r2,r0,r7,LSL #1
;;;370        if ((pif->bInterfaceNumber == interface_number) && (pif->bAlternateSetting == alt_settings))
000022  7890              LDRB     r0,[r2,#2]
000024  42a0              CMP      r0,r4
000026  d104              BNE      |L4.50|
000028  78d0              LDRB     r0,[r2,#3]
00002a  42a8              CMP      r0,r5
00002c  d101              BNE      |L4.50|
;;;371        {
;;;372          return  if_ix;
00002e  4608              MOV      r0,r1
                  |L4.48|
;;;373        }
;;;374        if_ix++;
;;;375      }
;;;376      return 0xFFU;
;;;377    }
000030  bdf0              POP      {r4-r7,pc}
                  |L4.50|
000032  1c48              ADDS     r0,r1,#1              ;374
000034  b2c1              UXTB     r1,r0                 ;374
                  |L4.54|
000036  2902              CMP      r1,#2                 ;367
000038  d3eb              BCC      |L4.18|
00003a  20ff              MOVS     r0,#0xff              ;376
00003c  e7f8              B        |L4.48|
;;;378    
                          ENDP


                          AREA ||i.USBH_GetActiveClass||, CODE, READONLY, ALIGN=1

                  USBH_GetActiveClass PROC
;;;308      */
;;;309    uint8_t USBH_GetActiveClass(USBH_HandleTypeDef *phost)
000000  4601              MOV      r1,r0
;;;310    {
;;;311      return (phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass);
000002  f8910347          LDRB     r0,[r1,#0x347]
;;;312    }
000006  4770              BX       lr
;;;313    
                          ENDP


                          AREA ||i.USBH_HandleEnum||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  USBH_HandleEnum PROC
;;;815      */
;;;816    static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
000000  b5fe              PUSH     {r1-r7,lr}
;;;817    {
000002  4604              MOV      r4,r0
;;;818      USBH_StatusTypeDef Status = USBH_BUSY;
000004  2601              MOVS     r6,#1
;;;819      USBH_StatusTypeDef ReqStatus = USBH_BUSY;
000006  2501              MOVS     r5,#1
;;;820    
;;;821      switch (phost->EnumState)
000008  7860              LDRB     r0,[r4,#1]
00000a  2808              CMP      r0,#8
00000c  d275              BCS      |L6.250|
00000e  e8dff000          TBB      [pc,r0]
000012  0457              DCB      0x04,0x57
000014  a2f5f3f2          DCB      0xa2,0xf5,0xf3,0xf2
000018  f1f0              DCB      0xf1,0xf0
;;;822      {
;;;823        case ENUM_IDLE:
;;;824          /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
;;;825          ReqStatus = USBH_Get_DevDesc(phost, 8U);
00001a  2108              MOVS     r1,#8
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       USBH_Get_DevDesc
000022  4605              MOV      r5,r0
;;;826          if (ReqStatus == USBH_OK)
000024  bb05              CBNZ     r5,|L6.104|
;;;827          {
;;;828            phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
000026  f894132d          LDRB     r1,[r4,#0x32d]
00002a  71a1              STRB     r1,[r4,#6]
;;;829    
;;;830            phost->EnumState = ENUM_GET_FULL_DEV_DESC;
00002c  2001              MOVS     r0,#1
00002e  7060              STRB     r0,[r4,#1]
;;;831    
;;;832            /* modify control channels configuration for MaxPacket size */
;;;833            USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
000030  79a0              LDRB     r0,[r4,#6]
000032  2200              MOVS     r2,#0
000034  f894131d          LDRB     r1,[r4,#0x31d]
000038  e9cd1200          STRD     r1,r2,[sp,#0]
00003c  9002              STR      r0,[sp,#8]
00003e  f894331c          LDRB     r3,[r4,#0x31c]
000042  7921              LDRB     r1,[r4,#4]
000044  2280              MOVS     r2,#0x80
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       USBH_OpenPipe
;;;834                          phost->device.speed, USBH_EP_CONTROL,
;;;835                          (uint16_t)phost->Control.pipe_size);
;;;836    
;;;837            /* Open Control pipes */
;;;838            USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
00004c  79a0              LDRB     r0,[r4,#6]
00004e  2200              MOVS     r2,#0
000050  f894131d          LDRB     r1,[r4,#0x31d]
000054  e9cd1200          STRD     r1,r2,[sp,#0]
000058  9002              STR      r0,[sp,#8]
00005a  f894331c          LDRB     r3,[r4,#0x31c]
00005e  7961              LDRB     r1,[r4,#5]
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       USBH_OpenPipe
000066  e02a              B        |L6.190|
                  |L6.104|
;;;839                          phost->device.speed, USBH_EP_CONTROL,
;;;840                          (uint16_t)phost->Control.pipe_size);
;;;841          }
;;;842          else if (ReqStatus == USBH_NOT_SUPPORTED)
000068  2d03              CMP      r5,#3
00006a  d128              BNE      |L6.190|
;;;843          {
;;;844            USBH_ErrLog("Control error: Get Device Descriptor request failed");
00006c  bf00              NOP      
00006e  a0e5              ADR      r0,|L6.1028|
000070  f7fffffe          BL       __2printf
000074  a0e5              ADR      r0,|L6.1036|
000076  f7fffffe          BL       __2printf
00007a  a0f1              ADR      r0,|L6.1088|
00007c  f7fffffe          BL       __2printf
000080  bf00              NOP      
;;;845            phost->device.EnumCnt++;
000082  f894031e          LDRB     r0,[r4,#0x31e]
000086  1c40              ADDS     r0,r0,#1
000088  f884031e          STRB     r0,[r4,#0x31e]
;;;846            if (phost->device.EnumCnt > 3U)
00008c  f894031e          LDRB     r0,[r4,#0x31e]
000090  2803              CMP      r0,#3
000092  d90a              BLS      |L6.170|
;;;847            {
;;;848              /* Buggy Device can't complete get device desc request */
;;;849              USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
000094  bf00              NOP      
000096  a0eb              ADR      r0,|L6.1092|
000098  f7fffffe          BL       __2printf
00009c  a0e8              ADR      r0,|L6.1088|
00009e  f7fffffe          BL       __2printf
0000a2  bf00              NOP      
;;;850              phost->gState = HOST_ABORT_STATE;
0000a4  200d              MOVS     r0,#0xd
0000a6  7020              STRB     r0,[r4,#0]
0000a8  e009              B        |L6.190|
                  |L6.170|
;;;851            }
;;;852            else
;;;853            {
;;;854              /* free control pipes */
;;;855              USBH_FreePipe(phost, phost->Control.pipe_out);
0000aa  7961              LDRB     r1,[r4,#5]
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       USBH_FreePipe
;;;856              USBH_FreePipe(phost, phost->Control.pipe_in);
0000b2  7921              LDRB     r1,[r4,#4]
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       USBH_FreePipe
;;;857    
;;;858              /* Reset the USB Device */
;;;859              phost->gState = HOST_IDLE;
0000ba  2000              MOVS     r0,#0
0000bc  7020              STRB     r0,[r4,#0]
                  |L6.190|
;;;860            }
;;;861          }
;;;862          else
;;;863          {
;;;864            /* .. */
;;;865          }
;;;866          break;
0000be  e19e              B        |L6.1022|
;;;867    
;;;868        case ENUM_GET_FULL_DEV_DESC:
;;;869          /* Get FULL Device Desc  */
;;;870          ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
0000c0  2112              MOVS     r1,#0x12
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       USBH_Get_DevDesc
0000c8  4605              MOV      r5,r0
;;;871          if (ReqStatus == USBH_OK)
0000ca  b9bd              CBNZ     r5,|L6.252|
;;;872          {
;;;873            USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct);
0000cc  bf00              NOP      
0000ce  f8b41330          LDRH     r1,[r4,#0x330]
0000d2  a0ec              ADR      r0,|L6.1156|
0000d4  f7fffffe          BL       __2printf
0000d8  a0d9              ADR      r0,|L6.1088|
0000da  f7fffffe          BL       __2printf
0000de  bf00              NOP      
;;;874            USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor);
0000e0  bf00              NOP      
0000e2  f8b4132e          LDRH     r1,[r4,#0x32e]
0000e6  a0ea              ADR      r0,|L6.1168|
0000e8  f7fffffe          BL       __2printf
0000ec  a0d4              ADR      r0,|L6.1088|
0000ee  f7fffffe          BL       __2printf
0000f2  bf00              NOP      
;;;875    
;;;876            phost->EnumState = ENUM_SET_ADDR;
0000f4  2002              MOVS     r0,#2
0000f6  7060              STRB     r0,[r4,#1]
0000f8  e02c              B        |L6.340|
                  |L6.250|
0000fa  e17f              B        |L6.1020|
                  |L6.252|
;;;877          }
;;;878          else if (ReqStatus == USBH_NOT_SUPPORTED)
0000fc  2d03              CMP      r5,#3
0000fe  d129              BNE      |L6.340|
;;;879          {
;;;880            USBH_ErrLog("Control error: Get Full Device Descriptor request failed");
000100  bf00              NOP      
000102  a0c0              ADR      r0,|L6.1028|
000104  f7fffffe          BL       __2printf
000108  a0e4              ADR      r0,|L6.1180|
00010a  f7fffffe          BL       __2printf
00010e  a0cc              ADR      r0,|L6.1088|
000110  f7fffffe          BL       __2printf
000114  bf00              NOP      
;;;881            phost->device.EnumCnt++;
000116  f894031e          LDRB     r0,[r4,#0x31e]
00011a  1c40              ADDS     r0,r0,#1
00011c  f884031e          STRB     r0,[r4,#0x31e]
;;;882            if (phost->device.EnumCnt > 3U)
000120  f894031e          LDRB     r0,[r4,#0x31e]
000124  2803              CMP      r0,#3
000126  d90a              BLS      |L6.318|
;;;883            {
;;;884              /* Buggy Device can't complete get device desc request */
;;;885              USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
000128  bf00              NOP      
00012a  a0c6              ADR      r0,|L6.1092|
00012c  f7fffffe          BL       __2printf
000130  a0c3              ADR      r0,|L6.1088|
000132  f7fffffe          BL       __2printf
000136  bf00              NOP      
;;;886              phost->gState = HOST_ABORT_STATE;
000138  200d              MOVS     r0,#0xd
00013a  7020              STRB     r0,[r4,#0]
00013c  e00a              B        |L6.340|
                  |L6.318|
;;;887            }
;;;888            else
;;;889            {
;;;890              /* Free control pipes */
;;;891              USBH_FreePipe(phost, phost->Control.pipe_out);
00013e  7961              LDRB     r1,[r4,#5]
000140  4620              MOV      r0,r4
000142  f7fffffe          BL       USBH_FreePipe
;;;892              USBH_FreePipe(phost, phost->Control.pipe_in);
000146  7921              LDRB     r1,[r4,#4]
000148  4620              MOV      r0,r4
00014a  f7fffffe          BL       USBH_FreePipe
;;;893    
;;;894              /* Reset the USB Device */
;;;895              phost->EnumState = ENUM_IDLE;
00014e  2000              MOVS     r0,#0
000150  7060              STRB     r0,[r4,#1]
;;;896              phost->gState = HOST_IDLE;
000152  7020              STRB     r0,[r4,#0]
                  |L6.340|
;;;897            }
;;;898          }
;;;899          else
;;;900          {
;;;901            /* .. */
;;;902          }
;;;903          break;
000154  e153              B        |L6.1022|
;;;904    
;;;905        case ENUM_SET_ADDR:
;;;906          /* set address */
;;;907          ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
000156  2101              MOVS     r1,#1
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       USBH_SetAddress
00015e  4605              MOV      r5,r0
;;;908          if (ReqStatus == USBH_OK)
000160  bb6d              CBNZ     r5,|L6.446|
;;;909          {
;;;910            USBH_Delay(2U);
000162  2002              MOVS     r0,#2
000164  f7fffffe          BL       USBH_Delay
;;;911            phost->device.address = USBH_DEVICE_ADDRESS;
000168  2101              MOVS     r1,#1
00016a  f884131c          STRB     r1,[r4,#0x31c]
;;;912    
;;;913            /* user callback for device address assigned */
;;;914            USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
00016e  bf00              NOP      
000170  f894131c          LDRB     r1,[r4,#0x31c]
000174  a0d8              ADR      r0,|L6.1240|
000176  f7fffffe          BL       __2printf
00017a  a0b1              ADR      r0,|L6.1088|
00017c  f7fffffe          BL       __2printf
000180  bf00              NOP      
;;;915            phost->EnumState = ENUM_GET_CFG_DESC;
000182  2003              MOVS     r0,#3
000184  7060              STRB     r0,[r4,#1]
;;;916    
;;;917            /* modify control channels to update device address */
;;;918            USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
000186  79a0              LDRB     r0,[r4,#6]
000188  2200              MOVS     r2,#0
00018a  f894131d          LDRB     r1,[r4,#0x31d]
00018e  e9cd1200          STRD     r1,r2,[sp,#0]
000192  9002              STR      r0,[sp,#8]
000194  f894331c          LDRB     r3,[r4,#0x31c]
000198  7921              LDRB     r1,[r4,#4]
00019a  2280              MOVS     r2,#0x80
00019c  4620              MOV      r0,r4
00019e  f7fffffe          BL       USBH_OpenPipe
;;;919                          phost->device.speed, USBH_EP_CONTROL,
;;;920                          (uint16_t)phost->Control.pipe_size);
;;;921    
;;;922            /* Open Control pipes */
;;;923            USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
0001a2  79a0              LDRB     r0,[r4,#6]
0001a4  2200              MOVS     r2,#0
0001a6  f894131d          LDRB     r1,[r4,#0x31d]
0001aa  e9cd1200          STRD     r1,r2,[sp,#0]
0001ae  9002              STR      r0,[sp,#8]
0001b0  f894331c          LDRB     r3,[r4,#0x31c]
0001b4  7961              LDRB     r1,[r4,#5]
0001b6  4620              MOV      r0,r4
0001b8  f7fffffe          BL       USBH_OpenPipe
0001bc  e018              B        |L6.496|
                  |L6.446|
;;;924                          phost->device.speed, USBH_EP_CONTROL,
;;;925                          (uint16_t)phost->Control.pipe_size);
;;;926          }
;;;927          else if (ReqStatus == USBH_NOT_SUPPORTED)
0001be  2d03              CMP      r5,#3
0001c0  d116              BNE      |L6.496|
;;;928          {
;;;929            USBH_ErrLog("Control error: Device Set Address request failed");
0001c2  bf00              NOP      
0001c4  a08f              ADR      r0,|L6.1028|
0001c6  f7fffffe          BL       __2printf
0001ca  a0c9              ADR      r0,|L6.1264|
0001cc  f7fffffe          BL       __2printf
0001d0  a09b              ADR      r0,|L6.1088|
0001d2  f7fffffe          BL       __2printf
0001d6  bf00              NOP      
;;;930    
;;;931            /* Buggy Device can't complete get device desc request */
;;;932            USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
0001d8  bf00              NOP      
0001da  a09a              ADR      r0,|L6.1092|
0001dc  f7fffffe          BL       __2printf
0001e0  a097              ADR      r0,|L6.1088|
0001e2  f7fffffe          BL       __2printf
0001e6  bf00              NOP      
;;;933            phost->gState = HOST_ABORT_STATE;
0001e8  200d              MOVS     r0,#0xd
0001ea  7020              STRB     r0,[r4,#0]
;;;934            phost->EnumState = ENUM_IDLE;
0001ec  2000              MOVS     r0,#0
0001ee  7060              STRB     r0,[r4,#1]
                  |L6.496|
;;;935          }
;;;936          else
;;;937          {
;;;938            /* .. */
;;;939          }
;;;940          break;
0001f0  e105              B        |L6.1022|
0001f2  e0d4              B        |L6.926|
0001f4  e0a1              B        |L6.826|
0001f6  e06e              B        |L6.726|
0001f8  e036              B        |L6.616|
0001fa  e7ff              B        |L6.508|
                  |L6.508|
;;;941    
;;;942        case ENUM_GET_CFG_DESC:
;;;943          /* get standard configuration descriptor */
;;;944          ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
0001fc  2109              MOVS     r1,#9
0001fe  4620              MOV      r0,r4
000200  f7fffffe          BL       USBH_Get_CfgDesc
000204  4605              MOV      r5,r0
;;;945          if (ReqStatus == USBH_OK)
000206  b915              CBNZ     r5,|L6.526|
;;;946          {
;;;947            phost->EnumState = ENUM_GET_FULL_CFG_DESC;
000208  2004              MOVS     r0,#4
00020a  7060              STRB     r0,[r4,#1]
00020c  e02b              B        |L6.614|
                  |L6.526|
;;;948          }
;;;949          else if (ReqStatus == USBH_NOT_SUPPORTED)
00020e  2d03              CMP      r5,#3
000210  d129              BNE      |L6.614|
;;;950          {
;;;951            USBH_ErrLog("Control error: Get Device configuration descriptor request failed");
000212  bf00              NOP      
000214  a07b              ADR      r0,|L6.1028|
000216  f7fffffe          BL       __2printf
00021a  48c2              LDR      r0,|L6.1316|
00021c  f7fffffe          BL       __2printf
000220  a087              ADR      r0,|L6.1088|
000222  f7fffffe          BL       __2printf
000226  bf00              NOP      
;;;952            phost->device.EnumCnt++;
000228  f894031e          LDRB     r0,[r4,#0x31e]
00022c  1c40              ADDS     r0,r0,#1
00022e  f884031e          STRB     r0,[r4,#0x31e]
;;;953            if (phost->device.EnumCnt > 3U)
000232  f894031e          LDRB     r0,[r4,#0x31e]
000236  2803              CMP      r0,#3
000238  d90a              BLS      |L6.592|
;;;954            {
;;;955              /* Buggy Device can't complete get device desc request */
;;;956              USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
00023a  bf00              NOP      
00023c  a081              ADR      r0,|L6.1092|
00023e  f7fffffe          BL       __2printf
000242  a07f              ADR      r0,|L6.1088|
000244  f7fffffe          BL       __2printf
000248  bf00              NOP      
;;;957              phost->gState = HOST_ABORT_STATE;
00024a  200d              MOVS     r0,#0xd
00024c  7020              STRB     r0,[r4,#0]
00024e  e00a              B        |L6.614|
                  |L6.592|
;;;958            }
;;;959            else
;;;960            {
;;;961              /* Free control pipes */
;;;962              USBH_FreePipe(phost, phost->Control.pipe_out);
000250  7961              LDRB     r1,[r4,#5]
000252  4620              MOV      r0,r4
000254  f7fffffe          BL       USBH_FreePipe
;;;963              USBH_FreePipe(phost, phost->Control.pipe_in);
000258  7921              LDRB     r1,[r4,#4]
00025a  4620              MOV      r0,r4
00025c  f7fffffe          BL       USBH_FreePipe
;;;964    
;;;965              /* Reset the USB Device */
;;;966              phost->EnumState = ENUM_IDLE;
000260  2000              MOVS     r0,#0
000262  7060              STRB     r0,[r4,#1]
;;;967              phost->gState = HOST_IDLE;
000264  7020              STRB     r0,[r4,#0]
                  |L6.614|
;;;968            }
;;;969          }
;;;970          else
;;;971          {
;;;972            /* .. */
;;;973          }
;;;974          break;
000266  e0ca              B        |L6.1022|
                  |L6.616|
;;;975    
;;;976        case ENUM_GET_FULL_CFG_DESC:
;;;977          /* get FULL config descriptor (config, interface, endpoints) */
;;;978          ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
000268  f8b4133a          LDRH     r1,[r4,#0x33a]
00026c  4620              MOV      r0,r4
00026e  f7fffffe          BL       USBH_Get_CfgDesc
000272  4605              MOV      r5,r0
;;;979          if (ReqStatus == USBH_OK)
000274  b915              CBNZ     r5,|L6.636|
;;;980          {
;;;981            phost->EnumState = ENUM_GET_MFC_STRING_DESC;
000276  2005              MOVS     r0,#5
000278  7060              STRB     r0,[r4,#1]
00027a  e02b              B        |L6.724|
                  |L6.636|
;;;982          }
;;;983          else if (ReqStatus == USBH_NOT_SUPPORTED)
00027c  2d03              CMP      r5,#3
00027e  d129              BNE      |L6.724|
;;;984          {
;;;985            USBH_ErrLog("Control error: Get Device configuration descriptor request failed");
000280  bf00              NOP      
000282  a060              ADR      r0,|L6.1028|
000284  f7fffffe          BL       __2printf
000288  48a6              LDR      r0,|L6.1316|
00028a  f7fffffe          BL       __2printf
00028e  a06c              ADR      r0,|L6.1088|
000290  f7fffffe          BL       __2printf
000294  bf00              NOP      
;;;986            phost->device.EnumCnt++;
000296  f894031e          LDRB     r0,[r4,#0x31e]
00029a  1c40              ADDS     r0,r0,#1
00029c  f884031e          STRB     r0,[r4,#0x31e]
;;;987            if (phost->device.EnumCnt > 3U)
0002a0  f894031e          LDRB     r0,[r4,#0x31e]
0002a4  2803              CMP      r0,#3
0002a6  d90a              BLS      |L6.702|
;;;988            {
;;;989              /* Buggy Device can't complete get device desc request */
;;;990              USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
0002a8  bf00              NOP      
0002aa  a066              ADR      r0,|L6.1092|
0002ac  f7fffffe          BL       __2printf
0002b0  a063              ADR      r0,|L6.1088|
0002b2  f7fffffe          BL       __2printf
0002b6  bf00              NOP      
;;;991              phost->gState = HOST_ABORT_STATE;
0002b8  200d              MOVS     r0,#0xd
0002ba  7020              STRB     r0,[r4,#0]
0002bc  e00a              B        |L6.724|
                  |L6.702|
;;;992            }
;;;993            else
;;;994            {
;;;995              /* Free control pipes */
;;;996              USBH_FreePipe(phost, phost->Control.pipe_out);
0002be  7961              LDRB     r1,[r4,#5]
0002c0  4620              MOV      r0,r4
0002c2  f7fffffe          BL       USBH_FreePipe
;;;997              USBH_FreePipe(phost, phost->Control.pipe_in);
0002c6  7921              LDRB     r1,[r4,#4]
0002c8  4620              MOV      r0,r4
0002ca  f7fffffe          BL       USBH_FreePipe
;;;998    
;;;999              /* Reset the USB Device */
;;;1000             phost->EnumState = ENUM_IDLE;
0002ce  2000              MOVS     r0,#0
0002d0  7060              STRB     r0,[r4,#1]
;;;1001             phost->gState = HOST_IDLE;
0002d2  7020              STRB     r0,[r4,#0]
                  |L6.724|
;;;1002           }
;;;1003         }
;;;1004         else
;;;1005         {
;;;1006           /* .. */
;;;1007         }
;;;1008         break;
0002d4  e093              B        |L6.1022|
                  |L6.726|
;;;1009   
;;;1010       case ENUM_GET_MFC_STRING_DESC:
;;;1011         if (phost->device.DevDesc.iManufacturer != 0U)
0002d6  f8940334          LDRB     r0,[r4,#0x334]
0002da  b318              CBZ      r0,|L6.804|
;;;1012         {
;;;1013           /* Check that Manufacturer String is available */
;;;1014           ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
0002dc  f8941334          LDRB     r1,[r4,#0x334]
0002e0  23ff              MOVS     r3,#0xff
0002e2  f504728e          ADD      r2,r4,#0x11c
0002e6  4620              MOV      r0,r4
0002e8  f7fffffe          BL       USBH_Get_StringDesc
0002ec  4605              MOV      r5,r0
;;;1015                                           phost->device.Data, 0xFFU);
;;;1016           if (ReqStatus == USBH_OK)
0002ee  b965              CBNZ     r5,|L6.778|
;;;1017           {
;;;1018             /* User callback for Manufacturing string */
;;;1019             USBH_UsrLog("Manufacturer : %s", (char *)(void *)phost->device.Data);
0002f0  bf00              NOP      
0002f2  f504718e          ADD      r1,r4,#0x11c
0002f6  a08c              ADR      r0,|L6.1320|
0002f8  f7fffffe          BL       __2printf
0002fc  a050              ADR      r0,|L6.1088|
0002fe  f7fffffe          BL       __2printf
000302  bf00              NOP      
;;;1020             phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000304  2006              MOVS     r0,#6
000306  7060              STRB     r0,[r4,#1]
000308  e016              B        |L6.824|
                  |L6.778|
;;;1021   
;;;1022   #if (USBH_USE_OS == 1U)
;;;1023             phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;1024   #if (osCMSIS < 0x20000U)
;;;1025             (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1026   #else
;;;1027             (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1028   #endif
;;;1029   #endif
;;;1030           }
;;;1031           else if (ReqStatus == USBH_NOT_SUPPORTED)
00030a  2d03              CMP      r5,#3
00030c  d114              BNE      |L6.824|
;;;1032           {
;;;1033             USBH_UsrLog("Manufacturer : N/A");
00030e  bf00              NOP      
000310  a08a              ADR      r0,|L6.1340|
000312  f7fffffe          BL       __2printf
000316  a04a              ADR      r0,|L6.1088|
000318  f7fffffe          BL       __2printf
00031c  bf00              NOP      
;;;1034             phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
00031e  2006              MOVS     r0,#6
000320  7060              STRB     r0,[r4,#1]
000322  e009              B        |L6.824|
                  |L6.804|
;;;1035   
;;;1036   #if (USBH_USE_OS == 1U)
;;;1037             phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;1038   #if (osCMSIS < 0x20000U)
;;;1039             (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1040   #else
;;;1041             (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1042   #endif
;;;1043   #endif
;;;1044           }
;;;1045           else
;;;1046           {
;;;1047             /* .. */
;;;1048           }
;;;1049         }
;;;1050         else
;;;1051         {
;;;1052           USBH_UsrLog("Manufacturer : N/A");
000324  bf00              NOP      
000326  a085              ADR      r0,|L6.1340|
000328  f7fffffe          BL       __2printf
00032c  a044              ADR      r0,|L6.1088|
00032e  f7fffffe          BL       __2printf
000332  bf00              NOP      
;;;1053           phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000334  2006              MOVS     r0,#6
000336  7060              STRB     r0,[r4,#1]
                  |L6.824|
;;;1054   
;;;1055   #if (USBH_USE_OS == 1U)
;;;1056           phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;1057   #if (osCMSIS < 0x20000U)
;;;1058           (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1059   #else
;;;1060           (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1061   #endif
;;;1062   #endif
;;;1063         }
;;;1064         break;
000338  e061              B        |L6.1022|
                  |L6.826|
;;;1065   
;;;1066       case ENUM_GET_PRODUCT_STRING_DESC:
;;;1067         if (phost->device.DevDesc.iProduct != 0U)
00033a  f8940335          LDRB     r0,[r4,#0x335]
00033e  b318              CBZ      r0,|L6.904|
;;;1068         {
;;;1069           /* Check that Product string is available */
;;;1070           ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
000340  f8941335          LDRB     r1,[r4,#0x335]
000344  23ff              MOVS     r3,#0xff
000346  f504728e          ADD      r2,r4,#0x11c
00034a  4620              MOV      r0,r4
00034c  f7fffffe          BL       USBH_Get_StringDesc
000350  4605              MOV      r5,r0
;;;1071                                           phost->device.Data, 0xFFU);
;;;1072           if (ReqStatus == USBH_OK)
000352  b965              CBNZ     r5,|L6.878|
;;;1073           {
;;;1074             /* User callback for Product string */
;;;1075             USBH_UsrLog("Product : %s", (char *)(void *)phost->device.Data);
000354  bf00              NOP      
000356  f504718e          ADD      r1,r4,#0x11c
00035a  a07d              ADR      r0,|L6.1360|
00035c  f7fffffe          BL       __2printf
000360  a037              ADR      r0,|L6.1088|
000362  f7fffffe          BL       __2printf
000366  bf00              NOP      
;;;1076             phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000368  2007              MOVS     r0,#7
00036a  7060              STRB     r0,[r4,#1]
00036c  e016              B        |L6.924|
                  |L6.878|
;;;1077           }
;;;1078           else if (ReqStatus == USBH_NOT_SUPPORTED)
00036e  2d03              CMP      r5,#3
000370  d114              BNE      |L6.924|
;;;1079           {
;;;1080             USBH_UsrLog("Product : N/A");
000372  bf00              NOP      
000374  a07a              ADR      r0,|L6.1376|
000376  f7fffffe          BL       __2printf
00037a  a031              ADR      r0,|L6.1088|
00037c  f7fffffe          BL       __2printf
000380  bf00              NOP      
;;;1081             phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000382  2007              MOVS     r0,#7
000384  7060              STRB     r0,[r4,#1]
000386  e009              B        |L6.924|
                  |L6.904|
;;;1082   
;;;1083   #if (USBH_USE_OS == 1U)
;;;1084             phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;1085   #if (osCMSIS < 0x20000U)
;;;1086             (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1087   #else
;;;1088             (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1089   #endif
;;;1090   #endif
;;;1091           }
;;;1092           else
;;;1093           {
;;;1094             /* .. */
;;;1095           }
;;;1096         }
;;;1097         else
;;;1098         {
;;;1099           USBH_UsrLog("Product : N/A");
000388  bf00              NOP      
00038a  a075              ADR      r0,|L6.1376|
00038c  f7fffffe          BL       __2printf
000390  a02b              ADR      r0,|L6.1088|
000392  f7fffffe          BL       __2printf
000396  bf00              NOP      
;;;1100           phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000398  2007              MOVS     r0,#7
00039a  7060              STRB     r0,[r4,#1]
                  |L6.924|
;;;1101   
;;;1102   #if (USBH_USE_OS == 1U)
;;;1103           phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;1104   #if (osCMSIS < 0x20000U)
;;;1105           (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1106   #else
;;;1107           (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1108   #endif
;;;1109   #endif
;;;1110         }
;;;1111         break;
00039c  e02f              B        |L6.1022|
                  |L6.926|
;;;1112   
;;;1113       case ENUM_GET_SERIALNUM_STRING_DESC:
;;;1114         if (phost->device.DevDesc.iSerialNumber != 0U)
00039e  f8940336          LDRB     r0,[r4,#0x336]
0003a2  b308              CBZ      r0,|L6.1000|
;;;1115         {
;;;1116           /* Check that Serial number string is available */
;;;1117           ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
0003a4  f8941336          LDRB     r1,[r4,#0x336]
0003a8  23ff              MOVS     r3,#0xff
0003aa  f504728e          ADD      r2,r4,#0x11c
0003ae  4620              MOV      r0,r4
0003b0  f7fffffe          BL       USBH_Get_StringDesc
0003b4  4605              MOV      r5,r0
;;;1118                                           phost->device.Data, 0xFFU);
;;;1119           if (ReqStatus == USBH_OK)
0003b6  b95d              CBNZ     r5,|L6.976|
;;;1120           {
;;;1121             /* User callback for Serial number string */
;;;1122             USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
0003b8  bf00              NOP      
0003ba  f504718e          ADD      r1,r4,#0x11c
0003be  a06c              ADR      r0,|L6.1392|
0003c0  f7fffffe          BL       __2printf
0003c4  a01e              ADR      r0,|L6.1088|
0003c6  f7fffffe          BL       __2printf
0003ca  bf00              NOP      
;;;1123             Status = USBH_OK;
0003cc  2600              MOVS     r6,#0
0003ce  e014              B        |L6.1018|
                  |L6.976|
;;;1124           }
;;;1125           else if (ReqStatus == USBH_NOT_SUPPORTED)
0003d0  2d03              CMP      r5,#3
0003d2  d112              BNE      |L6.1018|
;;;1126           {
;;;1127             USBH_UsrLog("Serial Number : N/A");
0003d4  bf00              NOP      
0003d6  a06b              ADR      r0,|L6.1412|
0003d8  f7fffffe          BL       __2printf
0003dc  a018              ADR      r0,|L6.1088|
0003de  f7fffffe          BL       __2printf
0003e2  bf00              NOP      
;;;1128             Status = USBH_OK;
0003e4  2600              MOVS     r6,#0
0003e6  e008              B        |L6.1018|
                  |L6.1000|
;;;1129           }
;;;1130           else
;;;1131           {
;;;1132             /* .. */
;;;1133           }
;;;1134         }
;;;1135         else
;;;1136         {
;;;1137           USBH_UsrLog("Serial Number : N/A");
0003e8  bf00              NOP      
0003ea  a066              ADR      r0,|L6.1412|
0003ec  f7fffffe          BL       __2printf
0003f0  a013              ADR      r0,|L6.1088|
0003f2  f7fffffe          BL       __2printf
0003f6  bf00              NOP      
;;;1138           Status = USBH_OK;
0003f8  2600              MOVS     r6,#0
                  |L6.1018|
;;;1139         }
;;;1140         break;
0003fa  e000              B        |L6.1022|
                  |L6.1020|
;;;1141   
;;;1142       default:
;;;1143         break;
0003fc  bf00              NOP      
                  |L6.1022|
0003fe  bf00              NOP                            ;866
;;;1144     }
;;;1145     return Status;
000400  4630              MOV      r0,r6
;;;1146   }
000402  bdfe              POP      {r1-r7,pc}
;;;1147   
                          ENDP

                  |L6.1028|
000404  4552524f          DCB      "ERROR: ",0
000408  523a2000
                  |L6.1036|
00040c  436f6e74          DCB      "Control error: Get Device Descriptor request failed",0
000410  726f6c20
000414  6572726f
000418  723a2047
00041c  65742044
000420  65766963
000424  65204465
000428  73637269
00042c  70746f72
000430  20726571
000434  75657374
000438  20666169
00043c  6c656400
                  |L6.1088|
000440  0a00              DCB      "\n",0
000442  00                DCB      0
000443  00                DCB      0
                  |L6.1092|
000444  436f6e74          DCB      "Control error, Device not Responding Please unplug the "
000448  726f6c20
00044c  6572726f
000450  722c2044
000454  65766963
000458  65206e6f
00045c  74205265
000460  73706f6e
000464  64696e67
000468  20506c65
00046c  61736520
000470  756e706c
000474  75672074
000478  686520  
00047b  44657669          DCB      "Device.",0
00047f  63652e00
000483  00                DCB      0
                  |L6.1156|
000484  5049443a          DCB      "PID: %xh",0
000488  20257868
00048c  00      
00048d  00                DCB      0
00048e  00                DCB      0
00048f  00                DCB      0
                  |L6.1168|
000490  5649443a          DCB      "VID: %xh",0
000494  20257868
000498  00      
000499  00                DCB      0
00049a  00                DCB      0
00049b  00                DCB      0
                  |L6.1180|
00049c  436f6e74          DCB      "Control error: Get Full Device Descriptor request faile"
0004a0  726f6c20
0004a4  6572726f
0004a8  723a2047
0004ac  65742046
0004b0  756c6c20
0004b4  44657669
0004b8  63652044
0004bc  65736372
0004c0  6970746f
0004c4  72207265
0004c8  71756573
0004cc  74206661
0004d0  696c65  
0004d3  6400              DCB      "d",0
0004d5  00                DCB      0
0004d6  00                DCB      0
0004d7  00                DCB      0
                  |L6.1240|
0004d8  41646472          DCB      "Address (#%d) assigned.",0
0004dc  65737320
0004e0  28232564
0004e4  29206173
0004e8  7369676e
0004ec  65642e00
                  |L6.1264|
0004f0  436f6e74          DCB      "Control error: Device Set Address request failed",0
0004f4  726f6c20
0004f8  6572726f
0004fc  723a2044
000500  65766963
000504  65205365
000508  74204164
00050c  64726573
000510  73207265
000514  71756573
000518  74206661
00051c  696c6564
000520  00      
000521  00                DCB      0
000522  00                DCB      0
000523  00                DCB      0
                  |L6.1316|
                          DCD      ||.conststring||
                  |L6.1320|
000528  4d616e75          DCB      "Manufacturer : %s",0
00052c  66616374
000530  75726572
000534  203a2025
000538  7300    
00053a  00                DCB      0
00053b  00                DCB      0
                  |L6.1340|
00053c  4d616e75          DCB      "Manufacturer : N/A",0
000540  66616374
000544  75726572
000548  203a204e
00054c  2f4100  
00054f  00                DCB      0
                  |L6.1360|
000550  50726f64          DCB      "Product : %s",0
000554  75637420
000558  3a202573
00055c  00      
00055d  00                DCB      0
00055e  00                DCB      0
00055f  00                DCB      0
                  |L6.1376|
000560  50726f64          DCB      "Product : N/A",0
000564  75637420
000568  3a204e2f
00056c  4100    
00056e  00                DCB      0
00056f  00                DCB      0
                  |L6.1392|
000570  53657269          DCB      "Serial Number : %s",0
000574  616c204e
000578  756d6265
00057c  72203a20
000580  257300  
000583  00                DCB      0
                  |L6.1412|
000584  53657269          DCB      "Serial Number : N/A",0
000588  616c204e
00058c  756d6265
000590  72203a20
000594  4e2f4100

                          AREA ||i.USBH_HandleSof||, CODE, READONLY, ALIGN=1

                  USBH_HandleSof PROC
;;;1179     */
;;;1180   static void  USBH_HandleSof(USBH_HandleTypeDef *phost)
000000  b510              PUSH     {r4,lr}
;;;1181   {
000002  4604              MOV      r4,r0
;;;1182     if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
000004  7820              LDRB     r0,[r4,#0]
000006  280b              CMP      r0,#0xb
000008  d107              BNE      |L7.26|
00000a  f8d4037c          LDR      r0,[r4,#0x37c]
00000e  b120              CBZ      r0,|L7.26|
;;;1183     {
;;;1184       phost->pActiveClass->SOFProcess(phost);
000010  f8d4037c          LDR      r0,[r4,#0x37c]
000014  6981              LDR      r1,[r0,#0x18]
000016  4620              MOV      r0,r4
000018  4788              BLX      r1
                  |L7.26|
;;;1185     }
;;;1186   }
00001a  bd10              POP      {r4,pc}
;;;1187   
                          ENDP


                          AREA ||i.USBH_Init||, CODE, READONLY, ALIGN=2

                  USBH_Init PROC
;;;95       */
;;;96     USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost,
000000  b570              PUSH     {r4-r6,lr}
;;;97                                   void (*pUsrFunc)(USBH_HandleTypeDef *phost,
;;;98                                   uint8_t id), uint8_t id)
;;;99     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;100      /* Check whether the USB Host handle is valid */
;;;101      if (phost == NULL)
000008  b964              CBNZ     r4,|L8.36|
;;;102      {
;;;103        USBH_ErrLog("Invalid Host handle");
00000a  bf00              NOP      
00000c  a013              ADR      r0,|L8.92|
00000e  f7fffffe          BL       __2printf
000012  a014              ADR      r0,|L8.100|
000014  f7fffffe          BL       __2printf
000018  a017              ADR      r0,|L8.120|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
;;;104        return USBH_FAIL;
000020  2002              MOVS     r0,#2
                  |L8.34|
;;;105      }
;;;106    
;;;107      /* Set DRiver ID */
;;;108      phost->id = id;
;;;109    
;;;110      /* Unlink class*/
;;;111      phost->pActiveClass = NULL;
;;;112      phost->ClassNumber = 0U;
;;;113    
;;;114      /* Restore default states and prepare EP0 */
;;;115      DeInitStateMachine(phost);
;;;116    
;;;117      /* Restore default Device connection states */
;;;118      phost->device.PortEnabled = 0U;
;;;119      phost->device.is_connected = 0U;
;;;120      phost->device.is_disconnected = 0U;
;;;121      phost->device.is_ReEnumerated = 0U;
;;;122    
;;;123      /* Assign User process */
;;;124      if (pUsrFunc != NULL)
;;;125      {
;;;126        phost->pUser = pUsrFunc;
;;;127      }
;;;128    
;;;129    #if (USBH_USE_OS == 1U)
;;;130    #if (osCMSIS < 0x20000U)
;;;131    
;;;132      /* Create USB Host Queue */
;;;133      osMessageQDef(USBH_Queue, MSGQUEUE_OBJECTS, uint16_t);
;;;134      phost->os_event = osMessageCreate(osMessageQ(USBH_Queue), NULL);
;;;135    
;;;136      /* Create USB Host Task */
;;;137    #if defined (USBH_PROCESS_STACK_SIZE)
;;;138      osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0U, USBH_PROCESS_STACK_SIZE);
;;;139    #else
;;;140      osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0U, 8U * configMINIMAL_STACK_SIZE);
;;;141    #endif /* defined (USBH_PROCESS_STACK_SIZE) */
;;;142    
;;;143      phost->thread = osThreadCreate(osThread(USBH_Thread), phost);
;;;144    
;;;145    #else
;;;146    
;;;147      /* Create USB Host Queue */
;;;148      phost->os_event = osMessageQueueNew(MSGQUEUE_OBJECTS, sizeof(uint32_t), NULL);
;;;149    
;;;150      /* Create USB Host Task */
;;;151      USBH_Thread_Atrr.name = "USBH_Queue";
;;;152    
;;;153    #if defined (USBH_PROCESS_STACK_SIZE)
;;;154      USBH_Thread_Atrr.stack_size = USBH_PROCESS_STACK_SIZE;
;;;155    #else
;;;156      USBH_Thread_Atrr.stack_size = (8U * configMINIMAL_STACK_SIZE);
;;;157    #endif /* defined (USBH_PROCESS_STACK_SIZE) */
;;;158    
;;;159      USBH_Thread_Atrr.priority = USBH_PROCESS_PRIO;
;;;160      phost->thread = osThreadNew(USBH_Process_OS, phost, &USBH_Thread_Atrr);
;;;161    
;;;162    #endif /* (osCMSIS < 0x20000U) */
;;;163    #endif /* (USBH_USE_OS == 1U) */
;;;164    
;;;165      /* Initialize low level driver */
;;;166      USBH_LL_Init(phost);
;;;167    
;;;168      return USBH_OK;
;;;169    }
000022  bd70              POP      {r4-r6,pc}
                  |L8.36|
000024  f88463cc          STRB     r6,[r4,#0x3cc]        ;108
000028  2000              MOVS     r0,#0                 ;111
00002a  f8c4037c          STR      r0,[r4,#0x37c]        ;111
00002e  f8c40380          STR      r0,[r4,#0x380]        ;112
000032  4620              MOV      r0,r4                 ;115
000034  f7fffffe          BL       DeInitStateMachine
000038  2100              MOVS     r1,#0                 ;118
00003a  f8841323          STRB     r1,[r4,#0x323]        ;118
00003e  f8841320          STRB     r1,[r4,#0x320]        ;119
000042  f8841321          STRB     r1,[r4,#0x321]        ;120
000046  f8841322          STRB     r1,[r4,#0x322]        ;121
00004a  b10d              CBZ      r5,|L8.80|
00004c  f8c453d4          STR      r5,[r4,#0x3d4]        ;126
                  |L8.80|
000050  4620              MOV      r0,r4                 ;166
000052  f7fffffe          BL       USBH_LL_Init
000056  2000              MOVS     r0,#0                 ;168
000058  e7e3              B        |L8.34|
;;;170    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
00005c  4552524f          DCB      "ERROR: ",0
000060  523a2000
                  |L8.100|
000064  496e7661          DCB      "Invalid Host handle",0
000068  6c696420
00006c  486f7374
000070  2068616e
000074  646c6500
                  |L8.120|
000078  0a00              DCB      "\n",0
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.USBH_IsPortEnabled||, CODE, READONLY, ALIGN=1

                  USBH_IsPortEnabled PROC
;;;1231     */
;;;1232   uint8_t USBH_IsPortEnabled(USBH_HandleTypeDef *phost)
000000  4601              MOV      r1,r0
;;;1233   {
;;;1234     return (phost->device.PortEnabled);
000002  f8910323          LDRB     r0,[r1,#0x323]
;;;1235   }
000006  4770              BX       lr
;;;1236   
                          ENDP


                          AREA ||i.USBH_LL_Connect||, CODE, READONLY, ALIGN=1

                  USBH_LL_Connect PROC
;;;1243     */
;;;1244   USBH_StatusTypeDef  USBH_LL_Connect(USBH_HandleTypeDef *phost)
000000  4601              MOV      r1,r0
;;;1245   {
;;;1246     phost->device.is_connected = 1U;
000002  2201              MOVS     r2,#1
000004  f8812320          STRB     r2,[r1,#0x320]
;;;1247     phost->device.is_disconnected = 0U;
000008  2200              MOVS     r2,#0
00000a  f8812321          STRB     r2,[r1,#0x321]
;;;1248     phost->device.is_ReEnumerated = 0U;
00000e  f8812322          STRB     r2,[r1,#0x322]
;;;1249   
;;;1250   
;;;1251   #if (USBH_USE_OS == 1U)
;;;1252     phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;1253   #if (osCMSIS < 0x20000U)
;;;1254     (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1255   #else
;;;1256     (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1257   #endif
;;;1258   #endif
;;;1259   
;;;1260     return USBH_OK;
000012  2000              MOVS     r0,#0
;;;1261   }
000014  4770              BX       lr
;;;1262   
                          ENDP


                          AREA ||i.USBH_LL_Disconnect||, CODE, READONLY, ALIGN=1

                  USBH_LL_Disconnect PROC
;;;1269     */
;;;1270   USBH_StatusTypeDef  USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
000000  b510              PUSH     {r4,lr}
;;;1271   {
000002  4604              MOV      r4,r0
;;;1272     /* update device connection states */
;;;1273     phost->device.is_disconnected = 1U;
000004  2101              MOVS     r1,#1
000006  f8841321          STRB     r1,[r4,#0x321]
;;;1274     phost->device.is_connected = 0U;
00000a  2100              MOVS     r1,#0
00000c  f8841320          STRB     r1,[r4,#0x320]
;;;1275     phost->device.PortEnabled = 0U;
000010  f8841323          STRB     r1,[r4,#0x323]
;;;1276   
;;;1277     /* Stop Host */
;;;1278     USBH_LL_Stop(phost);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       USBH_LL_Stop
;;;1279   
;;;1280     /* FRee Control Pipes */
;;;1281     USBH_FreePipe(phost, phost->Control.pipe_in);
00001a  7921              LDRB     r1,[r4,#4]
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       USBH_FreePipe
;;;1282     USBH_FreePipe(phost, phost->Control.pipe_out);
000022  7961              LDRB     r1,[r4,#5]
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       USBH_FreePipe
;;;1283   #if (USBH_USE_OS == 1U)
;;;1284     phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;1285   #if (osCMSIS < 0x20000U)
;;;1286     (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1287   #else
;;;1288     (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1289   #endif
;;;1290   #endif
;;;1291   
;;;1292     return USBH_OK;
00002a  2000              MOVS     r0,#0
;;;1293   }
00002c  bd10              POP      {r4,pc}
;;;1294   
                          ENDP


                          AREA ||i.USBH_LL_IncTimer||, CODE, READONLY, ALIGN=1

                  USBH_LL_IncTimer PROC
;;;1166     */
;;;1167   void  USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
000000  b510              PUSH     {r4,lr}
;;;1168   {
000002  4604              MOV      r4,r0
;;;1169     phost->Timer++;
000004  f8d403c4          LDR      r0,[r4,#0x3c4]
000008  1c40              ADDS     r0,r0,#1
00000a  f8c403c4          STR      r0,[r4,#0x3c4]
;;;1170     USBH_HandleSof(phost);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USBH_HandleSof
;;;1171   }
000014  bd10              POP      {r4,pc}
;;;1172   
                          ENDP


                          AREA ||i.USBH_LL_PortDisabled||, CODE, READONLY, ALIGN=1

                  USBH_LL_PortDisabled PROC
;;;1217     */
;;;1218   void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
000000  2200              MOVS     r2,#0
;;;1219   {
;;;1220     phost->device.PortEnabled = 0U;
000002  f8802323          STRB     r2,[r0,#0x323]
;;;1221   
;;;1222     return;
;;;1223   }
000006  4770              BX       lr
;;;1224   
                          ENDP


                          AREA ||i.USBH_LL_PortEnabled||, CODE, READONLY, ALIGN=1

                  USBH_LL_PortEnabled PROC
;;;1194     */
;;;1195   void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
000000  2201              MOVS     r2,#1
;;;1196   {
;;;1197     phost->device.PortEnabled = 1U;
000002  f8802323          STRB     r2,[r0,#0x323]
;;;1198   
;;;1199   #if (USBH_USE_OS == 1U)
;;;1200     phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;1201   #if (osCMSIS < 0x20000U)
;;;1202     (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;1203   #else
;;;1204     (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;1205   #endif
;;;1206   #endif
;;;1207   
;;;1208     return;
;;;1209   }
000006  4770              BX       lr
;;;1210   
                          ENDP


                          AREA ||i.USBH_LL_SetTimer||, CODE, READONLY, ALIGN=1

                  USBH_LL_SetTimer PROC
;;;1154     */
;;;1155   void  USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
000000  f8c013c4          STR      r1,[r0,#0x3c4]
;;;1156   {
;;;1157     phost->Timer = time;
;;;1158   }
000004  4770              BX       lr
;;;1159   
                          ENDP


                          AREA ||i.USBH_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  USBH_Process PROC
;;;456      */
;;;457    USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
000000  b57f              PUSH     {r0-r6,lr}
;;;458    {
000002  4604              MOV      r4,r0
;;;459      __IO USBH_StatusTypeDef status = USBH_FAIL;
000004  2002              MOVS     r0,#2
000006  9003              STR      r0,[sp,#0xc]
;;;460      uint8_t idx = 0U;
000008  2500              MOVS     r5,#0
;;;461    
;;;462      /* check for Host pending port disconnect event */
;;;463      if (phost->device.is_disconnected == 1U)
00000a  f8940321          LDRB     r0,[r4,#0x321]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L16.22|
;;;464      {
;;;465        phost->gState = HOST_DEV_DISCONNECTED;
000012  2003              MOVS     r0,#3
000014  7020              STRB     r0,[r4,#0]
                  |L16.22|
;;;466      }
;;;467    
;;;468      switch (phost->gState)
000016  7820              LDRB     r0,[r4,#0]
000018  280e              CMP      r0,#0xe
00001a  d27d              BCS      |L16.280|
00001c  e8dff000          TBB      [pc,r0]
000020  072158f8          DCB      0x07,0x21,0x58,0xf8
000024  7c92f7b6          DCB      0x7c,0x92,0xf7,0xb6
000028  c1d2eaf6          DCB      0xc1,0xd2,0xea,0xf6
00002c  7cf5              DCB      0x7c,0xf5
;;;469      {
;;;470        case HOST_IDLE :
;;;471    
;;;472          if (phost->device.is_connected)
00002e  f8940320          LDRB     r0,[r4,#0x320]
000032  b1a8              CBZ      r0,|L16.96|
;;;473          {
;;;474            USBH_UsrLog("USB Device Connected");
000034  bf00              NOP      
000036  a0d4              ADR      r0,|L16.904|
000038  f7fffffe          BL       __2printf
00003c  a0d8              ADR      r0,|L16.928|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP      
;;;475    
;;;476            /* Wait for 200 ms after connection */
;;;477            phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
000044  2001              MOVS     r0,#1
000046  7020              STRB     r0,[r4,#0]
;;;478            USBH_Delay(200U);
000048  20c8              MOVS     r0,#0xc8
00004a  f7fffffe          BL       USBH_Delay
;;;479            USBH_LL_ResetPort(phost);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       USBH_LL_ResetPort
;;;480    
;;;481            /* Make sure to start with Default address */
;;;482            phost->device.address = USBH_ADDRESS_DEFAULT;
000054  2100              MOVS     r1,#0
000056  f884131c          STRB     r1,[r4,#0x31c]
;;;483            phost->Timeout = 0U;
00005a  2000              MOVS     r0,#0
00005c  f8c403c8          STR      r0,[r4,#0x3c8]
                  |L16.96|
;;;484    
;;;485    #if (USBH_USE_OS == 1U)
;;;486            phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;487    #if (osCMSIS < 0x20000U)
;;;488            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;489    #else
;;;490            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;491    #endif
;;;492    #endif
;;;493          }
;;;494          break;
000060  e18e              B        |L16.896|
;;;495    
;;;496        case HOST_DEV_WAIT_FOR_ATTACHMENT: /* Wait for Port Enabled */
;;;497    
;;;498          if (phost->device.PortEnabled == 1U)
000062  f8940323          LDRB     r0,[r4,#0x323]
000066  2801              CMP      r0,#1
000068  d10d              BNE      |L16.134|
;;;499          {
;;;500            USBH_UsrLog("USB Device Reset Completed");
00006a  bf00              NOP      
00006c  a0cd              ADR      r0,|L16.932|
00006e  f7fffffe          BL       __2printf
000072  a0cb              ADR      r0,|L16.928|
000074  f7fffffe          BL       __2printf
000078  bf00              NOP      
;;;501            phost->device.RstCnt = 0U;
00007a  2100              MOVS     r1,#0
00007c  f884131f          STRB     r1,[r4,#0x31f]
;;;502            phost->gState = HOST_DEV_ATTACHED;
000080  2002              MOVS     r0,#2
000082  7020              STRB     r0,[r4,#0]
000084  e023              B        |L16.206|
                  |L16.134|
;;;503          }
;;;504          else
;;;505          {
;;;506            if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
000086  f8d403c8          LDR      r0,[r4,#0x3c8]
00008a  f5b07f7a          CMP      r0,#0x3e8
00008e  d916              BLS      |L16.190|
;;;507            {
;;;508              phost->device.RstCnt++;
000090  f894031f          LDRB     r0,[r4,#0x31f]
000094  1c40              ADDS     r0,r0,#1
000096  f884031f          STRB     r0,[r4,#0x31f]
;;;509              if (phost->device.RstCnt > 3U)
00009a  f894031f          LDRB     r0,[r4,#0x31f]
00009e  2803              CMP      r0,#3
0000a0  d90a              BLS      |L16.184|
;;;510              {
;;;511                /* Buggy Device can't complete reset */
;;;512                USBH_UsrLog("USB Reset Failed, Please unplug the Device.");
0000a2  bf00              NOP      
0000a4  a0c6              ADR      r0,|L16.960|
0000a6  f7fffffe          BL       __2printf
0000aa  a0bd              ADR      r0,|L16.928|
0000ac  f7fffffe          BL       __2printf
0000b0  bf00              NOP      
;;;513                phost->gState = HOST_ABORT_STATE;
0000b2  200d              MOVS     r0,#0xd
0000b4  7020              STRB     r0,[r4,#0]
0000b6  e00a              B        |L16.206|
                  |L16.184|
;;;514              }
;;;515              else
;;;516              {
;;;517                phost->gState = HOST_IDLE;
0000b8  2000              MOVS     r0,#0
0000ba  7020              STRB     r0,[r4,#0]
0000bc  e007              B        |L16.206|
                  |L16.190|
;;;518              }
;;;519            }
;;;520            else
;;;521            {
;;;522              phost->Timeout += 10U;
0000be  f8d403c8          LDR      r0,[r4,#0x3c8]
0000c2  300a              ADDS     r0,r0,#0xa
0000c4  f8c403c8          STR      r0,[r4,#0x3c8]
;;;523              USBH_Delay(10U);
0000c8  200a              MOVS     r0,#0xa
0000ca  f7fffffe          BL       USBH_Delay
                  |L16.206|
;;;524            }
;;;525          }
;;;526    #if (USBH_USE_OS == 1U)
;;;527          phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;528    #if (osCMSIS < 0x20000U)
;;;529          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;530    #else
;;;531          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;532    #endif
;;;533    #endif
;;;534          break;
0000ce  e157              B        |L16.896|
;;;535    
;;;536        case HOST_DEV_ATTACHED :
;;;537    
;;;538          if (phost->pUser != NULL)
0000d0  f8d403d4          LDR      r0,[r4,#0x3d4]
0000d4  b120              CBZ      r0,|L16.224|
;;;539          {
;;;540            phost->pUser(phost, HOST_USER_CONNECTION);
0000d6  2104              MOVS     r1,#4
0000d8  4620              MOV      r0,r4
0000da  f8d423d4          LDR      r2,[r4,#0x3d4]
0000de  4790              BLX      r2
                  |L16.224|
;;;541          }
;;;542    
;;;543          /* Wait for 100 ms after Reset */
;;;544          USBH_Delay(100U);
0000e0  2064              MOVS     r0,#0x64
0000e2  f7fffffe          BL       USBH_Delay
;;;545    
;;;546          phost->device.speed = USBH_LL_GetSpeed(phost);
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       USBH_LL_GetSpeed
0000ec  f884031d          STRB     r0,[r4,#0x31d]
;;;547    
;;;548          phost->gState = HOST_ENUMERATION;
0000f0  2005              MOVS     r0,#5
0000f2  7020              STRB     r0,[r4,#0]
;;;549    
;;;550          phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
0000f4  2100              MOVS     r1,#0
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       USBH_AllocPipe
0000fc  7160              STRB     r0,[r4,#5]
;;;551          phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
0000fe  2180              MOVS     r1,#0x80
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       USBH_AllocPipe
000106  7120              STRB     r0,[r4,#4]
;;;552    
;;;553          /* Open Control pipes */
;;;554          USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
000108  79a0              LDRB     r0,[r4,#6]
00010a  2200              MOVS     r2,#0
00010c  f894131d          LDRB     r1,[r4,#0x31d]
000110  e9cd1200          STRD     r1,r2,[sp,#0]
000114  9002              STR      r0,[sp,#8]
000116  e000              B        |L16.282|
                  |L16.280|
000118  e130              B        |L16.892|
                  |L16.282|
00011a  f894331c          LDRB     r3,[r4,#0x31c]
00011e  7921              LDRB     r1,[r4,#4]
000120  2280              MOVS     r2,#0x80
000122  4620              MOV      r0,r4
000124  f7fffffe          BL       USBH_OpenPipe
;;;555                        phost->device.address, phost->device.speed,
;;;556                        USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
;;;557    
;;;558          /* Open Control pipes */
;;;559          USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
000128  79a0              LDRB     r0,[r4,#6]
00012a  2200              MOVS     r2,#0
00012c  f894131d          LDRB     r1,[r4,#0x31d]
000130  e9cd1200          STRD     r1,r2,[sp,#0]
000134  9002              STR      r0,[sp,#8]
000136  f894331c          LDRB     r3,[r4,#0x31c]
00013a  7961              LDRB     r1,[r4,#5]
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       USBH_OpenPipe
;;;560                        phost->device.address, phost->device.speed,
;;;561                        USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
;;;562    
;;;563    #if (USBH_USE_OS == 1U)
;;;564          phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;565    #if (osCMSIS < 0x20000U)
;;;566          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;567    #else
;;;568          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;569    #endif
;;;570    #endif
;;;571          break;
000142  e11d              B        |L16.896|
;;;572    
;;;573        case HOST_ENUMERATION:
;;;574          /* Check for enumeration status */
;;;575          status = USBH_HandleEnum(phost);
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       USBH_HandleEnum
00014a  9003              STR      r0,[sp,#0xc]
;;;576          if (status == USBH_OK)
00014c  f89d000c          LDRB     r0,[sp,#0xc]
000150  b9d8              CBNZ     r0,|L16.394|
;;;577          {
;;;578            /* The function shall return USBH_OK when full enumeration is complete */
;;;579            USBH_UsrLog("Enumeration done.");
000152  bf00              NOP      
000154  a0a5              ADR      r0,|L16.1004|
000156  f7fffffe          BL       __2printf
00015a  a091              ADR      r0,|L16.928|
00015c  f7fffffe          BL       __2printf
000160  bf00              NOP      
;;;580    
;;;581            phost->device.current_interface = 0U;
000162  2100              MOVS     r1,#0
000164  f8841324          STRB     r1,[r4,#0x324]
;;;582    
;;;583            if (phost->device.DevDesc.bNumConfigurations == 1U)
000168  f8940337          LDRB     r0,[r4,#0x337]
00016c  2801              CMP      r0,#1
00016e  d10a              BNE      |L16.390|
;;;584            {
;;;585              USBH_UsrLog("This device has only 1 configuration.");
000170  bf00              NOP      
000172  a0a3              ADR      r0,|L16.1024|
000174  f7fffffe          BL       __2printf
000178  a089              ADR      r0,|L16.928|
00017a  f7fffffe          BL       __2printf
00017e  bf00              NOP      
;;;586              phost->gState = HOST_SET_CONFIGURATION;
000180  2008              MOVS     r0,#8
000182  7020              STRB     r0,[r4,#0]
000184  e001              B        |L16.394|
                  |L16.390|
;;;587            }
;;;588            else
;;;589            {
;;;590              phost->gState = HOST_INPUT;
000186  2007              MOVS     r0,#7
000188  7020              STRB     r0,[r4,#0]
                  |L16.394|
;;;591            }
;;;592    #if (USBH_USE_OS == 1U)
;;;593            phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;594    #if (osCMSIS < 0x20000U)
;;;595            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;596    #else
;;;597            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;598    #endif
;;;599    #endif
;;;600          }
;;;601          break;
00018a  e0f9              B        |L16.896|
;;;602    
;;;603        case HOST_INPUT:
;;;604        {
;;;605          /* user callback for end of device basic enumeration */
;;;606          if (phost->pUser != NULL)
00018c  f8d403d4          LDR      r0,[r4,#0x3d4]
000190  b130              CBZ      r0,|L16.416|
;;;607          {
;;;608            phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
000192  2101              MOVS     r1,#1
000194  4620              MOV      r0,r4
000196  f8d423d4          LDR      r2,[r4,#0x3d4]
00019a  4790              BLX      r2
;;;609            phost->gState = HOST_SET_CONFIGURATION;
00019c  2008              MOVS     r0,#8
00019e  7020              STRB     r0,[r4,#0]
                  |L16.416|
;;;610    
;;;611    #if (USBH_USE_OS == 1U)
;;;612            phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;613    #if (osCMSIS < 0x20000U)
;;;614            (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;615    #else
;;;616            (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;617    #endif
;;;618    #endif
;;;619          }
;;;620        }
;;;621        break;
0001a0  e0ee              B        |L16.896|
;;;622    
;;;623        case HOST_SET_CONFIGURATION:
;;;624          /* set configuration */
;;;625          if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
0001a2  f894133d          LDRB     r1,[r4,#0x33d]
0001a6  4620              MOV      r0,r4
0001a8  f7fffffe          BL       USBH_SetCfg
0001ac  b948              CBNZ     r0,|L16.450|
;;;626          {
;;;627            phost->gState = HOST_SET_WAKEUP_FEATURE;
0001ae  2009              MOVS     r0,#9
0001b0  7020              STRB     r0,[r4,#0]
;;;628            USBH_UsrLog("Default configuration set.");
0001b2  bf00              NOP      
0001b4  a09c              ADR      r0,|L16.1064|
0001b6  f7fffffe          BL       __2printf
0001ba  a079              ADR      r0,|L16.928|
0001bc  f7fffffe          BL       __2printf
0001c0  bf00              NOP      
                  |L16.450|
;;;629          }
;;;630    
;;;631    #if (USBH_USE_OS == 1U)
;;;632          phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;633    #if (osCMSIS < 0x20000U)
;;;634          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;635    #else
;;;636          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;637    #endif
;;;638    #endif
;;;639          break;
0001c2  e0dd              B        |L16.896|
;;;640    
;;;641        case  HOST_SET_WAKEUP_FEATURE:
;;;642    
;;;643          if ((phost->device.CfgDesc.bmAttributes) & (1U << 5))
0001c4  f894033f          LDRB     r0,[r4,#0x33f]
0001c8  f0000020          AND      r0,r0,#0x20
0001cc  b178              CBZ      r0,|L16.494|
;;;644          {
;;;645            if (USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP) == USBH_OK)
0001ce  2101              MOVS     r1,#1
0001d0  4620              MOV      r0,r4
0001d2  f7fffffe          BL       USBH_SetFeature
0001d6  b960              CBNZ     r0,|L16.498|
;;;646            {
;;;647              USBH_UsrLog("Device remote wakeup enabled");
0001d8  bf00              NOP      
0001da  a09a              ADR      r0,|L16.1092|
0001dc  f7fffffe          BL       __2printf
0001e0  a06f              ADR      r0,|L16.928|
0001e2  f7fffffe          BL       __2printf
0001e6  bf00              NOP      
;;;648              phost->gState = HOST_CHECK_CLASS;
0001e8  200a              MOVS     r0,#0xa
0001ea  7020              STRB     r0,[r4,#0]
0001ec  e001              B        |L16.498|
                  |L16.494|
;;;649            }
;;;650          }
;;;651          else
;;;652          {
;;;653            phost->gState = HOST_CHECK_CLASS;
0001ee  200a              MOVS     r0,#0xa
0001f0  7020              STRB     r0,[r4,#0]
                  |L16.498|
;;;654          }
;;;655    
;;;656    #if (USBH_USE_OS == 1U)
;;;657          phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;658    #if (osCMSIS < 0x20000U)
;;;659          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;660    #else
;;;661          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;662    #endif
;;;663    #endif
;;;664          break;
0001f2  e0c5              B        |L16.896|
;;;665    
;;;666        case HOST_CHECK_CLASS:
;;;667    
;;;668          if (phost->ClassNumber == 0U)
0001f4  f8d40380          LDR      r0,[r4,#0x380]
0001f8  b958              CBNZ     r0,|L16.530|
;;;669          {
;;;670            USBH_UsrLog("No Class has been registered.");
0001fa  bf00              NOP      
0001fc  a099              ADR      r0,|L16.1124|
0001fe  f7fffffe          BL       __2printf
000202  a067              ADR      r0,|L16.928|
000204  f7fffffe          BL       __2printf
000208  e050              B        |L16.684|
00020a  e0b8              B        |L16.894|
00020c  e07d              B        |L16.778|
00020e  e04e              B        |L16.686|
000210  e084              B        |L16.796|
                  |L16.530|
;;;671          }
;;;672          else
;;;673          {
;;;674            phost->pActiveClass = NULL;
000212  2000              MOVS     r0,#0
000214  f8c4037c          STR      r0,[r4,#0x37c]
;;;675    
;;;676            for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
000218  2500              MOVS     r5,#0
00021a  e011              B        |L16.576|
                  |L16.540|
;;;677            {
;;;678              if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
00021c  f504705e          ADD      r0,r4,#0x378
000220  f8500025          LDR      r0,[r0,r5,LSL #2]
000224  7901              LDRB     r1,[r0,#4]
000226  f8940347          LDRB     r0,[r4,#0x347]
00022a  4281              CMP      r1,r0
00022c  d106              BNE      |L16.572|
;;;679              {
;;;680                phost->pActiveClass = phost->pClass[idx];
00022e  f504705e          ADD      r0,r4,#0x378
000232  f8500025          LDR      r0,[r0,r5,LSL #2]
000236  f8c4037c          STR      r0,[r4,#0x37c]
;;;681                break;
00023a  e003              B        |L16.580|
                  |L16.572|
00023c  1c68              ADDS     r0,r5,#1              ;676
00023e  b2c5              UXTB     r5,r0                 ;676
                  |L16.576|
000240  2d00              CMP      r5,#0                 ;676
000242  d0eb              BEQ      |L16.540|
                  |L16.580|
000244  bf00              NOP      
;;;682              }
;;;683            }
;;;684    
;;;685            if (phost->pActiveClass != NULL)
000246  f8d4037c          LDR      r0,[r4,#0x37c]
00024a  b328              CBZ      r0,|L16.664|
;;;686            {
;;;687              if (phost->pActiveClass->Init(phost) == USBH_OK)
00024c  f8d4037c          LDR      r0,[r4,#0x37c]
000250  6881              LDR      r1,[r0,#8]
000252  4620              MOV      r0,r4
000254  4788              BLX      r1
000256  b990              CBNZ     r0,|L16.638|
;;;688              {
;;;689                phost->gState = HOST_CLASS_REQUEST;
000258  2006              MOVS     r0,#6
00025a  7020              STRB     r0,[r4,#0]
;;;690                USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
00025c  bf00              NOP      
00025e  f8d4037c          LDR      r0,[r4,#0x37c]
000262  6801              LDR      r1,[r0,#0]
000264  a087              ADR      r0,|L16.1156|
000266  f7fffffe          BL       __2printf
00026a  a04d              ADR      r0,|L16.928|
00026c  f7fffffe          BL       __2printf
000270  bf00              NOP      
;;;691    
;;;692                /* Inform user that a class has been activated */
;;;693                phost->pUser(phost, HOST_USER_CLASS_SELECTED);
000272  2103              MOVS     r1,#3
000274  4620              MOV      r0,r4
000276  f8d423d4          LDR      r2,[r4,#0x3d4]
00027a  4790              BLX      r2
00027c  e016              B        |L16.684|
                  |L16.638|
;;;694              }
;;;695              else
;;;696              {
;;;697                phost->gState = HOST_ABORT_STATE;
00027e  200d              MOVS     r0,#0xd
000280  7020              STRB     r0,[r4,#0]
;;;698                USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
000282  bf00              NOP      
000284  f8d4037c          LDR      r0,[r4,#0x37c]
000288  6801              LDR      r1,[r0,#0]
00028a  a083              ADR      r0,|L16.1176|
00028c  f7fffffe          BL       __2printf
000290  a043              ADR      r0,|L16.928|
000292  f7fffffe          BL       __2printf
000296  e009              B        |L16.684|
                  |L16.664|
;;;699              }
;;;700            }
;;;701            else
;;;702            {
;;;703              phost->gState = HOST_ABORT_STATE;
000298  200d              MOVS     r0,#0xd
00029a  7020              STRB     r0,[r4,#0]
;;;704              USBH_UsrLog("No registered class for this device.");
00029c  bf00              NOP      
00029e  a086              ADR      r0,|L16.1208|
0002a0  f7fffffe          BL       __2printf
0002a4  a03e              ADR      r0,|L16.928|
0002a6  f7fffffe          BL       __2printf
0002aa  bf00              NOP      
                  |L16.684|
;;;705            }
;;;706          }
;;;707    
;;;708    #if (USBH_USE_OS == 1U)
;;;709          phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;710    #if (osCMSIS < 0x20000U)
;;;711          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;712    #else
;;;713          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;714    #endif
;;;715    #endif
;;;716          break;
0002ac  e068              B        |L16.896|
                  |L16.686|
;;;717    
;;;718        case HOST_CLASS_REQUEST:
;;;719          /* process class standard control requests state machine */
;;;720          if (phost->pActiveClass != NULL)
0002ae  f8d4037c          LDR      r0,[r4,#0x37c]
0002b2  b1e0              CBZ      r0,|L16.750|
;;;721          {
;;;722            status = phost->pActiveClass->Requests(phost);
0002b4  f8d4037c          LDR      r0,[r4,#0x37c]
0002b8  6901              LDR      r1,[r0,#0x10]
0002ba  4620              MOV      r0,r4
0002bc  4788              BLX      r1
0002be  9003              STR      r0,[sp,#0xc]
;;;723    
;;;724            if (status == USBH_OK)
0002c0  f89d000c          LDRB     r0,[sp,#0xc]
0002c4  b910              CBNZ     r0,|L16.716|
;;;725            {
;;;726              phost->gState = HOST_CLASS;
0002c6  200b              MOVS     r0,#0xb
0002c8  7020              STRB     r0,[r4,#0]
0002ca  e01d              B        |L16.776|
                  |L16.716|
;;;727            }
;;;728            else if (status == USBH_FAIL)
0002cc  f89d000c          LDRB     r0,[sp,#0xc]
0002d0  2802              CMP      r0,#2
0002d2  d119              BNE      |L16.776|
;;;729            {
;;;730              phost->gState = HOST_ABORT_STATE;
0002d4  200d              MOVS     r0,#0xd
0002d6  7020              STRB     r0,[r4,#0]
;;;731              USBH_ErrLog("Device not responding Please Unplug.");
0002d8  bf00              NOP      
0002da  a081              ADR      r0,|L16.1248|
0002dc  f7fffffe          BL       __2printf
0002e0  a081              ADR      r0,|L16.1256|
0002e2  f7fffffe          BL       __2printf
0002e6  a02e              ADR      r0,|L16.928|
0002e8  f7fffffe          BL       __2printf
0002ec  e00c              B        |L16.776|
                  |L16.750|
;;;732            }
;;;733            else
;;;734            {
;;;735              /* .. */
;;;736            }
;;;737          }
;;;738          else
;;;739          {
;;;740            phost->gState = HOST_ABORT_STATE;
0002ee  200d              MOVS     r0,#0xd
0002f0  7020              STRB     r0,[r4,#0]
;;;741            USBH_ErrLog("Invalid Class Driver.");
0002f2  bf00              NOP      
0002f4  a07a              ADR      r0,|L16.1248|
0002f6  f7fffffe          BL       __2printf
0002fa  a085              ADR      r0,|L16.1296|
0002fc  f7fffffe          BL       __2printf
000300  a027              ADR      r0,|L16.928|
000302  f7fffffe          BL       __2printf
000306  bf00              NOP      
                  |L16.776|
;;;742          }
;;;743    #if (USBH_USE_OS == 1U)
;;;744          phost->os_msg = (uint32_t)USBH_STATE_CHANGED_EVENT;
;;;745    #if (osCMSIS < 0x20000U)
;;;746          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;747    #else
;;;748          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;749    #endif
;;;750    #endif
;;;751          break;
000308  e03a              B        |L16.896|
                  |L16.778|
;;;752    
;;;753        case HOST_CLASS:
;;;754          /* process class state machine */
;;;755          if (phost->pActiveClass != NULL)
00030a  f8d4037c          LDR      r0,[r4,#0x37c]
00030e  b120              CBZ      r0,|L16.794|
;;;756          {
;;;757            phost->pActiveClass->BgndProcess(phost);
000310  f8d4037c          LDR      r0,[r4,#0x37c]
000314  6941              LDR      r1,[r0,#0x14]
000316  4620              MOV      r0,r4
000318  4788              BLX      r1
                  |L16.794|
;;;758          }
;;;759          break;
00031a  e031              B        |L16.896|
                  |L16.796|
;;;760    
;;;761        case HOST_DEV_DISCONNECTED :
;;;762          phost->device.is_disconnected = 0U;
00031c  2100              MOVS     r1,#0
00031e  f8841321          STRB     r1,[r4,#0x321]
;;;763    
;;;764          DeInitStateMachine(phost);
000322  4620              MOV      r0,r4
000324  f7fffffe          BL       DeInitStateMachine
;;;765    
;;;766          /* Re-Initilaize Host for new Enumeration */
;;;767          if (phost->pActiveClass != NULL)
000328  f8d4037c          LDR      r0,[r4,#0x37c]
00032c  b138              CBZ      r0,|L16.830|
;;;768          {
;;;769            phost->pActiveClass->DeInit(phost);
00032e  f8d4037c          LDR      r0,[r4,#0x37c]
000332  68c1              LDR      r1,[r0,#0xc]
000334  4620              MOV      r0,r4
000336  4788              BLX      r1
;;;770            phost->pActiveClass = NULL;
000338  2000              MOVS     r0,#0
00033a  f8c4037c          STR      r0,[r4,#0x37c]
                  |L16.830|
;;;771          }
;;;772    
;;;773          if (phost->pUser != NULL)
00033e  f8d403d4          LDR      r0,[r4,#0x3d4]
000342  b120              CBZ      r0,|L16.846|
;;;774          {
;;;775            phost->pUser(phost, HOST_USER_DISCONNECTION);
000344  2105              MOVS     r1,#5
000346  4620              MOV      r0,r4
000348  f8d423d4          LDR      r2,[r4,#0x3d4]
00034c  4790              BLX      r2
                  |L16.846|
;;;776          }
;;;777          USBH_UsrLog("USB Device disconnected");
00034e  bf00              NOP      
000350  a075              ADR      r0,|L16.1320|
000352  f7fffffe          BL       __2printf
000356  a012              ADR      r0,|L16.928|
000358  f7fffffe          BL       __2printf
00035c  bf00              NOP      
;;;778    
;;;779          if (phost->device.is_ReEnumerated == 1U)
00035e  f8940322          LDRB     r0,[r4,#0x322]
000362  2801              CMP      r0,#1
000364  d106              BNE      |L16.884|
;;;780          {
;;;781            phost->device.is_ReEnumerated = 0U;
000366  2100              MOVS     r1,#0
000368  f8841322          STRB     r1,[r4,#0x322]
;;;782    
;;;783            /* Start the host and re-enable Vbus */
;;;784            USBH_Start(phost);
00036c  4620              MOV      r0,r4
00036e  f7fffffe          BL       USBH_Start
000372  e002              B        |L16.890|
                  |L16.884|
;;;785          }
;;;786          else
;;;787          {
;;;788            /* Device Disconnection Completed, start USB Driver */
;;;789            USBH_LL_Start(phost);
000374  4620              MOV      r0,r4
000376  f7fffffe          BL       USBH_LL_Start
                  |L16.890|
;;;790          }
;;;791    
;;;792    #if (USBH_USE_OS == 1U)
;;;793          phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;794    #if (osCMSIS < 0x20000U)
;;;795          (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;796    #else
;;;797          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;798    #endif
;;;799    #endif
;;;800          break;
00037a  e001              B        |L16.896|
                  |L16.892|
;;;801    
;;;802        case HOST_ABORT_STATE:
00037c  bf00              NOP      
                  |L16.894|
;;;803        default :
;;;804          break;
00037e  bf00              NOP      
                  |L16.896|
000380  bf00              NOP                            ;494
;;;805      }
;;;806      return USBH_OK;
000382  2000              MOVS     r0,#0
;;;807    }
000384  b004              ADD      sp,sp,#0x10
000386  bd70              POP      {r4-r6,pc}
;;;808    
                          ENDP

                  |L16.904|
000388  55534220          DCB      "USB Device Connected",0
00038c  44657669
000390  63652043
000394  6f6e6e65
000398  63746564
00039c  00      
00039d  00                DCB      0
00039e  00                DCB      0
00039f  00                DCB      0
                  |L16.928|
0003a0  0a00              DCB      "\n",0
0003a2  00                DCB      0
0003a3  00                DCB      0
                  |L16.932|
0003a4  55534220          DCB      "USB Device Reset Completed",0
0003a8  44657669
0003ac  63652052
0003b0  65736574
0003b4  20436f6d
0003b8  706c6574
0003bc  656400  
0003bf  00                DCB      0
                  |L16.960|
0003c0  55534220          DCB      "USB Reset Failed, Please unplug the Device.",0
0003c4  52657365
0003c8  74204661
0003cc  696c6564
0003d0  2c20506c
0003d4  65617365
0003d8  20756e70
0003dc  6c756720
0003e0  74686520
0003e4  44657669
0003e8  63652e00
                  |L16.1004|
0003ec  456e756d          DCB      "Enumeration done.",0
0003f0  65726174
0003f4  696f6e20
0003f8  646f6e65
0003fc  2e00    
0003fe  00                DCB      0
0003ff  00                DCB      0
                  |L16.1024|
000400  54686973          DCB      "This device has only 1 configuration.",0
000404  20646576
000408  69636520
00040c  68617320
000410  6f6e6c79
000414  20312063
000418  6f6e6669
00041c  67757261
000420  74696f6e
000424  2e00    
000426  00                DCB      0
000427  00                DCB      0
                  |L16.1064|
000428  44656661          DCB      "Default configuration set.",0
00042c  756c7420
000430  636f6e66
000434  69677572
000438  6174696f
00043c  6e207365
000440  742e00  
000443  00                DCB      0
                  |L16.1092|
000444  44657669          DCB      "Device remote wakeup enabled",0
000448  63652072
00044c  656d6f74
000450  65207761
000454  6b657570
000458  20656e61
00045c  626c6564
000460  00      
000461  00                DCB      0
000462  00                DCB      0
000463  00                DCB      0
                  |L16.1124|
000464  4e6f2043          DCB      "No Class has been registered.",0
000468  6c617373
00046c  20686173
000470  20626565
000474  6e207265
000478  67697374
00047c  65726564
000480  2e00    
000482  00                DCB      0
000483  00                DCB      0
                  |L16.1156|
000484  25732063          DCB      "%s class started.",0
000488  6c617373
00048c  20737461
000490  72746564
000494  2e00    
000496  00                DCB      0
000497  00                DCB      0
                  |L16.1176|
000498  44657669          DCB      "Device not supporting %s class.",0
00049c  6365206e
0004a0  6f742073
0004a4  7570706f
0004a8  7274696e
0004ac  67202573
0004b0  20636c61
0004b4  73732e00
                  |L16.1208|
0004b8  4e6f2072          DCB      "No registered class for this device.",0
0004bc  65676973
0004c0  74657265
0004c4  6420636c
0004c8  61737320
0004cc  666f7220
0004d0  74686973
0004d4  20646576
0004d8  6963652e
0004dc  00      
0004dd  00                DCB      0
0004de  00                DCB      0
0004df  00                DCB      0
                  |L16.1248|
0004e0  4552524f          DCB      "ERROR: ",0
0004e4  523a2000
                  |L16.1256|
0004e8  44657669          DCB      "Device not responding Please Unplug.",0
0004ec  6365206e
0004f0  6f742072
0004f4  6573706f
0004f8  6e64696e
0004fc  6720506c
000500  65617365
000504  20556e70
000508  6c75672e
00050c  00      
00050d  00                DCB      0
00050e  00                DCB      0
00050f  00                DCB      0
                  |L16.1296|
000510  496e7661          DCB      "Invalid Class Driver.",0
000514  6c696420
000518  436c6173
00051c  73204472
000520  69766572
000524  2e00    
000526  00                DCB      0
000527  00                DCB      0
                  |L16.1320|
000528  55534220          DCB      "USB Device disconnected",0
00052c  44657669
000530  63652064
000534  6973636f
000538  6e6e6563
00053c  74656400

                          AREA ||i.USBH_ReEnumerate||, CODE, READONLY, ALIGN=1

                  USBH_ReEnumerate PROC
;;;425      */
;;;426    USBH_StatusTypeDef USBH_ReEnumerate(USBH_HandleTypeDef *phost)
000000  b510              PUSH     {r4,lr}
;;;427    {
000002  4604              MOV      r4,r0
;;;428      if (USBH_IsPortEnabled(phost))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USBH_IsPortEnabled
00000a  b140              CBZ      r0,|L17.30|
;;;429      {
;;;430        phost->device.is_ReEnumerated = 1U;
00000c  2101              MOVS     r1,#1
00000e  f8841322          STRB     r1,[r4,#0x322]
;;;431    
;;;432        /* Stop Host */
;;;433        USBH_Stop(phost);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USBH_Stop
;;;434    
;;;435        phost->device.is_disconnected = 1U;
000018  2101              MOVS     r1,#1
00001a  f8841321          STRB     r1,[r4,#0x321]
                  |L17.30|
;;;436      }
;;;437    
;;;438    #if (USBH_USE_OS == 1U)
;;;439      phost->os_msg = (uint32_t)USBH_PORT_EVENT;
;;;440    #if (osCMSIS < 0x20000U)
;;;441      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
;;;442    #else
;;;443      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
;;;444    #endif
;;;445    #endif
;;;446    
;;;447      return USBH_OK;
00001e  2000              MOVS     r0,#0
;;;448    }
000020  bd10              POP      {r4,pc}
;;;449    
                          ENDP


                          AREA ||i.USBH_RegisterClass||, CODE, READONLY, ALIGN=2

                  USBH_RegisterClass PROC
;;;244      */
;;;245    USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
000000  b570              PUSH     {r4-r6,lr}
;;;246    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;247      USBH_StatusTypeDef status = USBH_OK;
000006  2600              MOVS     r6,#0
;;;248    
;;;249      if (pclass != NULL)
000008  b1cd              CBZ      r5,|L18.62|
;;;250      {
;;;251        if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
00000a  f8d40380          LDR      r0,[r4,#0x380]
00000e  b948              CBNZ     r0,|L18.36|
;;;252        {
;;;253          /* link the class to the USB Host handle */
;;;254          phost->pClass[phost->ClassNumber++] = pclass;
000010  f8d41380          LDR      r1,[r4,#0x380]
000014  1c48              ADDS     r0,r1,#1
000016  f8c40380          STR      r0,[r4,#0x380]
00001a  f504705e          ADD      r0,r4,#0x378
00001e  f8405021          STR      r5,[r0,r1,LSL #2]
;;;255          status = USBH_OK;
000022  e018              B        |L18.86|
                  |L18.36|
;;;256        }
;;;257        else
;;;258        {
;;;259          USBH_ErrLog("Max Class Number reached");
000024  bf00              NOP      
000026  a00d              ADR      r0,|L18.92|
000028  f7fffffe          BL       __2printf
00002c  a00d              ADR      r0,|L18.100|
00002e  f7fffffe          BL       __2printf
000032  a013              ADR      r0,|L18.128|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP      
;;;260          status = USBH_FAIL;
00003a  2602              MOVS     r6,#2
00003c  e00b              B        |L18.86|
                  |L18.62|
;;;261        }
;;;262      }
;;;263      else
;;;264      {
;;;265        USBH_ErrLog("Invalid Class handle");
00003e  bf00              NOP      
000040  a006              ADR      r0,|L18.92|
000042  f7fffffe          BL       __2printf
000046  a00f              ADR      r0,|L18.132|
000048  f7fffffe          BL       __2printf
00004c  a00c              ADR      r0,|L18.128|
00004e  f7fffffe          BL       __2printf
000052  bf00              NOP      
;;;266        status = USBH_FAIL;
000054  2602              MOVS     r6,#2
                  |L18.86|
;;;267      }
;;;268    
;;;269      return status;
000056  4630              MOV      r0,r6
;;;270    }
000058  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP

00005a  0000              DCW      0x0000
                  |L18.92|
00005c  4552524f          DCB      "ERROR: ",0
000060  523a2000
                  |L18.100|
000064  4d617820          DCB      "Max Class Number reached",0
000068  436c6173
00006c  73204e75
000070  6d626572
000074  20726561
000078  63686564
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L18.128|
000080  0a00              DCB      "\n",0
000082  00                DCB      0
000083  00                DCB      0
                  |L18.132|
000084  496e7661          DCB      "Invalid Class handle",0
000088  6c696420
00008c  436c6173
000090  73206861
000094  6e646c65
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.USBH_SelectInterface||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  USBH_SelectInterface PROC
;;;279      */
;;;280    USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
000000  b570              PUSH     {r4-r6,lr}
;;;281    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;282      USBH_StatusTypeDef status = USBH_OK;
000006  2600              MOVS     r6,#0
;;;283    
;;;284      if (interface < phost->device.CfgDesc.bNumInterfaces)
000008  f894033c          LDRB     r0,[r4,#0x33c]
00000c  42a8              CMP      r0,r5
00000e  dd3d              BLE      |L19.140|
;;;285      {
;;;286        phost->device.current_interface = interface;
000010  f8845324          STRB     r5,[r4,#0x324]
;;;287        USBH_UsrLog("Switching to Interface (#%d)", interface);
000014  bf00              NOP      
000016  4629              MOV      r1,r5
000018  a023              ADR      r0,|L19.168|
00001a  f7fffffe          BL       __2printf
00001e  a02a              ADR      r0,|L19.200|
000020  f7fffffe          BL       __2printf
000024  bf00              NOP      
;;;288        USBH_UsrLog("Class    : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass);
000026  bf00              NOP      
000028  eb050085          ADD      r0,r5,r5,LSL #2
00002c  eb0002c5          ADD      r2,r0,r5,LSL #3
000030  f2043042          ADD      r0,r4,#0x342
000034  eb000042          ADD      r0,r0,r2,LSL #1
000038  7941              LDRB     r1,[r0,#5]
00003a  a024              ADR      r0,|L19.204|
00003c  f7fffffe          BL       __2printf
000040  a021              ADR      r0,|L19.200|
000042  f7fffffe          BL       __2printf
000046  bf00              NOP      
;;;289        USBH_UsrLog("SubClass : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass);
000048  bf00              NOP      
00004a  eb050085          ADD      r0,r5,r5,LSL #2
00004e  eb0002c5          ADD      r2,r0,r5,LSL #3
000052  f2043042          ADD      r0,r4,#0x342
000056  eb000042          ADD      r0,r0,r2,LSL #1
00005a  7981              LDRB     r1,[r0,#6]
00005c  a01f              ADR      r0,|L19.220|
00005e  f7fffffe          BL       __2printf
000062  a019              ADR      r0,|L19.200|
000064  f7fffffe          BL       __2printf
000068  bf00              NOP      
;;;290        USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
00006a  bf00              NOP      
00006c  eb050085          ADD      r0,r5,r5,LSL #2
000070  eb0002c5          ADD      r2,r0,r5,LSL #3
000074  f2043042          ADD      r0,r4,#0x342
000078  eb000042          ADD      r0,r0,r2,LSL #1
00007c  79c1              LDRB     r1,[r0,#7]
00007e  a01b              ADR      r0,|L19.236|
000080  f7fffffe          BL       __2printf
000084  a010              ADR      r0,|L19.200|
000086  f7fffffe          BL       __2printf
00008a  e00b              B        |L19.164|
                  |L19.140|
;;;291      }
;;;292      else
;;;293      {
;;;294        USBH_ErrLog("Cannot Select This Interface.");
00008c  bf00              NOP      
00008e  a01b              ADR      r0,|L19.252|
000090  f7fffffe          BL       __2printf
000094  a01b              ADR      r0,|L19.260|
000096  f7fffffe          BL       __2printf
00009a  a00b              ADR      r0,|L19.200|
00009c  f7fffffe          BL       __2printf
0000a0  bf00              NOP      
;;;295        status = USBH_FAIL;
0000a2  2602              MOVS     r6,#2
                  |L19.164|
;;;296      }
;;;297    
;;;298      return status;
0000a4  4630              MOV      r0,r6
;;;299    }
0000a6  bd70              POP      {r4-r6,pc}
;;;300    
                          ENDP

                  |L19.168|
0000a8  53776974          DCB      "Switching to Interface (#%d)",0
0000ac  6368696e
0000b0  6720746f
0000b4  20496e74
0000b8  65726661
0000bc  63652028
0000c0  23256429
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L19.200|
0000c8  0a00              DCB      "\n",0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L19.204|
0000cc  436c6173          DCB      "Class    : %xh",0
0000d0  73202020
0000d4  203a2025
0000d8  786800  
0000db  00                DCB      0
                  |L19.220|
0000dc  53756243          DCB      "SubClass : %xh",0
0000e0  6c617373
0000e4  203a2025
0000e8  786800  
0000eb  00                DCB      0
                  |L19.236|
0000ec  50726f74          DCB      "Protocol : %xh",0
0000f0  6f636f6c
0000f4  203a2025
0000f8  786800  
0000fb  00                DCB      0
                  |L19.252|
0000fc  4552524f          DCB      "ERROR: ",0
000100  523a2000
                  |L19.260|
000104  43616e6e          DCB      "Cannot Select This Interface.",0
000108  6f742053
00010c  656c6563
000110  74205468
000114  69732049
000118  6e746572
00011c  66616365
000120  2e00    
000122  00                DCB      0
000123  00                DCB      0

                          AREA ||i.USBH_Start||, CODE, READONLY, ALIGN=1

                  USBH_Start PROC
;;;385      */
;;;386    USBH_StatusTypeDef  USBH_Start(USBH_HandleTypeDef *phost)
000000  b510              PUSH     {r4,lr}
;;;387    {
000002  4604              MOV      r4,r0
;;;388      /* Start the low level driver  */
;;;389      USBH_LL_Start(phost);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USBH_LL_Start
;;;390    
;;;391      /* Activate VBUS on the port */
;;;392      USBH_LL_DriverVBUS(phost, TRUE);
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       USBH_LL_DriverVBUS
;;;393    
;;;394      return USBH_OK;
000012  2000              MOVS     r0,#0
;;;395    }
000014  bd10              POP      {r4,pc}
;;;396    
                          ENDP


                          AREA ||i.USBH_Stop||, CODE, READONLY, ALIGN=1

                  USBH_Stop PROC
;;;403      */
;;;404    USBH_StatusTypeDef  USBH_Stop(USBH_HandleTypeDef *phost)
000000  b510              PUSH     {r4,lr}
;;;405    {
000002  4604              MOV      r4,r0
;;;406      /* DeActivate VBUS on the port */
;;;407      USBH_LL_DriverVBUS(phost, FALSE);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USBH_LL_DriverVBUS
;;;408    
;;;409      /* Stop and cleanup the low level driver  */
;;;410      USBH_LL_Stop(phost);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       USBH_LL_Stop
;;;411    
;;;412      /* Free Control Pipes */
;;;413      USBH_FreePipe(phost, phost->Control.pipe_in);
000012  7921              LDRB     r1,[r4,#4]
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       USBH_FreePipe
;;;414      USBH_FreePipe(phost, phost->Control.pipe_out);
00001a  7961              LDRB     r1,[r4,#5]
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       USBH_FreePipe
;;;415    
;;;416      return USBH_OK;
000022  2000              MOVS     r0,#0
;;;417    }
000024  bd10              POP      {r4,pc}
;;;418    
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  436f6e74          DCB      "Control error: Get Device configuration descriptor requ"
000004  726f6c20
000008  6572726f
00000c  723a2047
000010  65742044
000014  65766963
000018  6520636f
00001c  6e666967
000020  75726174
000024  696f6e20
000028  64657363
00002c  72697074
000030  6f722072
000034  657175  
000037  65737420          DCB      "est failed",0
00003b  6661696c
00003f  656400  

;*** Start embedded assembler ***

#line 1 "../Middlewares/ST/STM32_USB_Host_Library/Core/Src/usbh_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_c8bbc4af____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___11_usbh_core_c_c8bbc4af____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_c8bbc4af____REVSH|
#line 478
|__asm___11_usbh_core_c_c8bbc4af____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_c8bbc4af____RRX|
#line 665
|__asm___11_usbh_core_c_c8bbc4af____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
