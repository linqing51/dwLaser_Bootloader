; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_dac.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_dac.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_dac.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dac.c]
                          THUMB

                          AREA ||i.DAC_DMAConvCpltCh1||, CODE, READONLY, ALIGN=1

                  DAC_DMAConvCpltCh1 PROC
;;;1228     */
;;;1229   static void DAC_DMAConvCpltCh1(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1230   {
000002  4604              MOV      r4,r0
;;;1231     DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1232     
;;;1233   #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;1234     hdac->ConvCpltCallbackCh1(hdac);
;;;1235   #else
;;;1236     HAL_DAC_ConvCpltCallbackCh1(hdac); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_DAC_ConvCpltCallbackCh1
;;;1237   #endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;1238     
;;;1239     hdac->State= HAL_DAC_STATE_READY;
00000c  2001              MOVS     r0,#1
00000e  7128              STRB     r0,[r5,#4]
;;;1240   }
000010  bd70              POP      {r4-r6,pc}
;;;1241   
                          ENDP


                          AREA ||i.DAC_DMAErrorCh1||, CODE, READONLY, ALIGN=1

                  DAC_DMAErrorCh1 PROC
;;;1264     */
;;;1265   static void DAC_DMAErrorCh1(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1266   {
000002  4605              MOV      r5,r0
;;;1267     DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1268       
;;;1269     /* Set DAC error code to DMA error */
;;;1270     hdac->ErrorCode |= HAL_DAC_ERROR_DMA;
000006  6920              LDR      r0,[r4,#0x10]
000008  f0400004          ORR      r0,r0,#4
00000c  6120              STR      r0,[r4,#0x10]
;;;1271       
;;;1272   #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;1273     hdac->ErrorCallbackCh1(hdac);
;;;1274   #else
;;;1275     HAL_DAC_ErrorCallbackCh1(hdac); 
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_DAC_ErrorCallbackCh1
;;;1276   #endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;1277       
;;;1278     hdac->State= HAL_DAC_STATE_READY;
000014  2001              MOVS     r0,#1
000016  7120              STRB     r0,[r4,#4]
;;;1279   }
000018  bd70              POP      {r4-r6,pc}
;;;1280   
                          ENDP


                          AREA ||i.DAC_DMAHalfConvCpltCh1||, CODE, READONLY, ALIGN=1

                  DAC_DMAHalfConvCpltCh1 PROC
;;;1247     */
;;;1248   static void DAC_DMAHalfConvCpltCh1(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1249   {
000002  4604              MOV      r4,r0
;;;1250       DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1251       /* Conversion complete callback */
;;;1252   #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;1253     hdac->ConvHalfCpltCallbackCh1(hdac);
;;;1254   #else
;;;1255       HAL_DAC_ConvHalfCpltCallbackCh1(hdac); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_DAC_ConvHalfCpltCallbackCh1
;;;1256   #endif  /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;1257   }
00000c  bd70              POP      {r4-r6,pc}
;;;1258   
                          ENDP


                          AREA ||i.HAL_DAC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ConfigChannel PROC
;;;848      */
;;;849    HAL_StatusTypeDef HAL_DAC_ConfigChannel(DAC_HandleTypeDef* hdac, DAC_ChannelConfTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;850    {
000002  4603              MOV      r3,r0
;;;851      uint32_t tmpreg1 = 0U, tmpreg2 = 0U;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
;;;852    
;;;853      /* Check the DAC parameters */
;;;854      assert_param(IS_DAC_TRIGGER(sConfig->DAC_Trigger));
;;;855      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(sConfig->DAC_OutputBuffer));
;;;856      assert_param(IS_DAC_CHANNEL(Channel));
;;;857      
;;;858      /* Process locked */
;;;859      __HAL_LOCK(hdac);
000008  bf00              NOP      
00000a  7958              LDRB     r0,[r3,#5]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L4.20|
000010  2002              MOVS     r0,#2
                  |L4.18|
;;;860      
;;;861      /* Change DAC state */
;;;862      hdac->State = HAL_DAC_STATE_BUSY;
;;;863      
;;;864      /* Get the DAC CR value */
;;;865      tmpreg1 = hdac->Instance->CR;
;;;866      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;867      tmpreg1 &= ~(((uint32_t)(DAC_CR_MAMP1 | DAC_CR_WAVE1 | DAC_CR_TSEL1 | DAC_CR_TEN1 | DAC_CR_BOFF1)) << Channel);
;;;868      /* Configure for the selected DAC channel: buffer output, trigger */
;;;869      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;870      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;871      tmpreg2 = (sConfig->DAC_Trigger | sConfig->DAC_OutputBuffer);
;;;872      /* Calculate CR register value depending on DAC_Channel */
;;;873      tmpreg1 |= tmpreg2 << Channel;
;;;874      /* Write to DAC CR */
;;;875      hdac->Instance->CR = tmpreg1;
;;;876      /* Disable wave generation */
;;;877      hdac->Instance->CR &= ~(DAC_CR_WAVE1 << Channel);
;;;878      
;;;879      /* Change DAC state */
;;;880      hdac->State = HAL_DAC_STATE_READY;
;;;881      
;;;882      /* Process unlocked */
;;;883      __HAL_UNLOCK(hdac);
;;;884      
;;;885      /* Return function status */
;;;886      return HAL_OK;
;;;887    }
000012  bd70              POP      {r4-r6,pc}
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;859
000016  7158              STRB     r0,[r3,#5]            ;859
000018  bf00              NOP                            ;859
00001a  2002              MOVS     r0,#2                 ;862
00001c  7118              STRB     r0,[r3,#4]            ;862
00001e  6818              LDR      r0,[r3,#0]            ;865
000020  6804              LDR      r4,[r0,#0]            ;865
000022  f64070fe          MOV      r0,#0xffe             ;867
000026  4090              LSLS     r0,r0,r2              ;867
000028  4384              BICS     r4,r4,r0              ;867
00002a  e9d10600          LDRD     r0,r6,[r1,#0]         ;871
00002e  ea400506          ORR      r5,r0,r6              ;871
000032  fa05f002          LSL      r0,r5,r2              ;873
000036  4304              ORRS     r4,r4,r0              ;873
000038  6818              LDR      r0,[r3,#0]            ;875
00003a  6004              STR      r4,[r0,#0]            ;875
00003c  6818              LDR      r0,[r3,#0]            ;877
00003e  6806              LDR      r6,[r0,#0]            ;877
000040  20c0              MOVS     r0,#0xc0              ;877
000042  4090              LSLS     r0,r0,r2              ;877
000044  4386              BICS     r6,r6,r0              ;877
000046  6818              LDR      r0,[r3,#0]            ;877
000048  6006              STR      r6,[r0,#0]            ;877
00004a  2001              MOVS     r0,#1                 ;880
00004c  7118              STRB     r0,[r3,#4]            ;880
00004e  bf00              NOP                            ;883
000050  2000              MOVS     r0,#0                 ;883
000052  7158              STRB     r0,[r3,#5]            ;883
000054  bf00              NOP                            ;883
000056  bf00              NOP                            ;886
000058  e7db              B        |L4.18|
;;;888    
                          ENDP


                          AREA ||i.HAL_DAC_ConvCpltCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ConvCpltCallbackCh1 PROC
;;;764      */
;;;765    __weak void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;766    {
;;;767      /* Prevent unused argument(s) compilation warning */
;;;768      UNUSED(hdac);
;;;769      /* NOTE : This function Should not be modified, when the callback is needed,
;;;770                the HAL_DAC_ConvCpltCallback could be implemented in the user file
;;;771       */
;;;772    }
;;;773    
                          ENDP


                          AREA ||i.HAL_DAC_ConvHalfCpltCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ConvHalfCpltCallbackCh1 PROC
;;;779      */
;;;780    __weak void HAL_DAC_ConvHalfCpltCallbackCh1(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;781    {
;;;782      /* Prevent unused argument(s) compilation warning */
;;;783      UNUSED(hdac);
;;;784      /* NOTE : This function Should not be modified, when the callback is needed,
;;;785                the HAL_DAC_ConvHalfCpltCallbackCh1 could be implemented in the user file
;;;786       */
;;;787    }
;;;788    
                          ENDP


                          AREA ||i.HAL_DAC_DMAUnderrunCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_DMAUnderrunCallbackCh1 PROC
;;;809      */
;;;810    __weak void HAL_DAC_DMAUnderrunCallbackCh1(DAC_HandleTypeDef *hdac)
000000  4770              BX       lr
;;;811    {
;;;812      /* Prevent unused argument(s) compilation warning */
;;;813      UNUSED(hdac);
;;;814      /* NOTE : This function Should not be modified, when the callback is needed,
;;;815                the HAL_DAC_DMAUnderrunCallbackCh1 could be implemented in the user file
;;;816       */
;;;817    }
;;;818    
                          ENDP


                          AREA ||i.HAL_DAC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DAC_DeInit PROC
;;;327      */
;;;328    HAL_StatusTypeDef HAL_DAC_DeInit(DAC_HandleTypeDef* hdac)
000000  b510              PUSH     {r4,lr}
;;;329    {
000002  4604              MOV      r4,r0
;;;330      /* Check DAC handle */
;;;331      if(hdac == NULL)
000004  b90c              CBNZ     r4,|L8.10|
;;;332      {
;;;333         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L8.8|
;;;334      }
;;;335    
;;;336      /* Check the parameters */
;;;337      assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));
;;;338    
;;;339      /* Change DAC state */
;;;340      hdac->State = HAL_DAC_STATE_BUSY;
;;;341    
;;;342    #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;343      if(hdac->MspDeInitCallback == NULL)
;;;344      {
;;;345        hdac->MspDeInitCallback = HAL_DAC_MspDeInit;
;;;346      }
;;;347      /* DeInit the low level hardware */
;;;348      hdac->MspDeInitCallback(hdac);
;;;349    #else
;;;350      /* DeInit the low level hardware */
;;;351      HAL_DAC_MspDeInit(hdac);
;;;352    #endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;353    
;;;354      /* Set DAC error code to none */
;;;355      hdac->ErrorCode = HAL_DAC_ERROR_NONE;
;;;356    
;;;357      /* Change DAC state */
;;;358      hdac->State = HAL_DAC_STATE_RESET;
;;;359    
;;;360      /* Release Lock */
;;;361      __HAL_UNLOCK(hdac);
;;;362    
;;;363      /* Return function status */
;;;364      return HAL_OK;
;;;365    }
000008  bd10              POP      {r4,pc}
                  |L8.10|
00000a  2002              MOVS     r0,#2                 ;340
00000c  7120              STRB     r0,[r4,#4]            ;340
00000e  4620              MOV      r0,r4                 ;351
000010  f7fffffe          BL       HAL_DAC_MspDeInit
000014  2000              MOVS     r0,#0                 ;355
000016  6120              STR      r0,[r4,#0x10]         ;355
000018  7120              STRB     r0,[r4,#4]            ;358
00001a  bf00              NOP                            ;361
00001c  7160              STRB     r0,[r4,#5]            ;361
00001e  bf00              NOP                            ;361
000020  bf00              NOP                            ;364
000022  e7f1              B        |L8.8|
;;;366    
                          ENDP


                          AREA ||i.HAL_DAC_ErrorCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ErrorCallbackCh1 PROC
;;;794      */
;;;795    __weak void HAL_DAC_ErrorCallbackCh1(DAC_HandleTypeDef *hdac)
000000  4770              BX       lr
;;;796    {
;;;797      /* Prevent unused argument(s) compilation warning */
;;;798      UNUSED(hdac);
;;;799      /* NOTE : This function Should not be modified, when the callback is needed,
;;;800                the HAL_DAC_ErrorCallbackCh1 could be implemented in the user file
;;;801       */
;;;802    }
;;;803    
                          ENDP


                          AREA ||i.HAL_DAC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DAC_GetError PROC
;;;969      */
;;;970    uint32_t HAL_DAC_GetError(DAC_HandleTypeDef *hdac)
000000  4601              MOV      r1,r0
;;;971    {
;;;972      return hdac->ErrorCode;
000002  6908              LDR      r0,[r1,#0x10]
;;;973    }
000004  4770              BX       lr
;;;974    
                          ENDP


                          AREA ||i.HAL_DAC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DAC_GetState PROC
;;;956      */
;;;957    HAL_DAC_StateTypeDef HAL_DAC_GetState(DAC_HandleTypeDef* hdac)
000000  4601              MOV      r1,r0
;;;958    {
;;;959      /* Return DAC state */
;;;960      return hdac->State;
000002  7908              LDRB     r0,[r1,#4]
;;;961    }
000004  4770              BX       lr
;;;962    
                          ENDP


                          AREA ||i.HAL_DAC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_DAC_GetValue PROC
;;;688      */
;;;689    uint32_t HAL_DAC_GetValue(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;690    {
;;;691      /* Check the parameters */
;;;692      assert_param(IS_DAC_CHANNEL(Channel));
;;;693      
;;;694      /* Returns the DAC channel data output register value */
;;;695      if(Channel == DAC_CHANNEL_1)
000002  b911              CBNZ     r1,|L12.10|
;;;696      {
;;;697        return hdac->Instance->DOR1;
000004  6810              LDR      r0,[r2,#0]
000006  6ac0              LDR      r0,[r0,#0x2c]
                  |L12.8|
;;;698      }
;;;699      else
;;;700      {
;;;701        return hdac->Instance->DOR2;
;;;702      }
;;;703    }
000008  4770              BX       lr
                  |L12.10|
00000a  6810              LDR      r0,[r2,#0]            ;701
00000c  6b00              LDR      r0,[r0,#0x30]         ;701
00000e  e7fb              B        |L12.8|
;;;704    
                          ENDP


                          AREA ||i.HAL_DAC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_DAC_IRQHandler PROC
;;;710      */
;;;711    void HAL_DAC_IRQHandler(DAC_HandleTypeDef* hdac)
000000  b510              PUSH     {r4,lr}
;;;712    {
000002  4604              MOV      r4,r0
;;;713      /* Check underrun channel 1 flag */
;;;714      if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR1))
000004  6820              LDR      r0,[r4,#0]
000006  6b40              LDR      r0,[r0,#0x34]
000008  f4005000          AND      r0,r0,#0x2000
00000c  f5b05f00          CMP      r0,#0x2000
000010  d112              BNE      |L13.56|
;;;715      {
;;;716        /* Change DAC state to error state */
;;;717        hdac->State = HAL_DAC_STATE_ERROR;
000012  2004              MOVS     r0,#4
000014  7120              STRB     r0,[r4,#4]
;;;718        
;;;719        /* Set DAC error code to channel1 DMA underrun error */
;;;720        hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH1;
000016  6920              LDR      r0,[r4,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  6120              STR      r0,[r4,#0x10]
;;;721        
;;;722        /* Clear the underrun flag */
;;;723        __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR1);
00001e  f44f5000          MOV      r0,#0x2000
000022  6821              LDR      r1,[r4,#0]
000024  6348              STR      r0,[r1,#0x34]
;;;724        
;;;725        /* Disable the selected DAC channel1 DMA request */
;;;726        hdac->Instance->CR &= ~DAC_CR_DMAEN1;
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4205080          BIC      r0,r0,#0x1000
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
;;;727        
;;;728        /* Error callback */ 
;;;729    #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;730          hdac->DMAUnderrunCallbackCh1(hdac);
;;;731    #else
;;;732        HAL_DAC_DMAUnderrunCallbackCh1(hdac);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_DAC_DMAUnderrunCallbackCh1
                  |L13.56|
;;;733    #endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;734      }
;;;735      /* Check underrun channel 2 flag */
;;;736      if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR2))
000038  6820              LDR      r0,[r4,#0]
00003a  6b40              LDR      r0,[r0,#0x34]
00003c  f0005000          AND      r0,r0,#0x20000000
000040  f1b05f00          CMP      r0,#0x20000000
000044  d112              BNE      |L13.108|
;;;737      {
;;;738        /* Change DAC state to error state */
;;;739        hdac->State = HAL_DAC_STATE_ERROR;
000046  2004              MOVS     r0,#4
000048  7120              STRB     r0,[r4,#4]
;;;740        
;;;741        /* Set DAC error code to channel2 DMA underrun error */
;;;742        hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH2;
00004a  6920              LDR      r0,[r4,#0x10]
00004c  f0400002          ORR      r0,r0,#2
000050  6120              STR      r0,[r4,#0x10]
;;;743        
;;;744        /* Clear the underrun flag */
;;;745        __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR2);
000052  f04f5000          MOV      r0,#0x20000000
000056  6821              LDR      r1,[r4,#0]
000058  6348              STR      r0,[r1,#0x34]
;;;746        
;;;747        /* Disable the selected DAC channel1 DMA request */
;;;748        hdac->Instance->CR &= ~DAC_CR_DMAEN2;
00005a  6820              LDR      r0,[r4,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  f0205080          BIC      r0,r0,#0x10000000
000062  6821              LDR      r1,[r4,#0]
000064  6008              STR      r0,[r1,#0]
;;;749        
;;;750        /* Error callback */ 
;;;751    #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;752          hdac->DMAUnderrunCallbackCh2(hdac);
;;;753    #else
;;;754        HAL_DACEx_DMAUnderrunCallbackCh2(hdac);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_DACEx_DMAUnderrunCallbackCh2
                  |L13.108|
;;;755    #endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;756      }
;;;757    }
00006c  bd10              POP      {r4,pc}
;;;758    
                          ENDP


                          AREA ||i.HAL_DAC_Init||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Init PROC
;;;268      */
;;;269    HAL_StatusTypeDef HAL_DAC_Init(DAC_HandleTypeDef* hdac)
000000  b510              PUSH     {r4,lr}
;;;270    { 
000002  4604              MOV      r4,r0
;;;271      /* Check DAC handle */
;;;272      if(hdac == NULL)
000004  b90c              CBNZ     r4,|L14.10|
;;;273      {
;;;274         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L14.8|
;;;275      }
;;;276      /* Check the parameters */
;;;277      assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));
;;;278      
;;;279      if(hdac->State == HAL_DAC_STATE_RESET)
;;;280      {  
;;;281    #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;282        /* Init the DAC Callback settings */
;;;283        hdac->ConvCpltCallbackCh1           = HAL_DAC_ConvCpltCallbackCh1;
;;;284        hdac->ConvHalfCpltCallbackCh1       = HAL_DAC_ConvHalfCpltCallbackCh1;
;;;285        hdac->ErrorCallbackCh1              = HAL_DAC_ErrorCallbackCh1;
;;;286        hdac->DMAUnderrunCallbackCh1        = HAL_DAC_DMAUnderrunCallbackCh1;
;;;287    
;;;288        hdac->ConvCpltCallbackCh2           = HAL_DACEx_ConvCpltCallbackCh2;
;;;289        hdac->ConvHalfCpltCallbackCh2       = HAL_DACEx_ConvHalfCpltCallbackCh2;
;;;290        hdac->ErrorCallbackCh2              = HAL_DACEx_ErrorCallbackCh2;
;;;291        hdac->DMAUnderrunCallbackCh2        = HAL_DACEx_DMAUnderrunCallbackCh2;
;;;292    
;;;293        if(hdac->MspInitCallback == NULL)
;;;294        {
;;;295          hdac->MspInitCallback               = HAL_DAC_MspInit;
;;;296        }
;;;297    #endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;298        /* Allocate lock resource and initialize it */
;;;299        hdac->Lock = HAL_UNLOCKED;
;;;300    #if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
;;;301        /* Init the low level hardware */
;;;302        hdac->MspInitCallback(hdac);
;;;303    #else
;;;304        /* Init the low level hardware */
;;;305        HAL_DAC_MspInit(hdac);
;;;306    #endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
;;;307      }
;;;308      
;;;309      /* Initialize the DAC state*/
;;;310      hdac->State = HAL_DAC_STATE_BUSY;
;;;311      
;;;312      /* Set DAC error code to none */
;;;313      hdac->ErrorCode = HAL_DAC_ERROR_NONE;
;;;314      
;;;315      /* Initialize the DAC state*/
;;;316      hdac->State = HAL_DAC_STATE_READY;
;;;317      
;;;318      /* Return function status */
;;;319      return HAL_OK;
;;;320    }
000008  bd10              POP      {r4,pc}
                  |L14.10|
00000a  7920              LDRB     r0,[r4,#4]            ;279
00000c  b920              CBNZ     r0,|L14.24|
00000e  2000              MOVS     r0,#0                 ;299
000010  7160              STRB     r0,[r4,#5]            ;299
000012  4620              MOV      r0,r4                 ;305
000014  f7fffffe          BL       HAL_DAC_MspInit
                  |L14.24|
000018  2002              MOVS     r0,#2                 ;310
00001a  7120              STRB     r0,[r4,#4]            ;310
00001c  2000              MOVS     r0,#0                 ;313
00001e  6120              STR      r0,[r4,#0x10]         ;313
000020  2001              MOVS     r0,#1                 ;316
000022  7120              STRB     r0,[r4,#4]            ;316
000024  2000              MOVS     r0,#0                 ;319
000026  e7ef              B        |L14.8|
;;;321    
                          ENDP


                          AREA ||i.HAL_DAC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_DAC_MspDeInit PROC
;;;387      */
;;;388    __weak void HAL_DAC_MspDeInit(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;389    {
;;;390      /* Prevent unused argument(s) compilation warning */
;;;391      UNUSED(hdac);
;;;392      /* NOTE : This function Should not be modified, when the callback is needed,
;;;393                the HAL_DAC_MspDeInit could be implemented in the user file
;;;394       */ 
;;;395    }
;;;396    
                          ENDP


                          AREA ||i.HAL_DAC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_DAC_MspInit PROC
;;;372      */
;;;373    __weak void HAL_DAC_MspInit(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;374    {
;;;375      /* Prevent unused argument(s) compilation warning */
;;;376      UNUSED(hdac);
;;;377      /* NOTE : This function Should not be modified, when the callback is needed,
;;;378                the HAL_DAC_MspInit could be implemented in the user file
;;;379       */ 
;;;380    }
;;;381    
                          ENDP


                          AREA ||i.HAL_DAC_SetValue||, CODE, READONLY, ALIGN=1

                  HAL_DAC_SetValue PROC
;;;904      */
;;;905    HAL_StatusTypeDef HAL_DAC_SetValue(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Alignment, uint32_t Data)
000000  b538              PUSH     {r3-r5,lr}
;;;906    {  
000002  4604              MOV      r4,r0
;;;907      __IO uint32_t tmp = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;908      
;;;909      /* Check the parameters */
;;;910      assert_param(IS_DAC_CHANNEL(Channel));
;;;911      assert_param(IS_DAC_ALIGN(Alignment));
;;;912      assert_param(IS_DAC_DATA(Data));
;;;913      
;;;914      tmp = (uint32_t)hdac->Instance; 
000008  6820              LDR      r0,[r4,#0]
00000a  9000              STR      r0,[sp,#0]
;;;915      if(Channel == DAC_CHANNEL_1)
00000c  b929              CBNZ     r1,|L17.26|
;;;916      {
;;;917        tmp += DAC_DHR12R1_ALIGNMENT(Alignment);
00000e  f1020008          ADD      r0,r2,#8
000012  9d00              LDR      r5,[sp,#0]
000014  4428              ADD      r0,r0,r5
000016  9000              STR      r0,[sp,#0]
000018  e004              B        |L17.36|
                  |L17.26|
;;;918      }
;;;919      else
;;;920      {
;;;921        tmp += DAC_DHR12R2_ALIGNMENT(Alignment);
00001a  f1020014          ADD      r0,r2,#0x14
00001e  9d00              LDR      r5,[sp,#0]
000020  4428              ADD      r0,r0,r5
000022  9000              STR      r0,[sp,#0]
                  |L17.36|
;;;922      }
;;;923    
;;;924      /* Set the DAC channel1 selected data holding register */
;;;925      *(__IO uint32_t *) tmp = Data;
000024  9800              LDR      r0,[sp,#0]
000026  6003              STR      r3,[r0,#0]
;;;926      
;;;927      /* Return function status */
;;;928      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;929    }
00002a  bd38              POP      {r3-r5,pc}
;;;930    
                          ENDP


                          AREA ||i.HAL_DAC_Start||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Start PROC
;;;428      */
;;;429    HAL_StatusTypeDef HAL_DAC_Start(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;430    {
000002  4602              MOV      r2,r0
;;;431      uint32_t tmp1 = 0U, tmp2 = 0U;
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;432      
;;;433      /* Check the parameters */
;;;434      assert_param(IS_DAC_CHANNEL(Channel));
;;;435      
;;;436      /* Process locked */
;;;437      __HAL_LOCK(hdac);
000008  bf00              NOP      
00000a  7950              LDRB     r0,[r2,#5]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L18.20|
000010  2002              MOVS     r0,#2
                  |L18.18|
;;;438      
;;;439      /* Change DAC state */
;;;440      hdac->State = HAL_DAC_STATE_BUSY;
;;;441      
;;;442      /* Enable the Peripheral */
;;;443      __HAL_DAC_ENABLE(hdac, Channel);
;;;444      
;;;445      if(Channel == DAC_CHANNEL_1)
;;;446      {
;;;447        tmp1 = hdac->Instance->CR & DAC_CR_TEN1;
;;;448        tmp2 = hdac->Instance->CR & DAC_CR_TSEL1;
;;;449        /* Check if software trigger enabled */
;;;450        if((tmp1 ==  DAC_CR_TEN1) && (tmp2 ==  DAC_CR_TSEL1))
;;;451        {
;;;452          /* Enable the selected DAC software conversion */
;;;453          hdac->Instance->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1;
;;;454        }
;;;455      }
;;;456      else
;;;457      {
;;;458        tmp1 = hdac->Instance->CR & DAC_CR_TEN2;
;;;459        tmp2 = hdac->Instance->CR & DAC_CR_TSEL2;    
;;;460        /* Check if software trigger enabled */
;;;461        if((tmp1 == DAC_CR_TEN2) && (tmp2 == DAC_CR_TSEL2))
;;;462        {
;;;463          /* Enable the selected DAC software conversion*/
;;;464          hdac->Instance->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG2;
;;;465        }
;;;466      }
;;;467      
;;;468      /* Change DAC state */
;;;469      hdac->State = HAL_DAC_STATE_READY;
;;;470      
;;;471      /* Process unlocked */
;;;472      __HAL_UNLOCK(hdac);
;;;473        
;;;474      /* Return function status */
;;;475      return HAL_OK;
;;;476    }
000012  bd30              POP      {r4,r5,pc}
                  |L18.20|
000014  2001              MOVS     r0,#1                 ;437
000016  7150              STRB     r0,[r2,#5]            ;437
000018  bf00              NOP                            ;437
00001a  2002              MOVS     r0,#2                 ;440
00001c  7110              STRB     r0,[r2,#4]            ;440
00001e  6810              LDR      r0,[r2,#0]            ;443
000020  6800              LDR      r0,[r0,#0]            ;443
000022  2501              MOVS     r5,#1                 ;443
000024  408d              LSLS     r5,r5,r1              ;443
000026  4328              ORRS     r0,r0,r5              ;443
000028  6815              LDR      r5,[r2,#0]            ;443
00002a  6028              STR      r0,[r5,#0]            ;443
00002c  b991              CBNZ     r1,|L18.84|
00002e  6810              LDR      r0,[r2,#0]            ;447
000030  6800              LDR      r0,[r0,#0]            ;447
000032  f0000304          AND      r3,r0,#4              ;447
000036  6810              LDR      r0,[r2,#0]            ;448
000038  6800              LDR      r0,[r0,#0]            ;448
00003a  f0000438          AND      r4,r0,#0x38           ;448
00003e  2b04              CMP      r3,#4                 ;450
000040  d11c              BNE      |L18.124|
000042  2c38              CMP      r4,#0x38              ;450
000044  d11a              BNE      |L18.124|
000046  6810              LDR      r0,[r2,#0]            ;453
000048  6840              LDR      r0,[r0,#4]            ;453
00004a  f0400001          ORR      r0,r0,#1              ;453
00004e  6815              LDR      r5,[r2,#0]            ;453
000050  6068              STR      r0,[r5,#4]            ;453
000052  e013              B        |L18.124|
                  |L18.84|
000054  6810              LDR      r0,[r2,#0]            ;458
000056  6800              LDR      r0,[r0,#0]            ;458
000058  f4002380          AND      r3,r0,#0x40000        ;458
00005c  6810              LDR      r0,[r2,#0]            ;459
00005e  6800              LDR      r0,[r0,#0]            ;459
000060  f4001460          AND      r4,r0,#0x380000       ;459
000064  f5b32f80          CMP      r3,#0x40000           ;461
000068  d108              BNE      |L18.124|
00006a  f5b41f60          CMP      r4,#0x380000          ;461
00006e  d105              BNE      |L18.124|
000070  6810              LDR      r0,[r2,#0]            ;464
000072  6840              LDR      r0,[r0,#4]            ;464
000074  f0400002          ORR      r0,r0,#2              ;464
000078  6815              LDR      r5,[r2,#0]            ;464
00007a  6068              STR      r0,[r5,#4]            ;464
                  |L18.124|
00007c  2001              MOVS     r0,#1                 ;469
00007e  7110              STRB     r0,[r2,#4]            ;469
000080  bf00              NOP                            ;472
000082  2000              MOVS     r0,#0                 ;472
000084  7150              STRB     r0,[r2,#5]            ;472
000086  bf00              NOP                            ;472
000088  bf00              NOP                            ;475
00008a  e7c2              B        |L18.18|
;;;477    
                          ENDP


                          AREA ||i.HAL_DAC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_DAC_Start_DMA PROC
;;;519      */
;;;520    HAL_StatusTypeDef HAL_DAC_Start_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t* pData, uint32_t Length, uint32_t Alignment)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;521    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  9f08              LDR      r7,[sp,#0x20]
;;;522      uint32_t tmpreg = 0U;
00000e  f04f0900          MOV      r9,#0
;;;523        
;;;524      /* Check the parameters */
;;;525      assert_param(IS_DAC_CHANNEL(Channel));
;;;526      assert_param(IS_DAC_ALIGN(Alignment));
;;;527      
;;;528      /* Process locked */
;;;529      __HAL_LOCK(hdac);
000012  bf00              NOP      
000014  7960              LDRB     r0,[r4,#5]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L19.32|
00001a  2002              MOVS     r0,#2
                  |L19.28|
;;;530      
;;;531      /* Change DAC state */
;;;532      hdac->State = HAL_DAC_STATE_BUSY;
;;;533    
;;;534      if(Channel == DAC_CHANNEL_1)
;;;535      {
;;;536        /* Set the DMA transfer complete callback for channel1 */
;;;537        hdac->DMA_Handle1->XferCpltCallback = DAC_DMAConvCpltCh1;
;;;538    
;;;539        /* Set the DMA half transfer complete callback for channel1 */
;;;540        hdac->DMA_Handle1->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh1;
;;;541    
;;;542        /* Set the DMA error callback for channel1 */
;;;543        hdac->DMA_Handle1->XferErrorCallback = DAC_DMAErrorCh1;
;;;544    
;;;545        /* Enable the selected DAC channel1 DMA request */
;;;546        hdac->Instance->CR |= DAC_CR_DMAEN1;
;;;547        
;;;548        /* Case of use of channel 1 */
;;;549        switch(Alignment)
;;;550        {
;;;551          case DAC_ALIGN_12B_R:
;;;552            /* Get DHR12R1 address */
;;;553            tmpreg = (uint32_t)&hdac->Instance->DHR12R1;
;;;554            break;
;;;555          case DAC_ALIGN_12B_L:
;;;556            /* Get DHR12L1 address */
;;;557            tmpreg = (uint32_t)&hdac->Instance->DHR12L1;
;;;558            break;
;;;559          case DAC_ALIGN_8B_R:
;;;560            /* Get DHR8R1 address */
;;;561            tmpreg = (uint32_t)&hdac->Instance->DHR8R1;
;;;562            break;
;;;563          default:
;;;564            break;
;;;565        }
;;;566      }
;;;567      else
;;;568      {
;;;569        /* Set the DMA transfer complete callback for channel2 */
;;;570        hdac->DMA_Handle2->XferCpltCallback = DAC_DMAConvCpltCh2;
;;;571    
;;;572        /* Set the DMA half transfer complete callback for channel2 */
;;;573        hdac->DMA_Handle2->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh2;
;;;574    
;;;575        /* Set the DMA error callback for channel2 */
;;;576        hdac->DMA_Handle2->XferErrorCallback = DAC_DMAErrorCh2;
;;;577    
;;;578        /* Enable the selected DAC channel2 DMA request */
;;;579        hdac->Instance->CR |= DAC_CR_DMAEN2;
;;;580    
;;;581        /* Case of use of channel 2 */
;;;582        switch(Alignment)
;;;583        {
;;;584          case DAC_ALIGN_12B_R:
;;;585            /* Get DHR12R2 address */
;;;586            tmpreg = (uint32_t)&hdac->Instance->DHR12R2;
;;;587            break;
;;;588          case DAC_ALIGN_12B_L:
;;;589            /* Get DHR12L2 address */
;;;590            tmpreg = (uint32_t)&hdac->Instance->DHR12L2;
;;;591            break;
;;;592          case DAC_ALIGN_8B_R:
;;;593            /* Get DHR8R2 address */
;;;594            tmpreg = (uint32_t)&hdac->Instance->DHR8R2;
;;;595            break;
;;;596          default:
;;;597            break;
;;;598        }
;;;599      }
;;;600      
;;;601      /* Enable the DMA Stream */
;;;602      if(Channel == DAC_CHANNEL_1)
;;;603      {
;;;604        /* Enable the DAC DMA underrun interrupt */
;;;605        __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR1);
;;;606        
;;;607        /* Enable the DMA Stream */
;;;608        HAL_DMA_Start_IT(hdac->DMA_Handle1, (uint32_t)pData, tmpreg, Length);
;;;609      } 
;;;610      else
;;;611      {
;;;612        /* Enable the DAC DMA underrun interrupt */
;;;613        __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR2);
;;;614        
;;;615        /* Enable the DMA Stream */
;;;616        HAL_DMA_Start_IT(hdac->DMA_Handle2, (uint32_t)pData, tmpreg, Length);
;;;617      }
;;;618      
;;;619      /* Enable the Peripheral */
;;;620      __HAL_DAC_ENABLE(hdac, Channel);
;;;621      
;;;622      /* Process Unlocked */
;;;623      __HAL_UNLOCK(hdac);
;;;624      
;;;625      /* Return function status */
;;;626      return HAL_OK;
;;;627    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L19.32|
000020  2001              MOVS     r0,#1                 ;529
000022  7160              STRB     r0,[r4,#5]            ;529
000024  bf00              NOP                            ;529
000026  2002              MOVS     r0,#2                 ;532
000028  7120              STRB     r0,[r4,#4]            ;532
00002a  bb15              CBNZ     r5,|L19.114|
00002c  4836              LDR      r0,|L19.264|
00002e  68a1              LDR      r1,[r4,#8]            ;537
000030  63c8              STR      r0,[r1,#0x3c]         ;537
000032  4836              LDR      r0,|L19.268|
000034  68a1              LDR      r1,[r4,#8]            ;540
000036  6408              STR      r0,[r1,#0x40]         ;540
000038  4835              LDR      r0,|L19.272|
00003a  68a1              LDR      r1,[r4,#8]            ;543
00003c  64c8              STR      r0,[r1,#0x4c]         ;543
00003e  6820              LDR      r0,[r4,#0]            ;546
000040  6800              LDR      r0,[r0,#0]            ;546
000042  f4405080          ORR      r0,r0,#0x1000         ;546
000046  6821              LDR      r1,[r4,#0]            ;546
000048  6008              STR      r0,[r1,#0]            ;546
00004a  b127              CBZ      r7,|L19.86|
00004c  2f04              CMP      r7,#4                 ;549
00004e  d006              BEQ      |L19.94|
000050  2f08              CMP      r7,#8                 ;549
000052  d10c              BNE      |L19.110|
000054  e007              B        |L19.102|
                  |L19.86|
000056  6820              LDR      r0,[r4,#0]            ;553
000058  f1000908          ADD      r9,r0,#8              ;553
00005c  e008              B        |L19.112|
                  |L19.94|
00005e  6820              LDR      r0,[r4,#0]            ;557
000060  f100090c          ADD      r9,r0,#0xc            ;557
000064  e004              B        |L19.112|
                  |L19.102|
000066  6820              LDR      r0,[r4,#0]            ;561
000068  f1000910          ADD      r9,r0,#0x10           ;561
00006c  e000              B        |L19.112|
                  |L19.110|
00006e  bf00              NOP                            ;564
                  |L19.112|
000070  e022              B        |L19.184|
                  |L19.114|
000072  4828              LDR      r0,|L19.276|
000074  68e1              LDR      r1,[r4,#0xc]          ;570
000076  63c8              STR      r0,[r1,#0x3c]         ;570
000078  4827              LDR      r0,|L19.280|
00007a  68e1              LDR      r1,[r4,#0xc]          ;573
00007c  6408              STR      r0,[r1,#0x40]         ;573
00007e  4827              LDR      r0,|L19.284|
000080  68e1              LDR      r1,[r4,#0xc]          ;576
000082  64c8              STR      r0,[r1,#0x4c]         ;576
000084  6820              LDR      r0,[r4,#0]            ;579
000086  6800              LDR      r0,[r0,#0]            ;579
000088  f0405080          ORR      r0,r0,#0x10000000     ;579
00008c  6821              LDR      r1,[r4,#0]            ;579
00008e  6008              STR      r0,[r1,#0]            ;579
000090  b127              CBZ      r7,|L19.156|
000092  2f04              CMP      r7,#4                 ;582
000094  d006              BEQ      |L19.164|
000096  2f08              CMP      r7,#8                 ;582
000098  d10c              BNE      |L19.180|
00009a  e007              B        |L19.172|
                  |L19.156|
00009c  6820              LDR      r0,[r4,#0]            ;586
00009e  f1000914          ADD      r9,r0,#0x14           ;586
0000a2  e008              B        |L19.182|
                  |L19.164|
0000a4  6820              LDR      r0,[r4,#0]            ;590
0000a6  f1000918          ADD      r9,r0,#0x18           ;590
0000aa  e004              B        |L19.182|
                  |L19.172|
0000ac  6820              LDR      r0,[r4,#0]            ;594
0000ae  f100091c          ADD      r9,r0,#0x1c           ;594
0000b2  e000              B        |L19.182|
                  |L19.180|
0000b4  bf00              NOP                            ;597
                  |L19.182|
0000b6  bf00              NOP                            ;587
                  |L19.184|
0000b8  b965              CBNZ     r5,|L19.212|
0000ba  6820              LDR      r0,[r4,#0]            ;605
0000bc  6800              LDR      r0,[r0,#0]            ;605
0000be  f4405000          ORR      r0,r0,#0x2000         ;605
0000c2  6821              LDR      r1,[r4,#0]            ;605
0000c4  6008              STR      r0,[r1,#0]            ;605
0000c6  4643              MOV      r3,r8                 ;608
0000c8  464a              MOV      r2,r9                 ;608
0000ca  4631              MOV      r1,r6                 ;608
0000cc  68a0              LDR      r0,[r4,#8]            ;608
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  e00b              B        |L19.236|
                  |L19.212|
0000d4  6820              LDR      r0,[r4,#0]            ;613
0000d6  6800              LDR      r0,[r0,#0]            ;613
0000d8  f0405000          ORR      r0,r0,#0x20000000     ;613
0000dc  6821              LDR      r1,[r4,#0]            ;613
0000de  6008              STR      r0,[r1,#0]            ;613
0000e0  4643              MOV      r3,r8                 ;616
0000e2  464a              MOV      r2,r9                 ;616
0000e4  4631              MOV      r1,r6                 ;616
0000e6  68e0              LDR      r0,[r4,#0xc]          ;616
0000e8  f7fffffe          BL       HAL_DMA_Start_IT
                  |L19.236|
0000ec  6820              LDR      r0,[r4,#0]            ;620
0000ee  6800              LDR      r0,[r0,#0]            ;620
0000f0  2101              MOVS     r1,#1                 ;620
0000f2  40a9              LSLS     r1,r1,r5              ;620
0000f4  4308              ORRS     r0,r0,r1              ;620
0000f6  6821              LDR      r1,[r4,#0]            ;620
0000f8  6008              STR      r0,[r1,#0]            ;620
0000fa  bf00              NOP                            ;623
0000fc  2000              MOVS     r0,#0                 ;623
0000fe  7160              STRB     r0,[r4,#5]            ;623
000100  bf00              NOP                            ;623
000102  bf00              NOP                            ;626
000104  e78a              B        |L19.28|
;;;628    
                          ENDP

000106  0000              DCW      0x0000
                  |L19.264|
                          DCD      DAC_DMAConvCpltCh1
                  |L19.268|
                          DCD      DAC_DMAHalfConvCpltCh1
                  |L19.272|
                          DCD      DAC_DMAErrorCh1
                  |L19.276|
                          DCD      DAC_DMAConvCpltCh2
                  |L19.280|
                          DCD      DAC_DMAHalfConvCpltCh2
                  |L19.284|
                          DCD      DAC_DMAErrorCh2

                          AREA ||i.HAL_DAC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Stop PROC
;;;487      */
;;;488    HAL_StatusTypeDef HAL_DAC_Stop(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;489    {
;;;490      /* Check the parameters */
;;;491      assert_param(IS_DAC_CHANNEL(Channel));
;;;492      
;;;493      /* Disable the Peripheral */
;;;494      __HAL_DAC_DISABLE(hdac, Channel);
000002  6810              LDR      r0,[r2,#0]
000004  6800              LDR      r0,[r0,#0]
000006  2301              MOVS     r3,#1
000008  408b              LSLS     r3,r3,r1
00000a  4398              BICS     r0,r0,r3
00000c  6813              LDR      r3,[r2,#0]
00000e  6018              STR      r0,[r3,#0]
;;;495     
;;;496      /* Change DAC state */
;;;497      hdac->State = HAL_DAC_STATE_READY;
000010  2001              MOVS     r0,#1
000012  7110              STRB     r0,[r2,#4]
;;;498      
;;;499      /* Return function status */
;;;500      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;501    }
000016  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i.HAL_DAC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Stop_DMA PROC
;;;638      */
;;;639    HAL_StatusTypeDef HAL_DAC_Stop_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;640    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;641      HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;642    
;;;643      /* Check the parameters */
;;;644      assert_param(IS_DAC_CHANNEL(Channel));
;;;645      
;;;646      /* Disable the selected DAC channel DMA request */
;;;647       hdac->Instance->CR &= ~(DAC_CR_DMAEN1 << Channel);
000008  6820              LDR      r0,[r4,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f44f5180          MOV      r1,#0x1000
000010  40a9              LSLS     r1,r1,r5
000012  4388              BICS     r0,r0,r1
000014  6821              LDR      r1,[r4,#0]
000016  6008              STR      r0,[r1,#0]
;;;648        
;;;649      /* Disable the Peripheral */
;;;650      __HAL_DAC_DISABLE(hdac, Channel);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  2001              MOVS     r0,#1
00001e  40a8              LSLS     r0,r0,r5
000020  4381              BICS     r1,r1,r0
000022  6820              LDR      r0,[r4,#0]
000024  6001              STR      r1,[r0,#0]
;;;651      
;;;652      /* Disable the DMA Channel */
;;;653      /* Channel1 is used */
;;;654      if(Channel == DAC_CHANNEL_1)
000026  b925              CBNZ     r5,|L21.50|
;;;655      { 
;;;656        status = HAL_DMA_Abort(hdac->DMA_Handle1);
000028  68a0              LDR      r0,[r4,#8]
00002a  f7fffffe          BL       HAL_DMA_Abort
00002e  4606              MOV      r6,r0
000030  e003              B        |L21.58|
                  |L21.50|
;;;657      }
;;;658      else /* Channel2 is used for */
;;;659      { 
;;;660        status = HAL_DMA_Abort(hdac->DMA_Handle2); 
000032  68e0              LDR      r0,[r4,#0xc]
000034  f7fffffe          BL       HAL_DMA_Abort
000038  4606              MOV      r6,r0
                  |L21.58|
;;;661      }
;;;662    
;;;663      /* Check if DMA Channel effectively disabled */
;;;664      if(status != HAL_OK)
00003a  b116              CBZ      r6,|L21.66|
;;;665      {
;;;666        /* Update DAC state machine to error */
;;;667        hdac->State = HAL_DAC_STATE_ERROR;      
00003c  2004              MOVS     r0,#4
00003e  7120              STRB     r0,[r4,#4]
000040  e001              B        |L21.70|
                  |L21.66|
;;;668      }
;;;669      else
;;;670      {
;;;671        /* Change DAC state */
;;;672        hdac->State = HAL_DAC_STATE_READY;
000042  2001              MOVS     r0,#1
000044  7120              STRB     r0,[r4,#4]
                  |L21.70|
;;;673      }
;;;674    
;;;675      /* Return function status */
;;;676      return status;
000046  4630              MOV      r0,r6
;;;677    }
000048  bd70              POP      {r4-r6,pc}
;;;678    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dac_c_4837ae93____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_dac_c_4837ae93____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dac_c_4837ae93____REVSH|
#line 478
|__asm___19_stm32f4xx_hal_dac_c_4837ae93____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dac_c_4837ae93____RRX|
#line 665
|__asm___19_stm32f4xx_hal_dac_c_4837ae93____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
