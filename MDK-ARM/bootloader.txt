; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\bootloader.o --asm_dir=./ --list_dir=--list --depend=mcu_application\bootloader.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\bootloader.crf ..\Bootloader\bootLoader.c]
                          THUMB

                          AREA ||i.DBGU_Printk||, CODE, READONLY, ALIGN=2

                  DBGU_Printk PROC
;;;1423   //触摸屏程序
;;;1424   static void DBGU_Printk(uint8_t *buffer){//arg pointer to a string ending by
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1425   	while(*buffer != '\0'){
000004  e007              B        |L1.22|
                  |L1.6|
;;;1426   		HAL_UART_Transmit(&GDDC_UART_HANDLE, buffer, 1, GDDC_TX_TIMEOUT);
000006  f64f73ff          MOV      r3,#0xffff
00000a  2201              MOVS     r2,#1
00000c  4621              MOV      r1,r4
00000e  4804              LDR      r0,|L1.32|
000010  f7fffffe          BL       HAL_UART_Transmit
;;;1427   		buffer ++;
000014  1c64              ADDS     r4,r4,#1
                  |L1.22|
000016  7820              LDRB     r0,[r4,#0]            ;1425
000018  2800              CMP      r0,#0                 ;1425
00001a  d1f4              BNE      |L1.6|
;;;1428       }
;;;1429   }
00001c  bd10              POP      {r4,pc}
;;;1430   static void DBGU_Printk_num(uint8_t *buffer, uint16_t datanum){//arg pointer to a string ending by
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      huart5

                          AREA ||i.DBGU_Printk_num||, CODE, READONLY, ALIGN=2

                  DBGU_Printk_num PROC
;;;1429   }
;;;1430   static void DBGU_Printk_num(uint8_t *buffer, uint16_t datanum){//arg pointer to a string ending by
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1431       while(datanum != 0){
000006  e009              B        |L2.28|
                  |L2.8|
;;;1432   		HAL_UART_Transmit(&GDDC_UART_HANDLE, buffer, 1, GDDC_TX_TIMEOUT);
000008  f64f73ff          MOV      r3,#0xffff
00000c  2201              MOVS     r2,#1
00000e  4629              MOV      r1,r5
000010  4804              LDR      r0,|L2.36|
000012  f7fffffe          BL       HAL_UART_Transmit
;;;1433   		buffer ++;
000016  1c6d              ADDS     r5,r5,#1
;;;1434           datanum--;
000018  1e60              SUBS     r0,r4,#1
00001a  b284              UXTH     r4,r0
                  |L2.28|
00001c  2c00              CMP      r4,#0                 ;1431
00001e  d1f3              BNE      |L2.8|
;;;1435       }
;;;1436   }
000020  bd70              POP      {r4-r6,pc}
;;;1437   static void dp_display_text(uint8_t *text){
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      huart5

                          AREA ||i.SystemClock_Reset||, CODE, READONLY, ALIGN=2

                  SystemClock_Reset PROC
;;;255    }
;;;256    static void SystemClock_Reset(void){
000000  b500              PUSH     {lr}
000002  b093              SUB      sp,sp,#0x4c
;;;257    	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
000004  2134              MOVS     r1,#0x34
000006  a806              ADD      r0,sp,#0x18
000008  f7fffffe          BL       __aeabi_memclr4
;;;258    	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
00000c  2114              MOVS     r1,#0x14
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memclr4
;;;259    	__HAL_RCC_BACKUPRESET_RELEASE();
000014  2000              MOVS     r0,#0
000016  4927              LDR      r1,|L3.180|
000018  6008              STR      r0,[r1,#0]
;;;260    	__HAL_RCC_BACKUPRESET_FORCE();
00001a  2001              MOVS     r0,#1
00001c  6008              STR      r0,[r1,#0]
;;;261    	__HAL_RCC_PLL_DISABLE();
00001e  2000              MOVS     r0,#0
000020  4925              LDR      r1,|L3.184|
000022  6608              STR      r0,[r1,#0x60]
;;;262    	__HAL_RCC_HSI_DISABLE();
000024  6008              STR      r0,[r1,#0]
;;;263    	/** Configure the main internal regulator output voltage */
;;;264    	__HAL_RCC_PWR_CLK_DISABLE();
000026  4825              LDR      r0,|L3.188|
000028  6800              LDR      r0,[r0,#0]
00002a  f0205080          BIC      r0,r0,#0x10000000
00002e  4923              LDR      r1,|L3.188|
000030  6008              STR      r0,[r1,#0]
;;;265    	__HAL_RCC_PWR_CLK_ENABLE();
000032  bf00              NOP      
000034  2000              MOVS     r0,#0
000036  9000              STR      r0,[sp,#0]
000038  4608              MOV      r0,r1
00003a  6800              LDR      r0,[r0,#0]
00003c  f0405080          ORR      r0,r0,#0x10000000
000040  6008              STR      r0,[r1,#0]
000042  4608              MOV      r0,r1
000044  6800              LDR      r0,[r0,#0]
000046  f0005080          AND      r0,r0,#0x10000000
00004a  9000              STR      r0,[sp,#0]
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;266    	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
000050  bf00              NOP      
000052  2000              MOVS     r0,#0
000054  9000              STR      r0,[sp,#0]
000056  481a              LDR      r0,|L3.192|
000058  6800              LDR      r0,[r0,#0]
00005a  f4404040          ORR      r0,r0,#0xc000
00005e  4918              LDR      r1,|L3.192|
000060  6008              STR      r0,[r1,#0]
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]
000066  f4004040          AND      r0,r0,#0xc000
00006a  9000              STR      r0,[sp,#0]
00006c  bf00              NOP      
00006e  bf00              NOP      
;;;267    	/** Initializes the CPU, AHB and APB busses clocks */
;;;268    	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
000070  2002              MOVS     r0,#2
000072  9006              STR      r0,[sp,#0x18]
;;;269    	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
000074  2001              MOVS     r0,#1
000076  9009              STR      r0,[sp,#0x24]
;;;270    	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
000078  2010              MOVS     r0,#0x10
00007a  900a              STR      r0,[sp,#0x28]
;;;271    	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
00007c  2000              MOVS     r0,#0
00007e  900c              STR      r0,[sp,#0x30]
;;;272    	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
000080  a806              ADD      r0,sp,#0x18
000082  f7fffffe          BL       HAL_RCC_OscConfig
000086  b108              CBZ      r0,|L3.140|
;;;273    		Error_Handler();
000088  f7fffffe          BL       Error_Handler
                  |L3.140|
;;;274    	}
;;;275    	/** Initializes the CPU, AHB and APB busses clocks */
;;;276    	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
00008c  200f              MOVS     r0,#0xf
00008e  9001              STR      r0,[sp,#4]
;;;277    	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
000090  2000              MOVS     r0,#0
000092  9002              STR      r0,[sp,#8]
;;;278    	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
000094  9003              STR      r0,[sp,#0xc]
;;;279    	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
000096  f44f5080          MOV      r0,#0x1000
00009a  9004              STR      r0,[sp,#0x10]
;;;280    	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
00009c  2000              MOVS     r0,#0
00009e  9005              STR      r0,[sp,#0x14]
;;;281    	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK){
0000a0  2100              MOVS     r1,#0
0000a2  a801              ADD      r0,sp,#4
0000a4  f7fffffe          BL       HAL_RCC_ClockConfig
0000a8  b108              CBZ      r0,|L3.174|
;;;282    		Error_Handler();
0000aa  f7fffffe          BL       Error_Handler
                  |L3.174|
;;;283    	}
;;;284    }
0000ae  b013              ADD      sp,sp,#0x4c
0000b0  bd00              POP      {pc}
;;;285    void resetInit(void){//复位后初始化
                          ENDP

0000b2  0000              DCW      0x0000
                  |L3.180|
                          DCD      0x42470e40
                  |L3.184|
                          DCD      0x42470000
                  |L3.188|
                          DCD      0x40023840
                  |L3.192|
                          DCD      0x40007000

                          AREA ||i.UsbGpioReset||, CODE, READONLY, ALIGN=2

                  UsbGpioReset PROC
;;;222    //HAL 初始化
;;;223    static void UsbGpioReset(void){//模拟USB拔插动作并关闭VBUS供电
000000  b500              PUSH     {lr}
000002  b087              SUB      sp,sp,#0x1c
;;;224    	GPIO_InitTypeDef GPIO_InitStruct;
;;;225    	/* GPIO Ports Clock Enable */
;;;226    	__HAL_RCC_GPIOA_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
00000a  483c              LDR      r0,|L4.252|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0400001          ORR      r0,r0,#1
000012  493a              LDR      r1,|L4.252|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0000001          AND      r0,r0,#1
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;227    	/*Configure GPIO pin Output Level */
;;;228    	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, GPIO_PIN_RESET);
000024  2200              MOVS     r2,#0
000026  1489              ASRS     r1,r1,#18
000028  4835              LDR      r0,|L4.256|
00002a  f7fffffe          BL       HAL_GPIO_WritePin
;;;229    	/*Configure GPIO pin : PA12 */
;;;230    	GPIO_InitStruct.Pin = GPIO_PIN_12;
00002e  f44f5080          MOV      r0,#0x1000
000032  9002              STR      r0,[sp,#8]
;;;231    	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
000034  2001              MOVS     r0,#1
000036  9003              STR      r0,[sp,#0xc]
;;;232    	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
000038  2002              MOVS     r0,#2
00003a  9004              STR      r0,[sp,#0x10]
;;;233    	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
00003c  2000              MOVS     r0,#0
00003e  9005              STR      r0,[sp,#0x14]
;;;234    	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
000040  a902              ADD      r1,sp,#8
000042  482f              LDR      r0,|L4.256|
000044  f7fffffe          BL       HAL_GPIO_Init
;;;235    	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, GPIO_PIN_RESET);                                            
000048  2200              MOVS     r2,#0
00004a  f44f5180          MOV      r1,#0x1000
00004e  482c              LDR      r0,|L4.256|
000050  f7fffffe          BL       HAL_GPIO_WritePin
;;;236    	softDelayMs(100);
000054  2064              MOVS     r0,#0x64
000056  f7fffffe          BL       softDelayMs
;;;237    	//先把PA12拉低再拉高，利用D+模拟USB的拔插动作   
;;;238    	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, GPIO_PIN_SET);
00005a  2201              MOVS     r2,#1
00005c  0311              LSLS     r1,r2,#12
00005e  4828              LDR      r0,|L4.256|
000060  f7fffffe          BL       HAL_GPIO_WritePin
;;;239    	softDelayMs(100);
000064  2064              MOVS     r0,#0x64
000066  f7fffffe          BL       softDelayMs
;;;240    	HAL_GPIO_DeInit(GPIOA, GPIO_PIN_12);
00006a  f44f5180          MOV      r1,#0x1000
00006e  4824              LDR      r0,|L4.256|
000070  f7fffffe          BL       HAL_GPIO_DeInit
;;;241    	__HAL_RCC_GPIOA_CLK_DISABLE();
000074  4821              LDR      r0,|L4.252|
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  491f              LDR      r1,|L4.252|
00007e  6008              STR      r0,[r1,#0]
;;;242    	__HAL_RCC_GPIOG_CLK_ENABLE();
000080  bf00              NOP      
000082  2000              MOVS     r0,#0
000084  9001              STR      r0,[sp,#4]
000086  4608              MOV      r0,r1
000088  6800              LDR      r0,[r0,#0]
00008a  f0400040          ORR      r0,r0,#0x40
00008e  6008              STR      r0,[r1,#0]
000090  4608              MOV      r0,r1
000092  6800              LDR      r0,[r0,#0]
000094  f0000040          AND      r0,r0,#0x40
000098  9001              STR      r0,[sp,#4]
00009a  bf00              NOP      
00009c  bf00              NOP      
;;;243    	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_8, GPIO_PIN_RESET);
00009e  2200              MOVS     r2,#0
0000a0  1589              ASRS     r1,r1,#22
0000a2  4818              LDR      r0,|L4.260|
0000a4  f7fffffe          BL       HAL_GPIO_WritePin
;;;244    	GPIO_InitStruct.Pin = GPIO_PIN_8;
0000a8  f44f7080          MOV      r0,#0x100
0000ac  9002              STR      r0,[sp,#8]
;;;245    	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
0000ae  2001              MOVS     r0,#1
0000b0  9003              STR      r0,[sp,#0xc]
;;;246    	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
0000b2  2002              MOVS     r0,#2
0000b4  9004              STR      r0,[sp,#0x10]
;;;247    	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
0000b6  2000              MOVS     r0,#0
0000b8  9005              STR      r0,[sp,#0x14]
;;;248    	HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
0000ba  a902              ADD      r1,sp,#8
0000bc  4811              LDR      r0,|L4.260|
0000be  f7fffffe          BL       HAL_GPIO_Init
;;;249    	softDelayMs(200);
0000c2  20c8              MOVS     r0,#0xc8
0000c4  f7fffffe          BL       softDelayMs
;;;250    	HAL_GPIO_DeInit(GPIOG, GPIO_PIN_12);
0000c8  f44f5180          MOV      r1,#0x1000
0000cc  480d              LDR      r0,|L4.260|
0000ce  f7fffffe          BL       HAL_GPIO_DeInit
;;;251    	__HAL_RCC_GPIOG_CLK_DISABLE();	
0000d2  480a              LDR      r0,|L4.252|
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f0200040          BIC      r0,r0,#0x40
0000da  4908              LDR      r1,|L4.252|
0000dc  6008              STR      r0,[r1,#0]
;;;252    	__HAL_RCC_USB_OTG_FS_CLK_DISABLE();//关闭USB时钟
0000de  1d08              ADDS     r0,r1,#4
0000e0  6800              LDR      r0,[r0,#0]
0000e2  f0200080          BIC      r0,r0,#0x80
0000e6  1d09              ADDS     r1,r1,#4
0000e8  6008              STR      r0,[r1,#0]
;;;253    	HAL_NVIC_DisableIRQ(OTG_FS_IRQn);//关闭USB 中断
0000ea  2043              MOVS     r0,#0x43
0000ec  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;254    	HAL_NVIC_ClearPendingIRQ(OTG_FS_IRQn);//清楚 USB 中断标志
0000f0  2043              MOVS     r0,#0x43
0000f2  f7fffffe          BL       HAL_NVIC_ClearPendingIRQ
;;;255    }
0000f6  b007              ADD      sp,sp,#0x1c
0000f8  bd00              POP      {pc}
;;;256    static void SystemClock_Reset(void){
                          ENDP

0000fa  0000              DCW      0x0000
                  |L4.252|
                          DCD      0x40023830
                  |L4.256|
                          DCD      0x40020000
                  |L4.260|
                          DCD      0x40021800

                          AREA ||i.beepDiag||, CODE, READONLY, ALIGN=2

                  beepDiag PROC
;;;725    }
;;;726    static void beepDiag(uint8_t diag){//蜂鸣器诊断声音 摩尔斯电码
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;727    	//关闭USB VBUS
;;;728    	switch(diag){
000004  f1a40030          SUB      r0,r4,#0x30
000008  281e              CMP      r0,#0x1e
00000a  d275              BCS      |L5.248|
00000c  e8dff010          TBH      [pc,r0,LSL #1]
000010  001e0075          DCW      0x001e,0x0075
000014  00cb0120          DCW      0x00cb,0x0120
000018  017501c9          DCW      0x0175,0x01c9
00001c  021e0271          DCW      0x021e,0x0271
000020  02c5031a          DCW      0x02c5,0x031a
000024  00740074          DCW      0x0074,0x0074
000028  00740074          DCW      0x0074,0x0074
00002c  00740074          DCW      0x0074,0x0074
000030  00740370          DCW      0x0074,0x0370
000034  039003d2          DCW      0x0390,0x03d2
000038  04180449          DCW      0x0418,0x0449
00003c  0457049b          DCW      0x0457,0x049b
000040  04cd050e          DCW      0x04cd,0x050e
000044  052d0571          DCW      0x052d,0x0571
000048  05a305e5          DCW      0x05a3,0x05e5
;;;729    		case '0':{
;;;730    			//-
;;;731    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00004c  2201              MOVS     r2,#1
00004e  2140              MOVS     r1,#0x40
000050  48fd              LDR      r0,|L5.1096|
000052  f7fffffe          BL       HAL_GPIO_WritePin
000056  2096              MOVS     r0,#0x96
000058  f7fffffe          BL       HAL_Delay
00005c  2200              MOVS     r2,#0
00005e  2140              MOVS     r1,#0x40
000060  48f9              LDR      r0,|L5.1096|
000062  f7fffffe          BL       HAL_GPIO_WritePin
000066  f44f707a          MOV      r0,#0x3e8
00006a  f7fffffe          BL       HAL_Delay
;;;732    			//-
;;;733    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00006e  2201              MOVS     r2,#1
000070  2140              MOVS     r1,#0x40
000072  48f5              LDR      r0,|L5.1096|
000074  f7fffffe          BL       HAL_GPIO_WritePin
000078  f24020ee          MOV      r0,#0x2ee
00007c  f7fffffe          BL       HAL_Delay
000080  2200              MOVS     r2,#0
000082  2140              MOVS     r1,#0x40
000084  48f0              LDR      r0,|L5.1096|
000086  f7fffffe          BL       HAL_GPIO_WritePin
00008a  f44f707a          MOV      r0,#0x3e8
00008e  f7fffffe          BL       HAL_Delay
;;;734    			//-
;;;735    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000092  2201              MOVS     r2,#1
000094  2140              MOVS     r1,#0x40
000096  48ec              LDR      r0,|L5.1096|
000098  f7fffffe          BL       HAL_GPIO_WritePin
00009c  f24020ee          MOV      r0,#0x2ee
0000a0  f7fffffe          BL       HAL_Delay
0000a4  2200              MOVS     r2,#0
0000a6  2140              MOVS     r1,#0x40
0000a8  48e7              LDR      r0,|L5.1096|
0000aa  f7fffffe          BL       HAL_GPIO_WritePin
0000ae  f44f707a          MOV      r0,#0x3e8
0000b2  f7fffffe          BL       HAL_Delay
;;;736    			//-
;;;737    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0000b6  2201              MOVS     r2,#1
0000b8  2140              MOVS     r1,#0x40
0000ba  48e3              LDR      r0,|L5.1096|
0000bc  f7fffffe          BL       HAL_GPIO_WritePin
0000c0  f24020ee          MOV      r0,#0x2ee
0000c4  f7fffffe          BL       HAL_Delay
0000c8  2200              MOVS     r2,#0
0000ca  2140              MOVS     r1,#0x40
0000cc  48de              LDR      r0,|L5.1096|
0000ce  f7fffffe          BL       HAL_GPIO_WritePin
0000d2  f44f707a          MOV      r0,#0x3e8
0000d6  f7fffffe          BL       HAL_Delay
;;;738    			//-
;;;739    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
0000da  2201              MOVS     r2,#1
0000dc  2140              MOVS     r1,#0x40
0000de  48da              LDR      r0,|L5.1096|
0000e0  f7fffffe          BL       HAL_GPIO_WritePin
0000e4  f24020ee          MOV      r0,#0x2ee
0000e8  f7fffffe          BL       HAL_Delay
0000ec  2200              MOVS     r2,#0
0000ee  2140              MOVS     r1,#0x40
0000f0  48d5              LDR      r0,|L5.1096|
0000f2  f7fffffe          BL       HAL_GPIO_WritePin
                  |L5.246|
;;;740    			break;
0000f6  e24f              B        |L5.1432|
                  |L5.248|
0000f8  e3fe              B        |L5.2296|
;;;741    		}
;;;742    		case '1':{
;;;743    			//.
;;;744    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0000fa  2201              MOVS     r2,#1
0000fc  2140              MOVS     r1,#0x40
0000fe  48d2              LDR      r0,|L5.1096|
000100  f7fffffe          BL       HAL_GPIO_WritePin
000104  2096              MOVS     r0,#0x96
000106  f7fffffe          BL       HAL_Delay
00010a  2200              MOVS     r2,#0
00010c  2140              MOVS     r1,#0x40
00010e  48ce              LDR      r0,|L5.1096|
000110  f7fffffe          BL       HAL_GPIO_WritePin
000114  f44f707a          MOV      r0,#0x3e8
000118  f7fffffe          BL       HAL_Delay
;;;745    			//-
;;;746    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00011c  2201              MOVS     r2,#1
00011e  2140              MOVS     r1,#0x40
000120  48c9              LDR      r0,|L5.1096|
000122  f7fffffe          BL       HAL_GPIO_WritePin
000126  f24020ee          MOV      r0,#0x2ee
00012a  f7fffffe          BL       HAL_Delay
00012e  2200              MOVS     r2,#0
000130  2140              MOVS     r1,#0x40
000132  48c5              LDR      r0,|L5.1096|
000134  f7fffffe          BL       HAL_GPIO_WritePin
000138  f44f707a          MOV      r0,#0x3e8
00013c  f7fffffe          BL       HAL_Delay
;;;747    			//-
;;;748    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000140  2201              MOVS     r2,#1
000142  2140              MOVS     r1,#0x40
000144  48c0              LDR      r0,|L5.1096|
000146  f7fffffe          BL       HAL_GPIO_WritePin
00014a  f24020ee          MOV      r0,#0x2ee
00014e  f7fffffe          BL       HAL_Delay
000152  2200              MOVS     r2,#0
000154  2140              MOVS     r1,#0x40
000156  48bc              LDR      r0,|L5.1096|
000158  f7fffffe          BL       HAL_GPIO_WritePin
00015c  f44f707a          MOV      r0,#0x3e8
000160  f7fffffe          BL       HAL_Delay
;;;749    			//-
;;;750    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000164  2201              MOVS     r2,#1
000166  2140              MOVS     r1,#0x40
000168  48b7              LDR      r0,|L5.1096|
00016a  f7fffffe          BL       HAL_GPIO_WritePin
00016e  f24020ee          MOV      r0,#0x2ee
000172  f7fffffe          BL       HAL_Delay
000176  2200              MOVS     r2,#0
000178  2140              MOVS     r1,#0x40
00017a  48b3              LDR      r0,|L5.1096|
00017c  f7fffffe          BL       HAL_GPIO_WritePin
000180  f44f707a          MOV      r0,#0x3e8
000184  f7fffffe          BL       HAL_Delay
;;;751    			//-
;;;752    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
000188  2201              MOVS     r2,#1
00018a  2140              MOVS     r1,#0x40
00018c  48ae              LDR      r0,|L5.1096|
00018e  f7fffffe          BL       HAL_GPIO_WritePin
000192  f24020ee          MOV      r0,#0x2ee
000196  f7fffffe          BL       HAL_Delay
00019a  2200              MOVS     r2,#0
00019c  2140              MOVS     r1,#0x40
00019e  48aa              LDR      r0,|L5.1096|
0001a0  f7fffffe          BL       HAL_GPIO_WritePin
;;;753    			break;
0001a4  e7a7              B        |L5.246|
;;;754    		};
;;;755    		case '2':{
;;;756    			//.
;;;757    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0001a6  2201              MOVS     r2,#1
0001a8  2140              MOVS     r1,#0x40
0001aa  48a7              LDR      r0,|L5.1096|
0001ac  f7fffffe          BL       HAL_GPIO_WritePin
0001b0  2096              MOVS     r0,#0x96
0001b2  f7fffffe          BL       HAL_Delay
0001b6  2200              MOVS     r2,#0
0001b8  2140              MOVS     r1,#0x40
0001ba  48a3              LDR      r0,|L5.1096|
0001bc  f7fffffe          BL       HAL_GPIO_WritePin
0001c0  f44f707a          MOV      r0,#0x3e8
0001c4  f7fffffe          BL       HAL_Delay
;;;758    			//.
;;;759    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0001c8  2201              MOVS     r2,#1
0001ca  2140              MOVS     r1,#0x40
0001cc  489e              LDR      r0,|L5.1096|
0001ce  f7fffffe          BL       HAL_GPIO_WritePin
0001d2  2096              MOVS     r0,#0x96
0001d4  f7fffffe          BL       HAL_Delay
0001d8  2200              MOVS     r2,#0
0001da  2140              MOVS     r1,#0x40
0001dc  489a              LDR      r0,|L5.1096|
0001de  f7fffffe          BL       HAL_GPIO_WritePin
0001e2  f44f707a          MOV      r0,#0x3e8
0001e6  f7fffffe          BL       HAL_Delay
;;;760    			//-
;;;761    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0001ea  2201              MOVS     r2,#1
0001ec  2140              MOVS     r1,#0x40
0001ee  4896              LDR      r0,|L5.1096|
0001f0  f7fffffe          BL       HAL_GPIO_WritePin
0001f4  f24020ee          MOV      r0,#0x2ee
0001f8  f7fffffe          BL       HAL_Delay
0001fc  2200              MOVS     r2,#0
0001fe  2140              MOVS     r1,#0x40
000200  4891              LDR      r0,|L5.1096|
000202  f7fffffe          BL       HAL_GPIO_WritePin
000206  f44f707a          MOV      r0,#0x3e8
00020a  f7fffffe          BL       HAL_Delay
;;;762    			//-
;;;763    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00020e  2201              MOVS     r2,#1
000210  2140              MOVS     r1,#0x40
000212  488d              LDR      r0,|L5.1096|
000214  f7fffffe          BL       HAL_GPIO_WritePin
000218  f24020ee          MOV      r0,#0x2ee
00021c  f7fffffe          BL       HAL_Delay
000220  2200              MOVS     r2,#0
000222  2140              MOVS     r1,#0x40
000224  4888              LDR      r0,|L5.1096|
000226  f7fffffe          BL       HAL_GPIO_WritePin
00022a  f44f707a          MOV      r0,#0x3e8
00022e  f7fffffe          BL       HAL_Delay
;;;764    			//-
;;;765    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
000232  2201              MOVS     r2,#1
000234  2140              MOVS     r1,#0x40
000236  4884              LDR      r0,|L5.1096|
000238  f7fffffe          BL       HAL_GPIO_WritePin
00023c  f24020ee          MOV      r0,#0x2ee
000240  f7fffffe          BL       HAL_Delay
000244  2200              MOVS     r2,#0
000246  2140              MOVS     r1,#0x40
000248  487f              LDR      r0,|L5.1096|
00024a  f7fffffe          BL       HAL_GPIO_WritePin
;;;766    			break;
00024e  e752              B        |L5.246|
;;;767    		};
;;;768    		case '3':{
;;;769    			//.
;;;770    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000250  2201              MOVS     r2,#1
000252  2140              MOVS     r1,#0x40
000254  487c              LDR      r0,|L5.1096|
000256  f7fffffe          BL       HAL_GPIO_WritePin
00025a  2096              MOVS     r0,#0x96
00025c  f7fffffe          BL       HAL_Delay
000260  2200              MOVS     r2,#0
000262  2140              MOVS     r1,#0x40
000264  4878              LDR      r0,|L5.1096|
000266  f7fffffe          BL       HAL_GPIO_WritePin
00026a  f44f707a          MOV      r0,#0x3e8
00026e  f7fffffe          BL       HAL_Delay
;;;771    			//.
;;;772    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000272  2201              MOVS     r2,#1
000274  2140              MOVS     r1,#0x40
000276  4874              LDR      r0,|L5.1096|
000278  f7fffffe          BL       HAL_GPIO_WritePin
00027c  2096              MOVS     r0,#0x96
00027e  f7fffffe          BL       HAL_Delay
000282  2200              MOVS     r2,#0
000284  2140              MOVS     r1,#0x40
000286  4870              LDR      r0,|L5.1096|
000288  f7fffffe          BL       HAL_GPIO_WritePin
00028c  f44f707a          MOV      r0,#0x3e8
000290  f7fffffe          BL       HAL_Delay
;;;773    			//.
;;;774    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000294  2201              MOVS     r2,#1
000296  2140              MOVS     r1,#0x40
000298  486b              LDR      r0,|L5.1096|
00029a  f7fffffe          BL       HAL_GPIO_WritePin
00029e  f24020ee          MOV      r0,#0x2ee
0002a2  f7fffffe          BL       HAL_Delay
0002a6  2200              MOVS     r2,#0
0002a8  2140              MOVS     r1,#0x40
0002aa  4867              LDR      r0,|L5.1096|
0002ac  f7fffffe          BL       HAL_GPIO_WritePin
0002b0  f44f707a          MOV      r0,#0x3e8
0002b4  f7fffffe          BL       HAL_Delay
;;;775    			//-
;;;776    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0002b8  2201              MOVS     r2,#1
0002ba  2140              MOVS     r1,#0x40
0002bc  4862              LDR      r0,|L5.1096|
0002be  f7fffffe          BL       HAL_GPIO_WritePin
0002c2  f24020ee          MOV      r0,#0x2ee
0002c6  f7fffffe          BL       HAL_Delay
0002ca  2200              MOVS     r2,#0
0002cc  2140              MOVS     r1,#0x40
0002ce  485e              LDR      r0,|L5.1096|
0002d0  f7fffffe          BL       HAL_GPIO_WritePin
0002d4  f44f707a          MOV      r0,#0x3e8
0002d8  f7fffffe          BL       HAL_Delay
;;;777    			//-
;;;778    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
0002dc  2201              MOVS     r2,#1
0002de  2140              MOVS     r1,#0x40
0002e0  4859              LDR      r0,|L5.1096|
0002e2  f7fffffe          BL       HAL_GPIO_WritePin
0002e6  f24020ee          MOV      r0,#0x2ee
0002ea  f7fffffe          BL       HAL_Delay
0002ee  2200              MOVS     r2,#0
0002f0  2140              MOVS     r1,#0x40
0002f2  4855              LDR      r0,|L5.1096|
0002f4  f7fffffe          BL       HAL_GPIO_WritePin
;;;779    			break;
0002f8  e6fd              B        |L5.246|
;;;780    		}
;;;781    		case '4':{
;;;782    			//.
;;;783    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0002fa  2201              MOVS     r2,#1
0002fc  2140              MOVS     r1,#0x40
0002fe  4852              LDR      r0,|L5.1096|
000300  f7fffffe          BL       HAL_GPIO_WritePin
000304  2096              MOVS     r0,#0x96
000306  f7fffffe          BL       HAL_Delay
00030a  2200              MOVS     r2,#0
00030c  2140              MOVS     r1,#0x40
00030e  484e              LDR      r0,|L5.1096|
000310  f7fffffe          BL       HAL_GPIO_WritePin
000314  f44f707a          MOV      r0,#0x3e8
000318  f7fffffe          BL       HAL_Delay
;;;784    			//.
;;;785    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00031c  2201              MOVS     r2,#1
00031e  2140              MOVS     r1,#0x40
000320  4849              LDR      r0,|L5.1096|
000322  f7fffffe          BL       HAL_GPIO_WritePin
000326  2096              MOVS     r0,#0x96
000328  f7fffffe          BL       HAL_Delay
00032c  2200              MOVS     r2,#0
00032e  2140              MOVS     r1,#0x40
000330  4845              LDR      r0,|L5.1096|
000332  f7fffffe          BL       HAL_GPIO_WritePin
000336  f44f707a          MOV      r0,#0x3e8
00033a  f7fffffe          BL       HAL_Delay
;;;786    			//.
;;;787    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00033e  2201              MOVS     r2,#1
000340  2140              MOVS     r1,#0x40
000342  4841              LDR      r0,|L5.1096|
000344  f7fffffe          BL       HAL_GPIO_WritePin
000348  f24020ee          MOV      r0,#0x2ee
00034c  f7fffffe          BL       HAL_Delay
000350  2200              MOVS     r2,#0
000352  2140              MOVS     r1,#0x40
000354  483c              LDR      r0,|L5.1096|
000356  f7fffffe          BL       HAL_GPIO_WritePin
00035a  f44f707a          MOV      r0,#0x3e8
00035e  f7fffffe          BL       HAL_Delay
;;;788    			//.
;;;789    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000362  2201              MOVS     r2,#1
000364  2140              MOVS     r1,#0x40
000366  4838              LDR      r0,|L5.1096|
000368  f7fffffe          BL       HAL_GPIO_WritePin
00036c  2096              MOVS     r0,#0x96
00036e  f7fffffe          BL       HAL_Delay
000372  2200              MOVS     r2,#0
000374  2140              MOVS     r1,#0x40
000376  4834              LDR      r0,|L5.1096|
000378  f7fffffe          BL       HAL_GPIO_WritePin
00037c  f44f707a          MOV      r0,#0x3e8
000380  f7fffffe          BL       HAL_Delay
;;;790    			//-
;;;791    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
000384  2201              MOVS     r2,#1
000386  2140              MOVS     r1,#0x40
000388  482f              LDR      r0,|L5.1096|
00038a  f7fffffe          BL       HAL_GPIO_WritePin
00038e  f24020ee          MOV      r0,#0x2ee
000392  f7fffffe          BL       HAL_Delay
000396  2200              MOVS     r2,#0
000398  2140              MOVS     r1,#0x40
00039a  482b              LDR      r0,|L5.1096|
00039c  f7fffffe          BL       HAL_GPIO_WritePin
;;;792    			break;
0003a0  e6a9              B        |L5.246|
;;;793    		}
;;;794    		case '5':{
;;;795    			//.
;;;796    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0003a2  2201              MOVS     r2,#1
0003a4  2140              MOVS     r1,#0x40
0003a6  4828              LDR      r0,|L5.1096|
0003a8  f7fffffe          BL       HAL_GPIO_WritePin
0003ac  2096              MOVS     r0,#0x96
0003ae  f7fffffe          BL       HAL_Delay
0003b2  2200              MOVS     r2,#0
0003b4  2140              MOVS     r1,#0x40
0003b6  4824              LDR      r0,|L5.1096|
0003b8  f7fffffe          BL       HAL_GPIO_WritePin
0003bc  f44f707a          MOV      r0,#0x3e8
0003c0  f7fffffe          BL       HAL_Delay
;;;797    			//.
;;;798    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0003c4  2201              MOVS     r2,#1
0003c6  2140              MOVS     r1,#0x40
0003c8  481f              LDR      r0,|L5.1096|
0003ca  f7fffffe          BL       HAL_GPIO_WritePin
0003ce  2096              MOVS     r0,#0x96
0003d0  f7fffffe          BL       HAL_Delay
0003d4  2200              MOVS     r2,#0
0003d6  2140              MOVS     r1,#0x40
0003d8  481b              LDR      r0,|L5.1096|
0003da  f7fffffe          BL       HAL_GPIO_WritePin
0003de  f44f707a          MOV      r0,#0x3e8
0003e2  f7fffffe          BL       HAL_Delay
;;;799    			//.
;;;800    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0003e6  2201              MOVS     r2,#1
0003e8  2140              MOVS     r1,#0x40
0003ea  4817              LDR      r0,|L5.1096|
0003ec  f7fffffe          BL       HAL_GPIO_WritePin
0003f0  2096              MOVS     r0,#0x96
0003f2  f7fffffe          BL       HAL_Delay
0003f6  2200              MOVS     r2,#0
0003f8  2140              MOVS     r1,#0x40
0003fa  4813              LDR      r0,|L5.1096|
0003fc  f7fffffe          BL       HAL_GPIO_WritePin
000400  f44f707a          MOV      r0,#0x3e8
000404  f7fffffe          BL       HAL_Delay
;;;801    			//.
;;;802    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000408  2201              MOVS     r2,#1
00040a  2140              MOVS     r1,#0x40
00040c  480e              LDR      r0,|L5.1096|
00040e  f7fffffe          BL       HAL_GPIO_WritePin
000412  2096              MOVS     r0,#0x96
000414  f7fffffe          BL       HAL_Delay
000418  2200              MOVS     r2,#0
00041a  2140              MOVS     r1,#0x40
00041c  480a              LDR      r0,|L5.1096|
00041e  f7fffffe          BL       HAL_GPIO_WritePin
000422  f44f707a          MOV      r0,#0x3e8
000426  f7fffffe          BL       HAL_Delay
;;;803    			//.
;;;804    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
00042a  2201              MOVS     r2,#1
00042c  2140              MOVS     r1,#0x40
00042e  4806              LDR      r0,|L5.1096|
000430  f7fffffe          BL       HAL_GPIO_WritePin
000434  2096              MOVS     r0,#0x96
000436  f7fffffe          BL       HAL_Delay
00043a  2200              MOVS     r2,#0
00043c  2140              MOVS     r1,#0x40
00043e  4802              LDR      r0,|L5.1096|
000440  f7fffffe          BL       HAL_GPIO_WritePin
;;;805    			break;
000444  e3eb              B        |L5.3102|
000446  0000              DCW      0x0000
                  |L5.1096|
                          DCD      0x40020400
;;;806    		}
;;;807    		case '6':{
;;;808    			//-
;;;809    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00044c  2201              MOVS     r2,#1
00044e  2140              MOVS     r1,#0x40
000450  48fa              LDR      r0,|L5.2108|
000452  f7fffffe          BL       HAL_GPIO_WritePin
000456  f24020ee          MOV      r0,#0x2ee
00045a  f7fffffe          BL       HAL_Delay
00045e  2200              MOVS     r2,#0
000460  2140              MOVS     r1,#0x40
000462  48f6              LDR      r0,|L5.2108|
000464  f7fffffe          BL       HAL_GPIO_WritePin
000468  f44f707a          MOV      r0,#0x3e8
00046c  f7fffffe          BL       HAL_Delay
;;;810    			//.
;;;811    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000470  2201              MOVS     r2,#1
000472  2140              MOVS     r1,#0x40
000474  48f1              LDR      r0,|L5.2108|
000476  f7fffffe          BL       HAL_GPIO_WritePin
00047a  2096              MOVS     r0,#0x96
00047c  f7fffffe          BL       HAL_Delay
000480  2200              MOVS     r2,#0
000482  2140              MOVS     r1,#0x40
000484  48ed              LDR      r0,|L5.2108|
000486  f7fffffe          BL       HAL_GPIO_WritePin
00048a  f44f707a          MOV      r0,#0x3e8
00048e  f7fffffe          BL       HAL_Delay
;;;812    			//.
;;;813    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000492  2201              MOVS     r2,#1
000494  2140              MOVS     r1,#0x40
000496  48e9              LDR      r0,|L5.2108|
000498  f7fffffe          BL       HAL_GPIO_WritePin
00049c  2096              MOVS     r0,#0x96
00049e  f7fffffe          BL       HAL_Delay
0004a2  2200              MOVS     r2,#0
0004a4  2140              MOVS     r1,#0x40
0004a6  48e5              LDR      r0,|L5.2108|
0004a8  f7fffffe          BL       HAL_GPIO_WritePin
0004ac  f44f707a          MOV      r0,#0x3e8
0004b0  f7fffffe          BL       HAL_Delay
;;;814    			//.
;;;815    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0004b4  2201              MOVS     r2,#1
0004b6  2140              MOVS     r1,#0x40
0004b8  48e0              LDR      r0,|L5.2108|
0004ba  f7fffffe          BL       HAL_GPIO_WritePin
0004be  2096              MOVS     r0,#0x96
0004c0  f7fffffe          BL       HAL_Delay
0004c4  2200              MOVS     r2,#0
0004c6  2140              MOVS     r1,#0x40
0004c8  48dc              LDR      r0,|L5.2108|
0004ca  f7fffffe          BL       HAL_GPIO_WritePin
0004ce  f44f707a          MOV      r0,#0x3e8
0004d2  f7fffffe          BL       HAL_Delay
;;;816    			//.
;;;817    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
0004d6  2201              MOVS     r2,#1
0004d8  2140              MOVS     r1,#0x40
0004da  48d8              LDR      r0,|L5.2108|
0004dc  f7fffffe          BL       HAL_GPIO_WritePin
0004e0  2096              MOVS     r0,#0x96
0004e2  f7fffffe          BL       HAL_Delay
0004e6  2200              MOVS     r2,#0
0004e8  2140              MOVS     r1,#0x40
0004ea  48d4              LDR      r0,|L5.2108|
0004ec  f7fffffe          BL       HAL_GPIO_WritePin
;;;818    			break;
0004f0  e395              B        |L5.3102|
;;;819    		}
;;;820    		case '7':{	
;;;821    			//-
;;;822    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0004f2  2201              MOVS     r2,#1
0004f4  2140              MOVS     r1,#0x40
0004f6  48d1              LDR      r0,|L5.2108|
0004f8  f7fffffe          BL       HAL_GPIO_WritePin
0004fc  f24020ee          MOV      r0,#0x2ee
000500  f7fffffe          BL       HAL_Delay
000504  2200              MOVS     r2,#0
000506  2140              MOVS     r1,#0x40
000508  48cc              LDR      r0,|L5.2108|
00050a  f7fffffe          BL       HAL_GPIO_WritePin
00050e  f44f707a          MOV      r0,#0x3e8
000512  f7fffffe          BL       HAL_Delay
;;;823    			//-
;;;824    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000516  2201              MOVS     r2,#1
000518  2140              MOVS     r1,#0x40
00051a  48c8              LDR      r0,|L5.2108|
00051c  f7fffffe          BL       HAL_GPIO_WritePin
000520  f24020ee          MOV      r0,#0x2ee
000524  f7fffffe          BL       HAL_Delay
000528  2200              MOVS     r2,#0
00052a  2140              MOVS     r1,#0x40
00052c  48c3              LDR      r0,|L5.2108|
00052e  f7fffffe          BL       HAL_GPIO_WritePin
000532  f44f707a          MOV      r0,#0x3e8
000536  f7fffffe          BL       HAL_Delay
;;;825    			//.
;;;826    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00053a  2201              MOVS     r2,#1
00053c  2140              MOVS     r1,#0x40
00053e  48bf              LDR      r0,|L5.2108|
000540  f7fffffe          BL       HAL_GPIO_WritePin
000544  2096              MOVS     r0,#0x96
000546  f7fffffe          BL       HAL_Delay
00054a  2200              MOVS     r2,#0
00054c  2140              MOVS     r1,#0x40
00054e  48bb              LDR      r0,|L5.2108|
000550  f7fffffe          BL       HAL_GPIO_WritePin
000554  f44f707a          MOV      r0,#0x3e8
000558  f7fffffe          BL       HAL_Delay
;;;827    			//.
;;;828    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00055c  2201              MOVS     r2,#1
00055e  2140              MOVS     r1,#0x40
000560  48b6              LDR      r0,|L5.2108|
000562  f7fffffe          BL       HAL_GPIO_WritePin
000566  2096              MOVS     r0,#0x96
000568  f7fffffe          BL       HAL_Delay
00056c  2200              MOVS     r2,#0
00056e  2140              MOVS     r1,#0x40
000570  48b2              LDR      r0,|L5.2108|
000572  f7fffffe          BL       HAL_GPIO_WritePin
000576  f44f707a          MOV      r0,#0x3e8
00057a  f7fffffe          BL       HAL_Delay
;;;829    			//.
;;;830    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
00057e  2201              MOVS     r2,#1
000580  2140              MOVS     r1,#0x40
000582  48ae              LDR      r0,|L5.2108|
000584  f7fffffe          BL       HAL_GPIO_WritePin
000588  2096              MOVS     r0,#0x96
00058a  f7fffffe          BL       HAL_Delay
00058e  2200              MOVS     r2,#0
000590  2140              MOVS     r1,#0x40
000592  48aa              LDR      r0,|L5.2108|
000594  f7fffffe          BL       HAL_GPIO_WritePin
                  |L5.1432|
;;;831    			break;
000598  e341              B        |L5.3102|
;;;832    		}
;;;833    		case '8':{
;;;834    			//-
;;;835    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00059a  2201              MOVS     r2,#1
00059c  2140              MOVS     r1,#0x40
00059e  48a7              LDR      r0,|L5.2108|
0005a0  f7fffffe          BL       HAL_GPIO_WritePin
0005a4  f24020ee          MOV      r0,#0x2ee
0005a8  f7fffffe          BL       HAL_Delay
0005ac  2200              MOVS     r2,#0
0005ae  2140              MOVS     r1,#0x40
0005b0  48a2              LDR      r0,|L5.2108|
0005b2  f7fffffe          BL       HAL_GPIO_WritePin
0005b6  f44f707a          MOV      r0,#0x3e8
0005ba  f7fffffe          BL       HAL_Delay
;;;836    			//-
;;;837    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0005be  2201              MOVS     r2,#1
0005c0  2140              MOVS     r1,#0x40
0005c2  489e              LDR      r0,|L5.2108|
0005c4  f7fffffe          BL       HAL_GPIO_WritePin
0005c8  f24020ee          MOV      r0,#0x2ee
0005cc  f7fffffe          BL       HAL_Delay
0005d0  2200              MOVS     r2,#0
0005d2  2140              MOVS     r1,#0x40
0005d4  4899              LDR      r0,|L5.2108|
0005d6  f7fffffe          BL       HAL_GPIO_WritePin
0005da  f44f707a          MOV      r0,#0x3e8
0005de  f7fffffe          BL       HAL_Delay
;;;838    			//-
;;;839    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0005e2  2201              MOVS     r2,#1
0005e4  2140              MOVS     r1,#0x40
0005e6  4895              LDR      r0,|L5.2108|
0005e8  f7fffffe          BL       HAL_GPIO_WritePin
0005ec  f24020ee          MOV      r0,#0x2ee
0005f0  f7fffffe          BL       HAL_Delay
0005f4  2200              MOVS     r2,#0
0005f6  2140              MOVS     r1,#0x40
0005f8  4890              LDR      r0,|L5.2108|
0005fa  f7fffffe          BL       HAL_GPIO_WritePin
0005fe  f44f707a          MOV      r0,#0x3e8
000602  f7fffffe          BL       HAL_Delay
;;;840    			//.
;;;841    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000606  2201              MOVS     r2,#1
000608  2140              MOVS     r1,#0x40
00060a  488c              LDR      r0,|L5.2108|
00060c  f7fffffe          BL       HAL_GPIO_WritePin
000610  2096              MOVS     r0,#0x96
000612  f7fffffe          BL       HAL_Delay
000616  2200              MOVS     r2,#0
000618  2140              MOVS     r1,#0x40
00061a  4888              LDR      r0,|L5.2108|
00061c  f7fffffe          BL       HAL_GPIO_WritePin
000620  f44f707a          MOV      r0,#0x3e8
000624  f7fffffe          BL       HAL_Delay
;;;842    			//.
;;;843    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
000628  2201              MOVS     r2,#1
00062a  2140              MOVS     r1,#0x40
00062c  4883              LDR      r0,|L5.2108|
00062e  f7fffffe          BL       HAL_GPIO_WritePin
000632  2096              MOVS     r0,#0x96
000634  f7fffffe          BL       HAL_Delay
000638  2200              MOVS     r2,#0
00063a  2140              MOVS     r1,#0x40
00063c  487f              LDR      r0,|L5.2108|
00063e  f7fffffe          BL       HAL_GPIO_WritePin
;;;844    			break;
000642  e2ec              B        |L5.3102|
;;;845    		}
;;;846    		case '9':{
;;;847    			//-
;;;848    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000644  2201              MOVS     r2,#1
000646  2140              MOVS     r1,#0x40
000648  487c              LDR      r0,|L5.2108|
00064a  f7fffffe          BL       HAL_GPIO_WritePin
00064e  f24020ee          MOV      r0,#0x2ee
000652  f7fffffe          BL       HAL_Delay
000656  2200              MOVS     r2,#0
000658  2140              MOVS     r1,#0x40
00065a  4878              LDR      r0,|L5.2108|
00065c  f7fffffe          BL       HAL_GPIO_WritePin
000660  f44f707a          MOV      r0,#0x3e8
000664  f7fffffe          BL       HAL_Delay
;;;849    			//-
;;;850    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000668  2201              MOVS     r2,#1
00066a  2140              MOVS     r1,#0x40
00066c  4873              LDR      r0,|L5.2108|
00066e  f7fffffe          BL       HAL_GPIO_WritePin
000672  f24020ee          MOV      r0,#0x2ee
000676  f7fffffe          BL       HAL_Delay
00067a  2200              MOVS     r2,#0
00067c  2140              MOVS     r1,#0x40
00067e  486f              LDR      r0,|L5.2108|
000680  f7fffffe          BL       HAL_GPIO_WritePin
000684  f44f707a          MOV      r0,#0x3e8
000688  f7fffffe          BL       HAL_Delay
;;;851    			//-
;;;852    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00068c  2201              MOVS     r2,#1
00068e  2140              MOVS     r1,#0x40
000690  486a              LDR      r0,|L5.2108|
000692  f7fffffe          BL       HAL_GPIO_WritePin
000696  f24020ee          MOV      r0,#0x2ee
00069a  f7fffffe          BL       HAL_Delay
00069e  2200              MOVS     r2,#0
0006a0  2140              MOVS     r1,#0x40
0006a2  4866              LDR      r0,|L5.2108|
0006a4  f7fffffe          BL       HAL_GPIO_WritePin
0006a8  f44f707a          MOV      r0,#0x3e8
0006ac  f7fffffe          BL       HAL_Delay
;;;853    			//-
;;;854    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0006b0  2201              MOVS     r2,#1
0006b2  2140              MOVS     r1,#0x40
0006b4  4861              LDR      r0,|L5.2108|
0006b6  f7fffffe          BL       HAL_GPIO_WritePin
0006ba  f24020ee          MOV      r0,#0x2ee
0006be  f7fffffe          BL       HAL_Delay
0006c2  2200              MOVS     r2,#0
0006c4  2140              MOVS     r1,#0x40
0006c6  485d              LDR      r0,|L5.2108|
0006c8  f7fffffe          BL       HAL_GPIO_WritePin
0006cc  f44f707a          MOV      r0,#0x3e8
0006d0  f7fffffe          BL       HAL_Delay
;;;855    			//.
;;;856    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
0006d4  2201              MOVS     r2,#1
0006d6  2140              MOVS     r1,#0x40
0006d8  4858              LDR      r0,|L5.2108|
0006da  f7fffffe          BL       HAL_GPIO_WritePin
0006de  2096              MOVS     r0,#0x96
0006e0  f7fffffe          BL       HAL_Delay
0006e4  2200              MOVS     r2,#0
0006e6  2140              MOVS     r1,#0x40
0006e8  4854              LDR      r0,|L5.2108|
0006ea  f7fffffe          BL       HAL_GPIO_WritePin
;;;857    			break;
0006ee  e296              B        |L5.3102|
;;;858    		}
;;;859    		case 'A':{
;;;860    			//.
;;;861    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0006f0  2201              MOVS     r2,#1
0006f2  2140              MOVS     r1,#0x40
0006f4  4851              LDR      r0,|L5.2108|
0006f6  f7fffffe          BL       HAL_GPIO_WritePin
0006fa  2096              MOVS     r0,#0x96
0006fc  f7fffffe          BL       HAL_Delay
000700  2200              MOVS     r2,#0
000702  2140              MOVS     r1,#0x40
000704  484d              LDR      r0,|L5.2108|
000706  f7fffffe          BL       HAL_GPIO_WritePin
00070a  f44f707a          MOV      r0,#0x3e8
00070e  f7fffffe          BL       HAL_Delay
;;;862    			//-
;;;863    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
000712  2201              MOVS     r2,#1
000714  2140              MOVS     r1,#0x40
000716  4849              LDR      r0,|L5.2108|
000718  f7fffffe          BL       HAL_GPIO_WritePin
00071c  f24020ee          MOV      r0,#0x2ee
000720  f7fffffe          BL       HAL_Delay
000724  2200              MOVS     r2,#0
000726  2140              MOVS     r1,#0x40
000728  4844              LDR      r0,|L5.2108|
00072a  f7fffffe          BL       HAL_GPIO_WritePin
;;;864    			break;
00072e  e276              B        |L5.3102|
;;;865    		}
;;;866    		case 'B':{
;;;867    			//-
;;;868    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000730  2201              MOVS     r2,#1
000732  2140              MOVS     r1,#0x40
000734  4841              LDR      r0,|L5.2108|
000736  f7fffffe          BL       HAL_GPIO_WritePin
00073a  f24020ee          MOV      r0,#0x2ee
00073e  f7fffffe          BL       HAL_Delay
000742  2200              MOVS     r2,#0
000744  2140              MOVS     r1,#0x40
000746  483d              LDR      r0,|L5.2108|
000748  f7fffffe          BL       HAL_GPIO_WritePin
00074c  f44f707a          MOV      r0,#0x3e8
000750  f7fffffe          BL       HAL_Delay
;;;869    			//.
;;;870    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000754  2201              MOVS     r2,#1
000756  2140              MOVS     r1,#0x40
000758  4838              LDR      r0,|L5.2108|
00075a  f7fffffe          BL       HAL_GPIO_WritePin
00075e  2096              MOVS     r0,#0x96
000760  f7fffffe          BL       HAL_Delay
000764  2200              MOVS     r2,#0
000766  2140              MOVS     r1,#0x40
000768  4834              LDR      r0,|L5.2108|
00076a  f7fffffe          BL       HAL_GPIO_WritePin
00076e  f44f707a          MOV      r0,#0x3e8
000772  f7fffffe          BL       HAL_Delay
;;;871    			//.
;;;872    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000776  2201              MOVS     r2,#1
000778  2140              MOVS     r1,#0x40
00077a  4830              LDR      r0,|L5.2108|
00077c  f7fffffe          BL       HAL_GPIO_WritePin
000780  2096              MOVS     r0,#0x96
000782  f7fffffe          BL       HAL_Delay
000786  2200              MOVS     r2,#0
000788  2140              MOVS     r1,#0x40
00078a  482c              LDR      r0,|L5.2108|
00078c  f7fffffe          BL       HAL_GPIO_WritePin
000790  f44f707a          MOV      r0,#0x3e8
000794  f7fffffe          BL       HAL_Delay
;;;873    			//.
;;;874    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
000798  2201              MOVS     r2,#1
00079a  2140              MOVS     r1,#0x40
00079c  4827              LDR      r0,|L5.2108|
00079e  f7fffffe          BL       HAL_GPIO_WritePin
0007a2  2096              MOVS     r0,#0x96
0007a4  f7fffffe          BL       HAL_Delay
0007a8  2200              MOVS     r2,#0
0007aa  2140              MOVS     r1,#0x40
0007ac  4823              LDR      r0,|L5.2108|
0007ae  f7fffffe          BL       HAL_GPIO_WritePin
;;;875    			break;			
0007b2  e234              B        |L5.3102|
;;;876    		}
;;;877    		case 'C':{
;;;878    			//-
;;;879    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0007b4  2201              MOVS     r2,#1
0007b6  2140              MOVS     r1,#0x40
0007b8  4820              LDR      r0,|L5.2108|
0007ba  f7fffffe          BL       HAL_GPIO_WritePin
0007be  f24020ee          MOV      r0,#0x2ee
0007c2  f7fffffe          BL       HAL_Delay
0007c6  2200              MOVS     r2,#0
0007c8  2140              MOVS     r1,#0x40
0007ca  481c              LDR      r0,|L5.2108|
0007cc  f7fffffe          BL       HAL_GPIO_WritePin
0007d0  f44f707a          MOV      r0,#0x3e8
0007d4  f7fffffe          BL       HAL_Delay
;;;880    			//.
;;;881    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0007d8  2201              MOVS     r2,#1
0007da  2140              MOVS     r1,#0x40
0007dc  4817              LDR      r0,|L5.2108|
0007de  f7fffffe          BL       HAL_GPIO_WritePin
0007e2  2096              MOVS     r0,#0x96
0007e4  f7fffffe          BL       HAL_Delay
0007e8  2200              MOVS     r2,#0
0007ea  2140              MOVS     r1,#0x40
0007ec  4813              LDR      r0,|L5.2108|
0007ee  f7fffffe          BL       HAL_GPIO_WritePin
0007f2  f44f707a          MOV      r0,#0x3e8
0007f6  f7fffffe          BL       HAL_Delay
;;;882    			//-
;;;883    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0007fa  2201              MOVS     r2,#1
0007fc  2140              MOVS     r1,#0x40
0007fe  480f              LDR      r0,|L5.2108|
000800  f7fffffe          BL       HAL_GPIO_WritePin
000804  f24020ee          MOV      r0,#0x2ee
000808  f7fffffe          BL       HAL_Delay
00080c  2200              MOVS     r2,#0
00080e  2140              MOVS     r1,#0x40
000810  480a              LDR      r0,|L5.2108|
000812  f7fffffe          BL       HAL_GPIO_WritePin
000816  f44f707a          MOV      r0,#0x3e8
00081a  f7fffffe          BL       HAL_Delay
;;;884    			//.
;;;885    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
00081e  2201              MOVS     r2,#1
000820  2140              MOVS     r1,#0x40
000822  4806              LDR      r0,|L5.2108|
000824  f7fffffe          BL       HAL_GPIO_WritePin
000828  2096              MOVS     r0,#0x96
00082a  f7fffffe          BL       HAL_Delay
00082e  2200              MOVS     r2,#0
000830  2140              MOVS     r1,#0x40
000832  4802              LDR      r0,|L5.2108|
000834  f7fffffe          BL       HAL_GPIO_WritePin
;;;886    			break;
000838  e1f1              B        |L5.3102|
00083a  0000              DCW      0x0000
                  |L5.2108|
                          DCD      0x40020400
;;;887    		}
;;;888    		case 'D':{
;;;889    			//-
;;;890    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000840  2201              MOVS     r2,#1
000842  2140              MOVS     r1,#0x40
000844  48f9              LDR      r0,|L5.3116|
000846  f7fffffe          BL       HAL_GPIO_WritePin
00084a  f24020ee          MOV      r0,#0x2ee
00084e  f7fffffe          BL       HAL_Delay
000852  2200              MOVS     r2,#0
000854  2140              MOVS     r1,#0x40
000856  48f5              LDR      r0,|L5.3116|
000858  f7fffffe          BL       HAL_GPIO_WritePin
00085c  f44f707a          MOV      r0,#0x3e8
000860  f7fffffe          BL       HAL_Delay
;;;891    			//.
;;;892    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000864  2201              MOVS     r2,#1
000866  2140              MOVS     r1,#0x40
000868  48f0              LDR      r0,|L5.3116|
00086a  f7fffffe          BL       HAL_GPIO_WritePin
00086e  2096              MOVS     r0,#0x96
000870  f7fffffe          BL       HAL_Delay
000874  2200              MOVS     r2,#0
000876  2140              MOVS     r1,#0x40
000878  48ec              LDR      r0,|L5.3116|
00087a  f7fffffe          BL       HAL_GPIO_WritePin
00087e  f44f707a          MOV      r0,#0x3e8
000882  f7fffffe          BL       HAL_Delay
;;;893    			//.
;;;894    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
000886  2201              MOVS     r2,#1
000888  2140              MOVS     r1,#0x40
00088a  48e8              LDR      r0,|L5.3116|
00088c  f7fffffe          BL       HAL_GPIO_WritePin
000890  2096              MOVS     r0,#0x96
000892  f7fffffe          BL       HAL_Delay
000896  2200              MOVS     r2,#0
000898  2140              MOVS     r1,#0x40
00089a  48e4              LDR      r0,|L5.3116|
00089c  f7fffffe          BL       HAL_GPIO_WritePin
;;;895    			break;
0008a0  e1bd              B        |L5.3102|
;;;896    		}
;;;897    		case 'E':{
;;;898    			//.
;;;899    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
0008a2  2201              MOVS     r2,#1
0008a4  2140              MOVS     r1,#0x40
0008a6  48e1              LDR      r0,|L5.3116|
0008a8  f7fffffe          BL       HAL_GPIO_WritePin
0008ac  2096              MOVS     r0,#0x96
0008ae  f7fffffe          BL       HAL_Delay
0008b2  2200              MOVS     r2,#0
0008b4  2140              MOVS     r1,#0x40
0008b6  48dd              LDR      r0,|L5.3116|
0008b8  f7fffffe          BL       HAL_GPIO_WritePin
;;;900    			break;
0008bc  e1af              B        |L5.3102|
;;;901    		}
;;;902    		case 'F':{
;;;903    			//.
;;;904    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0008be  2201              MOVS     r2,#1
0008c0  2140              MOVS     r1,#0x40
0008c2  48da              LDR      r0,|L5.3116|
0008c4  f7fffffe          BL       HAL_GPIO_WritePin
0008c8  2096              MOVS     r0,#0x96
0008ca  f7fffffe          BL       HAL_Delay
0008ce  2200              MOVS     r2,#0
0008d0  2140              MOVS     r1,#0x40
0008d2  48d6              LDR      r0,|L5.3116|
0008d4  f7fffffe          BL       HAL_GPIO_WritePin
0008d8  f44f707a          MOV      r0,#0x3e8
0008dc  f7fffffe          BL       HAL_Delay
;;;905    			//.
;;;906    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0008e0  2201              MOVS     r2,#1
0008e2  2140              MOVS     r1,#0x40
0008e4  48d1              LDR      r0,|L5.3116|
0008e6  f7fffffe          BL       HAL_GPIO_WritePin
0008ea  2096              MOVS     r0,#0x96
0008ec  f7fffffe          BL       HAL_Delay
0008f0  2200              MOVS     r2,#0
0008f2  2140              MOVS     r1,#0x40
0008f4  48cd              LDR      r0,|L5.3116|
0008f6  e000              B        |L5.2298|
                  |L5.2296|
0008f8  e190              B        |L5.3100|
                  |L5.2298|
0008fa  f7fffffe          BL       HAL_GPIO_WritePin
0008fe  f44f707a          MOV      r0,#0x3e8
000902  f7fffffe          BL       HAL_Delay
;;;907    			//-
;;;908    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000906  2201              MOVS     r2,#1
000908  2140              MOVS     r1,#0x40
00090a  48c8              LDR      r0,|L5.3116|
00090c  f7fffffe          BL       HAL_GPIO_WritePin
000910  f24020ee          MOV      r0,#0x2ee
000914  f7fffffe          BL       HAL_Delay
000918  2200              MOVS     r2,#0
00091a  2140              MOVS     r1,#0x40
00091c  48c3              LDR      r0,|L5.3116|
00091e  f7fffffe          BL       HAL_GPIO_WritePin
000922  f44f707a          MOV      r0,#0x3e8
000926  f7fffffe          BL       HAL_Delay
;;;909    			//.
;;;910    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
00092a  2201              MOVS     r2,#1
00092c  2140              MOVS     r1,#0x40
00092e  48bf              LDR      r0,|L5.3116|
000930  f7fffffe          BL       HAL_GPIO_WritePin
000934  2096              MOVS     r0,#0x96
000936  f7fffffe          BL       HAL_Delay
00093a  2200              MOVS     r2,#0
00093c  2140              MOVS     r1,#0x40
00093e  48bb              LDR      r0,|L5.3116|
000940  f7fffffe          BL       HAL_GPIO_WritePin
;;;911    			break;
000944  e16b              B        |L5.3102|
;;;912    		}
;;;913    		case 'G':{
;;;914    			//-
;;;915    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000946  2201              MOVS     r2,#1
000948  2140              MOVS     r1,#0x40
00094a  48b8              LDR      r0,|L5.3116|
00094c  f7fffffe          BL       HAL_GPIO_WritePin
000950  f24020ee          MOV      r0,#0x2ee
000954  f7fffffe          BL       HAL_Delay
000958  2200              MOVS     r2,#0
00095a  2140              MOVS     r1,#0x40
00095c  48b3              LDR      r0,|L5.3116|
00095e  f7fffffe          BL       HAL_GPIO_WritePin
000962  f44f707a          MOV      r0,#0x3e8
000966  f7fffffe          BL       HAL_Delay
;;;916    			//-
;;;917    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
00096a  2201              MOVS     r2,#1
00096c  2140              MOVS     r1,#0x40
00096e  48af              LDR      r0,|L5.3116|
000970  f7fffffe          BL       HAL_GPIO_WritePin
000974  f24020ee          MOV      r0,#0x2ee
000978  f7fffffe          BL       HAL_Delay
00097c  2200              MOVS     r2,#0
00097e  2140              MOVS     r1,#0x40
000980  48aa              LDR      r0,|L5.3116|
000982  f7fffffe          BL       HAL_GPIO_WritePin
000986  f44f707a          MOV      r0,#0x3e8
00098a  f7fffffe          BL       HAL_Delay
;;;918    			//.
;;;919    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
00098e  2201              MOVS     r2,#1
000990  2140              MOVS     r1,#0x40
000992  48a6              LDR      r0,|L5.3116|
000994  f7fffffe          BL       HAL_GPIO_WritePin
000998  2096              MOVS     r0,#0x96
00099a  f7fffffe          BL       HAL_Delay
00099e  2200              MOVS     r2,#0
0009a0  2140              MOVS     r1,#0x40
0009a2  48a2              LDR      r0,|L5.3116|
0009a4  f7fffffe          BL       HAL_GPIO_WritePin
;;;920    			break;
0009a8  e139              B        |L5.3102|
;;;921    		}
;;;922    		case 'H':{
;;;923    			//.
;;;924    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0009aa  2201              MOVS     r2,#1
0009ac  2140              MOVS     r1,#0x40
0009ae  489f              LDR      r0,|L5.3116|
0009b0  f7fffffe          BL       HAL_GPIO_WritePin
0009b4  2096              MOVS     r0,#0x96
0009b6  f7fffffe          BL       HAL_Delay
0009ba  2200              MOVS     r2,#0
0009bc  2140              MOVS     r1,#0x40
0009be  489b              LDR      r0,|L5.3116|
0009c0  f7fffffe          BL       HAL_GPIO_WritePin
0009c4  f44f707a          MOV      r0,#0x3e8
0009c8  f7fffffe          BL       HAL_Delay
;;;925    			//.
;;;926    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0009cc  2201              MOVS     r2,#1
0009ce  2140              MOVS     r1,#0x40
0009d0  4896              LDR      r0,|L5.3116|
0009d2  f7fffffe          BL       HAL_GPIO_WritePin
0009d6  2096              MOVS     r0,#0x96
0009d8  f7fffffe          BL       HAL_Delay
0009dc  2200              MOVS     r2,#0
0009de  2140              MOVS     r1,#0x40
0009e0  4892              LDR      r0,|L5.3116|
0009e2  f7fffffe          BL       HAL_GPIO_WritePin
0009e6  f44f707a          MOV      r0,#0x3e8
0009ea  f7fffffe          BL       HAL_Delay
;;;927    			//.
;;;928    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
0009ee  2201              MOVS     r2,#1
0009f0  2140              MOVS     r1,#0x40
0009f2  488e              LDR      r0,|L5.3116|
0009f4  f7fffffe          BL       HAL_GPIO_WritePin
0009f8  2096              MOVS     r0,#0x96
0009fa  f7fffffe          BL       HAL_Delay
0009fe  2200              MOVS     r2,#0
000a00  2140              MOVS     r1,#0x40
000a02  488a              LDR      r0,|L5.3116|
000a04  f7fffffe          BL       HAL_GPIO_WritePin
000a08  f44f707a          MOV      r0,#0x3e8
000a0c  f7fffffe          BL       HAL_Delay
;;;929    			//.
;;;930    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
000a10  2201              MOVS     r2,#1
000a12  2140              MOVS     r1,#0x40
000a14  4885              LDR      r0,|L5.3116|
000a16  f7fffffe          BL       HAL_GPIO_WritePin
000a1a  2096              MOVS     r0,#0x96
000a1c  f7fffffe          BL       HAL_Delay
000a20  2200              MOVS     r2,#0
000a22  2140              MOVS     r1,#0x40
000a24  4881              LDR      r0,|L5.3116|
000a26  f7fffffe          BL       HAL_GPIO_WritePin
;;;931    			break;			
000a2a  e0f8              B        |L5.3102|
;;;932    		}
;;;933    		case 'I':{
;;;934    			//.
;;;935    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000a2c  2201              MOVS     r2,#1
000a2e  2140              MOVS     r1,#0x40
000a30  487e              LDR      r0,|L5.3116|
000a32  f7fffffe          BL       HAL_GPIO_WritePin
000a36  2096              MOVS     r0,#0x96
000a38  f7fffffe          BL       HAL_Delay
000a3c  2200              MOVS     r2,#0
000a3e  2140              MOVS     r1,#0x40
000a40  487a              LDR      r0,|L5.3116|
000a42  f7fffffe          BL       HAL_GPIO_WritePin
000a46  f44f707a          MOV      r0,#0x3e8
000a4a  f7fffffe          BL       HAL_Delay
;;;936    			//.
;;;937    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
000a4e  2201              MOVS     r2,#1
000a50  2140              MOVS     r1,#0x40
000a52  4876              LDR      r0,|L5.3116|
000a54  f7fffffe          BL       HAL_GPIO_WritePin
000a58  2096              MOVS     r0,#0x96
000a5a  f7fffffe          BL       HAL_Delay
000a5e  2200              MOVS     r2,#0
000a60  2140              MOVS     r1,#0x40
000a62  4872              LDR      r0,|L5.3116|
000a64  f7fffffe          BL       HAL_GPIO_WritePin
;;;938    			break;
000a68  e0d9              B        |L5.3102|
;;;939    		}
;;;940    		case 'J':{
;;;941    			//.
;;;942    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000a6a  2201              MOVS     r2,#1
000a6c  2140              MOVS     r1,#0x40
000a6e  486f              LDR      r0,|L5.3116|
000a70  f7fffffe          BL       HAL_GPIO_WritePin
000a74  2096              MOVS     r0,#0x96
000a76  f7fffffe          BL       HAL_Delay
000a7a  2200              MOVS     r2,#0
000a7c  2140              MOVS     r1,#0x40
000a7e  486b              LDR      r0,|L5.3116|
000a80  f7fffffe          BL       HAL_GPIO_WritePin
000a84  f44f707a          MOV      r0,#0x3e8
000a88  f7fffffe          BL       HAL_Delay
;;;943    			//-
;;;944    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000a8c  2201              MOVS     r2,#1
000a8e  2140              MOVS     r1,#0x40
000a90  4866              LDR      r0,|L5.3116|
000a92  f7fffffe          BL       HAL_GPIO_WritePin
000a96  f24020ee          MOV      r0,#0x2ee
000a9a  f7fffffe          BL       HAL_Delay
000a9e  2200              MOVS     r2,#0
000aa0  2140              MOVS     r1,#0x40
000aa2  4862              LDR      r0,|L5.3116|
000aa4  f7fffffe          BL       HAL_GPIO_WritePin
000aa8  f44f707a          MOV      r0,#0x3e8
000aac  f7fffffe          BL       HAL_Delay
;;;945    			//-
;;;946    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000ab0  2201              MOVS     r2,#1
000ab2  2140              MOVS     r1,#0x40
000ab4  485d              LDR      r0,|L5.3116|
000ab6  f7fffffe          BL       HAL_GPIO_WritePin
000aba  f24020ee          MOV      r0,#0x2ee
000abe  f7fffffe          BL       HAL_Delay
000ac2  2200              MOVS     r2,#0
000ac4  2140              MOVS     r1,#0x40
000ac6  4859              LDR      r0,|L5.3116|
000ac8  f7fffffe          BL       HAL_GPIO_WritePin
000acc  f44f707a          MOV      r0,#0x3e8
000ad0  f7fffffe          BL       HAL_Delay
;;;947    			//-
;;;948    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
000ad4  2201              MOVS     r2,#1
000ad6  2140              MOVS     r1,#0x40
000ad8  4854              LDR      r0,|L5.3116|
000ada  f7fffffe          BL       HAL_GPIO_WritePin
000ade  f24020ee          MOV      r0,#0x2ee
000ae2  f7fffffe          BL       HAL_Delay
000ae6  2200              MOVS     r2,#0
000ae8  2140              MOVS     r1,#0x40
000aea  4850              LDR      r0,|L5.3116|
000aec  f7fffffe          BL       HAL_GPIO_WritePin
;;;949    			break;
000af0  e095              B        |L5.3102|
;;;950    		}
;;;951    		case 'K':{
;;;952    			//-
;;;953    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000af2  2201              MOVS     r2,#1
000af4  2140              MOVS     r1,#0x40
000af6  484d              LDR      r0,|L5.3116|
000af8  f7fffffe          BL       HAL_GPIO_WritePin
000afc  f24020ee          MOV      r0,#0x2ee
000b00  f7fffffe          BL       HAL_Delay
000b04  2200              MOVS     r2,#0
000b06  2140              MOVS     r1,#0x40
000b08  4848              LDR      r0,|L5.3116|
000b0a  f7fffffe          BL       HAL_GPIO_WritePin
000b0e  f44f707a          MOV      r0,#0x3e8
000b12  f7fffffe          BL       HAL_Delay
;;;954    			//.
;;;955    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000b16  2201              MOVS     r2,#1
000b18  2140              MOVS     r1,#0x40
000b1a  4844              LDR      r0,|L5.3116|
000b1c  f7fffffe          BL       HAL_GPIO_WritePin
000b20  2096              MOVS     r0,#0x96
000b22  f7fffffe          BL       HAL_Delay
000b26  2200              MOVS     r2,#0
000b28  2140              MOVS     r1,#0x40
000b2a  4840              LDR      r0,|L5.3116|
000b2c  f7fffffe          BL       HAL_GPIO_WritePin
000b30  f44f707a          MOV      r0,#0x3e8
000b34  f7fffffe          BL       HAL_Delay
;;;956    			//-
;;;957    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
000b38  2201              MOVS     r2,#1
000b3a  2140              MOVS     r1,#0x40
000b3c  483b              LDR      r0,|L5.3116|
000b3e  f7fffffe          BL       HAL_GPIO_WritePin
000b42  f24020ee          MOV      r0,#0x2ee
000b46  f7fffffe          BL       HAL_Delay
000b4a  2200              MOVS     r2,#0
000b4c  2140              MOVS     r1,#0x40
000b4e  4837              LDR      r0,|L5.3116|
000b50  f7fffffe          BL       HAL_GPIO_WritePin
;;;958    			break;
000b54  e063              B        |L5.3102|
;;;959    		}
;;;960    		case 'L':{//．━ ．．
;;;961    			//.
;;;962    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000b56  2201              MOVS     r2,#1
000b58  2140              MOVS     r1,#0x40
000b5a  4834              LDR      r0,|L5.3116|
000b5c  f7fffffe          BL       HAL_GPIO_WritePin
000b60  2096              MOVS     r0,#0x96
000b62  f7fffffe          BL       HAL_Delay
000b66  2200              MOVS     r2,#0
000b68  2140              MOVS     r1,#0x40
000b6a  4830              LDR      r0,|L5.3116|
000b6c  f7fffffe          BL       HAL_GPIO_WritePin
000b70  f44f707a          MOV      r0,#0x3e8
000b74  f7fffffe          BL       HAL_Delay
;;;963    			//-
;;;964    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000b78  2201              MOVS     r2,#1
000b7a  2140              MOVS     r1,#0x40
000b7c  482b              LDR      r0,|L5.3116|
000b7e  f7fffffe          BL       HAL_GPIO_WritePin
000b82  f24020ee          MOV      r0,#0x2ee
000b86  f7fffffe          BL       HAL_Delay
000b8a  2200              MOVS     r2,#0
000b8c  2140              MOVS     r1,#0x40
000b8e  4827              LDR      r0,|L5.3116|
000b90  f7fffffe          BL       HAL_GPIO_WritePin
000b94  f44f707a          MOV      r0,#0x3e8
000b98  f7fffffe          BL       HAL_Delay
;;;965    			//.
;;;966    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000b9c  2201              MOVS     r2,#1
000b9e  2140              MOVS     r1,#0x40
000ba0  4822              LDR      r0,|L5.3116|
000ba2  f7fffffe          BL       HAL_GPIO_WritePin
000ba6  2096              MOVS     r0,#0x96
000ba8  f7fffffe          BL       HAL_Delay
000bac  2200              MOVS     r2,#0
000bae  2140              MOVS     r1,#0x40
000bb0  481e              LDR      r0,|L5.3116|
000bb2  f7fffffe          BL       HAL_GPIO_WritePin
000bb6  f44f707a          MOV      r0,#0x3e8
000bba  f7fffffe          BL       HAL_Delay
;;;967    			//.
;;;968    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_SHORT_TIME);SET_RED(GPIO_PIN_RESET);
000bbe  2201              MOVS     r2,#1
000bc0  2140              MOVS     r1,#0x40
000bc2  481a              LDR      r0,|L5.3116|
000bc4  f7fffffe          BL       HAL_GPIO_WritePin
000bc8  2096              MOVS     r0,#0x96
000bca  f7fffffe          BL       HAL_Delay
000bce  2200              MOVS     r2,#0
000bd0  2140              MOVS     r1,#0x40
000bd2  4816              LDR      r0,|L5.3116|
000bd4  f7fffffe          BL       HAL_GPIO_WritePin
;;;969    			break;
000bd8  e021              B        |L5.3102|
;;;970    		}
;;;971    		case 'M':{//━ ━
;;;972    			//-
;;;973    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);HAL_Delay(MORSECODE_SPACE_TIME);
000bda  2201              MOVS     r2,#1
000bdc  2140              MOVS     r1,#0x40
000bde  4813              LDR      r0,|L5.3116|
000be0  f7fffffe          BL       HAL_GPIO_WritePin
000be4  f24020ee          MOV      r0,#0x2ee
000be8  f7fffffe          BL       HAL_Delay
000bec  2200              MOVS     r2,#0
000bee  2140              MOVS     r1,#0x40
000bf0  480e              LDR      r0,|L5.3116|
000bf2  f7fffffe          BL       HAL_GPIO_WritePin
000bf6  f44f707a          MOV      r0,#0x3e8
000bfa  f7fffffe          BL       HAL_Delay
;;;974    			//-
;;;975    			SET_RED(GPIO_PIN_SET);HAL_Delay(MORSECODE_LONG_TIME);SET_RED(GPIO_PIN_RESET);
000bfe  2201              MOVS     r2,#1
000c00  2140              MOVS     r1,#0x40
000c02  480a              LDR      r0,|L5.3116|
000c04  f7fffffe          BL       HAL_GPIO_WritePin
000c08  f24020ee          MOV      r0,#0x2ee
000c0c  f7fffffe          BL       HAL_Delay
000c10  2200              MOVS     r2,#0
000c12  2140              MOVS     r1,#0x40
000c14  4805              LDR      r0,|L5.3116|
000c16  f7fffffe          BL       HAL_GPIO_WritePin
;;;976    			break;
000c1a  e000              B        |L5.3102|
                  |L5.3100|
;;;977    		}
;;;978    		default:break;
000c1c  bf00              NOP      
                  |L5.3102|
000c1e  bf00              NOP                            ;740
;;;979    	}
;;;980    	HAL_Delay(3000);
000c20  f64030b8          MOV      r0,#0xbb8
000c24  f7fffffe          BL       HAL_Delay
;;;981    }
000c28  bd10              POP      {r4,pc}
000c2a  0000              DCW      0x0000
                  |L5.3116|
                          DCD      0x40020400
                          ENDP


                          AREA ||i.bootLoadFailHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  bootLoadFailHandler PROC
;;;981    }
;;;982    static void bootLoadFailHandler(uint8_t ftype){//引导错误程序
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;983    	MX_DriverVbusFS(FALSE);//关闭USB VBUS
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       MX_DriverVbusFS
;;;984    	SET_ERR_LED(GPIO_PIN_RESET);
00000a  2200              MOVS     r2,#0
00000c  2120              MOVS     r1,#0x20
00000e  485a              LDR      r0,|L6.376|
000010  f7fffffe          BL       HAL_GPIO_WritePin
;;;985    	printf("Bootloader:SYS_ERR_LED->On!\n");
000014  a059              ADR      r0,|L6.380|
000016  f7fffffe          BL       __2printf
;;;986    	SET_GREEN(GPIO_PIN_RESET);
00001a  2200              MOVS     r2,#0
00001c  2120              MOVS     r1,#0x20
00001e  485f              LDR      r0,|L6.412|
000020  f7fffffe          BL       HAL_GPIO_WritePin
;;;987    	SET_BLUE(GPIO_PIN_RESET);
000024  2200              MOVS     r2,#0
000026  2180              MOVS     r1,#0x80
000028  485c              LDR      r0,|L6.412|
00002a  f7fffffe          BL       HAL_GPIO_WritePin
;;;988    	SET_RED(GPIO_PIN_RESET);
00002e  2200              MOVS     r2,#0
000030  2140              MOVS     r1,#0x40
000032  485a              LDR      r0,|L6.412|
000034  f7fffffe          BL       HAL_GPIO_WritePin
;;;989    	switch(ftype){
000038  f1a40030          SUB      r0,r4,#0x30
00003c  281b              CMP      r0,#0x1b
00003e  d26f              BCS      |L6.288|
000040  e8dff000          TBB      [pc,r0]
000044  0e172031          DCB      0x0e,0x17,0x20,0x31
000048  3a299797          DCB      0x3a,0x29,0x97,0x97
00004c  43979797          DCB      0x43,0x97,0x97,0x97
000050  97979797          DCB      0x97,0x97,0x97,0x97
000054  974c5597          DCB      0x97,0x4c,0x55,0x97
000058  5e666f77          DCB      0x5e,0x66,0x6f,0x77
00005c  7f878f00          DCB      0x7f,0x87,0x8f,0x00
;;;990    		case BT_FAIL_READ_CFG:{//从U盘读取CFG失败
;;;991    			printf("Bootloader:FailHandler,Read %s fail!.\n", CFG_FIRMWARE_FILENAME);
000060  a14f              ADR      r1,|L6.416|
000062  a052              ADR      r0,|L6.428|
000064  f7fffffe          BL       __2printf
;;;992    			while(1){
000068  e002              B        |L6.112|
                  |L6.106|
;;;993    				beepDiag(BT_FAIL_READ_CFG);
00006a  2030              MOVS     r0,#0x30
00006c  f7fffffe          BL       beepDiag
                  |L6.112|
000070  e7fb              B        |L6.106|
;;;994    			};
;;;995    		}
;;;996    		case BT_FAIL_READ_LMCU_APP:{//从U盘读取MCU APP失败
;;;997    			printf("Bootloader:FailHandler,Read %s fail!.\n", LMCU_FIRMWARE_FILENAME);
000072  a158              ADR      r1,|L6.468|
000074  a04d              ADR      r0,|L6.428|
000076  f7fffffe          BL       __2printf
;;;998    			while(1){
00007a  e002              B        |L6.130|
                  |L6.124|
;;;999    				beepDiag(BT_FAIL_READ_LMCU_APP);
00007c  2031              MOVS     r0,#0x31
00007e  f7fffffe          BL       beepDiag
                  |L6.130|
000082  e7fb              B        |L6.124|
;;;1000   			};
;;;1001   		}
;;;1002   		case BT_FAIL_READ_LLCD_APP:{//从U盘读取LCD APP失败
;;;1003   			printf("Bootloader:FailHandler,Read %s fail!.\n", LLCD_FIRMWARE_FILENAME);
000084  a156              ADR      r1,|L6.480|
000086  a049              ADR      r0,|L6.428|
000088  f7fffffe          BL       __2printf
;;;1004   			while(1){
00008c  e002              B        |L6.148|
                  |L6.142|
;;;1005   				beepDiag(BT_FAIL_READ_LLCD_APP);
00008e  2032              MOVS     r0,#0x32
000090  f7fffffe          BL       beepDiag
                  |L6.148|
000094  e7fb              B        |L6.142|
;;;1006   			};
;;;1007   		}
;;;1008   		case BT_FAIL_ERASE_MCU_APP:{//擦除MCU APP FLASH区域失败
;;;1009   			printf("Bootloader:FailHandler,Erase mcu application fail\n");
000096  a055              ADR      r0,|L6.492|
000098  f7fffffe          BL       __2printf
;;;1010   			while(1){
00009c  e002              B        |L6.164|
                  |L6.158|
;;;1011   				beepDiag(BT_FAIL_ERASE_MCU_APP);
00009e  2035              MOVS     r0,#0x35
0000a0  f7fffffe          BL       beepDiag
                  |L6.164|
0000a4  e7fb              B        |L6.158|
;;;1012   			};
;;;1013   		}
;;;1014   		case BT_FAIL_READ_LEROM_BIN:{
;;;1015   			printf("Bootloader:FailHandler,Read %s fail!\n", LOAD_EPROM_FILENAME);
0000a6  a15e              ADR      r1,|L6.544|
0000a8  a060              ADR      r0,|L6.556|
0000aa  f7fffffe          BL       __2printf
;;;1016   			while(1){
0000ae  e002              B        |L6.182|
                  |L6.176|
;;;1017   				beepDiag(BT_FAIL_READ_LEROM_BIN);
0000b0  2033              MOVS     r0,#0x33
0000b2  f7fffffe          BL       beepDiag
                  |L6.182|
0000b6  e7fb              B        |L6.176|
;;;1018   			}
;;;1019   		}
;;;1020   		case BT_FAIL_WRITE_SEROM_BIN:{
;;;1021   			printf("Bootloader:FailHandler,Write %s fail!\n", SAVE_EPROM_FILENAME);
0000b8  a166              ADR      r1,|L6.596|
0000ba  a069              ADR      r0,|L6.608|
0000bc  f7fffffe          BL       __2printf
;;;1022   			while(1){
0000c0  e002              B        |L6.200|
                  |L6.194|
;;;1023   				beepDiag(BT_FAIL_WRITE_SEROM_BIN);
0000c2  2034              MOVS     r0,#0x34
0000c4  f7fffffe          BL       beepDiag
                  |L6.200|
0000c8  e7fb              B        |L6.194|
;;;1024   			}
;;;1025   		}
;;;1026   		case BT_FAIL_LMCU_APP_CHECK:{//lmcu.bin 检查错误
;;;1027   			printf("Bootloader:FailHandler,%s size is invalid!\n", LMCU_FIRMWARE_FILENAME);
0000ca  a142              ADR      r1,|L6.468|
0000cc  a06e              ADR      r0,|L6.648|
0000ce  f7fffffe          BL       __2printf
;;;1028   			while(1){
0000d2  e002              B        |L6.218|
                  |L6.212|
;;;1029   				beepDiag(BT_FAIL_LMCU_APP_CHECK);
0000d4  2038              MOVS     r0,#0x38
0000d6  f7fffffe          BL       beepDiag
                  |L6.218|
0000da  e7fb              B        |L6.212|
;;;1030   			};
;;;1031   		}
;;;1032   		case BT_FAIL_LLCD_APP_CHECK:{//llcd.bin 检查错误
;;;1033   			printf("Bootloader:FailHandler,%s size is invalid!\n", LLCD_FIRMWARE_FILENAME);
0000dc  a140              ADR      r1,|L6.480|
0000de  a06a              ADR      r0,|L6.648|
0000e0  f7fffffe          BL       __2printf
;;;1034   			while(1){
0000e4  e002              B        |L6.236|
                  |L6.230|
;;;1035   				beepDiag(BT_FAIL_LLCD_APP_CHECK);
0000e6  2041              MOVS     r0,#0x41
0000e8  f7fffffe          BL       beepDiag
                  |L6.236|
0000ec  e7fb              B        |L6.230|
;;;1036   			};
;;;1037   		}
;;;1038   		case BT_FAIL_CHECKSUM_MCU_APP_FLASH:{//校验 lmcu.bin 错误
;;;1039   			printf("Bootloader:FailHandler,Verify %s fail!.\n", LMCU_FIRMWARE_FILENAME);
0000ee  a139              ADR      r1,|L6.468|
0000f0  a070              ADR      r0,|L6.692|
0000f2  f7fffffe          BL       __2printf
;;;1040   			while(1){
0000f6  e002              B        |L6.254|
                  |L6.248|
;;;1041   				beepDiag(BT_FAIL_CHECKSUM_MCU_APP_FLASH);
0000f8  2042              MOVS     r0,#0x42
0000fa  f7fffffe          BL       beepDiag
                  |L6.254|
0000fe  e7fb              B        |L6.248|
;;;1042   			};
;;;1043   		}
;;;1044   		case BT_FAIL_LCD_NOT_RESPOND:{//LCD 串口无响应或错误
;;;1045   			printf("Bootloader:FailHandler,LCD is not responsed!.\n");
000100  a077              ADR      r0,|L6.736|
000102  f7fffffe          BL       __2printf
;;;1046   			while(1){
000106  e002              B        |L6.270|
                  |L6.264|
;;;1047   				beepDiag(BT_FAIL_LCD_NOT_RESPOND);
000108  2044              MOVS     r0,#0x44
00010a  f7fffffe          BL       beepDiag
                  |L6.270|
00010e  e7fb              B        |L6.264|
;;;1048   			};
;;;1049   		}
;;;1050   		case BT_FAIL_LCD_DOWNLOAD:{//LCD 命令无响应
;;;1051   			printf("Bootloader:FailHandler,LCD download fail!.\n");
000110  a07f              ADR      r0,|L6.784|
000112  f7fffffe          BL       __2printf
;;;1052   			while(1){
000116  e002              B        |L6.286|
                  |L6.280|
;;;1053   				beepDiag(BT_FAIL_LCD_DOWNLOAD);
000118  2045              MOVS     r0,#0x45
00011a  f7fffffe          BL       beepDiag
                  |L6.286|
00011e  e7fb              B        |L6.280|
                  |L6.288|
000120  e027              B        |L6.370|
;;;1054   			};
;;;1055   		}
;;;1056   		case BT_FAIL_VECTOR_TABLE_INVALID:{//APP无效向量表
;;;1057   			printf("Bootloader:FailHandler,App vector table invalid.\n");
000122  a086              ADR      r0,|L6.828|
000124  f7fffffe          BL       __2printf
;;;1058   			while(1){
000128  e002              B        |L6.304|
                  |L6.298|
;;;1059   				beepDiag(BT_FAIL_VECTOR_TABLE_INVALID);
00012a  2046              MOVS     r0,#0x46
00012c  f7fffffe          BL       beepDiag
                  |L6.304|
000130  e7fb              B        |L6.298|
;;;1060   			};
;;;1061   		}
;;;1062   		case BT_FAIL_CHECK_BLANK:{//FLASH 查空错误
;;;1063   			printf("Bootloader:FailHandler,Flash is not blank!.\n");
000132  a08f              ADR      r0,|L6.880|
000134  f7fffffe          BL       __2printf
;;;1064   			while(1){
000138  e002              B        |L6.320|
                  |L6.314|
;;;1065   				beepDiag(BT_FAIL_CHECK_BLANK);
00013a  2047              MOVS     r0,#0x47
00013c  f7fffffe          BL       beepDiag
                  |L6.320|
000140  e7fb              B        |L6.314|
;;;1066   			};
;;;1067   		}
;;;1068   		case BT_DONE_CLEAR_ALL:{
;;;1069   			printf("Bootloader:DoneHandler,Flash and Eprom easer done!.\n");
000142  a097              ADR      r0,|L6.928|
000144  f7fffffe          BL       __2printf
;;;1070   			while(1){
000148  e002              B        |L6.336|
                  |L6.330|
;;;1071   				beepDiag(BT_DONE_CLEAR_ALL);
00014a  2048              MOVS     r0,#0x48
00014c  f7fffffe          BL       beepDiag
                  |L6.336|
000150  e7fb              B        |L6.330|
;;;1072   			}
;;;1073   		}
;;;1074   		case BT_DONE_UPDATE_EPROM:{
;;;1075   			printf("Bootloader:DoneHandler,Update eprom form udisk done!.\n");
000152  a0a1              ADR      r0,|L6.984|
000154  f7fffffe          BL       __2printf
;;;1076   			while(1){
000158  e002              B        |L6.352|
                  |L6.346|
;;;1077   				beepDiag(BT_DONE_UPDATE_EPROM);
00015a  2049              MOVS     r0,#0x49
00015c  f7fffffe          BL       beepDiag
                  |L6.352|
000160  e7fb              B        |L6.346|
;;;1078   			}
;;;1079   		}
;;;1080   		case BT_DONE_DUMP_EPROM:{
;;;1081   			printf("Bootloader:DoneHandler,Dump eprom to udisk done!\n");
000162  a0ab              ADR      r0,|L6.1040|
000164  f7fffffe          BL       __2printf
;;;1082   			while(1){
000168  e002              B        |L6.368|
                  |L6.362|
;;;1083   				beepDiag(BT_DONE_DUMP_EPROM);
00016a  204a              MOVS     r0,#0x4a
00016c  f7fffffe          BL       beepDiag
                  |L6.368|
000170  e7fb              B        |L6.362|
                  |L6.370|
;;;1084   			}
;;;1085   		}
;;;1086   		default:{
;;;1087   			break;
000172  bf00              NOP      
000174  bf00              NOP      
;;;1088   		}
;;;1089   	}
;;;1090   }
000176  bd10              POP      {r4,pc}
;;;1091   static void clearFlash(void){//清除MCU FLASH
                          ENDP

                  |L6.376|
                          DCD      0x40020800
                  |L6.380|
00017c  426f6f74          DCB      "Bootloader:SYS_ERR_LED->On!\n",0
000180  6c6f6164
000184  65723a53
000188  59535f45
00018c  52525f4c
000190  45442d3e
000194  4f6e210a
000198  00      
000199  00                DCB      0
00019a  00                DCB      0
00019b  00                DCB      0
                  |L6.412|
                          DCD      0x40020400
                  |L6.416|
0001a0  2f6c6173          DCB      "/las.cfg",0
0001a4  2e636667
0001a8  00      
0001a9  00                DCB      0
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L6.428|
0001ac  426f6f74          DCB      "Bootloader:FailHandler,Read %s fail!.\n",0
0001b0  6c6f6164
0001b4  65723a46
0001b8  61696c48
0001bc  616e646c
0001c0  65722c52
0001c4  65616420
0001c8  25732066
0001cc  61696c21
0001d0  2e0a00  
0001d3  00                DCB      0
                  |L6.468|
0001d4  2f6c645f          DCB      "/ld_mcu.bin",0
0001d8  6d63752e
0001dc  62696e00
                  |L6.480|
0001e0  2f6c645f          DCB      "/ld_lcd.pkg",0
0001e4  6c63642e
0001e8  706b6700
                  |L6.492|
0001ec  426f6f74          DCB      "Bootloader:FailHandler,Erase mcu application fail\n",0
0001f0  6c6f6164
0001f4  65723a46
0001f8  61696c48
0001fc  616e646c
000200  65722c45
000204  72617365
000208  206d6375
00020c  20617070
000210  6c696361
000214  74696f6e
000218  20666169
00021c  6c0a00  
00021f  00                DCB      0
                  |L6.544|
000220  2f6c6570          DCB      "/leprom.bin",0
000224  726f6d2e
000228  62696e00
                  |L6.556|
00022c  426f6f74          DCB      "Bootloader:FailHandler,Read %s fail!\n",0
000230  6c6f6164
000234  65723a46
000238  61696c48
00023c  616e646c
000240  65722c52
000244  65616420
000248  25732066
00024c  61696c21
000250  0a00    
000252  00                DCB      0
000253  00                DCB      0
                  |L6.596|
000254  2f736570          DCB      "/seprom.bin",0
000258  726f6d2e
00025c  62696e00
                  |L6.608|
000260  426f6f74          DCB      "Bootloader:FailHandler,Write %s fail!\n",0
000264  6c6f6164
000268  65723a46
00026c  61696c48
000270  616e646c
000274  65722c57
000278  72697465
00027c  20257320
000280  6661696c
000284  210a00  
000287  00                DCB      0
                  |L6.648|
000288  426f6f74          DCB      "Bootloader:FailHandler,%s size is invalid!\n",0
00028c  6c6f6164
000290  65723a46
000294  61696c48
000298  616e646c
00029c  65722c25
0002a0  73207369
0002a4  7a652069
0002a8  7320696e
0002ac  76616c69
0002b0  64210a00
                  |L6.692|
0002b4  426f6f74          DCB      "Bootloader:FailHandler,Verify %s fail!.\n",0
0002b8  6c6f6164
0002bc  65723a46
0002c0  61696c48
0002c4  616e646c
0002c8  65722c56
0002cc  65726966
0002d0  79202573
0002d4  20666169
0002d8  6c212e0a
0002dc  00      
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0
                  |L6.736|
0002e0  426f6f74          DCB      "Bootloader:FailHandler,LCD is not responsed!.\n",0
0002e4  6c6f6164
0002e8  65723a46
0002ec  61696c48
0002f0  616e646c
0002f4  65722c4c
0002f8  43442069
0002fc  73206e6f
000300  74207265
000304  73706f6e
000308  73656421
00030c  2e0a00  
00030f  00                DCB      0
                  |L6.784|
000310  426f6f74          DCB      "Bootloader:FailHandler,LCD download fail!.\n",0
000314  6c6f6164
000318  65723a46
00031c  61696c48
000320  616e646c
000324  65722c4c
000328  43442064
00032c  6f776e6c
000330  6f616420
000334  6661696c
000338  212e0a00
                  |L6.828|
00033c  426f6f74          DCB      "Bootloader:FailHandler,App vector table invalid.\n",0
000340  6c6f6164
000344  65723a46
000348  61696c48
00034c  616e646c
000350  65722c41
000354  70702076
000358  6563746f
00035c  72207461
000360  626c6520
000364  696e7661
000368  6c69642e
00036c  0a00    
00036e  00                DCB      0
00036f  00                DCB      0
                  |L6.880|
000370  426f6f74          DCB      "Bootloader:FailHandler,Flash is not blank!.\n",0
000374  6c6f6164
000378  65723a46
00037c  61696c48
000380  616e646c
000384  65722c46
000388  6c617368
00038c  20697320
000390  6e6f7420
000394  626c616e
000398  6b212e0a
00039c  00      
00039d  00                DCB      0
00039e  00                DCB      0
00039f  00                DCB      0
                  |L6.928|
0003a0  426f6f74          DCB      "Bootloader:DoneHandler,Flash and Eprom easer done!.\n",0
0003a4  6c6f6164
0003a8  65723a44
0003ac  6f6e6548
0003b0  616e646c
0003b4  65722c46
0003b8  6c617368
0003bc  20616e64
0003c0  20457072
0003c4  6f6d2065
0003c8  61736572
0003cc  20646f6e
0003d0  65212e0a
0003d4  00      
0003d5  00                DCB      0
0003d6  00                DCB      0
0003d7  00                DCB      0
                  |L6.984|
0003d8  426f6f74          DCB      "Bootloader:DoneHandler,Update eprom form udisk done!.\n"
0003dc  6c6f6164
0003e0  65723a44
0003e4  6f6e6548
0003e8  616e646c
0003ec  65722c55
0003f0  70646174
0003f4  65206570
0003f8  726f6d20
0003fc  666f726d
000400  20756469
000404  736b2064
000408  6f6e6521
00040c  2e0a    
00040e  00                DCB      0
00040f  00                DCB      0
                  |L6.1040|
000410  426f6f74          DCB      "Bootloader:DoneHandler,Dump eprom to udisk done!\n",0
000414  6c6f6164
000418  65723a44
00041c  6f6e6548
000420  616e646c
000424  65722c44
000428  756d7020
00042c  6570726f
000430  6d20746f
000434  20756469
000438  736b2064
00043c  6f6e6521
000440  0a00    
000442  00                DCB      0
000443  00                DCB      0

                          AREA ||i.bootLoadInit||, CODE, READONLY, ALIGN=2

                  bootLoadInit PROC
;;;317    /******************************************************************************/
;;;318    void bootLoadInit(void){//引导程序初始化
000000  b510              PUSH     {r4,lr}
;;;319    	BID = 0;
000002  2000              MOVS     r0,#0
000004  49a6              LDR      r1,|L7.672|
000006  7008              STRB     r0,[r1,#0]
;;;320    	SET_RUN_LED(GPIO_PIN_SET);
000008  2201              MOVS     r2,#1
00000a  4611              MOV      r1,r2
00000c  48a5              LDR      r0,|L7.676|
00000e  f7fffffe          BL       HAL_GPIO_WritePin
;;;321    	SET_ERR_LED(GPIO_PIN_SET);
000012  2201              MOVS     r2,#1
000014  2120              MOVS     r1,#0x20
000016  48a4              LDR      r0,|L7.680|
000018  f7fffffe          BL       HAL_GPIO_WritePin
;;;322    	SET_FAN5V(GPIO_PIN_SET);//打开5V风扇
00001c  2201              MOVS     r2,#1
00001e  2104              MOVS     r1,#4
000020  48a2              LDR      r0,|L7.684|
000022  f7fffffe          BL       HAL_GPIO_WritePin
;;;323    	SET_FAN24V(GPIO_PIN_SET);//打开24V风扇
000026  2201              MOVS     r2,#1
000028  0211              LSLS     r1,r2,#8
00002a  489f              LDR      r0,|L7.680|
00002c  f7fffffe          BL       HAL_GPIO_WritePin
;;;324    	SET_LCD(GPIO_PIN_SET);//打开LCD供电
000030  2201              MOVS     r2,#1
000032  0391              LSLS     r1,r2,#14
000034  489b              LDR      r0,|L7.676|
000036  f7fffffe          BL       HAL_GPIO_WritePin
;;;325    	SET_TEC(GPIO_PIN_RESET);//关闭制冷
00003a  2200              MOVS     r2,#0
00003c  f44f4100          MOV      r1,#0x8000
000040  4898              LDR      r0,|L7.676|
000042  f7fffffe          BL       HAL_GPIO_WritePin
;;;326    	SET_LP_PWM(GPIO_PIN_RESET);//关闭所有激光
000046  2200              MOVS     r2,#0
000048  2180              MOVS     r1,#0x80
00004a  4899              LDR      r0,|L7.688|
00004c  f7fffffe          BL       HAL_GPIO_WritePin
;;;327    	SET_SPK_SD(GPIO_PIN_RESET);//关闭喇叭
000050  2200              MOVS     r2,#0
000052  2140              MOVS     r1,#0x40
000054  4896              LDR      r0,|L7.688|
000056  f7fffffe          BL       HAL_GPIO_WritePin
;;;328    	initChipDac();//DAC初始化
00005a  f7fffffe          BL       initChipDac
;;;329    
;;;330    	SET_RED(GPIO_PIN_RESET);//设置R LED亮度
00005e  2200              MOVS     r2,#0
000060  2140              MOVS     r1,#0x40
000062  4890              LDR      r0,|L7.676|
000064  f7fffffe          BL       HAL_GPIO_WritePin
;;;331    	SET_GREEN(GPIO_PIN_RESET);//设置G LED亮度
000068  2200              MOVS     r2,#0
00006a  2120              MOVS     r1,#0x20
00006c  488d              LDR      r0,|L7.676|
00006e  f7fffffe          BL       HAL_GPIO_WritePin
;;;332    	SET_BLUE(GPIO_PIN_RESET);//设置B LED亮度
000072  2200              MOVS     r2,#0
000074  2180              MOVS     r1,#0x80
000076  488b              LDR      r0,|L7.676|
000078  f7fffffe          BL       HAL_GPIO_WritePin
;;;333    	SET_AIM(GPIO_PIN_RESET);
00007c  2200              MOVS     r2,#0
00007e  2110              MOVS     r1,#0x10
000080  4888              LDR      r0,|L7.676|
000082  f7fffffe          BL       HAL_GPIO_WritePin
;;;334    	//R
;;;335    	SET_RED(GPIO_PIN_SET);//设置R LED亮度
000086  2201              MOVS     r2,#1
000088  2140              MOVS     r1,#0x40
00008a  4886              LDR      r0,|L7.676|
00008c  f7fffffe          BL       HAL_GPIO_WritePin
;;;336    	SET_GREEN(GPIO_PIN_RESET);//设置G LED亮度
000090  2200              MOVS     r2,#0
000092  2120              MOVS     r1,#0x20
000094  4883              LDR      r0,|L7.676|
000096  f7fffffe          BL       HAL_GPIO_WritePin
;;;337    	SET_BLUE(GPIO_PIN_RESET);//设置B LED亮度
00009a  2200              MOVS     r2,#0
00009c  2180              MOVS     r1,#0x80
00009e  4881              LDR      r0,|L7.676|
0000a0  f7fffffe          BL       HAL_GPIO_WritePin
;;;338    	HAL_Delay(200);
0000a4  20c8              MOVS     r0,#0xc8
0000a6  f7fffffe          BL       HAL_Delay
;;;339    	//G
;;;340    	SET_BLUE(GPIO_PIN_RESET);//设置B LED亮度
0000aa  2200              MOVS     r2,#0
0000ac  2180              MOVS     r1,#0x80
0000ae  487d              LDR      r0,|L7.676|
0000b0  f7fffffe          BL       HAL_GPIO_WritePin
;;;341    	SET_RED(GPIO_PIN_RESET);//设置R LED亮度
0000b4  2200              MOVS     r2,#0
0000b6  2140              MOVS     r1,#0x40
0000b8  487a              LDR      r0,|L7.676|
0000ba  f7fffffe          BL       HAL_GPIO_WritePin
;;;342    	SET_GREEN(GPIO_PIN_SET);//设置G LED亮度
0000be  2201              MOVS     r2,#1
0000c0  2120              MOVS     r1,#0x20
0000c2  4878              LDR      r0,|L7.676|
0000c4  f7fffffe          BL       HAL_GPIO_WritePin
;;;343    	HAL_Delay(200);
0000c8  20c8              MOVS     r0,#0xc8
0000ca  f7fffffe          BL       HAL_Delay
;;;344    	//B
;;;345    	SET_BLUE(GPIO_PIN_SET);//设置B LED亮度
0000ce  2201              MOVS     r2,#1
0000d0  2180              MOVS     r1,#0x80
0000d2  4874              LDR      r0,|L7.676|
0000d4  f7fffffe          BL       HAL_GPIO_WritePin
;;;346    	SET_RED(GPIO_PIN_RESET);//设置R LED亮度
0000d8  2200              MOVS     r2,#0
0000da  2140              MOVS     r1,#0x40
0000dc  4871              LDR      r0,|L7.676|
0000de  f7fffffe          BL       HAL_GPIO_WritePin
;;;347    	SET_GREEN(GPIO_PIN_RESET);//设置G LED亮度
0000e2  2200              MOVS     r2,#0
0000e4  2120              MOVS     r1,#0x20
0000e6  486f              LDR      r0,|L7.676|
0000e8  f7fffffe          BL       HAL_GPIO_WritePin
;;;348    	HAL_Delay(200);
0000ec  20c8              MOVS     r0,#0xc8
0000ee  f7fffffe          BL       HAL_Delay
;;;349    	SET_BLUE(GPIO_PIN_RESET);//设置B LED亮度
0000f2  2200              MOVS     r2,#0
0000f4  2180              MOVS     r1,#0x80
0000f6  486b              LDR      r0,|L7.676|
0000f8  f7fffffe          BL       HAL_GPIO_WritePin
;;;350    	SET_RED(GPIO_PIN_RESET);//设置R LED亮度
0000fc  2200              MOVS     r2,#0
0000fe  2140              MOVS     r1,#0x40
000100  4868              LDR      r0,|L7.676|
000102  f7fffffe          BL       HAL_GPIO_WritePin
;;;351    	SET_GREEN(GPIO_PIN_SET);//设置G LED亮度
000106  2201              MOVS     r2,#1
000108  2120              MOVS     r1,#0x20
00010a  4866              LDR      r0,|L7.676|
00010c  f7fffffe          BL       HAL_GPIO_WritePin
;;;352    	
;;;353    	overTime = HAL_GetTick() + CONFIG_JUMP_DELAY;
000110  f7fffffe          BL       HAL_GetTick
000114  f500607a          ADD      r0,r0,#0xfa0
000118  4966              LDR      r1,|L7.692|
00011a  6008              STR      r0,[r1,#0]  ; overTime
;;;354    	releaseTime0 = 0;
00011c  2000              MOVS     r0,#0
00011e  4966              LDR      r1,|L7.696|
000120  6008              STR      r0,[r1,#0]  ; releaseTime0
;;;355    	releaseTime1 = 0;
000122  4966              LDR      r1,|L7.700|
000124  6008              STR      r0,[r1,#0]  ; releaseTime1
;;;356    	usbReady = FALSE;
000126  4966              LDR      r1,|L7.704|
000128  7008              STRB     r0,[r1,#0]
;;;357    	bootLoadState = BT_STATE_IDLE; 
00012a  4966              LDR      r1,|L7.708|
00012c  7008              STRB     r0,[r1,#0]
;;;358    	printf("\r\n");
00012e  a066              ADR      r0,|L7.712|
000130  f7fffffe          BL       __2printf
;;;359    	printf("\r\n");
000134  a064              ADR      r0,|L7.712|
000136  f7fffffe          BL       __2printf
;;;360    	printf("\r\n");   
00013a  a063              ADR      r0,|L7.712|
00013c  f7fffffe          BL       __2printf
;;;361    	//显示输入IO状态
;;;362    	if(HAL_GPIO_ReadPin(SYS_ID0_GPIO_Port, SYS_ID0_Pin) == GPIO_PIN_SET){
000140  2102              MOVS     r1,#2
000142  4858              LDR      r0,|L7.676|
000144  f7fffffe          BL       HAL_GPIO_ReadPin
000148  2801              CMP      r0,#1
00014a  d109              BNE      |L7.352|
;;;363    		printf("Bootloader:INPUT->SYS_ID0       = HIGH!\n");
00014c  a05f              ADR      r0,|L7.716|
00014e  f7fffffe          BL       __2printf
;;;364    		BID |= (1 << 0);
000152  4853              LDR      r0,|L7.672|
000154  7800              LDRB     r0,[r0,#0]  ; BID
000156  f0400001          ORR      r0,r0,#1
00015a  4951              LDR      r1,|L7.672|
00015c  7008              STRB     r0,[r1,#0]
00015e  e002              B        |L7.358|
                  |L7.352|
;;;365    	}
;;;366    	else{
;;;367    		printf("Bootloader:INPUT->SYS_ID0       = LOW!\n");
000160  a065              ADR      r0,|L7.760|
000162  f7fffffe          BL       __2printf
                  |L7.358|
;;;368    	}
;;;369    	if(HAL_GPIO_ReadPin(SYS_ID1_GPIO_Port, SYS_ID1_Pin) == GPIO_PIN_SET){
000166  2104              MOVS     r1,#4
000168  484e              LDR      r0,|L7.676|
00016a  f7fffffe          BL       HAL_GPIO_ReadPin
00016e  2801              CMP      r0,#1
000170  d109              BNE      |L7.390|
;;;370    		printf("Bootloader:INPUT->SYS_ID1       = HIGH!\n");
000172  a06b              ADR      r0,|L7.800|
000174  f7fffffe          BL       __2printf
;;;371    		BID |= (1 << 1);
000178  4849              LDR      r0,|L7.672|
00017a  7800              LDRB     r0,[r0,#0]  ; BID
00017c  f0400002          ORR      r0,r0,#2
000180  4947              LDR      r1,|L7.672|
000182  7008              STRB     r0,[r1,#0]
000184  e002              B        |L7.396|
                  |L7.390|
;;;372    	}
;;;373    	else{
;;;374    		printf("Bootloader:INPUT->SYS_ID1       = LOW!\n");
000186  a071              ADR      r0,|L7.844|
000188  f7fffffe          BL       __2printf
                  |L7.396|
;;;375    	}
;;;376    	if(HAL_GPIO_ReadPin(SYS_ID2_GPIO_Port, SYS_ID2_Pin) == GPIO_PIN_SET){
00018c  f44f6180          MOV      r1,#0x400
000190  4844              LDR      r0,|L7.676|
000192  f7fffffe          BL       HAL_GPIO_ReadPin
000196  2801              CMP      r0,#1
000198  d109              BNE      |L7.430|
;;;377    		printf("Bootloader:INPUT->SYS_ID2       = HIGH!\n");
00019a  a076              ADR      r0,|L7.884|
00019c  f7fffffe          BL       __2printf
;;;378    		BID |= (1 << 2);
0001a0  483f              LDR      r0,|L7.672|
0001a2  7800              LDRB     r0,[r0,#0]  ; BID
0001a4  f0400004          ORR      r0,r0,#4
0001a8  493d              LDR      r1,|L7.672|
0001aa  7008              STRB     r0,[r1,#0]
0001ac  e002              B        |L7.436|
                  |L7.430|
;;;379    	}
;;;380    	else{
;;;381    		printf("Bootloader:INPUT->SYS_ID2       = LOW!\n");
0001ae  a07c              ADR      r0,|L7.928|
0001b0  f7fffffe          BL       __2printf
                  |L7.436|
;;;382    	}
;;;383    	if(HAL_GPIO_ReadPin(FSWITCH_NC_GPIO_Port, FSWITCH_NC_Pin) == GPIO_PIN_SET){
0001b4  f44f4100          MOV      r1,#0x8000
0001b8  483d              LDR      r0,|L7.688|
0001ba  f7fffffe          BL       HAL_GPIO_ReadPin
0001be  2801              CMP      r0,#1
0001c0  d103              BNE      |L7.458|
;;;384    		printf("Bootloader:INPUT->FSWITCH_NC    = Open!\n");
0001c2  a081              ADR      r0,|L7.968|
0001c4  f7fffffe          BL       __2printf
0001c8  e002              B        |L7.464|
                  |L7.458|
;;;385    	}
;;;386    	else{
;;;387    		printf("Bootloader:INPUT->FSWITCH_NC    = Close!\n");
0001ca  a08a              ADR      r0,|L7.1012|
0001cc  f7fffffe          BL       __2printf
                  |L7.464|
;;;388    	}
;;;389    	if(HAL_GPIO_ReadPin(FSWITCH_NO_GPIO_Port, FSWITCH_NO_Pin) == GPIO_PIN_SET){
0001d0  f44f6180          MOV      r1,#0x400
0001d4  4834              LDR      r0,|L7.680|
0001d6  f7fffffe          BL       HAL_GPIO_ReadPin
0001da  2801              CMP      r0,#1
0001dc  d103              BNE      |L7.486|
;;;390    		printf("Bootloader:INPUT->FSWITCH_NO    = Open!\n");
0001de  a090              ADR      r0,|L7.1056|
0001e0  f7fffffe          BL       __2printf
0001e4  e002              B        |L7.492|
                  |L7.486|
;;;391    	}
;;;392    	else{
;;;393    		printf("Bootloader:INPUT->FSWITCH_NO    = Close!\n");
0001e6  a099              ADR      r0,|L7.1100|
0001e8  f7fffffe          BL       __2printf
                  |L7.492|
;;;394    	}
;;;395    	if(HAL_GPIO_ReadPin(ESTOP_IN_GPIO_Port, ESTOP_IN_Pin) == GPIO_PIN_SET){
0001ec  f44f6100          MOV      r1,#0x800
0001f0  482d              LDR      r0,|L7.680|
0001f2  f7fffffe          BL       HAL_GPIO_ReadPin
0001f6  2801              CMP      r0,#1
0001f8  d103              BNE      |L7.514|
;;;396    		printf("Bootloader:INPUT->ESTOP         = Open!\n");
0001fa  a09f              ADR      r0,|L7.1144|
0001fc  f7fffffe          BL       __2printf
000200  e002              B        |L7.520|
                  |L7.514|
;;;397    	}
;;;398    	else{
;;;399    		printf("Bootloader:INPUT->ESTOP         = Close!\n");
000202  a0a8              ADR      r0,|L7.1188|
000204  f7fffffe          BL       __2printf
                  |L7.520|
;;;400    	}
;;;401    	if(HAL_GPIO_ReadPin(INTLOCK_IN_GPIO_Port, INTLOCK_IN_Pin) == GPIO_PIN_SET){
000208  f44f5180          MOV      r1,#0x1000
00020c  4826              LDR      r0,|L7.680|
00020e  f7fffffe          BL       HAL_GPIO_ReadPin
000212  2801              CMP      r0,#1
000214  d103              BNE      |L7.542|
;;;402    		printf("Bootloader:INPUT->INTLOCK       = Open!\n");
000216  a0ae              ADR      r0,|L7.1232|
000218  f7fffffe          BL       __2printf
00021c  e002              B        |L7.548|
                  |L7.542|
;;;403    	}
;;;404    	else{
;;;405    		printf("Bootloader:INPUT->INTLOCK       = Close!\n");
00021e  a0b7              ADR      r0,|L7.1276|
000220  f7fffffe          BL       __2printf
                  |L7.548|
;;;406    	}
;;;407    	if(HAL_GPIO_ReadPin(PM_ALARM_GPIO_Port, PM_ALARM_Pin) == GPIO_PIN_SET){//PM_ALARM
000224  2110              MOVS     r1,#0x10
000226  4822              LDR      r0,|L7.688|
000228  f7fffffe          BL       HAL_GPIO_ReadPin
00022c  2801              CMP      r0,#1
00022e  d103              BNE      |L7.568|
;;;408    		printf("Bootloader:INPUT->PM_ALARM      = High!\n");
000230  a0bd              ADR      r0,|L7.1320|
000232  f7fffffe          BL       __2printf
000236  e002              B        |L7.574|
                  |L7.568|
;;;409    	}
;;;410    	else{
;;;411    		printf("Bootloader:INPUT->PM_ALARM      = Low!\n");
000238  a0c6              ADR      r0,|L7.1364|
00023a  f7fffffe          BL       __2printf
                  |L7.574|
;;;412    	}
;;;413    	if(HAL_GPIO_ReadPin(SOFTPOWER_IN_GPIO_Port, SOFTPOWER_IN_Pin) == GPIO_PIN_SET){//Soft Power Key
00023e  2110              MOVS     r1,#0x10
000240  4819              LDR      r0,|L7.680|
000242  f7fffffe          BL       HAL_GPIO_ReadPin
000246  2801              CMP      r0,#1
000248  d103              BNE      |L7.594|
;;;414    		printf("Bootloader:INPUT->SOFTPOWER_IN 	= Open!\n");
00024a  a0cc              ADR      r0,|L7.1404|
00024c  f7fffffe          BL       __2printf
000250  e002              B        |L7.600|
                  |L7.594|
;;;415    	}
;;;416    	else{
;;;417    		printf("Bootloader:INPUT->SOFTPOWER_IN	= Close!\n");
000252  a0d5              ADR      r0,|L7.1448|
000254  f7fffffe          BL       __2printf
                  |L7.600|
;;;418    	}
;;;419    	//显示输出IO状态
;;;420    	if(HAL_GPIO_ReadPin(LP_PWM_GPIO_Port, LP_PWM_Pin) == GPIO_PIN_SET){//LP_PWM
000258  2180              MOVS     r1,#0x80
00025a  4815              LDR      r0,|L7.688|
00025c  f7fffffe          BL       HAL_GPIO_ReadPin
000260  2801              CMP      r0,#1
000262  d103              BNE      |L7.620|
;;;421    		printf("Bootloader:OUTPUT->LP_PWM     	= High!\n");
000264  a0db              ADR      r0,|L7.1492|
000266  f7fffffe          BL       __2printf
00026a  e002              B        |L7.626|
                  |L7.620|
;;;422    	}
;;;423    	else{
;;;424    		printf("Bootloader:OUTPUT->LP_PWM     	= Low!\n");
00026c  a0e3              ADR      r0,|L7.1532|
00026e  f7fffffe          BL       __2printf
                  |L7.626|
;;;425    	}
;;;426    	if(HAL_GPIO_ReadPin(FAN5V_OUT_GPIO_Port, FAN5V_OUT_Pin) == GPIO_PIN_SET){//FAN
000272  2104              MOVS     r1,#4
000274  480d              LDR      r0,|L7.684|
000276  f7fffffe          BL       HAL_GPIO_ReadPin
00027a  2801              CMP      r0,#1
00027c  d103              BNE      |L7.646|
;;;427    		printf("Bootloader:OUTPUT->FAN5V_OUT    = High!\n");
00027e  a0e9              ADR      r0,|L7.1572|
000280  f7fffffe          BL       __2printf
000284  e002              B        |L7.652|
                  |L7.646|
;;;428    	}
;;;429    	else{
;;;430    		printf("Bootloader:OUTPUT->FAN5V_OUT    = Low!\n");
000286  a0f2              ADR      r0,|L7.1616|
000288  f7fffffe          BL       __2printf
                  |L7.652|
;;;431    	}
;;;432    	if(HAL_GPIO_ReadPin(HEN_OUT1_GPIO_Port, HEN_OUT1_Pin) == GPIO_PIN_SET){//FAN
00028c  f44f7180          MOV      r1,#0x100
000290  4805              LDR      r0,|L7.680|
000292  f7fffffe          BL       HAL_GPIO_ReadPin
000296  2801              CMP      r0,#1
000298  d100              BNE      |L7.668|
;;;433    		printf("Bootloader:OUTPUT->FAN24V_OUT   = High!\n");
00029a  e1ed              B        |L7.1656|
                  |L7.668|
00029c  e1f0              B        |L7.1664|
00029e  0000              DCW      0x0000
                  |L7.672|
                          DCD      BID
                  |L7.676|
                          DCD      0x40020400
                  |L7.680|
                          DCD      0x40020800
                  |L7.684|
                          DCD      0x40020c00
                  |L7.688|
                          DCD      0x40020000
                  |L7.692|
                          DCD      overTime
                  |L7.696|
                          DCD      releaseTime0
                  |L7.700|
                          DCD      releaseTime1
                  |L7.704|
                          DCD      usbReady
                  |L7.708|
                          DCD      bootLoadState
                  |L7.712|
0002c8  0d0a00            DCB      "\r\n",0
0002cb  00                DCB      0
                  |L7.716|
0002cc  426f6f74          DCB      "Bootloader:INPUT->SYS_ID0       = HIGH!\n",0
0002d0  6c6f6164
0002d4  65723a49
0002d8  4e505554
0002dc  2d3e5359
0002e0  535f4944
0002e4  30202020
0002e8  20202020
0002ec  3d204849
0002f0  4748210a
0002f4  00      
0002f5  00                DCB      0
0002f6  00                DCB      0
0002f7  00                DCB      0
                  |L7.760|
0002f8  426f6f74          DCB      "Bootloader:INPUT->SYS_ID0       = LOW!\n",0
0002fc  6c6f6164
000300  65723a49
000304  4e505554
000308  2d3e5359
00030c  535f4944
000310  30202020
000314  20202020
000318  3d204c4f
00031c  57210a00
                  |L7.800|
000320  426f6f74          DCB      "Bootloader:INPUT->SYS_ID1       = HIGH!\n",0
000324  6c6f6164
000328  65723a49
00032c  4e505554
000330  2d3e5359
000334  535f4944
000338  31202020
00033c  20202020
000340  3d204849
000344  4748210a
000348  00      
000349  00                DCB      0
00034a  00                DCB      0
00034b  00                DCB      0
                  |L7.844|
00034c  426f6f74          DCB      "Bootloader:INPUT->SYS_ID1       = LOW!\n",0
000350  6c6f6164
000354  65723a49
000358  4e505554
00035c  2d3e5359
000360  535f4944
000364  31202020
000368  20202020
00036c  3d204c4f
000370  57210a00
                  |L7.884|
000374  426f6f74          DCB      "Bootloader:INPUT->SYS_ID2       = HIGH!\n",0
000378  6c6f6164
00037c  65723a49
000380  4e505554
000384  2d3e5359
000388  535f4944
00038c  32202020
000390  20202020
000394  3d204849
000398  4748210a
00039c  00      
00039d  00                DCB      0
00039e  00                DCB      0
00039f  00                DCB      0
                  |L7.928|
0003a0  426f6f74          DCB      "Bootloader:INPUT->SYS_ID2       = LOW!\n",0
0003a4  6c6f6164
0003a8  65723a49
0003ac  4e505554
0003b0  2d3e5359
0003b4  535f4944
0003b8  32202020
0003bc  20202020
0003c0  3d204c4f
0003c4  57210a00
                  |L7.968|
0003c8  426f6f74          DCB      "Bootloader:INPUT->FSWITCH_NC    = Open!\n",0
0003cc  6c6f6164
0003d0  65723a49
0003d4  4e505554
0003d8  2d3e4653
0003dc  57495443
0003e0  485f4e43
0003e4  20202020
0003e8  3d204f70
0003ec  656e210a
0003f0  00      
0003f1  00                DCB      0
0003f2  00                DCB      0
0003f3  00                DCB      0
                  |L7.1012|
0003f4  426f6f74          DCB      "Bootloader:INPUT->FSWITCH_NC    = Close!\n",0
0003f8  6c6f6164
0003fc  65723a49
000400  4e505554
000404  2d3e4653
000408  57495443
00040c  485f4e43
000410  20202020
000414  3d20436c
000418  6f736521
00041c  0a00    
00041e  00                DCB      0
00041f  00                DCB      0
                  |L7.1056|
000420  426f6f74          DCB      "Bootloader:INPUT->FSWITCH_NO    = Open!\n",0
000424  6c6f6164
000428  65723a49
00042c  4e505554
000430  2d3e4653
000434  57495443
000438  485f4e4f
00043c  20202020
000440  3d204f70
000444  656e210a
000448  00      
000449  00                DCB      0
00044a  00                DCB      0
00044b  00                DCB      0
                  |L7.1100|
00044c  426f6f74          DCB      "Bootloader:INPUT->FSWITCH_NO    = Close!\n",0
000450  6c6f6164
000454  65723a49
000458  4e505554
00045c  2d3e4653
000460  57495443
000464  485f4e4f
000468  20202020
00046c  3d20436c
000470  6f736521
000474  0a00    
000476  00                DCB      0
000477  00                DCB      0
                  |L7.1144|
000478  426f6f74          DCB      "Bootloader:INPUT->ESTOP         = Open!\n",0
00047c  6c6f6164
000480  65723a49
000484  4e505554
000488  2d3e4553
00048c  544f5020
000490  20202020
000494  20202020
000498  3d204f70
00049c  656e210a
0004a0  00      
0004a1  00                DCB      0
0004a2  00                DCB      0
0004a3  00                DCB      0
                  |L7.1188|
0004a4  426f6f74          DCB      "Bootloader:INPUT->ESTOP         = Close!\n",0
0004a8  6c6f6164
0004ac  65723a49
0004b0  4e505554
0004b4  2d3e4553
0004b8  544f5020
0004bc  20202020
0004c0  20202020
0004c4  3d20436c
0004c8  6f736521
0004cc  0a00    
0004ce  00                DCB      0
0004cf  00                DCB      0
                  |L7.1232|
0004d0  426f6f74          DCB      "Bootloader:INPUT->INTLOCK       = Open!\n",0
0004d4  6c6f6164
0004d8  65723a49
0004dc  4e505554
0004e0  2d3e494e
0004e4  544c4f43
0004e8  4b202020
0004ec  20202020
0004f0  3d204f70
0004f4  656e210a
0004f8  00      
0004f9  00                DCB      0
0004fa  00                DCB      0
0004fb  00                DCB      0
                  |L7.1276|
0004fc  426f6f74          DCB      "Bootloader:INPUT->INTLOCK       = Close!\n",0
000500  6c6f6164
000504  65723a49
000508  4e505554
00050c  2d3e494e
000510  544c4f43
000514  4b202020
000518  20202020
00051c  3d20436c
000520  6f736521
000524  0a00    
000526  00                DCB      0
000527  00                DCB      0
                  |L7.1320|
000528  426f6f74          DCB      "Bootloader:INPUT->PM_ALARM      = High!\n",0
00052c  6c6f6164
000530  65723a49
000534  4e505554
000538  2d3e504d
00053c  5f414c41
000540  524d2020
000544  20202020
000548  3d204869
00054c  6768210a
000550  00      
000551  00                DCB      0
000552  00                DCB      0
000553  00                DCB      0
                  |L7.1364|
000554  426f6f74          DCB      "Bootloader:INPUT->PM_ALARM      = Low!\n",0
000558  6c6f6164
00055c  65723a49
000560  4e505554
000564  2d3e504d
000568  5f414c41
00056c  524d2020
000570  20202020
000574  3d204c6f
000578  77210a00
                  |L7.1404|
00057c  426f6f74          DCB      "Bootloader:INPUT->SOFTPOWER_IN \t= Open!\n",0
000580  6c6f6164
000584  65723a49
000588  4e505554
00058c  2d3e534f
000590  4654504f
000594  5745525f
000598  494e2009
00059c  3d204f70
0005a0  656e210a
0005a4  00      
0005a5  00                DCB      0
0005a6  00                DCB      0
0005a7  00                DCB      0
                  |L7.1448|
0005a8  426f6f74          DCB      "Bootloader:INPUT->SOFTPOWER_IN\t= Close!\n",0
0005ac  6c6f6164
0005b0  65723a49
0005b4  4e505554
0005b8  2d3e534f
0005bc  4654504f
0005c0  5745525f
0005c4  494e093d
0005c8  20436c6f
0005cc  7365210a
0005d0  00      
0005d1  00                DCB      0
0005d2  00                DCB      0
0005d3  00                DCB      0
                  |L7.1492|
0005d4  426f6f74          DCB      "Bootloader:OUTPUT->LP_PWM     \t= High!\n",0
0005d8  6c6f6164
0005dc  65723a4f
0005e0  55545055
0005e4  542d3e4c
0005e8  505f5057
0005ec  4d202020
0005f0  2020093d
0005f4  20486967
0005f8  68210a00
                  |L7.1532|
0005fc  426f6f74          DCB      "Bootloader:OUTPUT->LP_PWM     \t= Low!\n",0
000600  6c6f6164
000604  65723a4f
000608  55545055
00060c  542d3e4c
000610  505f5057
000614  4d202020
000618  2020093d
00061c  204c6f77
000620  210a00  
000623  00                DCB      0
                  |L7.1572|
000624  426f6f74          DCB      "Bootloader:OUTPUT->FAN5V_OUT    = High!\n",0
000628  6c6f6164
00062c  65723a4f
000630  55545055
000634  542d3e46
000638  414e3556
00063c  5f4f5554
000640  20202020
000644  3d204869
000648  6768210a
00064c  00      
00064d  00                DCB      0
00064e  00                DCB      0
00064f  00                DCB      0
                  |L7.1616|
000650  426f6f74          DCB      "Bootloader:OUTPUT->FAN5V_OUT    = Low!\n",0
000654  6c6f6164
000658  65723a4f
00065c  55545055
000660  542d3e46
000664  414e3556
000668  5f4f5554
00066c  20202020
000670  3d204c6f
000674  77210a00
                  |L7.1656|
000678  a00c              ADR      r0,|L7.1708|
00067a  f7fffffe          BL       __2printf
00067e  e002              B        |L7.1670|
                  |L7.1664|
;;;434    	}
;;;435    	else{
;;;436    		printf("Bootloader:OUTPUT->FAN24V_OUT   = Low!\n");
000680  a015              ADR      r0,|L7.1752|
000682  f7fffffe          BL       __2printf
                  |L7.1670|
;;;437    	}
;;;438    	if(HAL_GPIO_ReadPin(HEN_OUT0_GPIO_Port, HEN_OUT0_Pin) == GPIO_PIN_SET){//TEC
000686  f44f4100          MOV      r1,#0x8000
00068a  481d              LDR      r0,|L7.1792|
00068c  f7fffffe          BL       HAL_GPIO_ReadPin
000690  2801              CMP      r0,#1
000692  d103              BNE      |L7.1692|
;;;439    		printf("Bootloader:OUTPUT->TEC_OUT      = High!\n");
000694  a01b              ADR      r0,|L7.1796|
000696  f7fffffe          BL       __2printf
00069a  e002              B        |L7.1698|
                  |L7.1692|
;;;440    	}
;;;441    	else{
;;;442    		printf("Bootloader:OUTPUT->TEC_OUT      = Low!\n");
00069c  a024              ADR      r0,|L7.1840|
00069e  f7fffffe          BL       __2printf
                  |L7.1698|
;;;443    	}
;;;444    	HAL_Delay(10);
0006a2  200a              MOVS     r0,#0xa
0006a4  f7fffffe          BL       HAL_Delay
;;;445    }
0006a8  bd10              POP      {r4,pc}
;;;446    void bootLoadProcess(void){//bootload 执行程序
                          ENDP

0006aa  0000              DCW      0x0000
                  |L7.1708|
0006ac  426f6f74          DCB      "Bootloader:OUTPUT->FAN24V_OUT   = High!\n",0
0006b0  6c6f6164
0006b4  65723a4f
0006b8  55545055
0006bc  542d3e46
0006c0  414e3234
0006c4  565f4f55
0006c8  54202020
0006cc  3d204869
0006d0  6768210a
0006d4  00      
0006d5  00                DCB      0
0006d6  00                DCB      0
0006d7  00                DCB      0
                  |L7.1752|
0006d8  426f6f74          DCB      "Bootloader:OUTPUT->FAN24V_OUT   = Low!\n",0
0006dc  6c6f6164
0006e0  65723a4f
0006e4  55545055
0006e8  542d3e46
0006ec  414e3234
0006f0  565f4f55
0006f4  54202020
0006f8  3d204c6f
0006fc  77210a00
                  |L7.1792|
                          DCD      0x40020400
                  |L7.1796|
000704  426f6f74          DCB      "Bootloader:OUTPUT->TEC_OUT      = High!\n",0
000708  6c6f6164
00070c  65723a4f
000710  55545055
000714  542d3e54
000718  45435f4f
00071c  55542020
000720  20202020
000724  3d204869
000728  6768210a
00072c  00      
00072d  00                DCB      0
00072e  00                DCB      0
00072f  00                DCB      0
                  |L7.1840|
000730  426f6f74          DCB      "Bootloader:OUTPUT->TEC_OUT      = Low!\n",0
000734  6c6f6164
000738  65723a4f
00073c  55545055
000740  542d3e54
000744  45435f4f
000748  55542020
00074c  20202020
000750  3d204c6f
000754  77210a00

                          AREA ||i.bootLoadProcess||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  bootLoadProcess PROC
;;;445    }
;;;446    void bootLoadProcess(void){//bootload 执行程序
000000  b5f0              PUSH     {r4-r7,lr}
000002  b091              SUB      sp,sp,#0x44
;;;447    	HAL_StatusTypeDef ret;
;;;448    	uint8_t fileBuff[64];
;;;449    	uint32_t crcFlash, crcUdisk;
;;;450    	uint32_t brByte;//实际读取的字节数
;;;451    	//uint32_t bwByte;//实际写入的字节数
;;;452    	//注册一个FATFS文件系统
;;;453    	switch(bootLoadState){
000004  48db              LDR      r0,|L8.884|
000006  7800              LDRB     r0,[r0,#0]  ; bootLoadState
000008  2807              CMP      r0,#7
00000a  d074              BEQ      |L8.246|
00000c  dc07              BGT      |L8.30|
00000e  2807              CMP      r0,#7
000010  d272              BCS      |L8.248|
000012  e8dff000          TBB      [pc,r0]
000016  1361              DCB      0x13,0x61
000018  7995c371          DCB      0x79,0x95,0xc3,0x71
00001c  fd00              DCB      0xfd,0x00
                  |L8.30|
00001e  280b              CMP      r0,#0xb
000020  d06b              BEQ      |L8.250|
000022  dc06              BGT      |L8.50|
000024  2808              CMP      r0,#8
000026  d069              BEQ      |L8.252|
000028  2809              CMP      r0,#9
00002a  d068              BEQ      |L8.254|
00002c  280a              CMP      r0,#0xa
                  |L8.46|
00002e  d163              BNE      |L8.248|
000030  e3f9              B        |L8.2086|
                  |L8.50|
000032  285a              CMP      r0,#0x5a
000034  d075              BEQ      |L8.290|
000036  2863              CMP      r0,#0x63
000038  d1f9              BNE      |L8.46|
00003a  e3f0              B        |L8.2078|
;;;454    		case BT_STATE_IDLE:{//开机等待U盘识别                             
;;;455    			SET_GREEN(GPIO_PIN_SET);
00003c  2201              MOVS     r2,#1
00003e  2120              MOVS     r1,#0x20
000040  48cd              LDR      r0,|L8.888|
000042  f7fffffe          BL       HAL_GPIO_WritePin
;;;456    			SET_BLUE(GPIO_PIN_RESET);
000046  2200              MOVS     r2,#0
000048  2180              MOVS     r1,#0x80
00004a  48cb              LDR      r0,|L8.888|
00004c  f7fffffe          BL       HAL_GPIO_WritePin
;;;457    			SET_RED(GPIO_PIN_RESET);
000050  2200              MOVS     r2,#0
000052  2140              MOVS     r1,#0x40
000054  48c8              LDR      r0,|L8.888|
000056  f7fffffe          BL       HAL_GPIO_WritePin
;;;458    			printf("Bootloader:Start...............\n");
00005a  a0c8              ADR      r0,|L8.892|
00005c  f7fffffe          BL       __2printf
;;;459    			readStm32UniqueID();
000060  f7fffffe          BL       readStm32UniqueID
;;;460    			printf("Bootloader:Board ID->0x%X\n", BID);
000064  48ce              LDR      r0,|L8.928|
000066  7801              LDRB     r1,[r0,#0]  ; BID
000068  a0ce              ADR      r0,|L8.932|
00006a  f7fffffe          BL       __2printf
;;;461    			printf("Bootloader:UniqueID->0x%08X%08X%08X\n", UniqueId[0], UniqueId[1], UniqueId[2]);
00006e  48d4              LDR      r0,|L8.960|
000070  6883              LDR      r3,[r0,#8]  ; UniqueId
000072  6842              LDR      r2,[r0,#4]  ; UniqueId
000074  6801              LDR      r1,[r0,#0]  ; UniqueId
000076  a0d3              ADR      r0,|L8.964|
000078  f7fffffe          BL       __2printf
;;;462    			printf("Bootloader:Mcu flash size->%d Kbytes\n", cpuGetFlashSize());
00007c  f7fffffe          BL       cpuGetFlashSize
000080  4607              MOV      r7,r0
000082  4639              MOV      r1,r7
000084  a0d9              ADR      r0,|L8.1004|
000086  f7fffffe          BL       __2printf
;;;463    			printf("Bootloader:Ver->0x%08X Build->%s:%s\n", BOOTLOADER_VER, __DATE__, __TIME__);
00008a  a3e2              ADR      r3,|L8.1044|
00008c  a2e4              ADR      r2,|L8.1056|
00008e  f04f1101          MOV      r1,#0x10001
000092  a0e6              ADR      r0,|L8.1068|
000094  f7fffffe          BL       __2printf
;;;464    			if(HAL_GPIO_ReadPin(INTLOCK_IN_GPIO_Port, INTLOCK_IN_Pin) == GPIO_PIN_SET &&//安全连锁未插入
000098  f44f5180          MOV      r1,#0x1000
00009c  48ed              LDR      r0,|L8.1108|
00009e  f7fffffe          BL       HAL_GPIO_ReadPin
0000a2  2801              CMP      r0,#1
0000a4  d114              BNE      |L8.208|
;;;465    			   HAL_GPIO_ReadPin(ESTOP_IN_GPIO_Port, ESTOP_IN_Pin) == GPIO_PIN_SET &&//急停开关按下
0000a6  02c1              LSLS     r1,r0,#11
0000a8  48ea              LDR      r0,|L8.1108|
0000aa  f7fffffe          BL       HAL_GPIO_ReadPin
0000ae  2801              CMP      r0,#1
0000b0  d10e              BNE      |L8.208|
;;;466    			   HAL_GPIO_ReadPin(FSWITCH_NC_GPIO_Port, FSWITCH_NC_Pin) == GPIO_PIN_RESET &&//脚踏插入
0000b2  03c1              LSLS     r1,r0,#15
0000b4  48e8              LDR      r0,|L8.1112|
0000b6  f7fffffe          BL       HAL_GPIO_ReadPin
0000ba  b948              CBNZ     r0,|L8.208|
;;;467    			   HAL_GPIO_ReadPin(FSWITCH_NO_GPIO_Port, FSWITCH_NO_Pin) == GPIO_PIN_RESET){//脚踏踩下
0000bc  f44f6180          MOV      r1,#0x400
0000c0  48e4              LDR      r0,|L8.1108|
0000c2  f7fffffe          BL       HAL_GPIO_ReadPin
0000c6  b918              CBNZ     r0,|L8.208|
;;;468    				bootLoadState = BT_STATE_LOAD_FWINFO;//进入USB更新APP流程
0000c8  2001              MOVS     r0,#1
0000ca  49aa              LDR      r1,|L8.884|
0000cc  7008              STRB     r0,[r1,#0]
0000ce  e002              B        |L8.214|
                  |L8.208|
;;;469    			}
;;;470    			else{//安全连锁插入
;;;471    				bootLoadState = BT_STATE_RUN_APP;//进入运行APP流程
0000d0  2063              MOVS     r0,#0x63
0000d2  49a8              LDR      r1,|L8.884|
0000d4  7008              STRB     r0,[r1,#0]
                  |L8.214|
;;;472    			}
;;;473    			break;
0000d6  e2e6              B        |L8.1702|
;;;474    		}
;;;475    		case BT_STATE_LOAD_FWINFO:{
;;;476    			ret = epromRead(CONFIG_EPROM_FWINFO_START, (uint8_t*)&firmwareInfo, sizeof(firmwareInfo));//从EPROM载入设备配置
0000d8  220c              MOVS     r2,#0xc
0000da  49e0              LDR      r1,|L8.1116|
0000dc  f44f50e8          MOV      r0,#0x1d00
0000e0  f7fffffe          BL       epromRead
0000e4  4606              MOV      r6,r0
;;;477    			if(ret == HAL_OK){
0000e6  b95e              CBNZ     r6,|L8.256|
;;;478    				bootLoadState = BT_STATE_USBHOST_INIT;
0000e8  2002              MOVS     r0,#2
0000ea  49a2              LDR      r1,|L8.884|
0000ec  7008              STRB     r0,[r1,#0]
;;;479    				printf("Bootloader:Load eprom done!\n");
0000ee  a0dc              ADR      r0,|L8.1120|
0000f0  f7fffffe          BL       __2printf
0000f4  e007              B        |L8.262|
                  |L8.246|
0000f6  e30c              B        |L8.1810|
                  |L8.248|
0000f8  e3fe              B        |L8.2296|
                  |L8.250|
0000fa  e397              B        |L8.2092|
                  |L8.252|
0000fc  e329              B        |L8.1874|
                  |L8.254|
0000fe  e38f              B        |L8.2080|
                  |L8.256|
;;;480    			}
;;;481    			else{
;;;482    				bootLoadState = BT_STATE_RUN_APP;//进入运行APP流程
000100  2063              MOVS     r0,#0x63
000102  499c              LDR      r1,|L8.884|
000104  7008              STRB     r0,[r1,#0]
                  |L8.262|
;;;483    			}
;;;484    			break;
000106  e7e6              B        |L8.214|
;;;485    		}
;;;486    		case BT_STATE_USBHOST_INIT:{//在USB HOST上挂载FATFS
;;;487    			retUsbH = f_mount(&USBH_fatfs, FATFS_ROOT, 0);
000108  2200              MOVS     r2,#0
00010a  a1dd              ADR      r1,|L8.1152|
00010c  48dd              LDR      r0,|L8.1156|
00010e  f7fffffe          BL       f_mount
000112  49dd              LDR      r1,|L8.1160|
000114  7008              STRB     r0,[r1,#0]
;;;488    			if(retUsbH != FR_OK){//挂载U盘失败
000116  4608              MOV      r0,r1
000118  7800              LDRB     r0,[r0,#0]  ; retUsbH
00011a  b150              CBZ      r0,|L8.306|
;;;489    				printf("Bootloader:Mount Fatfs errror:%d!\n", retUsbH);
00011c  4608              MOV      r0,r1
00011e  7801              LDRB     r1,[r0,#0]  ; retUsbH
000120  e000              B        |L8.292|
                  |L8.290|
000122  e38c              B        |L8.2110|
                  |L8.292|
000124  a0d9              ADR      r0,|L8.1164|
000126  f7fffffe          BL       __2printf
;;;490    				bootLoadState = BT_STATE_RUN_APP;//跳转到APP
00012a  2063              MOVS     r0,#0x63
00012c  4991              LDR      r1,|L8.884|
00012e  7008              STRB     r0,[r1,#0]
000130  e005              B        |L8.318|
                  |L8.306|
;;;491    			}
;;;492    			else{//挂载U盘成功
;;;493    				printf("Bootloader:Mount Fatfs sucess!\n");
000132  a0df              ADR      r0,|L8.1200|
000134  f7fffffe          BL       __2printf
;;;494    				bootLoadState = BT_STATE_WAIT_UDISK;
000138  2003              MOVS     r0,#3
00013a  498e              LDR      r1,|L8.884|
00013c  7008              STRB     r0,[r1,#0]
                  |L8.318|
;;;495    			}
;;;496    			break;
00013e  e7ca              B        |L8.214|
;;;497    		}
;;;498    		case BT_STATE_WAIT_UDISK:{//等待USB DISK就绪
;;;499    			//显示倒计时
;;;500    			releaseTime0 = (overTime - (int32_t)HAL_GetTick()) / 1000;
000140  f7fffffe          BL       HAL_GetTick
000144  49e2              LDR      r1,|L8.1232|
000146  6809              LDR      r1,[r1,#0]  ; overTime
000148  1a08              SUBS     r0,r1,r0
00014a  f44f717a          MOV      r1,#0x3e8
00014e  fb90f0f1          SDIV     r0,r0,r1
000152  49e0              LDR      r1,|L8.1236|
000154  6008              STR      r0,[r1,#0]  ; releaseTime0
;;;501    			if(releaseTime0 != releaseTime1){
000156  4608              MOV      r0,r1
000158  6800              LDR      r0,[r0,#0]  ; releaseTime0
00015a  49df              LDR      r1,|L8.1240|
00015c  6809              LDR      r1,[r1,#0]  ; releaseTime1
00015e  4288              CMP      r0,r1
000160  d008              BEQ      |L8.372|
;;;502    				printf("Bootloader:Wait usb disk init:%d Second!\n", releaseTime0);
000162  48dc              LDR      r0,|L8.1236|
000164  6801              LDR      r1,[r0,#0]  ; releaseTime0
000166  a0dd              ADR      r0,|L8.1244|
000168  f7fffffe          BL       __2printf
;;;503    				releaseTime1 = releaseTime0;
00016c  48d9              LDR      r0,|L8.1236|
00016e  6800              LDR      r0,[r0,#0]  ; releaseTime0
000170  49d9              LDR      r1,|L8.1240|
000172  6008              STR      r0,[r1,#0]  ; releaseTime1
                  |L8.372|
;;;504    			} 
;;;505    			if(releaseTime0 <= 0){
000174  48d7              LDR      r0,|L8.1236|
000176  6800              LDR      r0,[r0,#0]  ; releaseTime0
000178  2800              CMP      r0,#0
00017a  dc03              BGT      |L8.388|
;;;506    				bootLoadState = BT_STATE_READ_CFG;
00017c  2004              MOVS     r0,#4
00017e  497d              LDR      r1,|L8.884|
000180  7008              STRB     r0,[r1,#0]
000182  e00a              B        |L8.410|
                  |L8.388|
;;;507    			}
;;;508    			else if(releaseTime0 <=2 && usbReady == TRUE){//U盘就绪
000184  48d3              LDR      r0,|L8.1236|
000186  6800              LDR      r0,[r0,#0]  ; releaseTime0
000188  2802              CMP      r0,#2
00018a  dc06              BGT      |L8.410|
00018c  48de              LDR      r0,|L8.1288|
00018e  7800              LDRB     r0,[r0,#0]  ; usbReady
000190  2801              CMP      r0,#1
000192  d102              BNE      |L8.410|
;;;509    				bootLoadState = BT_STATE_READ_CFG;
000194  2004              MOVS     r0,#4
000196  4977              LDR      r1,|L8.884|
000198  7008              STRB     r0,[r1,#0]
                  |L8.410|
;;;510    			}
;;;511    			break;
00019a  e3d8              B        |L8.2382|
;;;512    		}
;;;513    		case BT_STATE_READ_CFG:{
;;;514    			//检查U盘是否存在Flash Down文件
;;;515    			retUsbH = f_open(&CfgFile, CFG_FIRMWARE_FILENAME, FA_OPEN_EXISTING | FA_READ);//读取完成信息文件
00019c  2201              MOVS     r2,#1
00019e  a1db              ADR      r1,|L8.1292|
0001a0  48dd              LDR      r0,|L8.1304|
0001a2  f7fffffe          BL       f_open
0001a6  49b8              LDR      r1,|L8.1160|
0001a8  7008              STRB     r0,[r1,#0]
;;;516    			if(retUsbH != FR_OK){//读取失败跳过固件更新直接运行程序
0001aa  4608              MOV      r0,r1
0001ac  7800              LDRB     r0,[r0,#0]  ; retUsbH
0001ae  b148              CBZ      r0,|L8.452|
;;;517    				printf("BootLoader:Open %s fail,ECODE=0x%02XH\n", CFG_FIRMWARE_FILENAME, retUsbH);
0001b0  4608              MOV      r0,r1
0001b2  7802              LDRB     r2,[r0,#0]  ; retUsbH
0001b4  a1d5              ADR      r1,|L8.1292|
0001b6  a0d9              ADR      r0,|L8.1308|
0001b8  f7fffffe          BL       __2printf
;;;518    				bootLoadState = BT_STATE_RUN_APP;//跳转到更新MCU APP固件
0001bc  2063              MOVS     r0,#0x63
0001be  496d              LDR      r1,|L8.884|
0001c0  7008              STRB     r0,[r1,#0]
0001c2  e270              B        |L8.1702|
                  |L8.452|
;;;519    			}
;;;520    			else{//读取成功检查文件内容
;;;521    				printf("BootLoader:Open %s sucess,ECODE=0x%02XH\n", CFG_FIRMWARE_FILENAME, retUsbH);
0001c4  48b0              LDR      r0,|L8.1160|
0001c6  7802              LDRB     r2,[r0,#0]  ; retUsbH
0001c8  a1d0              ADR      r1,|L8.1292|
0001ca  a0de              ADR      r0,|L8.1348|
0001cc  f7fffffe          BL       __2printf
;;;522    				f_lseek(&CfgFile, 0);//读取指针移动到开头
0001d0  2100              MOVS     r1,#0
0001d2  48d1              LDR      r0,|L8.1304|
0001d4  f7fffffe          BL       f_lseek
;;;523    				retUsbH = f_read(&CfgFile, fileBuff, 5, &brByte);
0001d8  466b              MOV      r3,sp
0001da  2205              MOVS     r2,#5
0001dc  a901              ADD      r1,sp,#4
0001de  48ce              LDR      r0,|L8.1304|
0001e0  f7fffffe          BL       f_read
0001e4  49a8              LDR      r1,|L8.1160|
0001e6  7008              STRB     r0,[r1,#0]
;;;524    				if((retUsbH != FR_OK) || (brByte < 5)){//读取文件开头4个字节
0001e8  4608              MOV      r0,r1
0001ea  7800              LDRB     r0,[r0,#0]  ; retUsbH
0001ec  b910              CBNZ     r0,|L8.500|
0001ee  9800              LDR      r0,[sp,#0]
0001f0  2805              CMP      r0,#5
0001f2  d202              BCS      |L8.506|
                  |L8.500|
;;;525    					bootLoadFailHandler(BT_FAIL_READ_CFG);//读取CFG错误
0001f4  2030              MOVS     r0,#0x30
0001f6  f7fffffe          BL       bootLoadFailHandler
                  |L8.506|
;;;526    				}
;;;527    				if(fileBuff[0] == 'U' && fileBuff[1] == '0' && fileBuff[2] == '1'){//U01 更新 MCU应用
0001fa  f89d0004          LDRB     r0,[sp,#4]
0001fe  2855              CMP      r0,#0x55
000200  d11c              BNE      |L8.572|
000202  f89d0005          LDRB     r0,[sp,#5]
000206  2830              CMP      r0,#0x30
000208  d118              BNE      |L8.572|
00020a  f89d0006          LDRB     r0,[sp,#6]
00020e  e000              B        |L8.530|
000210  e24a              B        |L8.1704|
                  |L8.530|
000212  2831              CMP      r0,#0x31
000214  d112              BNE      |L8.572|
;;;528    					if(fileBuff[3] == DEVID_L && fileBuff[4] == DEVID_H){//设备匹配
000216  f89d0007          LDRB     r0,[sp,#7]
00021a  2841              CMP      r0,#0x41
00021c  d10a              BNE      |L8.564|
00021e  f89d0008          LDRB     r0,[sp,#8]
000222  2830              CMP      r0,#0x30
000224  d106              BNE      |L8.564|
;;;529    						printf("Bootloader:Start upgrade mcu application!\n");
000226  a0d2              ADR      r0,|L8.1392|
000228  f7fffffe          BL       __2printf
;;;530    						bootLoadState = BT_STATE_UPDATE_MCU_APP;
00022c  2006              MOVS     r0,#6
00022e  4951              LDR      r1,|L8.884|
000230  7008              STRB     r0,[r1,#0]
000232  e235              B        |L8.1696|
                  |L8.564|
;;;531    					}
;;;532    					else{
;;;533    						bootLoadState = BT_STATE_RUN_APP;
000234  2063              MOVS     r0,#0x63
000236  494f              LDR      r1,|L8.884|
000238  7008              STRB     r0,[r1,#0]
00023a  e231              B        |L8.1696|
                  |L8.572|
;;;534    					}
;;;535    				}
;;;536    				else if(fileBuff[0] == 'U' && fileBuff[1] == '0' && fileBuff[2] == '2'){//U02 更新 触摸屏
00023c  f89d0004          LDRB     r0,[sp,#4]
000240  2855              CMP      r0,#0x55
000242  d11a              BNE      |L8.634|
000244  f89d0005          LDRB     r0,[sp,#5]
000248  2830              CMP      r0,#0x30
00024a  d116              BNE      |L8.634|
00024c  f89d0006          LDRB     r0,[sp,#6]
000250  2832              CMP      r0,#0x32
000252  d112              BNE      |L8.634|
;;;537    					if(fileBuff[3] == DEVID_L && fileBuff[4] == DEVID_H){//设备匹配
000254  f89d0007          LDRB     r0,[sp,#7]
000258  2841              CMP      r0,#0x41
00025a  d10a              BNE      |L8.626|
00025c  f89d0008          LDRB     r0,[sp,#8]
000260  2830              CMP      r0,#0x30
000262  d106              BNE      |L8.626|
;;;538    						printf("Bootloader:Start upgrade lcd application!\n");
000264  a0cd              ADR      r0,|L8.1436|
000266  f7fffffe          BL       __2printf
;;;539    						bootLoadState = BT_STATE_UPDATE_LCD_APP;
00026a  2007              MOVS     r0,#7
00026c  4941              LDR      r1,|L8.884|
00026e  7008              STRB     r0,[r1,#0]
000270  e216              B        |L8.1696|
                  |L8.626|
;;;540    					}
;;;541    					else{
;;;542    						bootLoadState = BT_STATE_RUN_APP;
000272  2063              MOVS     r0,#0x63
000274  493f              LDR      r1,|L8.884|
000276  7008              STRB     r0,[r1,#0]
000278  e212              B        |L8.1696|
                  |L8.634|
;;;543    					}
;;;544    				}
;;;545    				else if(fileBuff[0] == 'U' && fileBuff[1] == '0' && fileBuff[2] == '3'){//U03 更新 应用&触摸屏
00027a  f89d0004          LDRB     r0,[sp,#4]
00027e  2855              CMP      r0,#0x55
000280  d11d              BNE      |L8.702|
000282  f89d0005          LDRB     r0,[sp,#5]
000286  2830              CMP      r0,#0x30
000288  d119              BNE      |L8.702|
00028a  f89d0006          LDRB     r0,[sp,#6]
00028e  2833              CMP      r0,#0x33
000290  d115              BNE      |L8.702|
;;;546    					if(fileBuff[3] == DEVID_L && fileBuff[4] == DEVID_H){//设备匹配
000292  f89d0007          LDRB     r0,[sp,#7]
000296  2841              CMP      r0,#0x41
000298  d10a              BNE      |L8.688|
00029a  f89d0008          LDRB     r0,[sp,#8]
00029e  2830              CMP      r0,#0x30
0002a0  d106              BNE      |L8.688|
;;;547    						printf("Bootloader:Start upgrade mcu application & lcd application!\n");
0002a2  a0c9              ADR      r0,|L8.1480|
0002a4  f7fffffe          BL       __2printf
;;;548    						bootLoadState = BT_STATE_UPDATE_BOTH_APP;
0002a8  2008              MOVS     r0,#8
0002aa  4932              LDR      r1,|L8.884|
0002ac  7008              STRB     r0,[r1,#0]
0002ae  e1f7              B        |L8.1696|
                  |L8.688|
;;;549    					}
;;;550    					else{
;;;551    						printf("Bootloader:Device ID is not mate,run app!\n");
0002b0  a0d5              ADR      r0,|L8.1544|
0002b2  f7fffffe          BL       __2printf
;;;552    						bootLoadState = BT_STATE_RUN_APP;
0002b6  2063              MOVS     r0,#0x63
0002b8  492e              LDR      r1,|L8.884|
0002ba  7008              STRB     r0,[r1,#0]
0002bc  e1f0              B        |L8.1696|
                  |L8.702|
;;;553    					}
;;;554    				}
;;;555    				else if(fileBuff[0] == 'U' && fileBuff[1] == '0' && fileBuff[2] == '4'){//U04 更新 EPROM
0002be  f89d0004          LDRB     r0,[sp,#4]
0002c2  2855              CMP      r0,#0x55
0002c4  d11d              BNE      |L8.770|
0002c6  f89d0005          LDRB     r0,[sp,#5]
0002ca  2830              CMP      r0,#0x30
0002cc  d119              BNE      |L8.770|
0002ce  f89d0006          LDRB     r0,[sp,#6]
0002d2  2834              CMP      r0,#0x34
0002d4  d115              BNE      |L8.770|
;;;556    					if(fileBuff[3] == DEVID_L && fileBuff[4] == DEVID_H){//设备匹配
0002d6  f89d0007          LDRB     r0,[sp,#7]
0002da  2841              CMP      r0,#0x41
0002dc  d10a              BNE      |L8.756|
0002de  f89d0008          LDRB     r0,[sp,#8]
0002e2  2830              CMP      r0,#0x30
0002e4  d106              BNE      |L8.756|
;;;557    						printf("Bootloader:Start update eprom!\n");
0002e6  a0d3              ADR      r0,|L8.1588|
0002e8  f7fffffe          BL       __2printf
;;;558    						bootLoadState = BT_STATE_UPDATE_EPROM;
0002ec  2009              MOVS     r0,#9
0002ee  4921              LDR      r1,|L8.884|
0002f0  7008              STRB     r0,[r1,#0]
0002f2  e1d5              B        |L8.1696|
                  |L8.756|
;;;559    					}
;;;560    					else{
;;;561    						printf("Bootloader:Device ID is not mate,run app!\n");
0002f4  a0c4              ADR      r0,|L8.1544|
0002f6  f7fffffe          BL       __2printf
;;;562    						bootLoadState = BT_STATE_RUN_APP;
0002fa  2063              MOVS     r0,#0x63
0002fc  491d              LDR      r1,|L8.884|
0002fe  7008              STRB     r0,[r1,#0]
000300  e1ce              B        |L8.1696|
                  |L8.770|
;;;563    					}
;;;564    				}
;;;565    				else if(fileBuff[0] == 'D' && fileBuff[1] == '0' && fileBuff[2] == '1'){//D1 读取EPROM
000302  f89d0004          LDRB     r0,[sp,#4]
000306  2844              CMP      r0,#0x44
000308  d11d              BNE      |L8.838|
00030a  f89d0005          LDRB     r0,[sp,#5]
00030e  2830              CMP      r0,#0x30
000310  d119              BNE      |L8.838|
000312  f89d0006          LDRB     r0,[sp,#6]
000316  2831              CMP      r0,#0x31
000318  d115              BNE      |L8.838|
;;;566    					if(fileBuff[3] == DEVID_L && fileBuff[4] == DEVID_H){//设备匹配
00031a  f89d0007          LDRB     r0,[sp,#7]
00031e  2841              CMP      r0,#0x41
000320  d10a              BNE      |L8.824|
000322  f89d0008          LDRB     r0,[sp,#8]
000326  2830              CMP      r0,#0x30
000328  d106              BNE      |L8.824|
;;;567    						printf("Bootloader:Start dump eprom to udisk!\n");
00032a  a0ca              ADR      r0,|L8.1620|
00032c  f7fffffe          BL       __2printf
;;;568    						bootLoadState = BT_STATE_DUMP_EPROM;
000330  200a              MOVS     r0,#0xa
000332  4910              LDR      r1,|L8.884|
000334  7008              STRB     r0,[r1,#0]
000336  e1b3              B        |L8.1696|
                  |L8.824|
;;;569    					}
;;;570    					else{
;;;571    						printf("Bootloader:Device ID is not mate,run app!\n");
000338  a0b3              ADR      r0,|L8.1544|
00033a  f7fffffe          BL       __2printf
;;;572    						bootLoadState = BT_STATE_RUN_APP;
00033e  2063              MOVS     r0,#0x63
000340  490c              LDR      r1,|L8.884|
000342  7008              STRB     r0,[r1,#0]
000344  e1ac              B        |L8.1696|
                  |L8.838|
;;;573    					}
;;;574    				}
;;;575    				else if(fileBuff[0] == 'C' && fileBuff[1] == '0' && fileBuff[2] == '1'){//U01 清除所有
000346  f89d0004          LDRB     r0,[sp,#4]
00034a  2843              CMP      r0,#0x43
00034c  d110              BNE      |L8.880|
00034e  f89d0005          LDRB     r0,[sp,#5]
000352  2830              CMP      r0,#0x30
000354  d10c              BNE      |L8.880|
000356  f89d0006          LDRB     r0,[sp,#6]
00035a  2831              CMP      r0,#0x31
00035c  d108              BNE      |L8.880|
;;;576    					if(fileBuff[3] == DEVID_L && fileBuff[4] == DEVID_H){//设备匹配
00035e  f89d0007          LDRB     r0,[sp,#7]
000362  2841              CMP      r0,#0x41
000364  d105              BNE      |L8.882|
000366  f89d0008          LDRB     r0,[sp,#8]
00036a  2830              CMP      r0,#0x30
00036c  d101              BNE      |L8.882|
;;;577    						printf("Bootloader:Start clear flash and eprom!\n");
00036e  e185              B        |L8.1660|
                  |L8.880|
000370  e193              B        |L8.1690|
                  |L8.882|
000372  e18a              B        |L8.1674|
                  |L8.884|
                          DCD      bootLoadState
                  |L8.888|
                          DCD      0x40020400
                  |L8.892|
00037c  426f6f74          DCB      "Bootloader:Start...............\n",0
000380  6c6f6164
000384  65723a53
000388  74617274
00038c  2e2e2e2e
000390  2e2e2e2e
000394  2e2e2e2e
000398  2e2e2e0a
00039c  00      
00039d  00                DCB      0
00039e  00                DCB      0
00039f  00                DCB      0
                  |L8.928|
                          DCD      BID
                  |L8.932|
0003a4  426f6f74          DCB      "Bootloader:Board ID->0x%X\n",0
0003a8  6c6f6164
0003ac  65723a42
0003b0  6f617264
0003b4  2049442d
0003b8  3e307825
0003bc  580a00  
0003bf  00                DCB      0
                  |L8.960|
                          DCD      UniqueId
                  |L8.964|
0003c4  426f6f74          DCB      "Bootloader:UniqueID->0x%08X%08X%08X\n",0
0003c8  6c6f6164
0003cc  65723a55
0003d0  6e697175
0003d4  6549442d
0003d8  3e307825
0003dc  30385825
0003e0  30385825
0003e4  3038580a
0003e8  00      
0003e9  00                DCB      0
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L8.1004|
0003ec  426f6f74          DCB      "Bootloader:Mcu flash size->%d Kbytes\n",0
0003f0  6c6f6164
0003f4  65723a4d
0003f8  63752066
0003fc  6c617368
000400  2073697a
000404  652d3e25
000408  64204b62
00040c  79746573
000410  0a00    
000412  00                DCB      0
000413  00                DCB      0
                  |L8.1044|
000414  32313a31          DCB      "21:13:00",0
000418  333a3030
00041c  00      
00041d  00                DCB      0
00041e  00                DCB      0
00041f  00                DCB      0
                  |L8.1056|
000420  41756720          DCB      "Aug  4 2021",0
000424  20342032
000428  30323100
                  |L8.1068|
00042c  426f6f74          DCB      "Bootloader:Ver->0x%08X Build->%s:%s\n",0
000430  6c6f6164
000434  65723a56
000438  65722d3e
00043c  30782530
000440  38582042
000444  75696c64
000448  2d3e2573
00044c  3a25730a
000450  00      
000451  00                DCB      0
000452  00                DCB      0
000453  00                DCB      0
                  |L8.1108|
                          DCD      0x40020800
                  |L8.1112|
                          DCD      0x40020000
                  |L8.1116|
                          DCD      firmwareInfo
                  |L8.1120|
000460  426f6f74          DCB      "Bootloader:Load eprom done!\n",0
000464  6c6f6164
000468  65723a4c
00046c  6f616420
000470  6570726f
000474  6d20646f
000478  6e65210a
00047c  00      
00047d  00                DCB      0
00047e  00                DCB      0
00047f  00                DCB      0
                  |L8.1152|
000480  303a00            DCB      "0:",0
000483  00                DCB      0
                  |L8.1156|
                          DCD      USBH_fatfs
                  |L8.1160|
                          DCD      retUsbH
                  |L8.1164|
00048c  426f6f74          DCB      "Bootloader:Mount Fatfs errror:%d!\n",0
000490  6c6f6164
000494  65723a4d
000498  6f756e74
00049c  20466174
0004a0  66732065
0004a4  7272726f
0004a8  723a2564
0004ac  210a00  
0004af  00                DCB      0
                  |L8.1200|
0004b0  426f6f74          DCB      "Bootloader:Mount Fatfs sucess!\n",0
0004b4  6c6f6164
0004b8  65723a4d
0004bc  6f756e74
0004c0  20466174
0004c4  66732073
0004c8  75636573
0004cc  73210a00
                  |L8.1232|
                          DCD      overTime
                  |L8.1236|
                          DCD      releaseTime0
                  |L8.1240|
                          DCD      releaseTime1
                  |L8.1244|
0004dc  426f6f74          DCB      "Bootloader:Wait usb disk init:%d Second!\n",0
0004e0  6c6f6164
0004e4  65723a57
0004e8  61697420
0004ec  75736220
0004f0  6469736b
0004f4  20696e69
0004f8  743a2564
0004fc  20536563
000500  6f6e6421
000504  0a00    
000506  00                DCB      0
000507  00                DCB      0
                  |L8.1288|
                          DCD      usbReady
                  |L8.1292|
00050c  2f6c6173          DCB      "/las.cfg",0
000510  2e636667
000514  00      
000515  00                DCB      0
000516  00                DCB      0
000517  00                DCB      0
                  |L8.1304|
                          DCD      CfgFile
                  |L8.1308|
00051c  426f6f74          DCB      "BootLoader:Open %s fail,ECODE=0x%02XH\n",0
000520  4c6f6164
000524  65723a4f
000528  70656e20
00052c  25732066
000530  61696c2c
000534  45434f44
000538  453d3078
00053c  25303258
000540  480a00  
000543  00                DCB      0
                  |L8.1348|
000544  426f6f74          DCB      "BootLoader:Open %s sucess,ECODE=0x%02XH\n",0
000548  4c6f6164
00054c  65723a4f
000550  70656e20
000554  25732073
000558  75636573
00055c  732c4543
000560  4f44453d
000564  30782530
000568  3258480a
00056c  00      
00056d  00                DCB      0
00056e  00                DCB      0
00056f  00                DCB      0
                  |L8.1392|
000570  426f6f74          DCB      "Bootloader:Start upgrade mcu application!\n",0
000574  6c6f6164
000578  65723a53
00057c  74617274
000580  20757067
000584  72616465
000588  206d6375
00058c  20617070
000590  6c696361
000594  74696f6e
000598  210a00  
00059b  00                DCB      0
                  |L8.1436|
00059c  426f6f74          DCB      "Bootloader:Start upgrade lcd application!\n",0
0005a0  6c6f6164
0005a4  65723a53
0005a8  74617274
0005ac  20757067
0005b0  72616465
0005b4  206c6364
0005b8  20617070
0005bc  6c696361
0005c0  74696f6e
0005c4  210a00  
0005c7  00                DCB      0
                  |L8.1480|
0005c8  426f6f74          DCB      "Bootloader:Start upgrade mcu application & lcd applicat"
0005cc  6c6f6164
0005d0  65723a53
0005d4  74617274
0005d8  20757067
0005dc  72616465
0005e0  206d6375
0005e4  20617070
0005e8  6c696361
0005ec  74696f6e
0005f0  2026206c
0005f4  63642061
0005f8  70706c69
0005fc  636174  
0005ff  696f6e21          DCB      "ion!\n",0
000603  0a00    
000605  00                DCB      0
000606  00                DCB      0
000607  00                DCB      0
                  |L8.1544|
000608  426f6f74          DCB      "Bootloader:Device ID is not mate,run app!\n",0
00060c  6c6f6164
000610  65723a44
000614  65766963
000618  65204944
00061c  20697320
000620  6e6f7420
000624  6d617465
000628  2c72756e
00062c  20617070
000630  210a00  
000633  00                DCB      0
                  |L8.1588|
000634  426f6f74          DCB      "Bootloader:Start update eprom!\n",0
000638  6c6f6164
00063c  65723a53
000640  74617274
000644  20757064
000648  61746520
00064c  6570726f
000650  6d210a00
                  |L8.1620|
000654  426f6f74          DCB      "Bootloader:Start dump eprom to udisk!\n",0
000658  6c6f6164
00065c  65723a53
000660  74617274
000664  2064756d
000668  70206570
00066c  726f6d20
000670  746f2075
000674  6469736b
000678  210a00  
00067b  00                DCB      0
                  |L8.1660|
00067c  a0b5              ADR      r0,|L8.2388|
00067e  f7fffffe          BL       __2printf
;;;578    						bootLoadState = BT_STATE_CLEAT_ALL;
000682  200b              MOVS     r0,#0xb
000684  49be              LDR      r1,|L8.2432|
000686  7008              STRB     r0,[r1,#0]
000688  e00a              B        |L8.1696|
                  |L8.1674|
;;;579    					}
;;;580    					else{
;;;581    						printf("Bootloader:Device ID is not mate,run app!\n");
00068a  f2af0084          ADR      r0,|L8.1544|
00068e  f7fffffe          BL       __2printf
;;;582    						bootLoadState = BT_STATE_RUN_APP;
000692  2063              MOVS     r0,#0x63
000694  49ba              LDR      r1,|L8.2432|
000696  7008              STRB     r0,[r1,#0]
000698  e002              B        |L8.1696|
                  |L8.1690|
;;;583    					}
;;;584    				}
;;;585    				else{//其它无需更新跳转到执行APP
;;;586    					bootLoadState = BT_STATE_RUN_APP;
00069a  2063              MOVS     r0,#0x63
00069c  49b8              LDR      r1,|L8.2432|
00069e  7008              STRB     r0,[r1,#0]
                  |L8.1696|
;;;587    				}
;;;588    				f_close(&CfgFile);
0006a0  48b8              LDR      r0,|L8.2436|
0006a2  f7fffffe          BL       f_close
                  |L8.1702|
;;;589    			}
;;;590    			break;
0006a6  e152              B        |L8.2382|
                  |L8.1704|
;;;591    		}
;;;592    		case BT_STATE_UPDATE_MCU_APP:{//更新ld_mcu.bin
;;;593    			crcFlash = getOriginAppCrc();//计算FLASH中APP固件CRC32
0006a8  f7fffffe          BL       getOriginAppCrc
0006ac  4605              MOV      r5,r0
;;;594    			crcUdisk = getNewMcuAppCrc();//计算U盘中MCU APP固件CRC32
0006ae  f7fffffe          BL       getNewMcuAppCrc
0006b2  4604              MOV      r4,r0
;;;595    			if((crcUdisk == firmwareInfo.mucAppCrc) && (crcFlash == firmwareInfo.mucAppCrc)){//校验码相同跳过更新
0006b4  48b4              LDR      r0,|L8.2440|
0006b6  6841              LDR      r1,[r0,#4]  ; firmwareInfo
0006b8  42a1              CMP      r1,r4
0006ba  d109              BNE      |L8.1744|
0006bc  6840              LDR      r0,[r0,#4]  ; firmwareInfo
0006be  42a8              CMP      r0,r5
0006c0  d106              BNE      |L8.1744|
;;;596    				printf("Bootloader:Check mcu app crc same,skip!\n");
0006c2  a0b2              ADR      r0,|L8.2444|
0006c4  f7fffffe          BL       __2printf
;;;597    				bootLoadState = BT_STATE_RESET;
0006c8  205a              MOVS     r0,#0x5a
0006ca  49ad              LDR      r1,|L8.2432|
0006cc  7008              STRB     r0,[r1,#0]
;;;598    				break;
0006ce  e13e              B        |L8.2382|
                  |L8.1744|
;;;599    			}
;;;600    			crcUdisk = updateMcuApp();//写入MCU FLASH
0006d0  f7fffffe          BL       updateMcuApp
0006d4  4604              MOV      r4,r0
;;;601    			crcFlash = getOriginAppCrc();//校验MCU FLASH
0006d6  f7fffffe          BL       getOriginAppCrc
0006da  4605              MOV      r5,r0
;;;602    			if(crcUdisk != crcFlash){
0006dc  42ac              CMP      r4,r5
0006de  d003              BEQ      |L8.1768|
;;;603    				bootLoadFailHandler(BT_FAIL_CHECKSUM_MCU_APP_FLASH);
0006e0  2042              MOVS     r0,#0x42
0006e2  f7fffffe          BL       bootLoadFailHandler
0006e6  e010              B        |L8.1802|
                  |L8.1768|
;;;604    			}
;;;605    			else{
;;;606    				printf("Bootloader:Checksum mcu app sucess.\n");
0006e8  a0b3              ADR      r0,|L8.2488|
0006ea  f7fffffe          BL       __2printf
;;;607    				firmwareInfo.mucAppCrc = crcFlash;//CRC值写入EPROM
0006ee  48a6              LDR      r0,|L8.2440|
0006f0  6045              STR      r5,[r0,#4]  ; firmwareInfo
;;;608    				epromWrite(CONFIG_EPROM_FWINFO_START, (uint8_t*)&firmwareInfo, sizeof(firmwareInfo));
0006f2  220c              MOVS     r2,#0xc
0006f4  4601              MOV      r1,r0
0006f6  f44f50e8          MOV      r0,#0x1d00
0006fa  f7fffffe          BL       epromWrite
;;;609    				clearEprom(CLEAR_EPROM_NVRAM);//清除NVRAM掉电储存区
0006fe  2002              MOVS     r0,#2
000700  f7fffffe          BL       clearEprom
;;;610    				printf("Bootloader:Update new crc32 sucess.\n");
000704  a0b6              ADR      r0,|L8.2528|
000706  f7fffffe          BL       __2printf
                  |L8.1802|
;;;611    			}
;;;612    			bootLoadState = BT_STATE_RESET;//更新APP
00070a  205a              MOVS     r0,#0x5a
00070c  499c              LDR      r1,|L8.2432|
00070e  7008              STRB     r0,[r1,#0]
;;;613    			break;
000710  e11d              B        |L8.2382|
                  |L8.1810|
;;;614    		}
;;;615    		case BT_STATE_UPDATE_LCD_APP:{//更新LCD应用程序			
;;;616    			crcUdisk = getNewLcdAppCrc();//计算U盘中MCU APP固件CRC32
000712  f7fffffe          BL       getNewLcdAppCrc
000716  4604              MOV      r4,r0
;;;617    			if(crcUdisk == firmwareInfo.lcdAppCrc){//校验码相同跳过更新
000718  489b              LDR      r0,|L8.2440|
00071a  6881              LDR      r1,[r0,#8]  ; firmwareInfo
00071c  42a1              CMP      r1,r4
00071e  d106              BNE      |L8.1838|
;;;618    				printf("Bootloader:Check lcd app crc same,skip!\n");
000720  a0b9              ADR      r0,|L8.2568|
000722  f7fffffe          BL       __2printf
;;;619    				bootLoadState = BT_STATE_RUN_APP;
000726  2063              MOVS     r0,#0x63
000728  4995              LDR      r1,|L8.2432|
00072a  7008              STRB     r0,[r1,#0]
;;;620    				break;
00072c  e10f              B        |L8.2382|
                  |L8.1838|
;;;621    			}
;;;622    			crcUdisk = updateLcdApp();
00072e  f7fffffe          BL       updateLcdApp
000732  4604              MOV      r4,r0
;;;623    			firmwareInfo.lcdAppCrc = crcUdisk;//更新EPROM中LCD APP CRC值
000734  4894              LDR      r0,|L8.2440|
000736  6084              STR      r4,[r0,#8]  ; firmwareInfo
;;;624    			epromWrite(CONFIG_EPROM_FWINFO_START, (uint8_t*)&firmwareInfo, sizeof(firmwareInfo));
000738  220c              MOVS     r2,#0xc
00073a  4601              MOV      r1,r0
00073c  f44f50e8          MOV      r0,#0x1d00
000740  f7fffffe          BL       epromWrite
;;;625    			printf("Bootloader:Update new crc32 sucess.\n");
000744  a0a6              ADR      r0,|L8.2528|
000746  f7fffffe          BL       __2printf
;;;626    			bootLoadState = BT_STATE_RESET;//更新APP
00074a  205a              MOVS     r0,#0x5a
00074c  498c              LDR      r1,|L8.2432|
00074e  7008              STRB     r0,[r1,#0]
;;;627    			break;
000750  e0fd              B        |L8.2382|
                  |L8.1874|
;;;628    		}
;;;629    		case BT_STATE_UPDATE_BOTH_APP:{//更新全部应用程序
;;;630    			//MCU 更新
;;;631    			crcFlash = getOriginAppCrc();//计算FLASH中APP固件CRC32
000752  f7fffffe          BL       getOriginAppCrc
000756  4605              MOV      r5,r0
;;;632    			crcUdisk = getNewMcuAppCrc();//计算U盘中MCU APP固件CRC32
000758  f7fffffe          BL       getNewMcuAppCrc
00075c  4604              MOV      r4,r0
;;;633    			if((crcUdisk == firmwareInfo.mucAppCrc) && (crcFlash == firmwareInfo.mucAppCrc)){//校验码相同跳过更新
00075e  488a              LDR      r0,|L8.2440|
000760  6841              LDR      r1,[r0,#4]  ; firmwareInfo
000762  42a1              CMP      r1,r4
000764  d106              BNE      |L8.1908|
000766  6840              LDR      r0,[r0,#4]  ; firmwareInfo
000768  42a8              CMP      r0,r5
00076a  d103              BNE      |L8.1908|
;;;634    				printf("Bootloader:Check mcu app crc same,skip!\n");
00076c  a087              ADR      r0,|L8.2444|
00076e  f7fffffe          BL       __2printf
000772  e01b              B        |L8.1964|
                  |L8.1908|
;;;635    			}
;;;636    			else{//从U盘更新固件
;;;637    				crcUdisk = updateMcuApp();	
000774  f7fffffe          BL       updateMcuApp
000778  4604              MOV      r4,r0
;;;638    				crcFlash = getOriginAppCrc();//校验MCU FLASH
00077a  f7fffffe          BL       getOriginAppCrc
00077e  4605              MOV      r5,r0
;;;639    				if(crcUdisk != crcFlash){
000780  42ac              CMP      r4,r5
000782  d002              BEQ      |L8.1930|
;;;640    					bootLoadFailHandler(BT_FAIL_CHECKSUM_MCU_APP_FLASH);
000784  2042              MOVS     r0,#0x42
000786  f7fffffe          BL       bootLoadFailHandler
                  |L8.1930|
;;;641    				}
;;;642    				firmwareInfo.mucAppCrc = crcFlash;//CRC值写入EPROM
00078a  487f              LDR      r0,|L8.2440|
00078c  6045              STR      r5,[r0,#4]  ; firmwareInfo
;;;643    				printf("Bootloader:Check mcu app sucess.\n");
00078e  a0a9              ADR      r0,|L8.2612|
000790  f7fffffe          BL       __2printf
;;;644    				epromWrite(CONFIG_EPROM_FWINFO_START, (uint8_t*)&firmwareInfo, sizeof(firmwareInfo));
000794  220c              MOVS     r2,#0xc
000796  497c              LDR      r1,|L8.2440|
000798  f44f50e8          MOV      r0,#0x1d00
00079c  f7fffffe          BL       epromWrite
;;;645    				clearEprom(CLEAR_EPROM_NVRAM);
0007a0  2002              MOVS     r0,#2
0007a2  f7fffffe          BL       clearEprom
;;;646    				printf("Bootloader:Update mcu app new crc32 sucess.\n");
0007a6  a0ac              ADR      r0,|L8.2648|
0007a8  f7fffffe          BL       __2printf
                  |L8.1964|
;;;647    			}
;;;648    			//LCD 更新
;;;649    			crcUdisk = getNewLcdAppCrc();//计算U盘中MCU APP固件CRC32
0007ac  f7fffffe          BL       getNewLcdAppCrc
0007b0  4604              MOV      r4,r0
;;;650    			if(crcUdisk == firmwareInfo.lcdAppCrc){//校验码相同跳过更新
0007b2  4875              LDR      r0,|L8.2440|
0007b4  6880              LDR      r0,[r0,#8]  ; firmwareInfo
0007b6  42a0              CMP      r0,r4
0007b8  d103              BNE      |L8.1986|
;;;651    				printf("Bootloader:Check lcd app crc same,skip!\n");
0007ba  a093              ADR      r0,|L8.2568|
0007bc  f7fffffe          BL       __2printf
0007c0  e028              B        |L8.2068|
                  |L8.1986|
;;;652    			}
;;;653    			else{
;;;654    				updateLcdApp();
0007c2  f7fffffe          BL       updateLcdApp
;;;655    				firmwareInfo.lcdAppCrc = crcUdisk;
0007c6  4870              LDR      r0,|L8.2440|
0007c8  6084              STR      r4,[r0,#8]  ; firmwareInfo
;;;656    				epromWrite(CONFIG_EPROM_FWINFO_START, (uint8_t*)&firmwareInfo, sizeof(firmwareInfo));
0007ca  220c              MOVS     r2,#0xc
0007cc  4601              MOV      r1,r0
0007ce  f44f50e8          MOV      r0,#0x1d00
0007d2  f7fffffe          BL       epromWrite
;;;657    				printf("Bootloader:Update lcd app new crc32 sucess,wait lcd upgrade done\n");
0007d6  48ac              LDR      r0,|L8.2696|
0007d8  f7fffffe          BL       __2printf
;;;658    				HAL_Delay(5000);HAL_Delay(5000);HAL_Delay(5000);HAL_Delay(5000);HAL_Delay(5000);
0007dc  f2413088          MOV      r0,#0x1388
0007e0  f7fffffe          BL       HAL_Delay
0007e4  f2413088          MOV      r0,#0x1388
0007e8  f7fffffe          BL       HAL_Delay
0007ec  f2413088          MOV      r0,#0x1388
0007f0  f7fffffe          BL       HAL_Delay
0007f4  f2413088          MOV      r0,#0x1388
0007f8  f7fffffe          BL       HAL_Delay
0007fc  f2413088          MOV      r0,#0x1388
000800  f7fffffe          BL       HAL_Delay
;;;659    				HAL_Delay(5000);HAL_Delay(5000);
000804  f2413088          MOV      r0,#0x1388
000808  f7fffffe          BL       HAL_Delay
00080c  f2413088          MOV      r0,#0x1388
000810  f7fffffe          BL       HAL_Delay
                  |L8.2068|
;;;660    			}
;;;661    			bootLoadState = BT_STATE_RESET;
000814  205a              MOVS     r0,#0x5a
000816  495a              LDR      r1,|L8.2432|
000818  7008              STRB     r0,[r1,#0]
;;;662    			break;
00081a  e098              B        |L8.2382|
00081c  e003              B        |L8.2086|
                  |L8.2078|
00081e  e033              B        |L8.2184|
                  |L8.2080|
;;;663    		}
;;;664    		case BT_STATE_UPDATE_EPROM:{//更新EPROM
;;;665    			updateEprom();
000820  f7fffffe          BL       updateEprom
;;;666    			break;
000824  e093              B        |L8.2382|
                  |L8.2086|
;;;667    		}
;;;668    		case BT_STATE_DUMP_EPROM:{
;;;669    			dumpEprom();
000826  f7fffffe          BL       dumpEprom
;;;670    			break;
00082a  e090              B        |L8.2382|
                  |L8.2092|
;;;671    		}
;;;672    		case BT_STATE_CLEAT_ALL:{//清除FLASH和EPROM全部
;;;673    			clearFlash();
00082c  f7fffffe          BL       clearFlash
;;;674    			clearEprom(CLEAR_EPROM_ALL);
000830  2001              MOVS     r0,#1
000832  f7fffffe          BL       clearEprom
;;;675    			bootLoadFailHandler(BT_DONE_CLEAR_ALL);
000836  2048              MOVS     r0,#0x48
000838  f7fffffe          BL       bootLoadFailHandler
;;;676    			break;
00083c  e087              B        |L8.2382|
                  |L8.2110|
;;;677    		}
;;;678    		case BT_STATE_RESET:{//复位
;;;679    			printf("Bootloader:System Reset\n");
00083e  a093              ADR      r0,|L8.2700|
000840  f7fffffe          BL       __2printf
;;;680    			__set_FAULTMASK(1);
000844  2001              MOVS     r0,#1
000846  f3808813          MSR      FAULTMASK,r0
00084a  bf00              NOP      
;;;681    			NVIC_SystemReset();/* Software reset */
00084c  bf00              NOP      
00084e  bf00              NOP      
000850  bf00              NOP      
000852  bf00              NOP      
000854  bf00              NOP      
000856  f3bf8f4f          DSB      
00085a  bf00              NOP      
00085c  bf00              NOP      
00085e  bf00              NOP      
000860  4891              LDR      r0,|L8.2728|
000862  6800              LDR      r0,[r0,#0]
000864  f40060e0          AND      r0,r0,#0x700
000868  4990              LDR      r1,|L8.2732|
00086a  4308              ORRS     r0,r0,r1
00086c  1d00              ADDS     r0,r0,#4
00086e  498e              LDR      r1,|L8.2728|
000870  6008              STR      r0,[r1,#0]
000872  bf00              NOP      
000874  bf00              NOP      
000876  bf00              NOP      
000878  f3bf8f4f          DSB      
00087c  bf00              NOP      
00087e  bf00              NOP      
000880  bf00              NOP      
000882  bf00              NOP      
                  |L8.2180|
000884  bf00              NOP      
000886  e7fd              B        |L8.2180|
                  |L8.2184|
;;;682    			break;
;;;683    		}
;;;684    		case BT_STATE_RUN_APP:{//运行应用程序
;;;685    			HAL_FLASH_Lock();//锁定FLASH
000888  f7fffffe          BL       HAL_FLASH_Lock
;;;686    			/* Check Vector Table: Test if user code is programmed starting from* address "APPLICATION_ADDRESS" */
;;;687    			if((((*(__IO uint32_t *) APPLICATION_FLASH_START_ADDRESS) & 0xFF000000) == 0x20000000) || (((*(__IO uint32_t *) APPLICATION_FLASH_START_ADDRESS) & 0xFF000000) == 0x10000000)){
00088c  4888              LDR      r0,|L8.2736|
00088e  6800              LDR      r0,[r0,#0]
000890  f000407f          AND      r0,r0,#0xff000000
000894  f1b05f00          CMP      r0,#0x20000000
000898  d006              BEQ      |L8.2216|
00089a  4885              LDR      r0,|L8.2736|
00089c  6800              LDR      r0,[r0,#0]
00089e  f000407f          AND      r0,r0,#0xff000000
0008a2  f1b05f80          CMP      r0,#0x10000000
0008a6  d14d              BNE      |L8.2372|
                  |L8.2216|
;;;688    				/* Jump to user application */
;;;689    				printf("Bootloader:Jump application address.\n");
0008a8  a082              ADR      r0,|L8.2740|
0008aa  f7fffffe          BL       __2printf
;;;690    				JumpAddress = *(__IO uint32_t *) (APPLICATION_FLASH_START_ADDRESS + 4);
0008ae  4880              LDR      r0,|L8.2736|
0008b0  6840              LDR      r0,[r0,#4]
0008b2  498a              LDR      r1,|L8.2780|
0008b4  6008              STR      r0,[r1,#0]  ; JumpAddress
;;;691    				printf("Bootloader:Jump Address:0x%X\n", JumpAddress);
0008b6  4608              MOV      r0,r1
0008b8  6801              LDR      r1,[r0,#0]  ; JumpAddress
0008ba  a089              ADR      r0,|L8.2784|
0008bc  f7fffffe          BL       __2printf
;;;692    				Jump_To_Application = (pFunction) JumpAddress;
0008c0  4886              LDR      r0,|L8.2780|
0008c2  6800              LDR      r0,[r0,#0]  ; JumpAddress
0008c4  498e              LDR      r1,|L8.2816|
0008c6  6008              STR      r0,[r1,#0]  ; Jump_To_Application
;;;693    				/* Initialize user application's Stack Pointer */
;;;694    				__set_MSP(*(__IO uint32_t *) APPLICATION_FLASH_START_ADDRESS);
0008c8  4979              LDR      r1,|L8.2736|
0008ca  6808              LDR      r0,[r1,#0]
0008cc  f3808808          MSR      MSP,r0
0008d0  bf00              NOP      
;;;695    				printf("Bootloader:Stack Pointer:0x%X\n", *(__IO uint32_t *) APPLICATION_FLASH_START_ADDRESS);
0008d2  4608              MOV      r0,r1
0008d4  6801              LDR      r1,[r0,#0]
0008d6  a08b              ADR      r0,|L8.2820|
0008d8  f7fffffe          BL       __2printf
;;;696    				printf("\n\n\n\r\r\r");
0008dc  a091              ADR      r0,|L8.2852|
0008de  f7fffffe          BL       __2printf
;;;697    				
;;;698    				SET_GREEN(GPIO_PIN_RESET);
0008e2  2200              MOVS     r2,#0
0008e4  2120              MOVS     r1,#0x20
0008e6  4891              LDR      r0,|L8.2860|
0008e8  f7fffffe          BL       HAL_GPIO_WritePin
;;;699    				SET_BLUE(GPIO_PIN_RESET);
0008ec  2200              MOVS     r2,#0
0008ee  2180              MOVS     r1,#0x80
0008f0  488e              LDR      r0,|L8.2860|
0008f2  f7fffffe          BL       HAL_GPIO_WritePin
;;;700    				SET_RED(GPIO_PIN_RESET);
0008f6  e000              B        |L8.2298|
                  |L8.2296|
0008f8  e028              B        |L8.2380|
                  |L8.2298|
0008fa  2200              MOVS     r2,#0
0008fc  2140              MOVS     r1,#0x40
0008fe  488b              LDR      r0,|L8.2860|
000900  f7fffffe          BL       HAL_GPIO_WritePin
;;;701    				__disable_irq();
000904  b672              CPSID    i
;;;702    				SysTick->CTRL = 0;//关键代码
000906  2000              MOVS     r0,#0
000908  f04f21e0          MOV      r1,#0xe000e000
00090c  6108              STR      r0,[r1,#0x10]
;;;703    				//关闭中断                                    				
;;;704    				HAL_NVIC_DisableIRQ(SysTick_IRQn); 
00090e  1e40              SUBS     r0,r0,#1
000910  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;705    				HAL_NVIC_DisableIRQ(OTG_FS_IRQn);
000914  2043              MOVS     r0,#0x43
000916  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;706    				HAL_NVIC_DisableIRQ(TIM6_DAC_IRQn);
00091a  2036              MOVS     r0,#0x36
00091c  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;707    				HAL_NVIC_ClearPendingIRQ(SysTick_IRQn);
000920  f04f30ff          MOV      r0,#0xffffffff
000924  f7fffffe          BL       HAL_NVIC_ClearPendingIRQ
;;;708    				HAL_NVIC_ClearPendingIRQ(OTG_FS_IRQn);
000928  2043              MOVS     r0,#0x43
00092a  f7fffffe          BL       HAL_NVIC_ClearPendingIRQ
;;;709    				HAL_NVIC_ClearPendingIRQ(TIM6_DAC_IRQn);
00092e  2036              MOVS     r0,#0x36
000930  f7fffffe          BL       HAL_NVIC_ClearPendingIRQ
;;;710    				//取消外设配置
;;;711    				//HAL_DeInit();
;;;712    				//HAL_I2C_MspDeInit(&hi2c1);
;;;713    				//HAL_UART_MspDeInit(&huart1);
;;;714    				//HAL_UART_MspDeInit(&huart5);
;;;715    				//USBH_DeInit(&hUsbHostFS);
;;;716    				//SystemClock_Reset();//复位RCC时钟
;;;717    				//UsbGpioReset();
;;;718    				SET_RUN_LED(GPIO_PIN_RESET);
000934  2200              MOVS     r2,#0
000936  2101              MOVS     r1,#1
000938  487c              LDR      r0,|L8.2860|
00093a  f7fffffe          BL       HAL_GPIO_WritePin
;;;719    				Jump_To_Application();
00093e  4870              LDR      r0,|L8.2816|
000940  6800              LDR      r0,[r0,#0]  ; Jump_To_Application
000942  4780              BLX      r0
                  |L8.2372|
;;;720    			}
;;;721    			bootLoadFailHandler(BT_FAIL_VECTOR_TABLE_INVALID);
000944  2046              MOVS     r0,#0x46
000946  f7fffffe          BL       bootLoadFailHandler
;;;722    		}
;;;723    		default:break;
00094a  bf00              NOP      
                  |L8.2380|
00094c  bf00              NOP      
                  |L8.2382|
00094e  bf00              NOP                            ;473
;;;724    	}
;;;725    }
000950  b011              ADD      sp,sp,#0x44
000952  bdf0              POP      {r4-r7,pc}
;;;726    static void beepDiag(uint8_t diag){//蜂鸣器诊断声音 摩尔斯电码
                          ENDP

                  |L8.2388|
000954  426f6f74          DCB      "Bootloader:Start clear flash and eprom!\n",0
000958  6c6f6164
00095c  65723a53
000960  74617274
000964  20636c65
000968  61722066
00096c  6c617368
000970  20616e64
000974  20657072
000978  6f6d210a
00097c  00      
00097d  00                DCB      0
00097e  00                DCB      0
00097f  00                DCB      0
                  |L8.2432|
                          DCD      bootLoadState
                  |L8.2436|
                          DCD      CfgFile
                  |L8.2440|
                          DCD      firmwareInfo
                  |L8.2444|
00098c  426f6f74          DCB      "Bootloader:Check mcu app crc same,skip!\n",0
000990  6c6f6164
000994  65723a43
000998  6865636b
00099c  206d6375
0009a0  20617070
0009a4  20637263
0009a8  2073616d
0009ac  652c736b
0009b0  6970210a
0009b4  00      
0009b5  00                DCB      0
0009b6  00                DCB      0
0009b7  00                DCB      0
                  |L8.2488|
0009b8  426f6f74          DCB      "Bootloader:Checksum mcu app sucess.\n",0
0009bc  6c6f6164
0009c0  65723a43
0009c4  6865636b
0009c8  73756d20
0009cc  6d637520
0009d0  61707020
0009d4  73756365
0009d8  73732e0a
0009dc  00      
0009dd  00                DCB      0
0009de  00                DCB      0
0009df  00                DCB      0
                  |L8.2528|
0009e0  426f6f74          DCB      "Bootloader:Update new crc32 sucess.\n",0
0009e4  6c6f6164
0009e8  65723a55
0009ec  70646174
0009f0  65206e65
0009f4  77206372
0009f8  63333220
0009fc  73756365
000a00  73732e0a
000a04  00      
000a05  00                DCB      0
000a06  00                DCB      0
000a07  00                DCB      0
                  |L8.2568|
000a08  426f6f74          DCB      "Bootloader:Check lcd app crc same,skip!\n",0
000a0c  6c6f6164
000a10  65723a43
000a14  6865636b
000a18  206c6364
000a1c  20617070
000a20  20637263
000a24  2073616d
000a28  652c736b
000a2c  6970210a
000a30  00      
000a31  00                DCB      0
000a32  00                DCB      0
000a33  00                DCB      0
                  |L8.2612|
000a34  426f6f74          DCB      "Bootloader:Check mcu app sucess.\n",0
000a38  6c6f6164
000a3c  65723a43
000a40  6865636b
000a44  206d6375
000a48  20617070
000a4c  20737563
000a50  6573732e
000a54  0a00    
000a56  00                DCB      0
000a57  00                DCB      0
                  |L8.2648|
000a58  426f6f74          DCB      "Bootloader:Update mcu app new crc32 sucess.\n",0
000a5c  6c6f6164
000a60  65723a55
000a64  70646174
000a68  65206d63
000a6c  75206170
000a70  70206e65
000a74  77206372
000a78  63333220
000a7c  73756365
000a80  73732e0a
000a84  00      
000a85  00                DCB      0
000a86  00                DCB      0
000a87  00                DCB      0
                  |L8.2696|
                          DCD      ||.conststring||+0x90
                  |L8.2700|
000a8c  426f6f74          DCB      "Bootloader:System Reset\n",0
000a90  6c6f6164
000a94  65723a53
000a98  79737465
000a9c  6d205265
000aa0  7365740a
000aa4  00      
000aa5  00                DCB      0
000aa6  00                DCB      0
000aa7  00                DCB      0
                  |L8.2728|
                          DCD      0xe000ed0c
                  |L8.2732|
                          DCD      0x05fa0000
                  |L8.2736|
                          DCD      0x08010000
                  |L8.2740|
000ab4  426f6f74          DCB      "Bootloader:Jump application address.\n",0
000ab8  6c6f6164
000abc  65723a4a
000ac0  756d7020
000ac4  6170706c
000ac8  69636174
000acc  696f6e20
000ad0  61646472
000ad4  6573732e
000ad8  0a00    
000ada  00                DCB      0
000adb  00                DCB      0
                  |L8.2780|
                          DCD      JumpAddress
                  |L8.2784|
000ae0  426f6f74          DCB      "Bootloader:Jump Address:0x%X\n",0
000ae4  6c6f6164
000ae8  65723a4a
000aec  756d7020
000af0  41646472
000af4  6573733a
000af8  30782558
000afc  0a00    
000afe  00                DCB      0
000aff  00                DCB      0
                  |L8.2816|
                          DCD      Jump_To_Application
                  |L8.2820|
000b04  426f6f74          DCB      "Bootloader:Stack Pointer:0x%X\n",0
000b08  6c6f6164
000b0c  65723a53
000b10  7461636b
000b14  20506f69
000b18  6e746572
000b1c  3a307825
000b20  580a00  
000b23  00                DCB      0
                  |L8.2852|
000b24  0a0a0a0d          DCB      "\n\n\n\r\r\r",0
000b28  0d0d00  
000b2b  00                DCB      0
                  |L8.2860|
                          DCD      0x40020400

                          AREA ||i.checkBlank||, CODE, READONLY, ALIGN=1

                  checkBlank PROC
;;;1481   //MCU FLASH处理
;;;1482   static void checkBlank(uint32_t adr, uint32_t size){//MCU Flash 查空
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1483   	uint8_t val;
;;;1484   	uint32_t i;
;;;1485   	for(i = 0;i < size;i ++){
000008  2400              MOVS     r4,#0
00000a  e006              B        |L9.26|
                  |L9.12|
;;;1486   		val = *(__IO uint8_t*)(adr + i);
00000c  5d2f              LDRB     r7,[r5,r4]
;;;1487   		if(val != 0xFF){
00000e  2fff              CMP      r7,#0xff
000010  d002              BEQ      |L9.24|
;;;1488   			bootLoadFailHandler(BT_FAIL_CHECK_BLANK);
000012  2047              MOVS     r0,#0x47
000014  f7fffffe          BL       bootLoadFailHandler
                  |L9.24|
000018  1c64              ADDS     r4,r4,#1              ;1485
                  |L9.26|
00001a  42b4              CMP      r4,r6                 ;1485
00001c  d3f6              BCC      |L9.12|
;;;1489   		}
;;;1490   	}
;;;1491   }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;1492   /*****************************************************************************/
                          ENDP


                          AREA ||i.clearEprom||, CODE, READONLY, ALIGN=2

                  clearEprom PROC
;;;1613   }
;;;1614   static void clearEprom(clarmEpromCmd_t cmd){//清除EPROM内容
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1615   	uint8_t var = 0;
000004  2600              MOVS     r6,#0
;;;1616   	uint32_t i;	
;;;1617   	switch(cmd){
000006  2d01              CMP      r5,#1
000008  d006              BEQ      |L10.24|
00000a  2d04              CMP      r5,#4
00000c  d012              BEQ      |L10.52|
00000e  2d05              CMP      r5,#5
000010  d01f              BEQ      |L10.82|
000012  2d06              CMP      r5,#6
000014  d13b              BNE      |L10.142|
000016  e02b              B        |L10.112|
                  |L10.24|
;;;1618   		case CLEAR_EPROM_ALL:{
;;;1619   			for(i = 0;i < CONFIG_EPROM_SIZE;i ++){
000018  2400              MOVS     r4,#0
00001a  e004              B        |L10.38|
                  |L10.28|
;;;1620   				epromWriteByte(i, var);
00001c  b2a0              UXTH     r0,r4
00001e  4631              MOV      r1,r6
000020  f7fffffe          BL       epromWriteByte
000024  1c64              ADDS     r4,r4,#1              ;1619
                  |L10.38|
000026  f5b44f00          CMP      r4,#0x8000            ;1619
00002a  d3f7              BCC      |L10.28|
;;;1621   			}
;;;1622   			printf("Bootloader->:Erase all eprom sucess!\n");
00002c  a019              ADR      r0,|L10.148|
00002e  f7fffffe          BL       __2printf
;;;1623   			break;
000032  e02d              B        |L10.144|
                  |L10.52|
;;;1624   		}
;;;1625   		case CLEAR_EPROM_FIRMWARE_INFO:{
;;;1626   			for(i = CONFIG_EPROM_FWINFO_START;i <= CONFIG_EPROM_FWINFO_END;i ++){
000034  f44f54e8          MOV      r4,#0x1d00
000038  e004              B        |L10.68|
                  |L10.58|
;;;1627   				epromWriteByte(i, var);
00003a  b2a0              UXTH     r0,r4
00003c  4631              MOV      r1,r6
00003e  f7fffffe          BL       epromWriteByte
000042  1c64              ADDS     r4,r4,#1              ;1626
                  |L10.68|
000044  f5b45fec          CMP      r4,#0x1d80            ;1626
000048  d3f7              BCC      |L10.58|
;;;1628   			}
;;;1629   			printf("Bootloader->:Erase eprom firmware info sucess!\n");
00004a  a01c              ADR      r0,|L10.188|
00004c  f7fffffe          BL       __2printf
;;;1630   			break;
000050  e01e              B        |L10.144|
                  |L10.82|
;;;1631   		}
;;;1632   		case CLEAR_EPROM_DEVICE_CONFIG:{
;;;1633   			for(i = CONFIG_EPROM_CONFIG_START;i <= CONFIG_EPROM_CONFIG_END;i ++){
000052  f44f54ec          MOV      r4,#0x1d80
000056  e004              B        |L10.98|
                  |L10.88|
;;;1634   				epromWriteByte(i, var);
000058  b2a0              UXTH     r0,r4
00005a  4631              MOV      r1,r6
00005c  f7fffffe          BL       epromWriteByte
000060  1c64              ADDS     r4,r4,#1              ;1633
                  |L10.98|
000062  f5b45ffc          CMP      r4,#0x1f80            ;1633
000066  d3f7              BCC      |L10.88|
;;;1635   			}
;;;1636   			printf("Bootloader->:Erase eprom device info sucess!\n");
000068  a020              ADR      r0,|L10.236|
00006a  f7fffffe          BL       __2printf
;;;1637   			break;
00006e  e00f              B        |L10.144|
                  |L10.112|
;;;1638   		}
;;;1639   		case CLEAR_EPROM_LOG_INFO:{
;;;1640   			for(i = CONFIG_EPROM_LOGINFO_START;i <= CONFIG_EPROM_LOGINFO_END;i ++){
000070  f44f54fc          MOV      r4,#0x1f80
000074  e004              B        |L10.128|
                  |L10.118|
;;;1641   				epromWriteByte(i, var);
000076  b2a0              UXTH     r0,r4
000078  4631              MOV      r1,r6
00007a  f7fffffe          BL       epromWriteByte
00007e  1c64              ADDS     r4,r4,#1              ;1640
                  |L10.128|
000080  f5b45f00          CMP      r4,#0x2000            ;1640
000084  d3f7              BCC      |L10.118|
;;;1642   			}
;;;1643   			printf("Bootloader->:Erase eprom log info sucess!\n");
000086  a025              ADR      r0,|L10.284|
000088  f7fffffe          BL       __2printf
;;;1644   			break;
00008c  e000              B        |L10.144|
                  |L10.142|
;;;1645   		}
;;;1646   		default:break;
00008e  bf00              NOP      
                  |L10.144|
000090  bf00              NOP                            ;1623
;;;1647   	}
;;;1648   }
000092  bd70              POP      {r4-r6,pc}
;;;1649   
                          ENDP

                  |L10.148|
000094  426f6f74          DCB      "Bootloader->:Erase all eprom sucess!\n",0
000098  6c6f6164
00009c  65722d3e
0000a0  3a457261
0000a4  73652061
0000a8  6c6c2065
0000ac  70726f6d
0000b0  20737563
0000b4  65737321
0000b8  0a00    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L10.188|
0000bc  426f6f74          DCB      "Bootloader->:Erase eprom firmware info sucess!\n",0
0000c0  6c6f6164
0000c4  65722d3e
0000c8  3a457261
0000cc  73652065
0000d0  70726f6d
0000d4  20666972
0000d8  6d776172
0000dc  6520696e
0000e0  666f2073
0000e4  75636573
0000e8  73210a00
                  |L10.236|
0000ec  426f6f74          DCB      "Bootloader->:Erase eprom device info sucess!\n",0
0000f0  6c6f6164
0000f4  65722d3e
0000f8  3a457261
0000fc  73652065
000100  70726f6d
000104  20646576
000108  69636520
00010c  696e666f
000110  20737563
000114  65737321
000118  0a00    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L10.284|
00011c  426f6f74          DCB      "Bootloader->:Erase eprom log info sucess!\n",0
000120  6c6f6164
000124  65722d3e
000128  3a457261
00012c  73652065
000130  70726f6d
000134  206c6f67
000138  20696e66
00013c  6f207375
000140  63657373
000144  210a00  
000147  00                DCB      0

                          AREA ||i.clearFlash||, CODE, READONLY, ALIGN=2

                  clearFlash PROC
;;;1090   }
;;;1091   static void clearFlash(void){//清除MCU FLASH
000000  b510              PUSH     {r4,lr}
;;;1092   	HAL_FLASH_Unlock();
000002  f7fffffe          BL       HAL_FLASH_Unlock
;;;1093   	__HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_BSY|FLASH_FLAG_EOP|FLASH_FLAG_PGSERR|FLASH_FLAG_WRPERR);
000006  4807              LDR      r0,|L11.36|
000008  4907              LDR      r1,|L11.40|
00000a  6008              STR      r0,[r1,#0]
;;;1094   	if (FLASH_If_EraseApplication() != 0x00){//擦除APP FLASH区域失败
00000c  f7fffffe          BL       FLASH_If_EraseApplication
000010  b110              CBZ      r0,|L11.24|
;;;1095   		bootLoadFailHandler(BT_FAIL_ERASE_MCU_APP);
000012  2035              MOVS     r0,#0x35
000014  f7fffffe          BL       bootLoadFailHandler
                  |L11.24|
;;;1096   	}
;;;1097   	checkBlank(APPLICATION_FLASH_START_ADDRESS, APPLICATION_FLASH_SIZE);//FLASH 查空
000018  f44f11b8          MOV      r1,#0x170000
00001c  4803              LDR      r0,|L11.44|
00001e  f7fffffe          BL       checkBlank
;;;1098   }
000022  bd10              POP      {r4,pc}
;;;1099   static uint32_t getNewMcuAppCrc(void){//获取待更新MCU APP CRC32
                          ENDP

                  |L11.36|
                          DCD      0x00010091
                  |L11.40|
                          DCD      0x40023c0c
                  |L11.44|
                          DCD      0x08010000

                          AREA ||i.crc32Calculate||, CODE, READONLY, ALIGN=2

                  crc32Calculate PROC
;;;293    //CRC32计算程序
;;;294    static uint32_t crc32Calculate(uint8_t *buf, uint32_t len){//CRC32 计算数组
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;295        uint32_t i;  
;;;296        for (i = 0; i < len; i++){  
000006  2100              MOVS     r1,#0
000008  e00e              B        |L12.40|
                  |L12.10|
;;;297           oldcrc32 = crc32Tab[(oldcrc32 ^ buf[i]) & 0xff] ^ (oldcrc32 >> 8);  
00000a  5c50              LDRB     r0,[r2,r1]
00000c  4c09              LDR      r4,|L12.52|
00000e  7824              LDRB     r4,[r4,#0]  ; oldcrc32
000010  4060              EORS     r0,r0,r4
000012  b2c0              UXTB     r0,r0
000014  4c08              LDR      r4,|L12.56|
000016  f8540020          LDR      r0,[r4,r0,LSL #2]
00001a  4c06              LDR      r4,|L12.52|
00001c  6824              LDR      r4,[r4,#0]  ; oldcrc32
00001e  ea802014          EOR      r0,r0,r4,LSR #8
000022  4c04              LDR      r4,|L12.52|
000024  6020              STR      r0,[r4,#0]  ; oldcrc32
000026  1c49              ADDS     r1,r1,#1              ;296
                  |L12.40|
000028  4299              CMP      r1,r3                 ;296
00002a  d3ee              BCC      |L12.10|
;;;298        }  
;;;299    	return (oldcrc32 ^ 0xFFFFFFFF);  
00002c  4801              LDR      r0,|L12.52|
00002e  6800              LDR      r0,[r0,#0]  ; oldcrc32
000030  43c0              MVNS     r0,r0
;;;300    }
000032  bd10              POP      {r4,pc}
;;;301    static uint32_t crc32CalculateAdd(uint8_t dat){//CRC32计算连续字节
                          ENDP

                  |L12.52|
                          DCD      oldcrc32
                  |L12.56|
                          DCD      crc32Tab

                          AREA ||i.crc32CalculateAdd||, CODE, READONLY, ALIGN=2

                  crc32CalculateAdd PROC
;;;300    }
;;;301    static uint32_t crc32CalculateAdd(uint8_t dat){//CRC32计算连续字节
000000  4601              MOV      r1,r0
;;;302    	oldcrc32 = crc32Tab[(oldcrc32 ^ dat) & 0xff] ^ (oldcrc32 >> 8);
000002  4808              LDR      r0,|L13.36|
000004  7800              LDRB     r0,[r0,#0]  ; oldcrc32
000006  4048              EORS     r0,r0,r1
000008  b2c0              UXTB     r0,r0
00000a  4a07              LDR      r2,|L13.40|
00000c  f8520020          LDR      r0,[r2,r0,LSL #2]
000010  4a04              LDR      r2,|L13.36|
000012  6812              LDR      r2,[r2,#0]  ; oldcrc32
000014  ea802012          EOR      r0,r0,r2,LSR #8
000018  4a02              LDR      r2,|L13.36|
00001a  6010              STR      r0,[r2,#0]  ; oldcrc32
;;;303    	return (oldcrc32 ^ 0xFFFFFFFF);
00001c  4610              MOV      r0,r2
00001e  6800              LDR      r0,[r0,#0]  ; oldcrc32
000020  43c0              MVNS     r0,r0
;;;304    }
000022  4770              BX       lr
;;;305    static void crc32Clear(void){//CRC32清楚计算值
                          ENDP

                  |L13.36|
                          DCD      oldcrc32
                  |L13.40|
                          DCD      crc32Tab

                          AREA ||i.crc32Clear||, CODE, READONLY, ALIGN=2

                  crc32Clear PROC
;;;304    }
;;;305    static void crc32Clear(void){//CRC32清楚计算值
000000  f04f30ff          MOV      r0,#0xffffffff
;;;306    	oldcrc32 = 0xFFFFFFFF;
000004  4901              LDR      r1,|L14.12|
000006  6008              STR      r0,[r1,#0]  ; oldcrc32
;;;307    }
000008  4770              BX       lr
;;;308    static void crc32SetCrcOld(uint32_t old){//CRC32设置计算值
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      oldcrc32

                          AREA ||i.crc32SetCrcOld||, CODE, READONLY, ALIGN=2

                  crc32SetCrcOld PROC
;;;307    }
;;;308    static void crc32SetCrcOld(uint32_t old){//CRC32设置计算值
000000  4901              LDR      r1,|L15.8|
;;;309    	oldcrc32 = old;
000002  6008              STR      r0,[r1,#0]  ; oldcrc32
;;;310    }
000004  4770              BX       lr
;;;311    static void softDelayMs(uint16_t ms){
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      oldcrc32

                          AREA ||i.dp_display_array||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dp_display_array PROC
;;;1460   }
;;;1461   static void dp_display_array(uint8_t *value, int bytes, int descriptive){
000000  b5fe              PUSH     {r1-r7,lr}
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;1462       /* User Specific Code */
;;;1463       uint8_t print_buf[10];
;;;1464       int i;
;;;1465       for(i=0; i < bytes; i++){
000008  2400              MOVS     r4,#0
00000a  e01f              B        |L16.76|
                  |L16.12|
;;;1466           if (descriptive == GDDC_HEX){
00000c  b946              CBNZ     r6,|L16.32|
;;;1467               sprintf((char *)print_buf, "%lX", (uint8_t)value[i]);
00000e  5d2a              LDRB     r2,[r5,r4]
000010  a110              ADR      r1,|L16.84|
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       __2sprintf
;;;1468               DBGU_Printk(print_buf);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       DBGU_Printk
00001e  e014              B        |L16.74|
                  |L16.32|
;;;1469           }
;;;1470           else if(descriptive == GDDC_DEC){
000020  2e01              CMP      r6,#1
000022  d108              BNE      |L16.54|
;;;1471               sprintf((char *)print_buf, "%ld", (uint8_t)value[i]);
000024  5d2a              LDRB     r2,[r5,r4]
000026  a10c              ADR      r1,|L16.88|
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       __2sprintf
;;;1472               DBGU_Printk(print_buf);
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       DBGU_Printk
000034  e009              B        |L16.74|
                  |L16.54|
;;;1473           }
;;;1474           else if(descriptive == GDDC_CHR){
000036  2e02              CMP      r6,#2
000038  d107              BNE      |L16.74|
;;;1475               sprintf((char *)print_buf, "%c", (uint8_t)value[i]);
00003a  5d2a              LDRB     r2,[r5,r4]
00003c  a107              ADR      r1,|L16.92|
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       __2sprintf
;;;1476               DBGU_Printk(print_buf);
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       DBGU_Printk
                  |L16.74|
00004a  1c64              ADDS     r4,r4,#1              ;1465
                  |L16.76|
00004c  42bc              CMP      r4,r7                 ;1465
00004e  dbdd              BLT      |L16.12|
;;;1477           }
;;;1478       }
;;;1479   }
000050  bdfe              POP      {r1-r7,pc}
;;;1480   /*****************************************************************************/
                          ENDP

000052  0000              DCW      0x0000
                  |L16.84|
000054  256c5800          DCB      "%lX",0
                  |L16.88|
000058  256c6400          DCB      "%ld",0
                  |L16.92|
00005c  256300            DCB      "%c",0
00005f  00                DCB      0

                          AREA ||i.dp_display_text||, CODE, READONLY, ALIGN=1

                  dp_display_text PROC
;;;1436   }
;;;1437   static void dp_display_text(uint8_t *text){
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1438       /* User Specific Code   */
;;;1439       DBGU_Printk(text);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       DBGU_Printk
;;;1440   }
00000a  bd10              POP      {r4,pc}
;;;1441   static void dp_display_text_num(uint8_t *text,uint16_t datanum){
                          ENDP


                          AREA ||i.dp_display_text_num||, CODE, READONLY, ALIGN=1

                  dp_display_text_num PROC
;;;1440   }
;;;1441   static void dp_display_text_num(uint8_t *text,uint16_t datanum){
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1442       /* User Specific Code   */
;;;1443       DBGU_Printk_num(text, datanum);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       DBGU_Printk_num
;;;1444   }
00000e  bd70              POP      {r4-r6,pc}
;;;1445   static void dp_display_value(uint32_t value, int descriptive){
                          ENDP


                          AREA ||i.dp_display_value||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dp_display_value PROC
;;;1444   }
;;;1445   static void dp_display_value(uint32_t value, int descriptive){
000000  b53e              PUSH     {r1-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1446       /* User Specific Code   */
;;;1447       uint8_t print_buf[10];
;;;1448       if (descriptive == GDDC_HEX){
000006  b944              CBNZ     r4,|L19.26|
;;;1449           sprintf((char *)print_buf, "%lX", value);
000008  462a              MOV      r2,r5
00000a  a10f              ADR      r1,|L19.72|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __2sprintf
;;;1450           DBGU_Printk(print_buf);
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       DBGU_Printk
000018  e014              B        |L19.68|
                  |L19.26|
;;;1451       }
;;;1452       else if(descriptive == GDDC_DEC){
00001a  2c01              CMP      r4,#1
00001c  d108              BNE      |L19.48|
;;;1453           sprintf((char *)print_buf, "%ld", value);
00001e  462a              MOV      r2,r5
000020  a10a              ADR      r1,|L19.76|
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       __2sprintf
;;;1454           DBGU_Printk(print_buf);
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       DBGU_Printk
00002e  e009              B        |L19.68|
                  |L19.48|
;;;1455       }
;;;1456       else if(descriptive == GDDC_CHR){
000030  2c02              CMP      r4,#2
000032  d107              BNE      |L19.68|
;;;1457           sprintf((char *)print_buf, "%c", (uint8_t)value);
000034  b2ea              UXTB     r2,r5
000036  a106              ADR      r1,|L19.80|
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       __2sprintf
;;;1458           DBGU_Printk(print_buf);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       DBGU_Printk
                  |L19.68|
;;;1459       }
;;;1460   }
000044  bd3e              POP      {r1-r5,pc}
;;;1461   static void dp_display_array(uint8_t *value, int bytes, int descriptive){
                          ENDP

000046  0000              DCW      0x0000
                  |L19.72|
000048  256c5800          DCB      "%lX",0
                  |L19.76|
00004c  256c6400          DCB      "%ld",0
                  |L19.80|
000050  256300            DCB      "%c",0
000053  00                DCB      0

                          AREA ||i.dumpEprom||, CODE, READONLY, ALIGN=2

                  dumpEprom PROC
;;;1397   }
;;;1398   static void dumpEprom(void){//下载EPROM信息到U盘
000000  b508              PUSH     {r3,lr}
;;;1399   	uint32_t wrByte;
;;;1400   	epromRead(0x0, RAM_Buf, CONFIG_EPROM_SIZE);
000002  f44f4200          MOV      r2,#0x8000
000006  4912              LDR      r1,|L20.80|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       epromRead
;;;1401   	retUsbH = f_open(&SepromFile, LOAD_EPROM_FILENAME, FA_CREATE_ALWAYS | FA_WRITE);
00000e  220a              MOVS     r2,#0xa
000010  a110              ADR      r1,|L20.84|
000012  4813              LDR      r0,|L20.96|
000014  f7fffffe          BL       f_open
000018  4912              LDR      r1,|L20.100|
00001a  7008              STRB     r0,[r1,#0]
;;;1402   	if(retUsbH != FR_OK){//打开失败
00001c  4608              MOV      r0,r1
00001e  7800              LDRB     r0,[r0,#0]  ; retUsbH
000020  b110              CBZ      r0,|L20.40|
;;;1403   		bootLoadFailHandler(BT_FAIL_WRITE_SEROM_BIN);
000022  2034              MOVS     r0,#0x34
000024  f7fffffe          BL       bootLoadFailHandler
                  |L20.40|
;;;1404   	}
;;;1405   	retUsbH = f_write(&SepromFile, RAM_Buf, CONFIG_EPROM_SIZE, &wrByte);
000028  466b              MOV      r3,sp
00002a  f44f4200          MOV      r2,#0x8000
00002e  4908              LDR      r1,|L20.80|
000030  480b              LDR      r0,|L20.96|
000032  f7fffffe          BL       f_write
000036  490b              LDR      r1,|L20.100|
000038  7008              STRB     r0,[r1,#0]
;;;1406   	if(retUsbH != FR_OK){//写入失败
00003a  4608              MOV      r0,r1
00003c  7800              LDRB     r0,[r0,#0]  ; retUsbH
00003e  b110              CBZ      r0,|L20.70|
;;;1407   		bootLoadFailHandler(BT_FAIL_WRITE_SEROM_BIN);
000040  2034              MOVS     r0,#0x34
000042  f7fffffe          BL       bootLoadFailHandler
                  |L20.70|
;;;1408   	}
;;;1409   	bootLoadFailHandler(BT_DONE_DUMP_EPROM);
000046  204a              MOVS     r0,#0x4a
000048  f7fffffe          BL       bootLoadFailHandler
;;;1410   }
00004c  bd08              POP      {r3,pc}
;;;1411   static uint32_t getOriginAppCrc(void){//计算MCU APP CRC32
                          ENDP

00004e  0000              DCW      0x0000
                  |L20.80|
                          DCD      RAM_Buf
                  |L20.84|
000054  2f6c6570          DCB      "/leprom.bin",0
000058  726f6d2e
00005c  62696e00
                  |L20.96|
                          DCD      SepromFile
                  |L20.100|
                          DCD      retUsbH

                          AREA ||i.epromRead||, CODE, READONLY, ALIGN=2

                  epromRead PROC
;;;1537   }
;;;1538   static HAL_StatusTypeDef epromRead(uint16_t ReadAddr, uint8_t *pBuffer, uint16_t NumToRead){//在的指定地址开始读出指定个数的数据
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b084              SUB      sp,sp,#0x10
000006  4607              MOV      r7,r0
000008  4614              MOV      r4,r2
;;;1539   //ReadAddr :开始读出的地址 对24c02为0~255
;;;1540   //pBuffer  :数据数组首地址
;;;1541   //NumToRead:要读出数据的个数
;;;1542   	HAL_StatusTypeDef ret;
;;;1543   	uint16_t rAddr, rBlock, rByte, doBlock;
;;;1544   	uint8_t* rBuffer;
;;;1545   	if(ReadAddr + NumToRead >= (CONFIG_EPROM_SIZE - 1)){//读地址超过限制
00000a  1938              ADDS     r0,r7,r4
00000c  f64771ff          MOV      r1,#0x7fff
000010  4288              CMP      r0,r1
000012  db04              BLT      |L21.30|
;;;1546   		ret = HAL_ERROR;
000014  2501              MOVS     r5,#1
;;;1547   		return ret;
000016  4628              MOV      r0,r5
                  |L21.24|
;;;1548   	}
;;;1549   	rBlock = NumToRead / CONFIG_EPROM_PAGE_SIZE;
;;;1550   	rByte = NumToRead % CONFIG_EPROM_PAGE_SIZE;
;;;1551   	rAddr = ReadAddr;
;;;1552   	rBuffer = pBuffer;
;;;1553   	for(doBlock = 0;doBlock < rBlock;doBlock ++){
;;;1554   		ret = HAL_I2C_Mem_Read(&hi2c1, CONFIG_EPROM_READ_ADDR, rAddr, I2C_MEMADD_SIZE_16BIT, rBuffer, CONFIG_EPROM_PAGE_SIZE, CONFIG_EPROM_TIMEOUT);
;;;1555   		if(ret != HAL_OK){
;;;1556   			ret = HAL_I2C_DeInit(&hi2c1);//释放IO口为GPIO，复位句柄状态标志
;;;1557   			ret = HAL_I2C_Init(&hi2c1);//这句重新初始化I2C控制器
;;;1558   			printf("sPlc->sPlcEprom:Eprom read block fail!\n");
;;;1559   		}
;;;1560   		rAddr += CONFIG_EPROM_PAGE_SIZE;
;;;1561   		rBuffer += CONFIG_EPROM_PAGE_SIZE;
;;;1562   	}
;;;1563   	if(rByte != 0x0){
;;;1564   		ret = HAL_I2C_Mem_Read(&hi2c1, CONFIG_EPROM_READ_ADDR, rAddr, I2C_MEMADD_SIZE_16BIT, rBuffer, rByte ,CONFIG_EPROM_TIMEOUT);
;;;1565   		if(ret != HAL_OK){
;;;1566   			ret = HAL_I2C_DeInit(&hi2c1);        //释放IO口为GPIO，复位句柄状态标志
;;;1567   			ret = HAL_I2C_Init(&hi2c1);          //这句重新初始化I2C控制器
;;;1568   		}
;;;1569   		printf("sPlc->sPlcEprom:Eprom read rbyte fail\n");
;;;1570   	}
;;;1571   	return ret;	
;;;1572   }  
000018  b007              ADD      sp,sp,#0x1c
00001a  e8bd8ff0          POP      {r4-r11,pc}
                  |L21.30|
00001e  4620              MOV      r0,r4                 ;1549
000020  17e1              ASRS     r1,r4,#31             ;1549
000022  eb047151          ADD      r1,r4,r1,LSR #29      ;1549
000026  f3c10bcf          UBFX     r11,r1,#3,#16         ;1549
00002a  17e1              ASRS     r1,r4,#31             ;1550
00002c  eb047151          ADD      r1,r4,r1,LSR #29      ;1550
000030  10c9              ASRS     r1,r1,#3              ;1550
000032  eba401c1          SUB      r1,r4,r1,LSL #3       ;1550
000036  fa1ff981          UXTH     r9,r1                 ;1550
00003a  46b8              MOV      r8,r7                 ;1551
00003c  9e05              LDR      r6,[sp,#0x14]         ;1552
00003e  f04f0a00          MOV      r10,#0                ;1553
000042  e021              B        |L21.136|
                  |L21.68|
000044  f44f707a          MOV      r0,#0x3e8             ;1554
000048  2108              MOVS     r1,#8                 ;1554
00004a  2310              MOVS     r3,#0x10              ;1554
00004c  4642              MOV      r2,r8                 ;1554
00004e  e9cd6100          STRD     r6,r1,[sp,#0]         ;1554
000052  9002              STR      r0,[sp,#8]            ;1554
000054  21a1              MOVS     r1,#0xa1              ;1554
000056  481c              LDR      r0,|L21.200|
000058  f7fffffe          BL       HAL_I2C_Mem_Read
00005c  4605              MOV      r5,r0                 ;1554
00005e  b155              CBZ      r5,|L21.118|
000060  4819              LDR      r0,|L21.200|
000062  f7fffffe          BL       HAL_I2C_DeInit
000066  4605              MOV      r5,r0                 ;1556
000068  4817              LDR      r0,|L21.200|
00006a  f7fffffe          BL       HAL_I2C_Init
00006e  4605              MOV      r5,r0                 ;1557
000070  a016              ADR      r0,|L21.204|
000072  f7fffffe          BL       __2printf
                  |L21.118|
000076  f1080008          ADD      r0,r8,#8              ;1560
00007a  fa1ff880          UXTH     r8,r0                 ;1560
00007e  3608              ADDS     r6,r6,#8              ;1561
000080  f10a0001          ADD      r0,r10,#1             ;1553
000084  fa1ffa80          UXTH     r10,r0                ;1553
                  |L21.136|
000088  45da              CMP      r10,r11               ;1553
00008a  dbdb              BLT      |L21.68|
00008c  f1b90f00          CMP      r9,#0                 ;1563
000090  d017              BEQ      |L21.194|
000092  f44f707a          MOV      r0,#0x3e8             ;1564
000096  2310              MOVS     r3,#0x10              ;1564
000098  4642              MOV      r2,r8                 ;1564
00009a  21a1              MOVS     r1,#0xa1              ;1564
00009c  e9cd6900          STRD     r6,r9,[sp,#0]         ;1564
0000a0  9002              STR      r0,[sp,#8]            ;1564
0000a2  4809              LDR      r0,|L21.200|
0000a4  f7fffffe          BL       HAL_I2C_Mem_Read
0000a8  4605              MOV      r5,r0                 ;1564
0000aa  b13d              CBZ      r5,|L21.188|
0000ac  4806              LDR      r0,|L21.200|
0000ae  f7fffffe          BL       HAL_I2C_DeInit
0000b2  4605              MOV      r5,r0                 ;1566
0000b4  4804              LDR      r0,|L21.200|
0000b6  f7fffffe          BL       HAL_I2C_Init
0000ba  4605              MOV      r5,r0                 ;1567
                  |L21.188|
0000bc  a00d              ADR      r0,|L21.244|
0000be  f7fffffe          BL       __2printf
                  |L21.194|
0000c2  4628              MOV      r0,r5                 ;1571
0000c4  e7a8              B        |L21.24|
;;;1573   static HAL_StatusTypeDef epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite){//在的指定地址开始写入指定个数的数据
                          ENDP

0000c6  0000              DCW      0x0000
                  |L21.200|
                          DCD      hi2c1
                  |L21.204|
0000cc  73506c63          DCB      "sPlc->sPlcEprom:Eprom read block fail!\n",0
0000d0  2d3e7350
0000d4  6c634570
0000d8  726f6d3a
0000dc  4570726f
0000e0  6d207265
0000e4  61642062
0000e8  6c6f636b
0000ec  20666169
0000f0  6c210a00
                  |L21.244|
0000f4  73506c63          DCB      "sPlc->sPlcEprom:Eprom read rbyte fail\n",0
0000f8  2d3e7350
0000fc  6c634570
000100  726f6d3a
000104  4570726f
000108  6d207265
00010c  61642072
000110  62797465
000114  20666169
000118  6c0a00  
00011b  00                DCB      0

                          AREA ||i.epromReadByte||, CODE, READONLY, ALIGN=2

                  epromReadByte PROC
;;;1493   //EEPROM 读写程序
;;;1494   static HAL_StatusTypeDef epromReadByte(uint16_t ReadAddr, uint8_t *rdat){//在指定地址读出8位数据
000000  b5fe              PUSH     {r1-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1495   //ReadAddr:开始读数的地址  
;;;1496   //返回值  :数据				  
;;;1497   	HAL_StatusTypeDef ret;
;;;1498   	if(ReadAddr > (CONFIG_EPROM_SIZE - 1)){//写地址超过容量
000006  f5b54f00          CMP      r5,#0x8000
00000a  db02              BLT      |L22.18|
;;;1499   		ret = HAL_ERROR;
00000c  2401              MOVS     r4,#1
;;;1500   		return ret;
00000e  4620              MOV      r0,r4
                  |L22.16|
;;;1501   	}	
;;;1502   	ret = HAL_I2C_Mem_Read(&hi2c1,
;;;1503   	                       CONFIG_EPROM_READ_ADDR,
;;;1504   	                       ReadAddr,
;;;1505   	                       I2C_MEMADD_SIZE_16BIT,
;;;1506   	                       (uint8_t*)(rdat),
;;;1507   	                       1,
;;;1508   	                       CONFIG_EPROM_TIMEOUT);
;;;1509   	if(ret != HAL_OK){
;;;1510   		ret = HAL_I2C_DeInit(&hi2c1);//释放IO口为GPIO，复位句柄状态标志
;;;1511   		ret = HAL_I2C_Init(&hi2c1);//这句重新初始化I2C控制器
;;;1512   		printf("sPlc->sPlcEprom:Eprom read byte fail!\n");
;;;1513   	}
;;;1514   	return ret;
;;;1515   }
000010  bdfe              POP      {r1-r7,pc}
                  |L22.18|
000012  f44f707a          MOV      r0,#0x3e8             ;1502
000016  2101              MOVS     r1,#1                 ;1502
000018  2310              MOVS     r3,#0x10              ;1502
00001a  462a              MOV      r2,r5                 ;1502
00001c  e9cd6100          STRD     r6,r1,[sp,#0]         ;1502
000020  9002              STR      r0,[sp,#8]            ;1502
000022  21a1              MOVS     r1,#0xa1              ;1502
000024  4808              LDR      r0,|L22.72|
000026  f7fffffe          BL       HAL_I2C_Mem_Read
00002a  4604              MOV      r4,r0                 ;1502
00002c  b154              CBZ      r4,|L22.68|
00002e  4806              LDR      r0,|L22.72|
000030  f7fffffe          BL       HAL_I2C_DeInit
000034  4604              MOV      r4,r0                 ;1510
000036  4804              LDR      r0,|L22.72|
000038  f7fffffe          BL       HAL_I2C_Init
00003c  4604              MOV      r4,r0                 ;1511
00003e  a003              ADR      r0,|L22.76|
000040  f7fffffe          BL       __2printf
                  |L22.68|
000044  4620              MOV      r0,r4                 ;1514
000046  e7e3              B        |L22.16|
;;;1516   static HAL_StatusTypeDef epromWriteByte(uint16_t WriteAddr, uint8_t wdat){//在指定地址写入8位数据
                          ENDP

                  |L22.72|
                          DCD      hi2c1
                  |L22.76|
00004c  73506c63          DCB      "sPlc->sPlcEprom:Eprom read byte fail!\n",0
000050  2d3e7350
000054  6c634570
000058  726f6d3a
00005c  4570726f
000060  6d207265
000064  61642062
000068  79746520
00006c  6661696c
000070  210a00  
000073  00                DCB      0

                          AREA ||i.epromWrite||, CODE, READONLY, ALIGN=2

                  epromWrite PROC
;;;1572   }  
;;;1573   static HAL_StatusTypeDef epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite){//在的指定地址开始写入指定个数的数据
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b084              SUB      sp,sp,#0x10
000006  4607              MOV      r7,r0
000008  4614              MOV      r4,r2
;;;1574   //WriteAddr :开始写入的地址 对24c02为0~255
;;;1575   //pBuffer   :数据数组首地址
;;;1576   //NumToWrite:要写入数据的个数
;;;1577   	HAL_StatusTypeDef ret;
;;;1578   	uint16_t wAddr, wBlock, wByte, doBlock;
;;;1579   	uint8_t* wBuffer;
;;;1580   	if(WriteAddr + NumToWrite >= (CONFIG_EPROM_SIZE - 1)){//读地址超过限制
00000a  1938              ADDS     r0,r7,r4
00000c  f64771ff          MOV      r1,#0x7fff
000010  4288              CMP      r0,r1
000012  db04              BLT      |L23.30|
;;;1581   		ret = HAL_ERROR;
000014  2501              MOVS     r5,#1
;;;1582   		return ret;
000016  4628              MOV      r0,r5
                  |L23.24|
;;;1583   	}
;;;1584   	wBlock = NumToWrite / CONFIG_EPROM_PAGE_SIZE;
;;;1585   	wByte = NumToWrite % CONFIG_EPROM_PAGE_SIZE;
;;;1586   	wAddr = WriteAddr;
;;;1587   	wBuffer = pBuffer;
;;;1588   	for(doBlock = 0;doBlock < wBlock;doBlock ++){
;;;1589   		ret = HAL_I2C_Mem_Write(&hi2c1, CONFIG_EPROM_WRITE_ADDR, wAddr, I2C_MEMADD_SIZE_16BIT, wBuffer, CONFIG_EPROM_PAGE_SIZE, CONFIG_EPROM_TIMEOUT);
;;;1590   		if(ret != HAL_OK){
;;;1591   			ret = HAL_I2C_DeInit(&hi2c1);        //释放IO口为GPIO，复位句柄状态标志
;;;1592   			ret = HAL_I2C_Init(&hi2c1);          //这句重新初始化I2C控制器
;;;1593   			printf("sPlc->sPlcEprom:Eprom write block fail!\n");	
;;;1594   		}
;;;1595   		wAddr += CONFIG_EPROM_PAGE_SIZE;
;;;1596   		wBuffer += CONFIG_EPROM_PAGE_SIZE;
;;;1597   #if CONFIG_EPROM_WRITE_DELAY > 0
;;;1598   		HAL_Delay(CONFIG_EPROM_WRITE_DELAY);
;;;1599   #endif
;;;1600   	}
;;;1601   	if(wByte != 0x0){
;;;1602   		ret = HAL_I2C_Mem_Write(&hi2c1, CONFIG_EPROM_WRITE_ADDR, wAddr, I2C_MEMADD_SIZE_16BIT, wBuffer, wByte, CONFIG_EPROM_TIMEOUT);
;;;1603   		if(ret != HAL_OK){
;;;1604   			ret = HAL_I2C_DeInit(&hi2c1);        //释放IO口为GPIO，复位句柄状态标志
;;;1605   			ret = HAL_I2C_Init(&hi2c1);          //这句重新初始化I2C控制器
;;;1606   			printf("sPlc->sPlcEprom:Eprom write remain byte fail!\n");
;;;1607   		}
;;;1608   	}
;;;1609   #if CONFIG_EPROM_WRITE_DELAY > 0
;;;1610   	HAL_Delay(CONFIG_EPROM_WRITE_DELAY);
;;;1611   #endif
;;;1612   	return ret;
;;;1613   }
000018  b007              ADD      sp,sp,#0x1c
00001a  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.30|
00001e  4620              MOV      r0,r4                 ;1584
000020  17e1              ASRS     r1,r4,#31             ;1584
000022  eb047151          ADD      r1,r4,r1,LSR #29      ;1584
000026  f3c10bcf          UBFX     r11,r1,#3,#16         ;1584
00002a  17e1              ASRS     r1,r4,#31             ;1585
00002c  eb047151          ADD      r1,r4,r1,LSR #29      ;1585
000030  10c9              ASRS     r1,r1,#3              ;1585
000032  eba401c1          SUB      r1,r4,r1,LSL #3       ;1585
000036  fa1ff981          UXTH     r9,r1                 ;1585
00003a  46b8              MOV      r8,r7                 ;1586
00003c  9e05              LDR      r6,[sp,#0x14]         ;1587
00003e  f04f0a00          MOV      r10,#0                ;1588
000042  e021              B        |L23.136|
                  |L23.68|
000044  f44f707a          MOV      r0,#0x3e8             ;1589
000048  2108              MOVS     r1,#8                 ;1589
00004a  2310              MOVS     r3,#0x10              ;1589
00004c  4642              MOV      r2,r8                 ;1589
00004e  e9cd6100          STRD     r6,r1,[sp,#0]         ;1589
000052  9002              STR      r0,[sp,#8]            ;1589
000054  21a0              MOVS     r1,#0xa0              ;1589
000056  481c              LDR      r0,|L23.200|
000058  f7fffffe          BL       HAL_I2C_Mem_Write
00005c  4605              MOV      r5,r0                 ;1589
00005e  b155              CBZ      r5,|L23.118|
000060  4819              LDR      r0,|L23.200|
000062  f7fffffe          BL       HAL_I2C_DeInit
000066  4605              MOV      r5,r0                 ;1591
000068  4817              LDR      r0,|L23.200|
00006a  f7fffffe          BL       HAL_I2C_Init
00006e  4605              MOV      r5,r0                 ;1592
000070  a016              ADR      r0,|L23.204|
000072  f7fffffe          BL       __2printf
                  |L23.118|
000076  f1080008          ADD      r0,r8,#8              ;1595
00007a  fa1ff880          UXTH     r8,r0                 ;1595
00007e  3608              ADDS     r6,r6,#8              ;1596
000080  f10a0001          ADD      r0,r10,#1             ;1588
000084  fa1ffa80          UXTH     r10,r0                ;1588
                  |L23.136|
000088  45da              CMP      r10,r11               ;1588
00008a  dbdb              BLT      |L23.68|
00008c  f1b90f00          CMP      r9,#0                 ;1601
000090  d017              BEQ      |L23.194|
000092  f44f707a          MOV      r0,#0x3e8             ;1602
000096  2310              MOVS     r3,#0x10              ;1602
000098  4642              MOV      r2,r8                 ;1602
00009a  21a0              MOVS     r1,#0xa0              ;1602
00009c  e9cd6900          STRD     r6,r9,[sp,#0]         ;1602
0000a0  9002              STR      r0,[sp,#8]            ;1602
0000a2  4809              LDR      r0,|L23.200|
0000a4  f7fffffe          BL       HAL_I2C_Mem_Write
0000a8  4605              MOV      r5,r0                 ;1602
0000aa  b155              CBZ      r5,|L23.194|
0000ac  4806              LDR      r0,|L23.200|
0000ae  f7fffffe          BL       HAL_I2C_DeInit
0000b2  4605              MOV      r5,r0                 ;1604
0000b4  4804              LDR      r0,|L23.200|
0000b6  f7fffffe          BL       HAL_I2C_Init
0000ba  4605              MOV      r5,r0                 ;1605
0000bc  a00e              ADR      r0,|L23.248|
0000be  f7fffffe          BL       __2printf
                  |L23.194|
0000c2  4628              MOV      r0,r5                 ;1612
0000c4  e7a8              B        |L23.24|
;;;1614   static void clearEprom(clarmEpromCmd_t cmd){//清除EPROM内容
                          ENDP

0000c6  0000              DCW      0x0000
                  |L23.200|
                          DCD      hi2c1
                  |L23.204|
0000cc  73506c63          DCB      "sPlc->sPlcEprom:Eprom write block fail!\n",0
0000d0  2d3e7350
0000d4  6c634570
0000d8  726f6d3a
0000dc  4570726f
0000e0  6d207772
0000e4  69746520
0000e8  626c6f63
0000ec  6b206661
0000f0  696c210a
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L23.248|
0000f8  73506c63          DCB      "sPlc->sPlcEprom:Eprom write remain byte fail!\n",0
0000fc  2d3e7350
000100  6c634570
000104  726f6d3a
000108  4570726f
00010c  6d207772
000110  69746520
000114  72656d61
000118  696e2062
00011c  79746520
000120  6661696c
000124  210a00  
000127  00                DCB      0

                          AREA ||i.epromWriteByte||, CODE, READONLY, ALIGN=2

                  epromWriteByte PROC
;;;1515   }
;;;1516   static HAL_StatusTypeDef epromWriteByte(uint16_t WriteAddr, uint8_t wdat){//在指定地址写入8位数据
000000  b533              PUSH     {r0,r1,r4,r5,lr}
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
;;;1517   //WriteAddr  :写入数据的目的地址    
;;;1518   //DataToWrite:要写入的数据				   	  	    																 
;;;1519   	HAL_StatusTypeDef ret;
;;;1520   	if(WriteAddr > (CONFIG_EPROM_SIZE - 1)){//写地址超过容量
000006  f5b54f00          CMP      r5,#0x8000
00000a  db03              BLT      |L24.20|
;;;1521   		ret = HAL_ERROR;
00000c  2401              MOVS     r4,#1
;;;1522   		return ret;
00000e  4620              MOV      r0,r4
                  |L24.16|
;;;1523   	}
;;;1524   	ret = HAL_I2C_Mem_Write(&hi2c1, 
;;;1525   	                        CONFIG_EPROM_WRITE_ADDR,
;;;1526   	                        WriteAddr, 
;;;1527   	                        I2C_MEMADD_SIZE_16BIT, 
;;;1528   	                        &wdat, 
;;;1529   	                        1, 
;;;1530   	                        CONFIG_EPROM_TIMEOUT);
;;;1531   	if(ret != HAL_OK){
;;;1532   		ret = HAL_I2C_DeInit(&hi2c1);//释放IO口为GPIO，复位句柄状态标志
;;;1533   		ret = HAL_I2C_Init(&hi2c1);//这句重新初始化I2C控制器
;;;1534   		printf("sPlc->sPlcEprom:Eprom write byte fail!\n");
;;;1535   	}
;;;1536   	return ret;
;;;1537   }
000010  b005              ADD      sp,sp,#0x14
000012  bd30              POP      {r4,r5,pc}
                  |L24.20|
000014  f44f707a          MOV      r0,#0x3e8             ;1524
000018  2101              MOVS     r1,#1                 ;1524
00001a  aa04              ADD      r2,sp,#0x10           ;1524
00001c  2310              MOVS     r3,#0x10              ;1524
00001e  e9cd2100          STRD     r2,r1,[sp,#0]         ;1524
000022  9002              STR      r0,[sp,#8]            ;1524
000024  462a              MOV      r2,r5                 ;1524
000026  21a0              MOVS     r1,#0xa0              ;1524
000028  4808              LDR      r0,|L24.76|
00002a  f7fffffe          BL       HAL_I2C_Mem_Write
00002e  4604              MOV      r4,r0                 ;1524
000030  b154              CBZ      r4,|L24.72|
000032  4806              LDR      r0,|L24.76|
000034  f7fffffe          BL       HAL_I2C_DeInit
000038  4604              MOV      r4,r0                 ;1532
00003a  4804              LDR      r0,|L24.76|
00003c  f7fffffe          BL       HAL_I2C_Init
000040  4604              MOV      r4,r0                 ;1533
000042  a003              ADR      r0,|L24.80|
000044  f7fffffe          BL       __2printf
                  |L24.72|
000048  4620              MOV      r0,r4                 ;1536
00004a  e7e1              B        |L24.16|
;;;1538   static HAL_StatusTypeDef epromRead(uint16_t ReadAddr, uint8_t *pBuffer, uint16_t NumToRead){//在的指定地址开始读出指定个数的数据
                          ENDP

                  |L24.76|
                          DCD      hi2c1
                  |L24.80|
000050  73506c63          DCB      "sPlc->sPlcEprom:Eprom write byte fail!\n",0
000054  2d3e7350
000058  6c634570
00005c  726f6d3a
000060  4570726f
000064  6d207772
000068  69746520
00006c  62797465
000070  20666169
000074  6c210a00

                          AREA ||i.getNewLcdAppCrc||, CODE, READONLY, ALIGN=2

                  getNewLcdAppCrc PROC
;;;1130   }
;;;1131   static uint32_t getNewLcdAppCrc(void){//获取待更新LCD APP CRC16
000000  b538              PUSH     {r3-r5,lr}
;;;1132   	uint32_t crc32;
;;;1133   	uint8_t readflag = TRUE;
000002  2501              MOVS     r5,#1
;;;1134   	uint16_t bytesread;//实际文件读取字节数
;;;1135   	retUsbH = f_open(&LcdFile, LLCD_FIRMWARE_FILENAME, FA_OPEN_EXISTING | FA_READ);
000004  2201              MOVS     r2,#1
000006  a11c              ADR      r1,|L25.120|
000008  481e              LDR      r0,|L25.132|
00000a  f7fffffe          BL       f_open
00000e  491e              LDR      r1,|L25.136|
000010  7008              STRB     r0,[r1,#0]
;;;1136   	if(retUsbH != FR_OK){//读取失败
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; retUsbH
000016  b110              CBZ      r0,|L25.30|
;;;1137   		bootLoadFailHandler(BT_FAIL_READ_LLCD_APP);			
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       bootLoadFailHandler
                  |L25.30|
;;;1138   	}
;;;1139   	f_lseek(&LcdFile, 0);//读取指针移动到开头
00001e  2100              MOVS     r1,#0
000020  4818              LDR      r0,|L25.132|
000022  f7fffffe          BL       f_lseek
;;;1140   	crc32 = 0;
000026  2400              MOVS     r4,#0
;;;1141   	crc32Clear();
000028  f7fffffe          BL       crc32Clear
;;;1142   	while(readflag){
00002c  e01d              B        |L25.106|
                  |L25.46|
;;;1143   		/* Read maximum 512 Kbyte from the selected file */
;;;1144   		f_read(&LcdFile, RAM_Buf, BUFFER_SIZE, (void*)&bytesread);
00002e  466b              MOV      r3,sp
000030  f44f4200          MOV      r2,#0x8000
000034  4915              LDR      r1,|L25.140|
000036  4813              LDR      r0,|L25.132|
000038  f7fffffe          BL       f_read
;;;1145   		
;;;1146   		crc32 = crc32Calculate(RAM_Buf, bytesread);
00003c  f8bd1000          LDRH     r1,[sp,#0]
000040  4812              LDR      r0,|L25.140|
000042  f7fffffe          BL       crc32Calculate
000046  4604              MOV      r4,r0
;;;1147   		/* Temp variable */
;;;1148   		TmpReadSize = bytesread;
000048  f8bd0000          LDRH     r0,[sp,#0]
00004c  4910              LDR      r1,|L25.144|
00004e  6008              STR      r0,[r1,#0]  ; TmpReadSize
;;;1149   		/* The read data < "BUFFER_SIZE" Kbyte */
;;;1150   		if(TmpReadSize < BUFFER_SIZE){
000050  4608              MOV      r0,r1
000052  6800              LDR      r0,[r0,#0]  ; TmpReadSize
000054  f5b04f00          CMP      r0,#0x8000
000058  d200              BCS      |L25.92|
;;;1151   			readflag = FALSE;
00005a  2500              MOVS     r5,#0
                  |L25.92|
;;;1152   		}
;;;1153   		LastPGAddress += TmpReadSize;
00005c  480d              LDR      r0,|L25.148|
00005e  6800              LDR      r0,[r0,#0]  ; LastPGAddress
000060  490b              LDR      r1,|L25.144|
000062  6809              LDR      r1,[r1,#0]  ; TmpReadSize
000064  4408              ADD      r0,r0,r1
000066  490b              LDR      r1,|L25.148|
000068  6008              STR      r0,[r1,#0]  ; LastPGAddress
                  |L25.106|
00006a  2d00              CMP      r5,#0                 ;1142
00006c  d1df              BNE      |L25.46|
;;;1154   	}
;;;1155   	f_close(&LcdFile);
00006e  4805              LDR      r0,|L25.132|
000070  f7fffffe          BL       f_close
;;;1156   	return crc32;
000074  4620              MOV      r0,r4
;;;1157   }
000076  bd38              POP      {r3-r5,pc}
;;;1158   static uint32_t updateMcuApp(void){//更新MCU APP
                          ENDP

                  |L25.120|
000078  2f6c645f          DCB      "/ld_lcd.pkg",0
00007c  6c63642e
000080  706b6700
                  |L25.132|
                          DCD      LcdFile
                  |L25.136|
                          DCD      retUsbH
                  |L25.140|
                          DCD      RAM_Buf
                  |L25.144|
                          DCD      TmpReadSize
                  |L25.148|
                          DCD      LastPGAddress

                          AREA ||i.getNewMcuAppCrc||, CODE, READONLY, ALIGN=2

                  getNewMcuAppCrc PROC
;;;1098   }
;;;1099   static uint32_t getNewMcuAppCrc(void){//获取待更新MCU APP CRC32
000000  b5f8              PUSH     {r3-r7,lr}
;;;1100   	uint32_t crc32;
;;;1101   	uint32_t i;
;;;1102   	uint8_t readflag = TRUE;
000002  2601              MOVS     r6,#1
;;;1103   	uint16_t bytesread;//实际文件读取字节数
;;;1104   	retUsbH = f_open(&McuFile, LMCU_FIRMWARE_FILENAME, FA_OPEN_EXISTING | FA_READ);
000004  2201              MOVS     r2,#1
000006  a124              ADR      r1,|L26.152|
000008  4826              LDR      r0,|L26.164|
00000a  f7fffffe          BL       f_open
00000e  4926              LDR      r1,|L26.168|
000010  7008              STRB     r0,[r1,#0]
;;;1105   	if(retUsbH != FR_OK){//读取失败
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; retUsbH
000016  b110              CBZ      r0,|L26.30|
;;;1106   		bootLoadFailHandler(BT_FAIL_READ_LMCU_APP);			
000018  2031              MOVS     r0,#0x31
00001a  f7fffffe          BL       bootLoadFailHandler
                  |L26.30|
;;;1107   	}
;;;1108   	if(f_size(&McuFile) > APPLICATION_FLASH_SIZE){//MCU固件大于FLSAH容量
00001e  4821              LDR      r0,|L26.164|
000020  68c0              LDR      r0,[r0,#0xc]  ; McuFile
000022  f5b01fb8          CMP      r0,#0x170000
000026  d902              BLS      |L26.46|
;;;1109   		bootLoadFailHandler(BT_FAIL_LMCU_APP_CHECK);
000028  2038              MOVS     r0,#0x38
00002a  f7fffffe          BL       bootLoadFailHandler
                  |L26.46|
;;;1110   	}
;;;1111   	crc32 = 0;
00002e  2500              MOVS     r5,#0
;;;1112   	crc32Clear();
000030  f7fffffe          BL       crc32Clear
;;;1113   	while(readflag){
000034  e01d              B        |L26.114|
                  |L26.54|
;;;1114   		/* Read maximum 512 Kbyte from the selected file */
;;;1115   		f_read(&McuFile, RAM_Buf, BUFFER_SIZE, (void*)&bytesread);
000036  466b              MOV      r3,sp
000038  f44f4200          MOV      r2,#0x8000
00003c  491b              LDR      r1,|L26.172|
00003e  4819              LDR      r0,|L26.164|
000040  f7fffffe          BL       f_read
;;;1116   		crc32 = crc32Calculate(RAM_Buf, bytesread);
000044  f8bd1000          LDRH     r1,[sp,#0]
000048  4818              LDR      r0,|L26.172|
00004a  f7fffffe          BL       crc32Calculate
00004e  4605              MOV      r5,r0
;;;1117   		/* Temp variable */
;;;1118   		TmpReadSize = bytesread;
000050  f8bd0000          LDRH     r0,[sp,#0]
000054  4916              LDR      r1,|L26.176|
000056  6008              STR      r0,[r1,#0]  ; TmpReadSize
;;;1119   		/* The read data < "BUFFER_SIZE" Kbyte */
;;;1120   		if(TmpReadSize < BUFFER_SIZE){
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]  ; TmpReadSize
00005c  f5b04f00          CMP      r0,#0x8000
000060  d200              BCS      |L26.100|
;;;1121   			readflag = FALSE;
000062  2600              MOVS     r6,#0
                  |L26.100|
;;;1122   		}
;;;1123   		LastPGAddress += TmpReadSize;
000064  4813              LDR      r0,|L26.180|
000066  6800              LDR      r0,[r0,#0]  ; LastPGAddress
000068  4911              LDR      r1,|L26.176|
00006a  6809              LDR      r1,[r1,#0]  ; TmpReadSize
00006c  4408              ADD      r0,r0,r1
00006e  4911              LDR      r1,|L26.180|
000070  6008              STR      r0,[r1,#0]  ; LastPGAddress
                  |L26.114|
000072  2e00              CMP      r6,#0                 ;1113
000074  d1df              BNE      |L26.54|
;;;1124   	}
;;;1125   	for(i = LastPGAddress;i < APPLICATION_FLASH_END_ADDRESS;i ++){//补完剩余CRC
000076  480f              LDR      r0,|L26.180|
000078  6804              LDR      r4,[r0,#0]  ; LastPGAddress
00007a  e004              B        |L26.134|
                  |L26.124|
;;;1126   		crc32 = crc32CalculateAdd(0xFF);
00007c  20ff              MOVS     r0,#0xff
00007e  f7fffffe          BL       crc32CalculateAdd
000082  4605              MOV      r5,r0
000084  1c64              ADDS     r4,r4,#1              ;1125
                  |L26.134|
000086  480c              LDR      r0,|L26.184|
000088  4284              CMP      r4,r0                 ;1125
00008a  d3f7              BCC      |L26.124|
;;;1127   	}
;;;1128   	f_close(&McuFile);
00008c  4805              LDR      r0,|L26.164|
00008e  f7fffffe          BL       f_close
;;;1129   	return crc32;
000092  4628              MOV      r0,r5
;;;1130   }
000094  bdf8              POP      {r3-r7,pc}
;;;1131   static uint32_t getNewLcdAppCrc(void){//获取待更新LCD APP CRC16
                          ENDP

000096  0000              DCW      0x0000
                  |L26.152|
000098  2f6c645f          DCB      "/ld_mcu.bin",0
00009c  6d63752e
0000a0  62696e00
                  |L26.164|
                          DCD      McuFile
                  |L26.168|
                          DCD      retUsbH
                  |L26.172|
                          DCD      RAM_Buf
                  |L26.176|
                          DCD      TmpReadSize
                  |L26.180|
                          DCD      LastPGAddress
                  |L26.184|
                          DCD      0x0817ffff

                          AREA ||i.getOriginAppCrc||, CODE, READONLY, ALIGN=2

                  getOriginAppCrc PROC
;;;1410   }
;;;1411   static uint32_t getOriginAppCrc(void){//计算MCU APP CRC32
000000  b570              PUSH     {r4-r6,lr}
;;;1412   	uint8_t val;
;;;1413   	uint32_t i;
;;;1414   	uint32_t crc32;
;;;1415   	crc32Clear();
000002  f7fffffe          BL       crc32Clear
;;;1416   	for(i = APPLICATION_FLASH_START_ADDRESS;i < APPLICATION_FLASH_END_ADDRESS;i ++){
000006  4c06              LDR      r4,|L27.32|
000008  e005              B        |L27.22|
                  |L27.10|
;;;1417   		val = *(__IO uint8_t*)(i);
00000a  7825              LDRB     r5,[r4,#0]
;;;1418   		crc32 = crc32CalculateAdd(val);//CRC32计算连续字节
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       crc32CalculateAdd
000012  4606              MOV      r6,r0
000014  1c64              ADDS     r4,r4,#1              ;1416
                  |L27.22|
000016  4803              LDR      r0,|L27.36|
000018  4284              CMP      r4,r0                 ;1416
00001a  d3f6              BCC      |L27.10|
;;;1419   	}
;;;1420   	return crc32;	
00001c  4630              MOV      r0,r6
;;;1421   }
00001e  bd70              POP      {r4-r6,pc}
;;;1422   /*****************************************************************************/
                          ENDP

                  |L27.32|
                          DCD      0x08010000
                  |L27.36|
                          DCD      0x0817ffff

                          AREA ||i.resetInit||, CODE, READONLY, ALIGN=1

                  resetInit PROC
;;;284    }
;;;285    void resetInit(void){//复位后初始化
000000  b510              PUSH     {r4,lr}
;;;286    	HAL_DeInit();
000002  f7fffffe          BL       HAL_DeInit
;;;287    	//复位RCC时钟
;;;288    	SystemClock_Reset();
000006  f7fffffe          BL       SystemClock_Reset
;;;289    	UsbGpioReset();
00000a  f7fffffe          BL       UsbGpioReset
;;;290    	__enable_irq();
00000e  b662              CPSIE    i
;;;291    }
000010  bd10              POP      {r4,pc}
;;;292    /*****************************************************************************/
                          ENDP


                          AREA ||i.softDelayMs||, CODE, READONLY, ALIGN=1

                  softDelayMs PROC
;;;310    }
;;;311    static void softDelayMs(uint16_t ms){
000000  4601              MOV      r1,r0
;;;312    	uint32_t i;
;;;313    	for(i = 0;i < 1000;i ++){
000002  2000              MOVS     r0,#0
000004  e00a              B        |L29.28|
                  |L29.6|
;;;314    		__nop();__nop();__nop();__nop();__nop();__nop();__nop();__nop();__nop();__nop();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
000014  bf00              NOP      
000016  bf00              NOP      
000018  bf00              NOP      
00001a  1c40              ADDS     r0,r0,#1              ;313
                  |L29.28|
00001c  f5b07f7a          CMP      r0,#0x3e8             ;313
000020  d3f1              BCC      |L29.6|
;;;315    	}
;;;316    }
000022  4770              BX       lr
;;;317    /******************************************************************************/
                          ENDP


                          AREA ||i.updateEprom||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  updateEprom PROC
;;;1374   }
;;;1375   static void updateEprom(void){//UDISK->EPROM
000000  b538              PUSH     {r3-r5,lr}
;;;1376   	HAL_StatusTypeDef ret;
;;;1377   	uint32_t brByte;
;;;1378   	retUsbH = f_open(&LepromFile, LOAD_EPROM_FILENAME, FA_OPEN_EXISTING | FA_READ);//读取完成信息文件
000002  2201              MOVS     r2,#1
000004  a120              ADR      r1,|L30.136|
000006  4823              LDR      r0,|L30.148|
000008  f7fffffe          BL       f_open
00000c  4922              LDR      r1,|L30.152|
00000e  7008              STRB     r0,[r1,#0]
;;;1379   	if(retUsbH != FR_OK){//读取失败跳过固件更新直接运行程序
000010  4608              MOV      r0,r1
000012  7800              LDRB     r0,[r0,#0]  ; retUsbH
000014  b148              CBZ      r0,|L30.42|
;;;1380   		printf("BootLoader:Open %s fail,ECODE=0x%02XH\n", LOAD_EPROM_FILENAME, retUsbH);
000016  4608              MOV      r0,r1
000018  7802              LDRB     r2,[r0,#0]  ; retUsbH
00001a  a11b              ADR      r1,|L30.136|
00001c  a01f              ADR      r0,|L30.156|
00001e  f7fffffe          BL       __2printf
;;;1381   				bootLoadFailHandler(BT_FAIL_READ_LEROM_BIN);
000022  2033              MOVS     r0,#0x33
000024  f7fffffe          BL       bootLoadFailHandler
000028  e02d              B        |L30.134|
                  |L30.42|
;;;1382   	}
;;;1383   	else{//读取成功检查文件内容
;;;1384   		printf("BootLoader:Open %s sucess,ECODE=0x%02XH\n", LOAD_EPROM_FILENAME, retUsbH);
00002a  481b              LDR      r0,|L30.152|
00002c  7802              LDRB     r2,[r0,#0]  ; retUsbH
00002e  a116              ADR      r1,|L30.136|
000030  a024              ADR      r0,|L30.196|
000032  f7fffffe          BL       __2printf
;;;1385   		f_lseek(&LepromFile, 0);//读取指针移动到开头
000036  2100              MOVS     r1,#0
000038  4816              LDR      r0,|L30.148|
00003a  f7fffffe          BL       f_lseek
;;;1386   		retUsbH = f_read(&LepromFile, RAM_Buf, CONFIG_EPROM_SIZE, &brByte);
00003e  466b              MOV      r3,sp
000040  f44f4200          MOV      r2,#0x8000
000044  492a              LDR      r1,|L30.240|
000046  4813              LDR      r0,|L30.148|
000048  f7fffffe          BL       f_read
00004c  4912              LDR      r1,|L30.152|
00004e  7008              STRB     r0,[r1,#0]
;;;1387   		if((retUsbH != FR_OK) || (brByte !=  CONFIG_EPROM_SIZE)){
000050  4608              MOV      r0,r1
000052  7800              LDRB     r0,[r0,#0]  ; retUsbH
000054  b918              CBNZ     r0,|L30.94|
000056  9800              LDR      r0,[sp,#0]
000058  f5b04f00          CMP      r0,#0x8000
00005c  d002              BEQ      |L30.100|
                  |L30.94|
;;;1388   			bootLoadFailHandler(BT_FAIL_READ_LEROM_BIN);
00005e  2033              MOVS     r0,#0x33
000060  f7fffffe          BL       bootLoadFailHandler
                  |L30.100|
;;;1389   		}
;;;1390   		f_close(&LepromFile);
000064  480b              LDR      r0,|L30.148|
000066  f7fffffe          BL       f_close
;;;1391   		ret = epromWrite(0, RAM_Buf, CONFIG_EPROM_SIZE);//写入EPROM
00006a  f44f4200          MOV      r2,#0x8000
00006e  4920              LDR      r1,|L30.240|
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       epromWrite
000076  4604              MOV      r4,r0
;;;1392   		if(ret != HAL_OK){
000078  b114              CBZ      r4,|L30.128|
;;;1393   			bootLoadFailHandler(BT_FAIL_WRITE_EPROM);
00007a  2037              MOVS     r0,#0x37
00007c  f7fffffe          BL       bootLoadFailHandler
                  |L30.128|
;;;1394   		}
;;;1395   		bootLoadFailHandler(BT_DONE_UPDATE_EPROM);
000080  2049              MOVS     r0,#0x49
000082  f7fffffe          BL       bootLoadFailHandler
                  |L30.134|
;;;1396   	}
;;;1397   }
000086  bd38              POP      {r3-r5,pc}
;;;1398   static void dumpEprom(void){//下载EPROM信息到U盘
                          ENDP

                  |L30.136|
000088  2f6c6570          DCB      "/leprom.bin",0
00008c  726f6d2e
000090  62696e00
                  |L30.148|
                          DCD      LepromFile
                  |L30.152|
                          DCD      retUsbH
                  |L30.156|
00009c  426f6f74          DCB      "BootLoader:Open %s fail,ECODE=0x%02XH\n",0
0000a0  4c6f6164
0000a4  65723a4f
0000a8  70656e20
0000ac  25732066
0000b0  61696c2c
0000b4  45434f44
0000b8  453d3078
0000bc  25303258
0000c0  480a00  
0000c3  00                DCB      0
                  |L30.196|
0000c4  426f6f74          DCB      "BootLoader:Open %s sucess,ECODE=0x%02XH\n",0
0000c8  4c6f6164
0000cc  65723a4f
0000d0  70656e20
0000d4  25732073
0000d8  75636573
0000dc  732c4543
0000e0  4f44453d
0000e4  30782530
0000e8  3258480a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L30.240|
                          DCD      RAM_Buf

                          AREA ||i.updateLcdApp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  updateLcdApp PROC
;;;1213   }
;;;1214   static uint32_t updateLcdApp(void){//更新LCD APP
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b09d              SUB      sp,sp,#0x74
;;;1215   	UART_HandleTypeDef *puart;
;;;1216   	HAL_StatusTypeDef uRet;
;;;1217   	uint32_t crc32;
;;;1218   	uint8_t baudrateSelect;
;;;1219   	uint8_t signName;
;;;1220       uint8_t preCmd[] =		   {0x61,0x78,0x72,0x63,0x65,0x6b,0x67,0x64,
000006  221c              MOVS     r2,#0x1c
000008  a1dc              ADR      r1,|L31.892|
00000a  a815              ADD      r0,sp,#0x54
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;1221   					            0x79,0x68,0x74,0x73,0x75,0x6e,0x71,0x77,
;;;1222   								0x70,0x6a,0x62,0x76,0x69,0x66,0x6f,0x6d,
;;;1223   								0x7a,0x6c};//升级前发送
;;;1224   	uint8_t cmd[] = 			{0xEE,0xF1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFC,0xFF,0xFF};        //下载命令
000010  a3e1              ADR      r3,|L31.920|
000012  cb0f              LDM      r3,{r0-r3}
000014  ac11              ADD      r4,sp,#0x44
000016  c40f              STM      r4!,{r0-r3}
;;;1225   	uint8_t cmdSnake[] = 		{0xEE,0x04,0xFF,0xFC,0xFF,0xFF};//屏幕握手命令
000018  a1e3              ADR      r1,|L31.936|
00001a  c903              LDM      r1,{r0,r1}
00001c  e9cd010f          STRD     r0,r1,[sp,#0x3c]
;;;1226   	uint8_t cmdSnakeBack[] = 	{0xEE,0x55,0xFF,0xFC,0xFF,0xFF};//握手返回命令
000020  a1e3              ADR      r1,|L31.944|
000022  c903              LDM      r1,{r0,r1}
000024  e9cd010d          STRD     r0,r1,[sp,#0x34]
;;;1227   	uint32_t bufIndex;
;;;1228   	uint32_t baudrateTable[]={9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600};//常用波特率放前面
000028  2220              MOVS     r2,#0x20
00002a  49e3              LDR      r1,|L31.952|
00002c  a804              ADD      r0,sp,#0x10
00002e  f7fffffe          BL       __aeabi_memcpy4
;;;1229   	uint32_t fileSize;//文件大小
;;;1230   	uint32_t blockSize = 2048;//需要读取的数据包大小
000032  f44f6900          MOV      r9,#0x800
;;;1231   	uint32_t transferByte;//读取字节数
;;;1232   	uint32_t actualByte;//实际读取的字节数
;;;1233   	uint32_t upSpeedBaudrate = GDDC_UPDATE_BAUDRATE;//提升波特率
000036  f44f30e1          MOV      r0,#0x1c200
00003a  9001              STR      r0,[sp,#4]
;;;1234   	uint32_t fileIndex;
;;;1235   	uint16_t checkSum;//校验码
;;;1236   	uint8_t lcdRetry;//错误重复次数
;;;1237   	puart = &GDDC_UART_HANDLE;
00003c  4cdf              LDR      r4,|L31.956|
;;;1238   	retUsbH = f_open(&LcdFile, LLCD_FIRMWARE_FILENAME, FA_OPEN_EXISTING | FA_READ);
00003e  2201              MOVS     r2,#1
000040  a1df              ADR      r1,|L31.960|
000042  48e2              LDR      r0,|L31.972|
000044  f7fffffe          BL       f_open
000048  49e1              LDR      r1,|L31.976|
00004a  7008              STRB     r0,[r1,#0]
;;;1239   	if(retUsbH != FR_OK){//读取失败
00004c  4608              MOV      r0,r1
00004e  7800              LDRB     r0,[r0,#0]  ; retUsbH
000050  b110              CBZ      r0,|L31.88|
;;;1240   		bootLoadFailHandler(BT_FAIL_READ_LLCD_APP);
000052  2032              MOVS     r0,#0x32
000054  f7fffffe          BL       bootLoadFailHandler
                  |L31.88|
;;;1241   	}
;;;1242   	f_lseek(&LcdFile, 0);//读取指针移动到开头
000058  2100              MOVS     r1,#0
00005a  48dc              LDR      r0,|L31.972|
00005c  f7fffffe          BL       f_lseek
;;;1243   	printf("Bootloader:Open %s sucess,ECODE=0x%02XH.\n", LLCD_FIRMWARE_FILENAME, retUsbH);
000060  48db              LDR      r0,|L31.976|
000062  7802              LDRB     r2,[r0,#0]  ; retUsbH
000064  a1d6              ADR      r1,|L31.960|
000066  a0db              ADR      r0,|L31.980|
000068  f7fffffe          BL       __2printf
;;;1244   	for(baudrateSelect = 0; baudrateSelect < (sizeof(baudrateTable) / 4); baudrateSelect ++){//波特率测试，握手		
00006c  2500              MOVS     r5,#0
00006e  e04d              B        |L31.268|
                  |L31.112|
;;;1245   		if(baudrateSelect >= (sizeof(baudrateTable) / 4)){
000070  2d08              CMP      r5,#8
000072  d302              BCC      |L31.122|
;;;1246   			bootLoadFailHandler(BT_FAIL_LCD_NOT_RESPOND);
000074  2044              MOVS     r0,#0x44
000076  f7fffffe          BL       bootLoadFailHandler
                  |L31.122|
;;;1247   		}
;;;1248   		__HAL_UART_DISABLE(puart);//关闭串口
00007a  6820              LDR      r0,[r4,#0]
00007c  68c0              LDR      r0,[r0,#0xc]
00007e  f4205000          BIC      r0,r0,#0x2000
000082  6821              LDR      r1,[r4,#0]
000084  60c8              STR      r0,[r1,#0xc]
;;;1249   		HAL_NVIC_DisableIRQ(GDDC_UART_IRQ);//关闭串口中断
000086  2025              MOVS     r0,#0x25
000088  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;1250   		HAL_NVIC_ClearPendingIRQ(GDDC_UART_IRQ);//清楚串口中断标志
00008c  2025              MOVS     r0,#0x25
00008e  f7fffffe          BL       HAL_NVIC_ClearPendingIRQ
;;;1251   		puart->Init.BaudRate = baudrateTable[baudrateSelect];
000092  a804              ADD      r0,sp,#0x10
000094  f8500025          LDR      r0,[r0,r5,LSL #2]
000098  6060              STR      r0,[r4,#4]
;;;1252   		puart->Init.WordLength = UART_WORDLENGTH_8B;
00009a  2100              MOVS     r1,#0
00009c  60a1              STR      r1,[r4,#8]
;;;1253   		puart->Init.StopBits = UART_STOPBITS_1;
00009e  60e1              STR      r1,[r4,#0xc]
;;;1254   		puart->Init.Parity = UART_PARITY_NONE;
0000a0  6121              STR      r1,[r4,#0x10]
;;;1255   		puart->Init.Mode = UART_MODE_TX_RX;
0000a2  210c              MOVS     r1,#0xc
0000a4  6161              STR      r1,[r4,#0x14]
;;;1256   		puart->Init.HwFlowCtl = UART_HWCONTROL_NONE;
0000a6  2100              MOVS     r1,#0
0000a8  61a1              STR      r1,[r4,#0x18]
;;;1257   		puart->Init.OverSampling = UART_OVERSAMPLING_16;
0000aa  61e1              STR      r1,[r4,#0x1c]
;;;1258   		if(HAL_UART_Init(puart) != HAL_OK){
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       HAL_UART_Init
0000b2  b108              CBZ      r0,|L31.184|
;;;1259   			Error_Handler();
0000b4  f7fffffe          BL       Error_Handler
                  |L31.184|
;;;1260   		}
;;;1261   		__HAL_UART_ENABLE(puart);//打开串口
0000b8  6820              LDR      r0,[r4,#0]
0000ba  68c0              LDR      r0,[r0,#0xc]
0000bc  f4405000          ORR      r0,r0,#0x2000
0000c0  6821              LDR      r1,[r4,#0]
0000c2  60c8              STR      r0,[r1,#0xc]
;;;1262   		memset(gddcRxBuf, 0x0, GDDC_RX_BUF_SIZE);
0000c4  2140              MOVS     r1,#0x40
0000c6  48ce              LDR      r0,|L31.1024|
0000c8  f7fffffe          BL       __aeabi_memclr4
;;;1263   		printf("Bootloader->updateLcdApp:Try lcd serial baudrate %d,send cmdSnake.\n", baudrateTable[baudrateSelect]);
0000cc  a804              ADD      r0,sp,#0x10
0000ce  f8501025          LDR      r1,[r0,r5,LSL #2]
0000d2  48cc              LDR      r0,|L31.1028|
0000d4  f7fffffe          BL       __2printf
;;;1264   		dp_display_text_num(cmdSnake, 6);//发送握手数据
0000d8  2106              MOVS     r1,#6
0000da  a80f              ADD      r0,sp,#0x3c
0000dc  f7fffffe          BL       dp_display_text_num
;;;1265   		uRet = HAL_UART_Receive(puart, gddcRxBuf, 6, 2000);//查询串口接收数据 超时1000
0000e0  f44f63fa          MOV      r3,#0x7d0
0000e4  2206              MOVS     r2,#6
0000e6  49c6              LDR      r1,|L31.1024|
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       HAL_UART_Receive
0000ee  4683              MOV      r11,r0
;;;1266   		if(strcmp((char *)cmdSnakeBack, (char *)gddcRxBuf) == 0){
0000f0  49c3              LDR      r1,|L31.1024|
0000f2  a80d              ADD      r0,sp,#0x34
0000f4  f7fffffe          BL       strcmp
0000f8  b930              CBNZ     r0,|L31.264|
;;;1267   			printf("Bootloader->updateLcdApp:Received cmdSnakeBack,set lcd serial baudrate %d.\n", baudrateTable[baudrateSelect]);
0000fa  a804              ADD      r0,sp,#0x10
0000fc  f8501025          LDR      r1,[r0,r5,LSL #2]
000100  48c1              LDR      r0,|L31.1032|
000102  f7fffffe          BL       __2printf
;;;1268   			break;
000106  e003              B        |L31.272|
                  |L31.264|
000108  1c68              ADDS     r0,r5,#1              ;1244
00010a  b2c5              UXTB     r5,r0                 ;1244
                  |L31.268|
00010c  2d08              CMP      r5,#8                 ;1244
00010e  d3af              BCC      |L31.112|
                  |L31.272|
000110  bf00              NOP      
;;;1269   		}
;;;1270   	}
;;;1271   	dp_display_text_num(preCmd, sizeof(preCmd));
000112  211a              MOVS     r1,#0x1a
000114  a815              ADD      r0,sp,#0x54
000116  f7fffffe          BL       dp_display_text_num
;;;1272       fileSize =  f_size(&LcdFile);
00011a  48ac              LDR      r0,|L31.972|
00011c  68c6              LDR      r6,[r0,#0xc]  ; LcdFile
;;;1273       //文件大小
;;;1274   	cmd[2] = (fileSize >> 24) & 0xff;
00011e  0e30              LSRS     r0,r6,#24
000120  f88d0046          STRB     r0,[sp,#0x46]
;;;1275   	cmd[3] = (fileSize >> 16) & 0xff;
000124  0c30              LSRS     r0,r6,#16
000126  f88d0047          STRB     r0,[sp,#0x47]
;;;1276   	cmd[4] = (fileSize >>  8) & 0xff;
00012a  0a30              LSRS     r0,r6,#8
00012c  f88d0048          STRB     r0,[sp,#0x48]
;;;1277   	cmd[5] = (fileSize) & 0xff;    
000130  b2f0              UXTB     r0,r6
000132  f88d0049          STRB     r0,[sp,#0x49]
;;;1278   	cmd[6] = (baudrateTable[baudrateSelect] >> 24) & 0xff;
000136  a804              ADD      r0,sp,#0x10
000138  f8500025          LDR      r0,[r0,r5,LSL #2]
00013c  0e00              LSRS     r0,r0,#24
00013e  f88d004a          STRB     r0,[sp,#0x4a]
;;;1279   	cmd[7] = (baudrateTable[baudrateSelect] >> 16) & 0xff;
000142  a804              ADD      r0,sp,#0x10
000144  f8500025          LDR      r0,[r0,r5,LSL #2]
000148  0c00              LSRS     r0,r0,#16
00014a  f88d004b          STRB     r0,[sp,#0x4b]
;;;1280   	cmd[8] = (baudrateTable[baudrateSelect] >>  8) & 0xff;
00014e  a804              ADD      r0,sp,#0x10
000150  f8300025          LDRH     r0,[r0,r5,LSL #2]
000154  0a00              LSRS     r0,r0,#8
000156  f88d004c          STRB     r0,[sp,#0x4c]
;;;1281   	cmd[9] = (baudrateTable[baudrateSelect]) & 0xff;    
00015a  a804              ADD      r0,sp,#0x10
00015c  f8100025          LDRB     r0,[r0,r5,LSL #2]
000160  f88d004d          STRB     r0,[sp,#0x4d]
;;;1282   	//校验和
;;;1283   	cmd[10] = cmd[1] + cmd[2] + cmd[3] + cmd[4] + cmd[5] + cmd[6] + cmd[7] + cmd[8] + cmd[9];
000164  f89d0045          LDRB     r0,[sp,#0x45]
000168  f89d1046          LDRB     r1,[sp,#0x46]
00016c  4408              ADD      r0,r0,r1
00016e  f89d1047          LDRB     r1,[sp,#0x47]
000172  4408              ADD      r0,r0,r1
000174  f89d1048          LDRB     r1,[sp,#0x48]
000178  4408              ADD      r0,r0,r1
00017a  f89d1049          LDRB     r1,[sp,#0x49]
00017e  4408              ADD      r0,r0,r1
000180  f89d104a          LDRB     r1,[sp,#0x4a]
000184  4408              ADD      r0,r0,r1
000186  f89d104b          LDRB     r1,[sp,#0x4b]
00018a  4408              ADD      r0,r0,r1
00018c  f89d104c          LDRB     r1,[sp,#0x4c]
000190  4408              ADD      r0,r0,r1
000192  f89d104d          LDRB     r1,[sp,#0x4d]
000196  4408              ADD      r0,r0,r1
000198  b2c0              UXTB     r0,r0
00019a  f88d004e          STRB     r0,[sp,#0x4e]
;;;1284       //发送下载命令
;;;1285   	memset(gddcRxBuf, 0x0, sizeof(gddcRxBuf));
00019e  2140              MOVS     r1,#0x40
0001a0  4897              LDR      r0,|L31.1024|
0001a2  f7fffffe          BL       __aeabi_memclr4
;;;1286   	printf("Bootloader->updateLcdApp:Send filesize and up speed baudrate.\n");
0001a6  a099              ADR      r0,|L31.1036|
0001a8  f7fffffe          BL       __2printf
;;;1287   	dp_display_text_num(cmd, 15);
0001ac  210f              MOVS     r1,#0xf
0001ae  a811              ADD      r0,sp,#0x44
0001b0  f7fffffe          BL       dp_display_text_num
;;;1288   	uRet = HAL_UART_Receive(puart, gddcRxBuf, 1, 10000);//查询串口接收数据 超时10000mS
0001b4  f2427310          MOV      r3,#0x2710
0001b8  2201              MOVS     r2,#1
0001ba  4991              LDR      r1,|L31.1024|
0001bc  4620              MOV      r0,r4
0001be  f7fffffe          BL       HAL_UART_Receive
0001c2  4683              MOV      r11,r0
;;;1289   	if(uRet != HAL_OK || gddcRxBuf[0] != 0xAA){
0001c4  f1bb0f00          CMP      r11,#0
0001c8  d103              BNE      |L31.466|
0001ca  488d              LDR      r0,|L31.1024|
0001cc  7800              LDRB     r0,[r0,#0]  ; gddcRxBuf
0001ce  28aa              CMP      r0,#0xaa
0001d0  d002              BEQ      |L31.472|
                  |L31.466|
;;;1290   		bootLoadFailHandler(BT_FAIL_LCD_NOT_RESPOND);
0001d2  2044              MOVS     r0,#0x44
0001d4  f7fffffe          BL       bootLoadFailHandler
                  |L31.472|
;;;1291   	}
;;;1292   	printf("Bootloader->updateLcdApp:Set up baudrate done.\n");
0001d8  a09c              ADR      r0,|L31.1100|
0001da  f7fffffe          BL       __2printf
;;;1293   	if(baudrateTable[baudrateSelect] != upSpeedBaudrate){//提升波特率与当前波特率不相同
0001de  a804              ADD      r0,sp,#0x10
0001e0  f8501025          LDR      r1,[r0,r5,LSL #2]
0001e4  9801              LDR      r0,[sp,#4]
0001e6  4281              CMP      r1,r0
0001e8  d028              BEQ      |L31.572|
;;;1294   		//重设串口到提升波特率
;;;1295   		printf("Bootloader->updateLcdApp:Set lcd serial up baudrate %d.\n", upSpeedBaudrate);
0001ea  a0a4              ADR      r0,|L31.1148|
0001ec  9901              LDR      r1,[sp,#4]
0001ee  f7fffffe          BL       __2printf
;;;1296   		__HAL_UART_DISABLE(puart);//关闭串口
0001f2  6820              LDR      r0,[r4,#0]
0001f4  68c0              LDR      r0,[r0,#0xc]
0001f6  f4205000          BIC      r0,r0,#0x2000
0001fa  6821              LDR      r1,[r4,#0]
0001fc  60c8              STR      r0,[r1,#0xc]
;;;1297   		HAL_NVIC_DisableIRQ(GDDC_UART_IRQ);//关闭串口中断
0001fe  2025              MOVS     r0,#0x25
000200  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;1298   		HAL_NVIC_ClearPendingIRQ(GDDC_UART_IRQ);//清楚串口中断标志
000204  2025              MOVS     r0,#0x25
000206  f7fffffe          BL       HAL_NVIC_ClearPendingIRQ
;;;1299   		GDDC_UART_HANDLE.Init.BaudRate = upSpeedBaudrate;
00020a  496c              LDR      r1,|L31.956|
00020c  9801              LDR      r0,[sp,#4]
00020e  6048              STR      r0,[r1,#4]  ; huart5
;;;1300   		GDDC_UART_HANDLE.Init.WordLength = UART_WORDLENGTH_8B;
000210  2100              MOVS     r1,#0
000212  486a              LDR      r0,|L31.956|
000214  6081              STR      r1,[r0,#8]
;;;1301   		GDDC_UART_HANDLE.Init.StopBits = UART_STOPBITS_1;
000216  60c1              STR      r1,[r0,#0xc]
;;;1302   		GDDC_UART_HANDLE.Init.Parity = UART_PARITY_NONE;
000218  6101              STR      r1,[r0,#0x10]
;;;1303   		GDDC_UART_HANDLE.Init.Mode = UART_MODE_TX_RX;
00021a  210c              MOVS     r1,#0xc
00021c  6141              STR      r1,[r0,#0x14]
;;;1304   		GDDC_UART_HANDLE.Init.HwFlowCtl = UART_HWCONTROL_NONE;
00021e  2100              MOVS     r1,#0
000220  6181              STR      r1,[r0,#0x18]
;;;1305   		GDDC_UART_HANDLE.Init.OverSampling = UART_OVERSAMPLING_16;
000222  61c1              STR      r1,[r0,#0x1c]
;;;1306   		if(HAL_UART_Init(puart) != HAL_OK){
000224  4620              MOV      r0,r4
000226  f7fffffe          BL       HAL_UART_Init
00022a  b108              CBZ      r0,|L31.560|
;;;1307   			Error_Handler();
00022c  f7fffffe          BL       Error_Handler
                  |L31.560|
;;;1308   		}
;;;1309   		__HAL_UART_ENABLE(puart);//打开串口
000230  6820              LDR      r0,[r4,#0]
000232  68c0              LDR      r0,[r0,#0xc]
000234  f4405000          ORR      r0,r0,#0x2000
000238  6821              LDR      r1,[r4,#0]
00023a  60c8              STR      r0,[r1,#0xc]
                  |L31.572|
;;;1310   	}
;;;1311   	HAL_Delay(200);//等待200mS
00023c  20c8              MOVS     r0,#0xc8
00023e  f7fffffe          BL       HAL_Delay
;;;1312       //一个数据包固定为2052字节
;;;1313       //格式:SN ~SN DATA CHECKSUM
;;;1314       //SN为包序号,1字节0~255循环使用
;;;1315       //~SN为上述序号取反
;;;1316       //DATA固定为2048字节,不够补0
;;;1317       //CHECKSUM,2字节,前面2050字节求和后取反
;;;1318   	signName = 0;
000242  2700              MOVS     r7,#0
;;;1319   	crc32 = 0;
000244  2000              MOVS     r0,#0
000246  901c              STR      r0,[sp,#0x70]
;;;1320   	crc32Clear();
000248  f7fffffe          BL       crc32Clear
;;;1321   	for(fileIndex = 0; fileIndex < fileSize; fileIndex += blockSize){
00024c  46b8              MOV      r8,r7
00024e  e08a              B        |L31.870|
                  |L31.592|
;;;1322   		memset(gddcTxBuf, 0x0, sizeof(gddcTxBuf));  
000250  f6400104          MOV      r1,#0x804
000254  4898              LDR      r0,|L31.1208|
000256  f7fffffe          BL       __aeabi_memclr4
;;;1323   		gddcTxBuf[0] = signName;
00025a  4897              LDR      r0,|L31.1208|
00025c  7007              STRB     r7,[r0,#0]
;;;1324   		gddcTxBuf[1] = ~signName;
00025e  43f8              MVNS     r0,r7
000260  4995              LDR      r1,|L31.1208|
000262  7048              STRB     r0,[r1,#1]
;;;1325           //读取2048个字节但不超过文件大小
;;;1326           transferByte = blockSize;
000264  f8cd900c          STR      r9,[sp,#0xc]
;;;1327   		if(fileIndex + transferByte > fileSize){
000268  f8dd900c          LDR      r9,[sp,#0xc]
00026c  eb080009          ADD      r0,r8,r9
000270  42b0              CMP      r0,r6
000272  d902              BLS      |L31.634|
;;;1328   			transferByte = fileSize - fileIndex;
000274  eba60008          SUB      r0,r6,r8
000278  9003              STR      r0,[sp,#0xc]
                  |L31.634|
;;;1329   		}
;;;1330   		retUsbH = f_read(&LcdFile, &gddcTxBuf[2], transferByte, &actualByte);
00027a  ab02              ADD      r3,sp,#8
00027c  498e              LDR      r1,|L31.1208|
00027e  1c89              ADDS     r1,r1,#2
000280  4852              LDR      r0,|L31.972|
000282  9a03              LDR      r2,[sp,#0xc]
000284  f7fffffe          BL       f_read
000288  4951              LDR      r1,|L31.976|
00028a  7008              STRB     r0,[r1,#0]
;;;1331   		crc32 = crc32Calculate(&gddcTxBuf[2], actualByte);
00028c  488a              LDR      r0,|L31.1208|
00028e  1c80              ADDS     r0,r0,#2
000290  9902              LDR      r1,[sp,#8]
000292  f7fffffe          BL       crc32Calculate
000296  901c              STR      r0,[sp,#0x70]
;;;1332   		if(retUsbH != FR_OK){
000298  484d              LDR      r0,|L31.976|
00029a  7800              LDRB     r0,[r0,#0]  ; retUsbH
00029c  b110              CBZ      r0,|L31.676|
;;;1333   			bootLoadFailHandler(BT_FAIL_READ_LLCD_APP);
00029e  2032              MOVS     r0,#0x32
0002a0  f7fffffe          BL       bootLoadFailHandler
                  |L31.676|
;;;1334           }
;;;1335           //计算校验和
;;;1336   		checkSum = 0x0;
0002a4  f04f0a00          MOV      r10,#0
;;;1337   		bufIndex = 0;
0002a8  2000              MOVS     r0,#0
0002aa  900c              STR      r0,[sp,#0x30]
;;;1338   		do{
0002ac  bf00              NOP      
                  |L31.686|
;;;1339   			checkSum += (uint16_t)gddcTxBuf[bufIndex];
0002ae  4982              LDR      r1,|L31.1208|
0002b0  980c              LDR      r0,[sp,#0x30]
0002b2  5c08              LDRB     r0,[r1,r0]
0002b4  4450              ADD      r0,r0,r10
0002b6  fa1ffa80          UXTH     r10,r0
;;;1340   			bufIndex ++;
0002ba  980c              LDR      r0,[sp,#0x30]
0002bc  1c40              ADDS     r0,r0,#1
0002be  900c              STR      r0,[sp,#0x30]
;;;1341   		}while(bufIndex < 2050);
0002c0  f6400102          MOV      r1,#0x802
0002c4  980c              LDR      r0,[sp,#0x30]
0002c6  4288              CMP      r0,r1
0002c8  d3f1              BCC      |L31.686|
;;;1342           //取反填充在包末尾
;;;1343   		checkSum = (uint16_t)~(checkSum);
0002ca  ea6f000a          MVN      r0,r10
0002ce  fa1ffa80          UXTH     r10,r0
;;;1344   		gddcTxBuf[2050] = (checkSum >> 8) & 0xFF;
0002d2  ea4f201a          LSR      r0,r10,#8
0002d6  4978              LDR      r1,|L31.1208|
0002d8  f8810802          STRB     r0,[r1,#0x802]
;;;1345   		gddcTxBuf[2051] = (checkSum) & 0xFF;   
0002dc  f881a803          STRB     r10,[r1,#0x803]
;;;1346   		do{
0002e0  bf00              NOP      
                  |L31.738|
;;;1347   			lcdRetry ++;
0002e2  9800              LDR      r0,[sp,#0]
0002e4  1c40              ADDS     r0,r0,#1
0002e6  b2c0              UXTB     r0,r0
0002e8  9000              STR      r0,[sp,#0]
;;;1348   			//发送数据包，直到成功或次数超过限制
;;;1349   			memset(gddcRxBuf, 0x0, sizeof(gddcRxBuf));
0002ea  2140              MOVS     r1,#0x40
0002ec  4844              LDR      r0,|L31.1024|
0002ee  f7fffffe          BL       __aeabi_memclr4
;;;1350   			printf("Bootloader->updateLcdApp:Send file block at 0x%08XH,", fileIndex);
0002f2  4641              MOV      r1,r8
0002f4  a071              ADR      r0,|L31.1212|
0002f6  f7fffffe          BL       __2printf
;;;1351   			dp_display_text_num(gddcTxBuf, (blockSize + 4));//send data
0002fa  f1090004          ADD      r0,r9,#4
0002fe  b281              UXTH     r1,r0
000300  486d              LDR      r0,|L31.1208|
000302  f7fffffe          BL       dp_display_text_num
;;;1352   			uRet = HAL_UART_Receive(puart, gddcRxBuf, 2, 1000);//查询串口接收数据 超时1000            
000306  f44f737a          MOV      r3,#0x3e8
00030a  2202              MOVS     r2,#2
00030c  493c              LDR      r1,|L31.1024|
00030e  4620              MOV      r0,r4
000310  f7fffffe          BL       HAL_UART_Receive
000314  4683              MOV      r11,r0
;;;1353   			if(uRet == HAL_OK){//接收正常
000316  f1bb0f00          CMP      r11,#0
00031a  d115              BNE      |L31.840|
;;;1354   				if(gddcRxBuf[1] == (uint8_t)(~(signName + 1)) || gddcRxBuf[0] == (signName+1)){
00031c  4838              LDR      r0,|L31.1024|
00031e  7841              LDRB     r1,[r0,#1]  ; gddcRxBuf
000320  1c78              ADDS     r0,r7,#1
000322  43c0              MVNS     r0,r0
000324  b2c0              UXTB     r0,r0
000326  4281              CMP      r1,r0
000328  d004              BEQ      |L31.820|
00032a  4835              LDR      r0,|L31.1024|
00032c  7801              LDRB     r1,[r0,#0]  ; gddcRxBuf
00032e  1c78              ADDS     r0,r7,#1
000330  4281              CMP      r1,r0
000332  d105              BNE      |L31.832|
                  |L31.820|
;;;1355   					signName = signName + 1;
000334  1c78              ADDS     r0,r7,#1
000336  b2c7              UXTB     r7,r0
;;;1356   					printf("ok!\n");
000338  a06e              ADR      r0,|L31.1268|
00033a  f7fffffe          BL       __2printf
;;;1357   					break;
00033e  e010              B        |L31.866|
                  |L31.832|
;;;1358   				}
;;;1359   				else{
;;;1360   					printf("SignName is not invalid\n");
000340  a06e              ADR      r0,|L31.1276|
000342  f7fffffe          BL       __2printf
000346  e00b              B        |L31.864|
                  |L31.840|
;;;1361   				}
;;;1362   			}
;;;1363   			else{//答应超时或错误
;;;1364   				printf("fail!\n");
000348  a073              ADR      r0,|L31.1304|
00034a  f7fffffe          BL       __2printf
;;;1365   				HAL_Delay(100);
00034e  2064              MOVS     r0,#0x64
000350  f7fffffe          BL       HAL_Delay
;;;1366   				if(lcdRetry > GDDC_RETRY_TIMES){//发送次数超时
000354  9800              LDR      r0,[sp,#0]
000356  280a              CMP      r0,#0xa
000358  dd02              BLE      |L31.864|
;;;1367   					bootLoadFailHandler(BT_FAIL_LCD_DOWNLOAD);
00035a  2045              MOVS     r0,#0x45
00035c  f7fffffe          BL       bootLoadFailHandler
                  |L31.864|
;;;1368   				}
;;;1369   			}
;;;1370   		}while(1);
000360  e7bf              B        |L31.738|
                  |L31.866|
000362  bf00              NOP                            ;1357
000364  44c8              ADD      r8,r8,r9              ;1321
                  |L31.870|
000366  45b0              CMP      r8,r6                 ;1321
000368  f4ffaf72          BCC      |L31.592|
;;;1371   	}
;;;1372   	f_close(&LcdFile);
00036c  4817              LDR      r0,|L31.972|
00036e  f7fffffe          BL       f_close
;;;1373   	return crc32;
000372  981c              LDR      r0,[sp,#0x70]
;;;1374   }
000374  b01d              ADD      sp,sp,#0x74
000376  e8bd8ff0          POP      {r4-r11,pc}
;;;1375   static void updateEprom(void){//UDISK->EPROM
                          ENDP

00037a  0000              DCW      0x0000
                  |L31.892|
00037c  61787263          DCB      "axrcekgdyhtsunqwpjbvifomzl",0
000380  656b6764
000384  79687473
000388  756e7177
00038c  706a6276
000390  69666f6d
000394  7a6c00  
000397  00                DCB      0
                  |L31.920|
000398  eef100            DCB      238,241,0
00039b  00                DCB      0
00039c  00                DCB      0
00039d  00                DCB      0
00039e  00                DCB      0
00039f  00                DCB      0
0003a0  00                DCB      0
0003a1  00                DCB      0
0003a2  00                DCB      0
0003a3  fffcffff          DCB      255,252,255,255,0
0003a7  00      
                  |L31.936|
0003a8  ee04fffc          DCB      238,4,255,252,255,255,0
0003ac  ffff00  
0003af  00                DCB      0
                  |L31.944|
0003b0  ee55fffc          DCB      238,"U",255,252,255,255,0
0003b4  ffff00  
0003b7  00                DCB      0
                  |L31.952|
                          DCD      ||.constdata||+0x400
                  |L31.956|
                          DCD      huart5
                  |L31.960|
0003c0  2f6c645f          DCB      "/ld_lcd.pkg",0
0003c4  6c63642e
0003c8  706b6700
                  |L31.972|
                          DCD      LcdFile
                  |L31.976|
                          DCD      retUsbH
                  |L31.980|
0003d4  426f6f74          DCB      "Bootloader:Open %s sucess,ECODE=0x%02XH.\n",0
0003d8  6c6f6164
0003dc  65723a4f
0003e0  70656e20
0003e4  25732073
0003e8  75636573
0003ec  732c4543
0003f0  4f44453d
0003f4  30782530
0003f8  3258482e
0003fc  0a00    
0003fe  00                DCB      0
0003ff  00                DCB      0
                  |L31.1024|
                          DCD      gddcRxBuf
                  |L31.1028|
                          DCD      ||.conststring||
                  |L31.1032|
                          DCD      ||.conststring||+0x44
                  |L31.1036|
00040c  426f6f74          DCB      "Bootloader->updateLcdApp:Send filesize and up speed bau"
000410  6c6f6164
000414  65722d3e
000418  75706461
00041c  74654c63
000420  64417070
000424  3a53656e
000428  64206669
00042c  6c657369
000430  7a652061
000434  6e642075
000438  70207370
00043c  65656420
000440  626175  
000443  64726174          DCB      "drate.\n",0
000447  652e0a00
00044b  00                DCB      0
                  |L31.1100|
00044c  426f6f74          DCB      "Bootloader->updateLcdApp:Set up baudrate done.\n",0
000450  6c6f6164
000454  65722d3e
000458  75706461
00045c  74654c63
000460  64417070
000464  3a536574
000468  20757020
00046c  62617564
000470  72617465
000474  20646f6e
000478  652e0a00
                  |L31.1148|
00047c  426f6f74          DCB      "Bootloader->updateLcdApp:Set lcd serial up baudrate %d."
000480  6c6f6164
000484  65722d3e
000488  75706461
00048c  74654c63
000490  64417070
000494  3a536574
000498  206c6364
00049c  20736572
0004a0  69616c20
0004a4  75702062
0004a8  61756472
0004ac  61746520
0004b0  25642e  
0004b3  0a00              DCB      "\n",0
0004b5  00                DCB      0
0004b6  00                DCB      0
0004b7  00                DCB      0
                  |L31.1208|
                          DCD      gddcTxBuf
                  |L31.1212|
0004bc  426f6f74          DCB      "Bootloader->updateLcdApp:Send file block at 0x%08XH,",0
0004c0  6c6f6164
0004c4  65722d3e
0004c8  75706461
0004cc  74654c63
0004d0  64417070
0004d4  3a53656e
0004d8  64206669
0004dc  6c652062
0004e0  6c6f636b
0004e4  20617420
0004e8  30782530
0004ec  3858482c
0004f0  00      
0004f1  00                DCB      0
0004f2  00                DCB      0
0004f3  00                DCB      0
                  |L31.1268|
0004f4  6f6b210a          DCB      "ok!\n",0
0004f8  00      
0004f9  00                DCB      0
0004fa  00                DCB      0
0004fb  00                DCB      0
                  |L31.1276|
0004fc  5369676e          DCB      "SignName is not invalid\n",0
000500  4e616d65
000504  20697320
000508  6e6f7420
00050c  696e7661
000510  6c69640a
000514  00      
000515  00                DCB      0
000516  00                DCB      0
000517  00                DCB      0
                  |L31.1304|
000518  6661696c          DCB      "fail!\n",0
00051c  210a00  
00051f  00                DCB      0

                          AREA ||i.updateMcuApp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  updateMcuApp PROC
;;;1157   }
;;;1158   static uint32_t updateMcuApp(void){//更新MCU APP
000000  b5f8              PUSH     {r3-r7,lr}
;;;1159   	uint32_t crc32;
;;;1160   	uint32_t i;
;;;1161   	uint32_t programcounter = 0x00;
000002  2400              MOVS     r4,#0
;;;1162   	uint8_t readflag = TRUE;
000004  2701              MOVS     r7,#1
;;;1163   	uint32_t bytesread;//实际文件读取字节数
;;;1164   	retUsbH = f_open(&McuFile, LMCU_FIRMWARE_FILENAME, FA_OPEN_EXISTING | FA_READ);
000006  2201              MOVS     r2,#1
000008  a140              ADR      r1,|L32.268|
00000a  4843              LDR      r0,|L32.280|
00000c  f7fffffe          BL       f_open
000010  4942              LDR      r1,|L32.284|
000012  7008              STRB     r0,[r1,#0]
;;;1165   	if(retUsbH != FR_OK){//读取失败
000014  4608              MOV      r0,r1
000016  7800              LDRB     r0,[r0,#0]  ; retUsbH
000018  b110              CBZ      r0,|L32.32|
;;;1166   		bootLoadFailHandler(BT_FAIL_READ_LMCU_APP);			
00001a  2031              MOVS     r0,#0x31
00001c  f7fffffe          BL       bootLoadFailHandler
                  |L32.32|
;;;1167   	}
;;;1168   	printf("Bootloader:Open %s sucess,ECODE=0x%02XH.\n", LMCU_FIRMWARE_FILENAME, retUsbH);
000020  483e              LDR      r0,|L32.284|
000022  7802              LDRB     r2,[r0,#0]  ; retUsbH
000024  a139              ADR      r1,|L32.268|
000026  a03e              ADR      r0,|L32.288|
000028  f7fffffe          BL       __2printf
;;;1169   	if(f_size(&McuFile) > APPLICATION_FLASH_SIZE){//MCU固件大于FLSAH容量
00002c  483a              LDR      r0,|L32.280|
00002e  68c0              LDR      r0,[r0,#0xc]  ; McuFile
000030  f5b01fb8          CMP      r0,#0x170000
000034  d902              BLS      |L32.60|
;;;1170   		bootLoadFailHandler(BT_FAIL_LMCU_APP_CHECK);
000036  2038              MOVS     r0,#0x38
000038  f7fffffe          BL       bootLoadFailHandler
                  |L32.60|
;;;1171   	}
;;;1172   	HAL_FLASH_Unlock();
00003c  f7fffffe          BL       HAL_FLASH_Unlock
;;;1173   	__HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_BSY|FLASH_FLAG_EOP|FLASH_FLAG_PGSERR|FLASH_FLAG_WRPERR);
000040  4842              LDR      r0,|L32.332|
000042  4943              LDR      r1,|L32.336|
000044  6008              STR      r0,[r1,#0]
;;;1174   	if (FLASH_If_EraseApplication() != 0x00){//擦除APP FLASH区域失败
000046  f7fffffe          BL       FLASH_If_EraseApplication
00004a  b110              CBZ      r0,|L32.82|
;;;1175   		bootLoadFailHandler(BT_FAIL_ERASE_MCU_APP);
00004c  2035              MOVS     r0,#0x35
00004e  f7fffffe          BL       bootLoadFailHandler
                  |L32.82|
;;;1176   	}
;;;1177   	checkBlank(APPLICATION_FLASH_START_ADDRESS, APPLICATION_FLASH_SIZE);//FLASH 查空
000052  f44f11b8          MOV      r1,#0x170000
000056  483f              LDR      r0,|L32.340|
000058  f7fffffe          BL       checkBlank
;;;1178   	printf("Bootloader:Erase mcu application sucess.\n");
00005c  a03e              ADR      r0,|L32.344|
00005e  f7fffffe          BL       __2printf
;;;1179   	RamAddress = (uint32_t)&RAM_Buf;//获取RAM缓存区地址
000062  4848              LDR      r0,|L32.388|
000064  4948              LDR      r1,|L32.392|
000066  6008              STR      r0,[r1,#0]  ; RamAddress
;;;1180   	/* Erase address init */
;;;1181   	LastPGAddress = APPLICATION_FLASH_START_ADDRESS;
000068  483a              LDR      r0,|L32.340|
00006a  4948              LDR      r1,|L32.396|
00006c  6008              STR      r0,[r1,#0]  ; LastPGAddress
;;;1182   	/* While file still contain data */
;;;1183   	crc32 = 0;
00006e  2600              MOVS     r6,#0
;;;1184   	crc32Clear();
000070  f7fffffe          BL       crc32Clear
;;;1185   	while(readflag){
000074  e032              B        |L32.220|
                  |L32.118|
;;;1186   		/* Read maximum 512 Kbyte from the selected file */
;;;1187   		f_read(&McuFile, RAM_Buf, BUFFER_SIZE, (void*)&bytesread);
000076  466b              MOV      r3,sp
000078  f44f4200          MOV      r2,#0x8000
00007c  4941              LDR      r1,|L32.388|
00007e  4826              LDR      r0,|L32.280|
000080  f7fffffe          BL       f_read
;;;1188   		crc32 = crc32Calculate(RAM_Buf, bytesread);
000084  483f              LDR      r0,|L32.388|
000086  9900              LDR      r1,[sp,#0]
000088  f7fffffe          BL       crc32Calculate
00008c  4606              MOV      r6,r0
;;;1189   		/* Temp variable */
;;;1190   		TmpReadSize = bytesread;
00008e  4940              LDR      r1,|L32.400|
000090  9800              LDR      r0,[sp,#0]
000092  6008              STR      r0,[r1,#0]  ; TmpReadSize
;;;1191   		/* The read data < "BUFFER_SIZE" Kbyte */
;;;1192   		if(TmpReadSize < BUFFER_SIZE){
000094  4608              MOV      r0,r1
000096  6800              LDR      r0,[r0,#0]  ; TmpReadSize
000098  f5b04f00          CMP      r0,#0x8000
00009c  d200              BCS      |L32.160|
;;;1193   			readflag = FALSE;
00009e  2700              MOVS     r7,#0
                  |L32.160|
;;;1194   		}
;;;1195   		/* Program flash memory */
;;;1196   		FLIP_GREEN();//绿灯
0000a0  2120              MOVS     r1,#0x20
0000a2  483c              LDR      r0,|L32.404|
0000a4  f7fffffe          BL       HAL_GPIO_TogglePin
;;;1197   		for(programcounter = 0; programcounter < TmpReadSize; programcounter += 4){
0000a8  2400              MOVS     r4,#0
0000aa  e00c              B        |L32.198|
                  |L32.172|
;;;1198   			/* Write word into flash memory */
;;;1199   			if(FLASH_If_Write((LastPGAddress + programcounter), *(uint32_t *) (RamAddress + programcounter)) != 0x00){
0000ac  4a36              LDR      r2,|L32.392|
0000ae  6812              LDR      r2,[r2,#0]  ; RamAddress
0000b0  5911              LDR      r1,[r2,r4]
0000b2  4a36              LDR      r2,|L32.396|
0000b4  6812              LDR      r2,[r2,#0]  ; LastPGAddress
0000b6  1910              ADDS     r0,r2,r4
0000b8  f7fffffe          BL       FLASH_If_Write
0000bc  b110              CBZ      r0,|L32.196|
;;;1200   				bootLoadFailHandler(BT_FAIL_WRITE_MCU_APP_FLASH);//写入FLASH错误
0000be  2043              MOVS     r0,#0x43
0000c0  f7fffffe          BL       bootLoadFailHandler
                  |L32.196|
0000c4  1d24              ADDS     r4,r4,#4              ;1197
                  |L32.198|
0000c6  4832              LDR      r0,|L32.400|
0000c8  6800              LDR      r0,[r0,#0]            ;1197  ; TmpReadSize
0000ca  4284              CMP      r4,r0                 ;1197
0000cc  d3ee              BCC      |L32.172|
;;;1201   			}
;;;1202   		}
;;;1203   		/* Update last programmed address value */
;;;1204   		LastPGAddress += TmpReadSize;
0000ce  482f              LDR      r0,|L32.396|
0000d0  6800              LDR      r0,[r0,#0]  ; LastPGAddress
0000d2  492f              LDR      r1,|L32.400|
0000d4  6809              LDR      r1,[r1,#0]  ; TmpReadSize
0000d6  4408              ADD      r0,r0,r1
0000d8  492c              LDR      r1,|L32.396|
0000da  6008              STR      r0,[r1,#0]  ; LastPGAddress
                  |L32.220|
0000dc  2f00              CMP      r7,#0                 ;1185
0000de  d1ca              BNE      |L32.118|
;;;1205   	}
;;;1206   	for(i = LastPGAddress;i < APPLICATION_FLASH_END_ADDRESS;i ++){//补完剩余CRC
0000e0  482a              LDR      r0,|L32.396|
0000e2  6805              LDR      r5,[r0,#0]  ; LastPGAddress
0000e4  e004              B        |L32.240|
                  |L32.230|
;;;1207   		crc32 = crc32CalculateAdd(0xFF);
0000e6  20ff              MOVS     r0,#0xff
0000e8  f7fffffe          BL       crc32CalculateAdd
0000ec  4606              MOV      r6,r0
0000ee  1c6d              ADDS     r5,r5,#1              ;1206
                  |L32.240|
0000f0  4829              LDR      r0,|L32.408|
0000f2  4285              CMP      r5,r0                 ;1206
0000f4  d3f7              BCC      |L32.230|
;;;1208   	}
;;;1209   	HAL_FLASH_Lock();
0000f6  f7fffffe          BL       HAL_FLASH_Lock
;;;1210   	printf("Bootloader:Write mcu app finish.\n");
0000fa  a028              ADR      r0,|L32.412|
0000fc  f7fffffe          BL       __2printf
;;;1211   	f_close(&McuFile);
000100  4805              LDR      r0,|L32.280|
000102  f7fffffe          BL       f_close
;;;1212   	return crc32;
000106  4630              MOV      r0,r6
;;;1213   }
000108  bdf8              POP      {r3-r7,pc}
;;;1214   static uint32_t updateLcdApp(void){//更新LCD APP
                          ENDP

00010a  0000              DCW      0x0000
                  |L32.268|
00010c  2f6c645f          DCB      "/ld_mcu.bin",0
000110  6d63752e
000114  62696e00
                  |L32.280|
                          DCD      McuFile
                  |L32.284|
                          DCD      retUsbH
                  |L32.288|
000120  426f6f74          DCB      "Bootloader:Open %s sucess,ECODE=0x%02XH.\n",0
000124  6c6f6164
000128  65723a4f
00012c  70656e20
000130  25732073
000134  75636573
000138  732c4543
00013c  4f44453d
000140  30782530
000144  3258482e
000148  0a00    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L32.332|
                          DCD      0x00010091
                  |L32.336|
                          DCD      0x40023c0c
                  |L32.340|
                          DCD      0x08010000
                  |L32.344|
000158  426f6f74          DCB      "Bootloader:Erase mcu application sucess.\n",0
00015c  6c6f6164
000160  65723a45
000164  72617365
000168  206d6375
00016c  20617070
000170  6c696361
000174  74696f6e
000178  20737563
00017c  6573732e
000180  0a00    
000182  00                DCB      0
000183  00                DCB      0
                  |L32.388|
                          DCD      RAM_Buf
                  |L32.392|
                          DCD      RamAddress
                  |L32.396|
                          DCD      LastPGAddress
                  |L32.400|
                          DCD      TmpReadSize
                  |L32.404|
                          DCD      0x40020400
                  |L32.408|
                          DCD      0x0817ffff
                  |L32.412|
00019c  426f6f74          DCB      "Bootloader:Write mcu app finish.\n",0
0001a0  6c6f6164
0001a4  65723a57
0001a8  72697465
0001ac  206d6375
0001b0  20617070
0001b4  2066696e
0001b8  6973682e
0001bc  0a00    
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RAM_Buf
                          %        32768
                  gddcRxBuf
                          %        64
                  gddcTxBuf
                          %        2052
                  USBH_fatfs
                          %        560
                  LogFile
                          %        560
                  CfgFile
                          %        560
                  McuFile
                          %        560
                  LcdFile
                          %        560
                  BotFile
                          %        560
                  SepromFile
                          %        560
                  LepromFile
                          %        560
                  FileDir
                          %        48
                  FileInfo
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  crc32Tab
                          DCD      0x00000000
                          DCD      0x77073096
                          DCD      0xee0e612c
                          DCD      0x990951ba
                          DCD      0x076dc419
                          DCD      0x706af48f
                          DCD      0xe963a535
                          DCD      0x9e6495a3
                          DCD      0x0edb8832
                          DCD      0x79dcb8a4
                          DCD      0xe0d5e91e
                          DCD      0x97d2d988
                          DCD      0x09b64c2b
                          DCD      0x7eb17cbd
                          DCD      0xe7b82d07
                          DCD      0x90bf1d91
                          DCD      0x1db71064
                          DCD      0x6ab020f2
                          DCD      0xf3b97148
                          DCD      0x84be41de
                          DCD      0x1adad47d
                          DCD      0x6ddde4eb
                          DCD      0xf4d4b551
                          DCD      0x83d385c7
                          DCD      0x136c9856
                          DCD      0x646ba8c0
                          DCD      0xfd62f97a
                          DCD      0x8a65c9ec
                          DCD      0x14015c4f
                          DCD      0x63066cd9
                          DCD      0xfa0f3d63
                          DCD      0x8d080df5
                          DCD      0x3b6e20c8
                          DCD      0x4c69105e
                          DCD      0xd56041e4
                          DCD      0xa2677172
                          DCD      0x3c03e4d1
                          DCD      0x4b04d447
                          DCD      0xd20d85fd
                          DCD      0xa50ab56b
                          DCD      0x35b5a8fa
                          DCD      0x42b2986c
                          DCD      0xdbbbc9d6
                          DCD      0xacbcf940
                          DCD      0x32d86ce3
                          DCD      0x45df5c75
                          DCD      0xdcd60dcf
                          DCD      0xabd13d59
                          DCD      0x26d930ac
                          DCD      0x51de003a
                          DCD      0xc8d75180
                          DCD      0xbfd06116
                          DCD      0x21b4f4b5
                          DCD      0x56b3c423
                          DCD      0xcfba9599
                          DCD      0xb8bda50f
                          DCD      0x2802b89e
                          DCD      0x5f058808
                          DCD      0xc60cd9b2
                          DCD      0xb10be924
                          DCD      0x2f6f7c87
                          DCD      0x58684c11
                          DCD      0xc1611dab
                          DCD      0xb6662d3d
                          DCD      0x76dc4190
                          DCD      0x01db7106
                          DCD      0x98d220bc
                          DCD      0xefd5102a
                          DCD      0x71b18589
                          DCD      0x06b6b51f
                          DCD      0x9fbfe4a5
                          DCD      0xe8b8d433
                          DCD      0x7807c9a2
                          DCD      0x0f00f934
                          DCD      0x9609a88e
                          DCD      0xe10e9818
                          DCD      0x7f6a0dbb
                          DCD      0x086d3d2d
                          DCD      0x91646c97
                          DCD      0xe6635c01
                          DCD      0x6b6b51f4
                          DCD      0x1c6c6162
                          DCD      0x856530d8
                          DCD      0xf262004e
                          DCD      0x6c0695ed
                          DCD      0x1b01a57b
                          DCD      0x8208f4c1
                          DCD      0xf50fc457
                          DCD      0x65b0d9c6
                          DCD      0x12b7e950
                          DCD      0x8bbeb8ea
                          DCD      0xfcb9887c
                          DCD      0x62dd1ddf
                          DCD      0x15da2d49
                          DCD      0x8cd37cf3
                          DCD      0xfbd44c65
                          DCD      0x4db26158
                          DCD      0x3ab551ce
                          DCD      0xa3bc0074
                          DCD      0xd4bb30e2
                          DCD      0x4adfa541
                          DCD      0x3dd895d7
                          DCD      0xa4d1c46d
                          DCD      0xd3d6f4fb
                          DCD      0x4369e96a
                          DCD      0x346ed9fc
                          DCD      0xad678846
                          DCD      0xda60b8d0
                          DCD      0x44042d73
                          DCD      0x33031de5
                          DCD      0xaa0a4c5f
                          DCD      0xdd0d7cc9
                          DCD      0x5005713c
                          DCD      0x270241aa
                          DCD      0xbe0b1010
                          DCD      0xc90c2086
                          DCD      0x5768b525
                          DCD      0x206f85b3
                          DCD      0xb966d409
                          DCD      0xce61e49f
                          DCD      0x5edef90e
                          DCD      0x29d9c998
                          DCD      0xb0d09822
                          DCD      0xc7d7a8b4
                          DCD      0x59b33d17
                          DCD      0x2eb40d81
                          DCD      0xb7bd5c3b
                          DCD      0xc0ba6cad
                          DCD      0xedb88320
                          DCD      0x9abfb3b6
                          DCD      0x03b6e20c
                          DCD      0x74b1d29a
                          DCD      0xead54739
                          DCD      0x9dd277af
                          DCD      0x04db2615
                          DCD      0x73dc1683
                          DCD      0xe3630b12
                          DCD      0x94643b84
                          DCD      0x0d6d6a3e
                          DCD      0x7a6a5aa8
                          DCD      0xe40ecf0b
                          DCD      0x9309ff9d
                          DCD      0x0a00ae27
                          DCD      0x7d079eb1
                          DCD      0xf00f9344
                          DCD      0x8708a3d2
                          DCD      0x1e01f268
                          DCD      0x6906c2fe
                          DCD      0xf762575d
                          DCD      0x806567cb
                          DCD      0x196c3671
                          DCD      0x6e6b06e7
                          DCD      0xfed41b76
                          DCD      0x89d32be0
                          DCD      0x10da7a5a
                          DCD      0x67dd4acc
                          DCD      0xf9b9df6f
                          DCD      0x8ebeeff9
                          DCD      0x17b7be43
                          DCD      0x60b08ed5
                          DCD      0xd6d6a3e8
                          DCD      0xa1d1937e
                          DCD      0x38d8c2c4
                          DCD      0x4fdff252
                          DCD      0xd1bb67f1
                          DCD      0xa6bc5767
                          DCD      0x3fb506dd
                          DCD      0x48b2364b
                          DCD      0xd80d2bda
                          DCD      0xaf0a1b4c
                          DCD      0x36034af6
                          DCD      0x41047a60
                          DCD      0xdf60efc3
                          DCD      0xa867df55
                          DCD      0x316e8eef
                          DCD      0x4669be79
                          DCD      0xcb61b38c
                          DCD      0xbc66831a
                          DCD      0x256fd2a0
                          DCD      0x5268e236
                          DCD      0xcc0c7795
                          DCD      0xbb0b4703
                          DCD      0x220216b9
                          DCD      0x5505262f
                          DCD      0xc5ba3bbe
                          DCD      0xb2bd0b28
                          DCD      0x2bb45a92
                          DCD      0x5cb36a04
                          DCD      0xc2d7ffa7
                          DCD      0xb5d0cf31
                          DCD      0x2cd99e8b
                          DCD      0x5bdeae1d
                          DCD      0x9b64c2b0
                          DCD      0xec63f226
                          DCD      0x756aa39c
                          DCD      0x026d930a
                          DCD      0x9c0906a9
                          DCD      0xeb0e363f
                          DCD      0x72076785
                          DCD      0x05005713
                          DCD      0x95bf4a82
                          DCD      0xe2b87a14
                          DCD      0x7bb12bae
                          DCD      0x0cb61b38
                          DCD      0x92d28e9b
                          DCD      0xe5d5be0d
                          DCD      0x7cdcefb7
                          DCD      0x0bdbdf21
                          DCD      0x86d3d2d4
                          DCD      0xf1d4e242
                          DCD      0x68ddb3f8
                          DCD      0x1fda836e
                          DCD      0x81be16cd
                          DCD      0xf6b9265b
                          DCD      0x6fb077e1
                          DCD      0x18b74777
                          DCD      0x88085ae6
                          DCD      0xff0f6a70
                          DCD      0x66063bca
                          DCD      0x11010b5c
                          DCD      0x8f659eff
                          DCD      0xf862ae69
                          DCD      0x616bffd3
                          DCD      0x166ccf45
                          DCD      0xa00ae278
                          DCD      0xd70dd2ee
                          DCD      0x4e048354
                          DCD      0x3903b3c2
                          DCD      0xa7672661
                          DCD      0xd06016f7
                          DCD      0x4969474d
                          DCD      0x3e6e77db
                          DCD      0xaed16a4a
                          DCD      0xd9d65adc
                          DCD      0x40df0b66
                          DCD      0x37d83bf0
                          DCD      0xa9bcae53
                          DCD      0xdebb9ec5
                          DCD      0x47b2cf7f
                          DCD      0x30b5ffe9
                          DCD      0xbdbdf21c
                          DCD      0xcabac28a
                          DCD      0x53b39330
                          DCD      0x24b4a3a6
                          DCD      0xbad03605
                          DCD      0xcdd70693
                          DCD      0x54de5729
                          DCD      0x23d967bf
                          DCD      0xb3667a2e
                          DCD      0xc4614ab8
                          DCD      0x5d681b02
                          DCD      0x2a6f2b94
                          DCD      0xb40bbe37
                          DCD      0xc30c8ea1
                          DCD      0x5a05df1b
                          DCD      0x2d02ef8d
                          DCD      0x00002580
                          DCD      0x00004b00
                          DCD      0x00009600
                          DCD      0x0000e100
                          DCD      0x0001c200
                          DCD      0x00038400
                          DCD      0x00070800
                          DCD      0x000e1000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  426f6f74          DCB      "Bootloader->updateLcdApp:Try lcd serial baudrate %d,sen"
000004  6c6f6164
000008  65722d3e
00000c  75706461
000010  74654c63
000014  64417070
000018  3a547279
00001c  206c6364
000020  20736572
000024  69616c20
000028  62617564
00002c  72617465
000030  2025642c
000034  73656e  
000037  6420636d          DCB      "d cmdSnake.\n",0
00003b  64536e61
00003f  6b652e0a
000043  00      
000044  426f6f74          DCB      "Bootloader->updateLcdApp:Received cmdSnakeBack,set lcd "
000048  6c6f6164
00004c  65722d3e
000050  75706461
000054  74654c63
000058  64417070
00005c  3a526563
000060  65697665
000064  6420636d
000068  64536e61
00006c  6b654261
000070  636b2c73
000074  6574206c
000078  636420  
00007b  73657269          DCB      "serial baudrate %d.\n",0
00007f  616c2062
000083  61756472
000087  61746520
00008b  25642e0a
00008f  00      
000090  426f6f74          DCB      "Bootloader:Update lcd app new crc32 sucess,wait lcd upg"
000094  6c6f6164
000098  65723a55
00009c  70646174
0000a0  65206c63
0000a4  64206170
0000a8  70206e65
0000ac  77206372
0000b0  63333220
0000b4  73756365
0000b8  73732c77
0000bc  61697420
0000c0  6c636420
0000c4  757067  
0000c7  72616465          DCB      "rade done\n",0
0000cb  20646f6e
0000cf  650a00  

                          AREA ||.data||, DATA, ALIGN=2

                  TmpReadSize
                          DCD      0x00000000
                  RamAddress
                          DCD      0x00000000
                  LastPGAddress
                          DCD      0x08010000
                  retUsbH
00000c  00                DCB      0x00
                  bootLoadState
00000d  00                DCB      0x00
                  usbReady
00000e  0000              DCB      0x00,0x00
                  releaseTime0
                          DCD      0x00000000
                  releaseTime1
                          DCD      0x00000000
                  overTime
                          DCD      0x00000000
                  releaseCounter
                          DCD      0x00000000
                  JumpAddress
                          DCD      0x00000000
                  Jump_To_Application
                          DCD      0x00000000
                  oldcrc32
                          DCD      0x00000000
                  BID
00002c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\Bootloader\\bootLoader.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bootLoader_c_607b9d9c____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___12_bootLoader_c_607b9d9c____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bootLoader_c_607b9d9c____REVSH|
#line 478
|__asm___12_bootLoader_c_607b9d9c____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_bootLoader_c_607b9d9c____RRX|
#line 665
|__asm___12_bootLoader_c_607b9d9c____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
