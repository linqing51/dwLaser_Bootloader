; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\diskio.o --asm_dir=./ --list_dir=--list --depend=mcu_application\diskio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\diskio.crf ../Middlewares/Third_Party/FatFs/src/diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;50       */
;;;51     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;52     	BYTE pdrv				/* Physical drive nmuber to identify the drive */
;;;53     )
;;;54     {
000002  4604              MOV      r4,r0
;;;55       DSTATUS stat = RES_OK;
000004  2500              MOVS     r5,#0
;;;56     
;;;57       if(disk.is_initialized[pdrv] == 0)
000006  4808              LDR      r0,|L1.40|
000008  5d00              LDRB     r0,[r0,r4]
00000a  b958              CBNZ     r0,|L1.36|
;;;58       {
;;;59         disk.is_initialized[pdrv] = 1;
00000c  2001              MOVS     r0,#1
00000e  4906              LDR      r1,|L1.40|
000010  5508              STRB     r0,[r1,r4]
;;;60         stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
000012  f1010208          ADD      r2,r1,#8
000016  5d10              LDRB     r0,[r2,r4]
000018  1d0a              ADDS     r2,r1,#4
00001a  f8522024          LDR      r2,[r2,r4,LSL #2]
00001e  6811              LDR      r1,[r2,#0]
000020  4788              BLX      r1
000022  4605              MOV      r5,r0
                  |L1.36|
;;;61       }
;;;62       return stat;
000024  4628              MOV      r0,r5
;;;63     }
000026  bd70              POP      {r4-r6,pc}
;;;64     
                          ENDP

                  |L1.40|
                          DCD      disk

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;116    #if _USE_IOCTL == 1
;;;117    DRESULT disk_ioctl (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;118    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;119    	BYTE cmd,		/* Control code */
;;;120    	void *buff		/* Buffer to send/receive control data */
;;;121    )
;;;122    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;123      DRESULT res;
;;;124    
;;;125      res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
00000a  4906              LDR      r1,|L2.36|
00000c  5d08              LDRB     r0,[r1,r4]
00000e  1f09              SUBS     r1,r1,#4
000010  f8511024          LDR      r1,[r1,r4,LSL #2]
000014  4632              MOV      r2,r6
000016  690b              LDR      r3,[r1,#0x10]
000018  4629              MOV      r1,r5
00001a  4798              BLX      r3
00001c  4607              MOV      r7,r0
;;;126      return res;
00001e  4638              MOV      r0,r7
;;;127    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;128    #endif /* _USE_IOCTL == 1 */
                          ENDP

                  |L2.36|
                          DCD      disk+0x8

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;72       */
;;;73     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;74     	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;75     	BYTE *buff,		/* Data buffer to store read data */
;;;76     	DWORD sector,	        /* Sector address in LBA */
;;;77     	UINT count		/* Number of sectors to read */
;;;78     )
;;;79     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;80       DRESULT res;
;;;81     
;;;82       res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
00000c  4907              LDR      r1,|L3.44|
00000e  5d08              LDRB     r0,[r1,r4]
000010  1f09              SUBS     r1,r1,#4
000012  f8511024          LDR      r1,[r1,r4,LSL #2]
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  f8d1c008          LDR      r12,[r1,#8]
00001e  4629              MOV      r1,r5
000020  47e0              BLX      r12
000022  4680              MOV      r8,r0
;;;83       return res;
000024  4640              MOV      r0,r8
;;;84     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;85     
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      disk+0x8

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=2

                  disk_status PROC
;;;35       */
;;;36     DSTATUS disk_status (
000000  b570              PUSH     {r4-r6,lr}
;;;37     	BYTE pdrv		/* Physical drive number to identify the drive */
;;;38     )
;;;39     {
000002  4604              MOV      r4,r0
;;;40       DSTATUS stat;
;;;41     
;;;42       stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
000004  4a04              LDR      r2,|L4.24|
000006  5d10              LDRB     r0,[r2,r4]
000008  1f12              SUBS     r2,r2,#4
00000a  f8522024          LDR      r2,[r2,r4,LSL #2]
00000e  6851              LDR      r1,[r2,#4]
000010  4788              BLX      r1
000012  4605              MOV      r5,r0
;;;43       return stat;
000014  4628              MOV      r0,r5
;;;44     }
000016  bd70              POP      {r4-r6,pc}
;;;45     
                          ENDP

                  |L4.24|
                          DCD      disk+0x8

                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                  disk_write PROC
;;;94     #if _USE_WRITE == 1
;;;95     DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;96     	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;97     	const BYTE *buff,	/* Data to be written */
;;;98     	DWORD sector,		/* Sector address in LBA */
;;;99     	UINT count        	/* Number of sectors to write */
;;;100    )
;;;101    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;102      DRESULT res;
;;;103    
;;;104      res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
00000c  4907              LDR      r1,|L5.44|
00000e  5d08              LDRB     r0,[r1,r4]
000010  1f09              SUBS     r1,r1,#4
000012  f8511024          LDR      r1,[r1,r4,LSL #2]
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  f8d1c00c          LDR      r12,[r1,#0xc]
00001e  4629              MOV      r1,r5
000020  47e0              BLX      r12
000022  4680              MOV      r8,r0
;;;105      return res;
000024  4640              MOV      r0,r8
;;;106    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;107    #endif /* _USE_WRITE == 1 */
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      disk+0x8

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;134      */
;;;135    __weak DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;136    {
;;;137      return 0;
;;;138    }
000002  4770              BX       lr
;;;139    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Middlewares/Third_Party/FatFs/src/diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___8_diskio_c_fd8865f0____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REVSH|
#line 478
|__asm___8_diskio_c_fd8865f0____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____RRX|
#line 665
|__asm___8_diskio_c_fd8865f0____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
