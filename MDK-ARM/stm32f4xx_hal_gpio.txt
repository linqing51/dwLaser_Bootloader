; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_gpio.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_gpio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_gpio.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;295      */
;;;296    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  b5f0              PUSH     {r4-r7,lr}
;;;297    {
000002  460c              MOV      r4,r1
;;;298      uint32_t position;
;;;299      uint32_t ioposition = 0x00U;
000004  2500              MOVS     r5,#0
;;;300      uint32_t iocurrent = 0x00U;
000006  2200              MOVS     r2,#0
;;;301      uint32_t tmp = 0x00U;
000008  2300              MOVS     r3,#0
;;;302    
;;;303      /* Check the parameters */
;;;304      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;305      
;;;306      /* Configure the port pins */
;;;307      for(position = 0U; position < GPIO_NUMBER; position++)
00000a  2100              MOVS     r1,#0
00000c  e08d              B        |L1.298|
                  |L1.14|
;;;308      {
;;;309        /* Get the IO position */
;;;310        ioposition = 0x01U << position;
00000e  2601              MOVS     r6,#1
000010  fa06f501          LSL      r5,r6,r1
;;;311        /* Get the current IO position */
;;;312        iocurrent = (GPIO_Pin) & ioposition;
000014  ea040205          AND      r2,r4,r5
;;;313    
;;;314        if(iocurrent == ioposition)
000018  42aa              CMP      r2,r5
00001a  d17d              BNE      |L1.280|
;;;315        {
;;;316          /*------------------------- EXTI Mode Configuration --------------------*/
;;;317          tmp = SYSCFG->EXTICR[position >> 2U];
00001c  4e45              LDR      r6,|L1.308|
00001e  088f              LSRS     r7,r1,#2
000020  f8563027          LDR      r3,[r6,r7,LSL #2]
;;;318          tmp &= (0x0FU << (4U * (position & 0x03U)));
000024  078e              LSLS     r6,r1,#30
000026  0f37              LSRS     r7,r6,#28
000028  260f              MOVS     r6,#0xf
00002a  40be              LSLS     r6,r6,r7
00002c  4033              ANDS     r3,r3,r6
;;;319          if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
00002e  4e42              LDR      r6,|L1.312|
000030  42b0              CMP      r0,r6
000032  d101              BNE      |L1.56|
000034  2600              MOVS     r6,#0
000036  e01e              B        |L1.118|
                  |L1.56|
000038  4e40              LDR      r6,|L1.316|
00003a  42b0              CMP      r0,r6
00003c  d101              BNE      |L1.66|
00003e  2601              MOVS     r6,#1
000040  e019              B        |L1.118|
                  |L1.66|
000042  4e3f              LDR      r6,|L1.320|
000044  42b0              CMP      r0,r6
000046  d101              BNE      |L1.76|
000048  2602              MOVS     r6,#2
00004a  e014              B        |L1.118|
                  |L1.76|
00004c  4e3d              LDR      r6,|L1.324|
00004e  42b0              CMP      r0,r6
000050  d101              BNE      |L1.86|
000052  2603              MOVS     r6,#3
000054  e00f              B        |L1.118|
                  |L1.86|
000056  4e3c              LDR      r6,|L1.328|
000058  42b0              CMP      r0,r6
00005a  d101              BNE      |L1.96|
00005c  2604              MOVS     r6,#4
00005e  e00a              B        |L1.118|
                  |L1.96|
000060  4e3a              LDR      r6,|L1.332|
000062  42b0              CMP      r0,r6
000064  d101              BNE      |L1.106|
000066  2605              MOVS     r6,#5
000068  e005              B        |L1.118|
                  |L1.106|
00006a  4e39              LDR      r6,|L1.336|
00006c  42b0              CMP      r0,r6
00006e  d101              BNE      |L1.116|
000070  2606              MOVS     r6,#6
000072  e000              B        |L1.118|
                  |L1.116|
000074  2607              MOVS     r6,#7
                  |L1.118|
000076  078f              LSLS     r7,r1,#30
000078  0f3f              LSRS     r7,r7,#28
00007a  40be              LSLS     r6,r6,r7
00007c  429e              CMP      r6,r3
00007e  d122              BNE      |L1.198|
;;;320          {
;;;321            /* Clear EXTI line configuration */
;;;322            EXTI->IMR &= ~((uint32_t)iocurrent);
000080  4e34              LDR      r6,|L1.340|
000082  6836              LDR      r6,[r6,#0]
000084  4396              BICS     r6,r6,r2
000086  4f33              LDR      r7,|L1.340|
000088  603e              STR      r6,[r7,#0]
;;;323            EXTI->EMR &= ~((uint32_t)iocurrent);
00008a  1d3e              ADDS     r6,r7,#4
00008c  6836              LDR      r6,[r6,#0]
00008e  4396              BICS     r6,r6,r2
000090  1d3f              ADDS     r7,r7,#4
000092  603e              STR      r6,[r7,#0]
;;;324            
;;;325            /* Clear Rising Falling edge configuration */
;;;326            EXTI->RTSR &= ~((uint32_t)iocurrent);
000094  1d3e              ADDS     r6,r7,#4
000096  6836              LDR      r6,[r6,#0]
000098  4396              BICS     r6,r6,r2
00009a  1d3f              ADDS     r7,r7,#4
00009c  603e              STR      r6,[r7,#0]
;;;327            EXTI->FTSR &= ~((uint32_t)iocurrent);
00009e  1d3e              ADDS     r6,r7,#4
0000a0  6836              LDR      r6,[r6,#0]
0000a2  4396              BICS     r6,r6,r2
0000a4  1d3f              ADDS     r7,r7,#4
0000a6  603e              STR      r6,[r7,#0]
;;;328    
;;;329            /* Configure the External Interrupt or event for the current IO */
;;;330            tmp = 0x0FU << (4U * (position & 0x03U));
0000a8  078e              LSLS     r6,r1,#30
0000aa  0f37              LSRS     r7,r6,#28
0000ac  260f              MOVS     r6,#0xf
0000ae  fa06f307          LSL      r3,r6,r7
;;;331            SYSCFG->EXTICR[position >> 2U] &= ~tmp;
0000b2  4e20              LDR      r6,|L1.308|
0000b4  088f              LSRS     r7,r1,#2
0000b6  f8566027          LDR      r6,[r6,r7,LSL #2]
0000ba  439e              BICS     r6,r6,r3
0000bc  4f1d              LDR      r7,|L1.308|
0000be  ea4f0c91          LSR      r12,r1,#2
0000c2  f847602c          STR      r6,[r7,r12,LSL #2]
                  |L1.198|
;;;332          }
;;;333    
;;;334          /*------------------------- GPIO Mode Configuration --------------------*/
;;;335          /* Configure IO Direction in Input Floating Mode */
;;;336          GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
0000c6  6806              LDR      r6,[r0,#0]
0000c8  ea4f0c41          LSL      r12,r1,#1
0000cc  2703              MOVS     r7,#3
0000ce  fa07f70c          LSL      r7,r7,r12
0000d2  43be              BICS     r6,r6,r7
0000d4  6006              STR      r6,[r0,#0]
;;;337    
;;;338          /* Configure the default Alternate Function in current IO */
;;;339          GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
0000d6  08cf              LSRS     r7,r1,#3
0000d8  f1000620          ADD      r6,r0,#0x20
0000dc  f8566027          LDR      r6,[r6,r7,LSL #2]
0000e0  074f              LSLS     r7,r1,#29
0000e2  ea4f6cd7          LSR      r12,r7,#27
0000e6  270f              MOVS     r7,#0xf
0000e8  fa07f70c          LSL      r7,r7,r12
0000ec  43be              BICS     r6,r6,r7
0000ee  ea4f0cd1          LSR      r12,r1,#3
0000f2  f1000720          ADD      r7,r0,#0x20
0000f6  f847602c          STR      r6,[r7,r12,LSL #2]
;;;340    
;;;341          /* Deactivate the Pull-up and Pull-down resistor for the current IO */
;;;342          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
0000fa  68c6              LDR      r6,[r0,#0xc]
0000fc  ea4f0c41          LSL      r12,r1,#1
000100  2703              MOVS     r7,#3
000102  fa07f70c          LSL      r7,r7,r12
000106  43be              BICS     r6,r6,r7
000108  60c6              STR      r6,[r0,#0xc]
;;;343    
;;;344          /* Configure the default value IO Output Type */
;;;345          GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
00010a  6846              LDR      r6,[r0,#4]
00010c  2701              MOVS     r7,#1
00010e  408f              LSLS     r7,r7,r1
000110  43be              BICS     r6,r6,r7
000112  6046              STR      r6,[r0,#4]
;;;346    
;;;347          /* Configure the default value for IO Speed */
;;;348          GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
000114  6886              LDR      r6,[r0,#8]
000116  e000              B        |L1.282|
                  |L1.280|
000118  e006              B        |L1.296|
                  |L1.282|
00011a  ea4f0c41          LSL      r12,r1,#1
00011e  2703              MOVS     r7,#3
000120  fa07f70c          LSL      r7,r7,r12
000124  43be              BICS     r6,r6,r7
000126  6086              STR      r6,[r0,#8]
                  |L1.296|
000128  1c49              ADDS     r1,r1,#1              ;307
                  |L1.298|
00012a  2910              CMP      r1,#0x10              ;307
00012c  f4ffaf6f          BCC      |L1.14|
;;;349        }
;;;350      }
;;;351    }
000130  bdf0              POP      {r4-r7,pc}
;;;352    
                          ENDP

000132  0000              DCW      0x0000
                  |L1.308|
                          DCD      0x40013808
                  |L1.312|
                          DCD      0x40020000
                  |L1.316|
                          DCD      0x40020400
                  |L1.320|
                          DCD      0x40020800
                  |L1.324|
                          DCD      0x40020c00
                  |L1.328|
                          DCD      0x40021000
                  |L1.332|
                          DCD      0x40021400
                  |L1.336|
                          DCD      0x40021800
                  |L1.340|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;509      */
;;;510    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;511    {
;;;512      /* Prevent unused argument(s) compilation warning */
;;;513      UNUSED(GPIO_Pin);
;;;514      /* NOTE: This function Should not be modified, when the callback is needed,
;;;515               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;516       */
;;;517    }
;;;518    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;494      */
;;;495    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;496    {
000002  4604              MOV      r4,r0
;;;497      /* EXTI line interrupt detected */
;;;498      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
000004  4804              LDR      r0,|L3.24|
000006  6800              LDR      r0,[r0,#0]
000008  4020              ANDS     r0,r0,r4
00000a  b120              CBZ      r0,|L3.22|
;;;499      {
;;;500        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  6004              STR      r4,[r0,#0]
;;;501        HAL_GPIO_EXTI_Callback(GPIO_Pin);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.22|
;;;502      }
;;;503    }
000016  bd10              POP      {r4,pc}
;;;504    
                          ENDP

                  |L3.24|
                          DCD      0x40013c14

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;170      */
;;;171    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  b5f8              PUSH     {r3-r7,lr}
;;;172    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;173      uint32_t position;
;;;174      uint32_t ioposition = 0x00U;
000006  2500              MOVS     r5,#0
;;;175      uint32_t iocurrent = 0x00U;
000008  2400              MOVS     r4,#0
;;;176      uint32_t temp = 0x00U;
00000a  2000              MOVS     r0,#0
;;;177    
;;;178      /* Check the parameters */
;;;179      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;180      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;181      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;182      assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;183    
;;;184      /* Configure the port pins */
;;;185      for(position = 0U; position < GPIO_NUMBER; position++)
00000c  2100              MOVS     r1,#0
00000e  e0d7              B        |L4.448|
                  |L4.16|
;;;186      {
;;;187        /* Get the IO position */
;;;188        ioposition = 0x01U << position;
000010  2601              MOVS     r6,#1
000012  fa06f501          LSL      r5,r6,r1
;;;189        /* Get the current IO position */
;;;190        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
000016  681e              LDR      r6,[r3,#0]
000018  ea060405          AND      r4,r6,r5
;;;191    
;;;192        if(iocurrent == ioposition)
00001c  42ac              CMP      r4,r5
00001e  d173              BNE      |L4.264|
;;;193        {
;;;194          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;195          /* In case of Output or Alternate function mode selection */
;;;196          if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
000020  685e              LDR      r6,[r3,#4]
000022  2e01              CMP      r6,#1
000024  d008              BEQ      |L4.56|
000026  685e              LDR      r6,[r3,#4]
000028  2e02              CMP      r6,#2
00002a  d005              BEQ      |L4.56|
;;;197             (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
00002c  685e              LDR      r6,[r3,#4]
00002e  2e11              CMP      r6,#0x11
000030  d002              BEQ      |L4.56|
000032  685e              LDR      r6,[r3,#4]
000034  2e12              CMP      r6,#0x12
000036  d113              BNE      |L4.96|
                  |L4.56|
;;;198          {
;;;199            /* Check the Speed parameter */
;;;200            assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;201            /* Configure the IO Speed */
;;;202            temp = GPIOx->OSPEEDR; 
000038  6890              LDR      r0,[r2,#8]
;;;203            temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
00003a  004f              LSLS     r7,r1,#1
00003c  2603              MOVS     r6,#3
00003e  40be              LSLS     r6,r6,r7
000040  43b0              BICS     r0,r0,r6
;;;204            temp |= (GPIO_Init->Speed << (position * 2U));
000042  004f              LSLS     r7,r1,#1
000044  68de              LDR      r6,[r3,#0xc]
000046  40be              LSLS     r6,r6,r7
000048  4330              ORRS     r0,r0,r6
;;;205            GPIOx->OSPEEDR = temp;
00004a  6090              STR      r0,[r2,#8]
;;;206    
;;;207            /* Configure the IO Output Type */
;;;208            temp = GPIOx->OTYPER;
00004c  6850              LDR      r0,[r2,#4]
;;;209            temp &= ~(GPIO_OTYPER_OT_0 << position) ;
00004e  2601              MOVS     r6,#1
000050  408e              LSLS     r6,r6,r1
000052  43b0              BICS     r0,r0,r6
;;;210            temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
000054  791e              LDRB     r6,[r3,#4]
000056  f3c61600          UBFX     r6,r6,#4,#1
00005a  408e              LSLS     r6,r6,r1
00005c  4330              ORRS     r0,r0,r6
;;;211            GPIOx->OTYPER = temp;
00005e  6050              STR      r0,[r2,#4]
                  |L4.96|
;;;212           }
;;;213    
;;;214          /* Activate the Pull-up or Pull down resistor for the current IO */
;;;215          temp = GPIOx->PUPDR;
000060  68d0              LDR      r0,[r2,#0xc]
;;;216          temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
000062  004f              LSLS     r7,r1,#1
000064  2603              MOVS     r6,#3
000066  40be              LSLS     r6,r6,r7
000068  43b0              BICS     r0,r0,r6
;;;217          temp |= ((GPIO_Init->Pull) << (position * 2U));
00006a  004f              LSLS     r7,r1,#1
00006c  689e              LDR      r6,[r3,#8]
00006e  40be              LSLS     r6,r6,r7
000070  4330              ORRS     r0,r0,r6
;;;218          GPIOx->PUPDR = temp;
000072  60d0              STR      r0,[r2,#0xc]
;;;219    
;;;220          /* In case of Alternate function mode selection */
;;;221          if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
000074  685e              LDR      r6,[r3,#4]
000076  2e02              CMP      r6,#2
000078  d002              BEQ      |L4.128|
00007a  685e              LDR      r6,[r3,#4]
00007c  2e12              CMP      r6,#0x12
00007e  d113              BNE      |L4.168|
                  |L4.128|
;;;222          {
;;;223            /* Check the Alternate function parameter */
;;;224            assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
;;;225            /* Configure Alternate function mapped with the current IO */
;;;226            temp = GPIOx->AFR[position >> 3U];
000080  08cf              LSRS     r7,r1,#3
000082  f1020620          ADD      r6,r2,#0x20
000086  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;227            temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
00008a  074e              LSLS     r6,r1,#29
00008c  0ef7              LSRS     r7,r6,#27
00008e  260f              MOVS     r6,#0xf
000090  40be              LSLS     r6,r6,r7
000092  43b0              BICS     r0,r0,r6
;;;228            temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
000094  074f              LSLS     r7,r1,#29
000096  0eff              LSRS     r7,r7,#27
000098  691e              LDR      r6,[r3,#0x10]
00009a  40be              LSLS     r6,r6,r7
00009c  4330              ORRS     r0,r0,r6
;;;229            GPIOx->AFR[position >> 3U] = temp;
00009e  08cf              LSRS     r7,r1,#3
0000a0  f1020620          ADD      r6,r2,#0x20
0000a4  f8460027          STR      r0,[r6,r7,LSL #2]
                  |L4.168|
;;;230          }
;;;231    
;;;232          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;233          temp = GPIOx->MODER;
0000a8  6810              LDR      r0,[r2,#0]
;;;234          temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
0000aa  004f              LSLS     r7,r1,#1
0000ac  2603              MOVS     r6,#3
0000ae  40be              LSLS     r6,r6,r7
0000b0  43b0              BICS     r0,r0,r6
;;;235          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
0000b2  791e              LDRB     r6,[r3,#4]
0000b4  f0060603          AND      r6,r6,#3
0000b8  004f              LSLS     r7,r1,#1
0000ba  40be              LSLS     r6,r6,r7
0000bc  4330              ORRS     r0,r0,r6
;;;236          GPIOx->MODER = temp;
0000be  6010              STR      r0,[r2,#0]
;;;237    
;;;238          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;239          /* Configure the External Interrupt or event for the current IO */
;;;240          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
0000c0  685e              LDR      r6,[r3,#4]
0000c2  f0065680          AND      r6,r6,#0x10000000
0000c6  f1b65f80          CMP      r6,#0x10000000
0000ca  d178              BNE      |L4.446|
;;;241          {
;;;242            /* Enable SYSCFG Clock */
;;;243            __HAL_RCC_SYSCFG_CLK_ENABLE();
0000cc  bf00              NOP      
0000ce  2600              MOVS     r6,#0
0000d0  9600              STR      r6,[sp,#0]
0000d2  4e3d              LDR      r6,|L4.456|
0000d4  6836              LDR      r6,[r6,#0]
0000d6  f4464680          ORR      r6,r6,#0x4000
0000da  4f3b              LDR      r7,|L4.456|
0000dc  603e              STR      r6,[r7,#0]
0000de  463e              MOV      r6,r7
0000e0  6836              LDR      r6,[r6,#0]
0000e2  f4064680          AND      r6,r6,#0x4000
0000e6  9600              STR      r6,[sp,#0]
0000e8  bf00              NOP      
0000ea  bf00              NOP      
;;;244    
;;;245            temp = SYSCFG->EXTICR[position >> 2U];
0000ec  4e37              LDR      r6,|L4.460|
0000ee  088f              LSRS     r7,r1,#2
0000f0  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;246            temp &= ~(0x0FU << (4U * (position & 0x03U)));
0000f4  078e              LSLS     r6,r1,#30
0000f6  0f37              LSRS     r7,r6,#28
0000f8  260f              MOVS     r6,#0xf
0000fa  40be              LSLS     r6,r6,r7
0000fc  43b0              BICS     r0,r0,r6
;;;247            temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
0000fe  4e34              LDR      r6,|L4.464|
000100  42b2              CMP      r2,r6
000102  d102              BNE      |L4.266|
000104  2600              MOVS     r6,#0
000106  e01f              B        |L4.328|
                  |L4.264|
000108  e059              B        |L4.446|
                  |L4.266|
00010a  4e32              LDR      r6,|L4.468|
00010c  42b2              CMP      r2,r6
00010e  d101              BNE      |L4.276|
000110  2601              MOVS     r6,#1
000112  e019              B        |L4.328|
                  |L4.276|
000114  4e30              LDR      r6,|L4.472|
000116  42b2              CMP      r2,r6
000118  d101              BNE      |L4.286|
00011a  2602              MOVS     r6,#2
00011c  e014              B        |L4.328|
                  |L4.286|
00011e  4e2f              LDR      r6,|L4.476|
000120  42b2              CMP      r2,r6
000122  d101              BNE      |L4.296|
000124  2603              MOVS     r6,#3
000126  e00f              B        |L4.328|
                  |L4.296|
000128  4e2d              LDR      r6,|L4.480|
00012a  42b2              CMP      r2,r6
00012c  d101              BNE      |L4.306|
00012e  2604              MOVS     r6,#4
000130  e00a              B        |L4.328|
                  |L4.306|
000132  4e2c              LDR      r6,|L4.484|
000134  42b2              CMP      r2,r6
000136  d101              BNE      |L4.316|
000138  2605              MOVS     r6,#5
00013a  e005              B        |L4.328|
                  |L4.316|
00013c  4e2a              LDR      r6,|L4.488|
00013e  42b2              CMP      r2,r6
000140  d101              BNE      |L4.326|
000142  2606              MOVS     r6,#6
000144  e000              B        |L4.328|
                  |L4.326|
000146  2607              MOVS     r6,#7
                  |L4.328|
000148  078f              LSLS     r7,r1,#30
00014a  0f3f              LSRS     r7,r7,#28
00014c  40be              LSLS     r6,r6,r7
00014e  4330              ORRS     r0,r0,r6
;;;248            SYSCFG->EXTICR[position >> 2U] = temp;
000150  4e1e              LDR      r6,|L4.460|
000152  088f              LSRS     r7,r1,#2
000154  f8460027          STR      r0,[r6,r7,LSL #2]
;;;249    
;;;250            /* Clear EXTI line configuration */
;;;251            temp = EXTI->IMR;
000158  4e24              LDR      r6,|L4.492|
00015a  6830              LDR      r0,[r6,#0]
;;;252            temp &= ~((uint32_t)iocurrent);
00015c  43a0              BICS     r0,r0,r4
;;;253            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
00015e  685e              LDR      r6,[r3,#4]
000160  f4063680          AND      r6,r6,#0x10000
000164  f5b63f80          CMP      r6,#0x10000
000168  d100              BNE      |L4.364|
;;;254            {
;;;255              temp |= iocurrent;
00016a  4320              ORRS     r0,r0,r4
                  |L4.364|
;;;256            }
;;;257            EXTI->IMR = temp;
00016c  4e1f              LDR      r6,|L4.492|
00016e  6030              STR      r0,[r6,#0]
;;;258    
;;;259            temp = EXTI->EMR;
000170  1d36              ADDS     r6,r6,#4
000172  6830              LDR      r0,[r6,#0]
;;;260            temp &= ~((uint32_t)iocurrent);
000174  43a0              BICS     r0,r0,r4
;;;261            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
000176  685e              LDR      r6,[r3,#4]
000178  f4063600          AND      r6,r6,#0x20000
00017c  f5b63f00          CMP      r6,#0x20000
000180  d100              BNE      |L4.388|
;;;262            {
;;;263              temp |= iocurrent;
000182  4320              ORRS     r0,r0,r4
                  |L4.388|
;;;264            }
;;;265            EXTI->EMR = temp;
000184  4e19              LDR      r6,|L4.492|
000186  1d36              ADDS     r6,r6,#4
000188  6030              STR      r0,[r6,#0]
;;;266    
;;;267            /* Clear Rising Falling edge configuration */
;;;268            temp = EXTI->RTSR;
00018a  1d36              ADDS     r6,r6,#4
00018c  6830              LDR      r0,[r6,#0]
;;;269            temp &= ~((uint32_t)iocurrent);
00018e  43a0              BICS     r0,r0,r4
;;;270            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
000190  685e              LDR      r6,[r3,#4]
000192  f4061680          AND      r6,r6,#0x100000
000196  f5b61f80          CMP      r6,#0x100000
00019a  d100              BNE      |L4.414|
;;;271            {
;;;272              temp |= iocurrent;
00019c  4320              ORRS     r0,r0,r4
                  |L4.414|
;;;273            }
;;;274            EXTI->RTSR = temp;
00019e  4e13              LDR      r6,|L4.492|
0001a0  3608              ADDS     r6,r6,#8
0001a2  6030              STR      r0,[r6,#0]
;;;275    
;;;276            temp = EXTI->FTSR;
0001a4  1d36              ADDS     r6,r6,#4
0001a6  6830              LDR      r0,[r6,#0]
;;;277            temp &= ~((uint32_t)iocurrent);
0001a8  43a0              BICS     r0,r0,r4
;;;278            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
0001aa  685e              LDR      r6,[r3,#4]
0001ac  f4061600          AND      r6,r6,#0x200000
0001b0  f5b61f00          CMP      r6,#0x200000
0001b4  d100              BNE      |L4.440|
;;;279            {
;;;280              temp |= iocurrent;
0001b6  4320              ORRS     r0,r0,r4
                  |L4.440|
;;;281            }
;;;282            EXTI->FTSR = temp;
0001b8  4e0c              LDR      r6,|L4.492|
0001ba  360c              ADDS     r6,r6,#0xc
0001bc  6030              STR      r0,[r6,#0]
                  |L4.446|
0001be  1c49              ADDS     r1,r1,#1              ;185
                  |L4.448|
0001c0  2910              CMP      r1,#0x10              ;185
0001c2  f4ffaf25          BCC      |L4.16|
;;;283          }
;;;284        }
;;;285      }
;;;286    }
0001c6  bdf8              POP      {r3-r7,pc}
;;;287    
                          ENDP

                  |L4.456|
                          DCD      0x40023844
                  |L4.460|
                          DCD      0x40013808
                  |L4.464|
                          DCD      0x40020000
                  |L4.468|
                          DCD      0x40020400
                  |L4.472|
                          DCD      0x40020800
                  |L4.476|
                          DCD      0x40020c00
                  |L4.480|
                          DCD      0x40021000
                  |L4.484|
                          DCD      0x40021400
                  |L4.488|
                          DCD      0x40021800
                  |L4.492|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;460      */
;;;461    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;462    {
000002  4602              MOV      r2,r0
;;;463      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000004  f44f3080          MOV      r0,#0x10000
000008  9000              STR      r0,[sp,#0]
;;;464    
;;;465      /* Check the parameters */
;;;466      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;467    
;;;468      /* Apply lock key write sequence */
;;;469      tmp |= GPIO_Pin;
00000a  9800              LDR      r0,[sp,#0]
00000c  4308              ORRS     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;470      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;471      GPIOx->LCKR = tmp;
000010  9800              LDR      r0,[sp,#0]
000012  61d0              STR      r0,[r2,#0x1c]
;;;472      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;473      GPIOx->LCKR = GPIO_Pin;
000014  61d1              STR      r1,[r2,#0x1c]
;;;474      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;475      GPIOx->LCKR = tmp;
000016  9800              LDR      r0,[sp,#0]
000018  61d0              STR      r0,[r2,#0x1c]
;;;476      /* Read LCKR register. This read is mandatory to complete key lock sequence */
;;;477      tmp = GPIOx->LCKR;
00001a  69d0              LDR      r0,[r2,#0x1c]
00001c  9000              STR      r0,[sp,#0]
;;;478    
;;;479      /* Read again in order to confirm lock is active */
;;;480     if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
00001e  69d0              LDR      r0,[r2,#0x1c]
000020  f4003080          AND      r0,r0,#0x10000
000024  b108              CBZ      r0,|L5.42|
;;;481      {
;;;482        return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;483      }
;;;484      else
;;;485      {
;;;486        return HAL_ERROR;
;;;487      }
;;;488    }
000028  bd08              POP      {r3,pc}
                  |L5.42|
00002a  2001              MOVS     r0,#1                 ;486
00002c  e7fc              B        |L5.40|
;;;489    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;376      */
;;;377    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;378    {
;;;379      GPIO_PinState bitstatus;
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;383    
;;;384      if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  6913              LDR      r3,[r2,#0x10]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;385      {
;;;386        bitstatus = GPIO_PIN_SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;387      }
;;;388      else
;;;389      {
;;;390        bitstatus = GPIO_PIN_RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;391      }
;;;392      return bitstatus;
;;;393    }
00000e  4770              BX       lr
;;;394    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;434      */
;;;435    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6942              LDR      r2,[r0,#0x14]
;;;436    {
;;;437      /* Check the parameters */
;;;438      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;439    
;;;440      if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
000002  400a              ANDS     r2,r2,r1
000004  428a              CMP      r2,r1
000006  d102              BNE      |L7.14|
;;;441      {
;;;442        GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
000008  040a              LSLS     r2,r1,#16
00000a  6182              STR      r2,[r0,#0x18]
00000c  e000              B        |L7.16|
                  |L7.14|
;;;443      }
;;;444      else
;;;445      {
;;;446        GPIOx->BSRR = GPIO_Pin;
00000e  6181              STR      r1,[r0,#0x18]
                  |L7.16|
;;;447      }
;;;448    }
000010  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;411      */
;;;412    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
;;;413    {
;;;414      /* Check the parameters */
;;;415      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;416      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;417    
;;;418      if(PinState != GPIO_PIN_RESET)
;;;419      {
;;;420        GPIOx->BSRR = GPIO_Pin;
000002  6181              STR      r1,[r0,#0x18]
000004  e001              B        |L8.10|
                  |L8.6|
;;;421      }
;;;422      else
;;;423      {
;;;424        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
000006  040b              LSLS     r3,r1,#16
000008  6183              STR      r3,[r0,#0x18]
                  |L8.10|
;;;425      }
;;;426    }
00000a  4770              BX       lr
;;;427    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____REVSH|
#line 478
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____RRX|
#line 665
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
