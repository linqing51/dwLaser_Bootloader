; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -omcu_application\stm32f4xx_hal_uart.o --asm_dir=./ --list_dir=--list --depend=mcu_application\stm32f4xx_hal_uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../FATFS/Target -I../FATFS/App -I../USB_HOST/App -I../USB_HOST/Target -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Middlewares/ST/STM32_USB_Host_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I..\Drivers\CMSIS\DSP\Include -I..\Bootloader -I..\..\dwLaser_Application\MCU_Application\deviceInfo -I.\RTE\_MCU_Application -IC:\Users\linqi\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\linqi\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F413xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F413xx -DARM_MATH_CM4 --omf_browse=mcu_application\stm32f4xx_hal_uart.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2423     */
;;;2424   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2425   {
;;;2426     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2427   
;;;2428     /* Process Locked */
;;;2429     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L1.18|
00000e  2002              MOVS     r0,#2
                  |L1.16|
;;;2430   
;;;2431     huart->gState = HAL_UART_STATE_BUSY;
;;;2432   
;;;2433     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2434     tmpreg = huart->Instance->CR1;
;;;2435   
;;;2436     /* Clear TE and RE bits */
;;;2437     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2438   
;;;2439     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2440     tmpreg |= (uint32_t)USART_CR1_RE;
;;;2441   
;;;2442     /* Write to USART CR1 */
;;;2443     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2444   
;;;2445     huart->gState = HAL_UART_STATE_READY;
;;;2446   
;;;2447     /* Process Unlocked */
;;;2448     __HAL_UNLOCK(huart);
;;;2449   
;;;2450     return HAL_OK;
;;;2451   }
000010  4770              BX       lr
                  |L1.18|
000012  2001              MOVS     r0,#1                 ;2429
000014  f8810038          STRB     r0,[r1,#0x38]         ;2429
000018  bf00              NOP                            ;2429
00001a  2024              MOVS     r0,#0x24              ;2431
00001c  f8810039          STRB     r0,[r1,#0x39]         ;2431
000020  6808              LDR      r0,[r1,#0]            ;2434
000022  68c2              LDR      r2,[r0,#0xc]          ;2434
000024  f022020c          BIC      r2,r2,#0xc            ;2437
000028  f0420204          ORR      r2,r2,#4              ;2440
00002c  6808              LDR      r0,[r1,#0]            ;2443
00002e  60c2              STR      r2,[r0,#0xc]          ;2443
000030  2020              MOVS     r0,#0x20              ;2445
000032  f8810039          STRB     r0,[r1,#0x39]         ;2445
000036  bf00              NOP                            ;2448
000038  2000              MOVS     r0,#0                 ;2448
00003a  f8810038          STRB     r0,[r1,#0x38]         ;2448
00003e  bf00              NOP                            ;2448
000040  bf00              NOP                            ;2450
000042  e7e5              B        |L1.16|
;;;2452   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2388     */
;;;2389   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2390   {
;;;2391     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2392   
;;;2393     /* Process Locked */
;;;2394     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L2.18|
00000e  2002              MOVS     r0,#2
                  |L2.16|
;;;2395   
;;;2396     huart->gState = HAL_UART_STATE_BUSY;
;;;2397   
;;;2398     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2399     tmpreg = huart->Instance->CR1;
;;;2400   
;;;2401     /* Clear TE and RE bits */
;;;2402     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2403   
;;;2404     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2405     tmpreg |= (uint32_t)USART_CR1_TE;
;;;2406   
;;;2407     /* Write to USART CR1 */
;;;2408     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2409   
;;;2410     huart->gState = HAL_UART_STATE_READY;
;;;2411   
;;;2412     /* Process Unlocked */
;;;2413     __HAL_UNLOCK(huart);
;;;2414   
;;;2415     return HAL_OK;
;;;2416   }
000010  4770              BX       lr
                  |L2.18|
000012  2001              MOVS     r0,#1                 ;2394
000014  f8810038          STRB     r0,[r1,#0x38]         ;2394
000018  bf00              NOP                            ;2394
00001a  2024              MOVS     r0,#0x24              ;2396
00001c  f8810039          STRB     r0,[r1,#0x39]         ;2396
000020  6808              LDR      r0,[r1,#0]            ;2399
000022  68c2              LDR      r2,[r0,#0xc]          ;2399
000024  f022020c          BIC      r2,r2,#0xc            ;2402
000028  f0420208          ORR      r2,r2,#8              ;2405
00002c  6808              LDR      r0,[r1,#0]            ;2408
00002e  60c2              STR      r2,[r0,#0xc]          ;2408
000030  2020              MOVS     r0,#0x20              ;2410
000032  f8810039          STRB     r0,[r1,#0x39]         ;2410
000036  bf00              NOP                            ;2413
000038  2000              MOVS     r0,#0                 ;2413
00003a  f8810038          STRB     r0,[r1,#0x38]         ;2413
00003e  bf00              NOP                            ;2413
000040  bf00              NOP                            ;2415
000042  e7e5              B        |L2.16|
;;;2417   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;393      */
;;;394    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;395    {
000002  4604              MOV      r4,r0
;;;396      /* Check the UART handle allocation */
;;;397      if (huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;398      {
;;;399        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;400      }
;;;401    
;;;402      /* Check the parameters */
;;;403      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;404      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;405      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;406    
;;;407      if (huart->gState == HAL_UART_STATE_RESET)
;;;408      {
;;;409        /* Allocate lock resource and initialize it */
;;;410        huart->Lock = HAL_UNLOCKED;
;;;411    
;;;412    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;413        UART_InitCallbacksToDefault(huart);
;;;414    
;;;415        if (huart->MspInitCallback == NULL)
;;;416        {
;;;417          huart->MspInitCallback = HAL_UART_MspInit;
;;;418        }
;;;419    
;;;420        /* Init the low level hardware */
;;;421        huart->MspInitCallback(huart);
;;;422    #else
;;;423        /* Init the low level hardware : GPIO, CLOCK */
;;;424        HAL_UART_MspInit(huart);
;;;425    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;426      }
;;;427    
;;;428      huart->gState = HAL_UART_STATE_BUSY;
;;;429    
;;;430      /* Disable the peripheral */
;;;431      __HAL_UART_DISABLE(huart);
;;;432    
;;;433      /* Set the UART Communication parameters */
;;;434      UART_SetConfig(huart);
;;;435    
;;;436      /* In half-duplex mode, the following bits must be kept cleared:
;;;437         - LINEN and CLKEN bits in the USART_CR2 register,
;;;438         - SCEN and IREN bits in the USART_CR3 register.*/
;;;439      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;440      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;441    
;;;442      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;443      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;444    
;;;445      /* Enable the peripheral */
;;;446      __HAL_UART_ENABLE(huart);
;;;447    
;;;448      /* Initialize the UART state*/
;;;449      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;450      huart->gState = HAL_UART_STATE_READY;
;;;451      huart->RxState = HAL_UART_STATE_READY;
;;;452    
;;;453      return HAL_OK;
;;;454    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f8940039          LDRB     r0,[r4,#0x39]         ;407
00000e  b928              CBNZ     r0,|L3.28|
000010  2000              MOVS     r0,#0                 ;410
000012  f8840038          STRB     r0,[r4,#0x38]         ;410
000016  4620              MOV      r0,r4                 ;424
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L3.28|
00001c  2024              MOVS     r0,#0x24              ;428
00001e  f8840039          STRB     r0,[r4,#0x39]         ;428
000022  6820              LDR      r0,[r4,#0]            ;431
000024  68c0              LDR      r0,[r0,#0xc]          ;431
000026  f4205000          BIC      r0,r0,#0x2000         ;431
00002a  6821              LDR      r1,[r4,#0]            ;431
00002c  60c8              STR      r0,[r1,#0xc]          ;431
00002e  4620              MOV      r0,r4                 ;434
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;439
000036  6900              LDR      r0,[r0,#0x10]         ;439
000038  f4204090          BIC      r0,r0,#0x4800         ;439
00003c  6821              LDR      r1,[r4,#0]            ;439
00003e  6108              STR      r0,[r1,#0x10]         ;439
000040  6820              LDR      r0,[r4,#0]            ;440
000042  6940              LDR      r0,[r0,#0x14]         ;440
000044  f0200022          BIC      r0,r0,#0x22           ;440
000048  6821              LDR      r1,[r4,#0]            ;440
00004a  6148              STR      r0,[r1,#0x14]         ;440
00004c  6820              LDR      r0,[r4,#0]            ;443
00004e  6940              LDR      r0,[r0,#0x14]         ;443
000050  f0400008          ORR      r0,r0,#8              ;443
000054  6821              LDR      r1,[r4,#0]            ;443
000056  6148              STR      r0,[r1,#0x14]         ;443
000058  6820              LDR      r0,[r4,#0]            ;446
00005a  68c0              LDR      r0,[r0,#0xc]          ;446
00005c  f4405000          ORR      r0,r0,#0x2000         ;446
000060  6821              LDR      r1,[r4,#0]            ;446
000062  60c8              STR      r0,[r1,#0xc]          ;446
000064  2000              MOVS     r0,#0                 ;449
000066  63e0              STR      r0,[r4,#0x3c]         ;449
000068  2020              MOVS     r0,#0x20              ;450
00006a  f8840039          STRB     r0,[r4,#0x39]         ;450
00006e  f884003a          STRB     r0,[r4,#0x3a]         ;451
000072  2000              MOVS     r0,#0                 ;453
000074  e7c8              B        |L3.8|
;;;455    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;466      */
;;;467    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;468    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;469      /* Check the UART handle allocation */
;;;470      if (huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;471      {
;;;472        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;473      }
;;;474    
;;;475      /* Check the LIN UART instance */
;;;476      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;477    
;;;478      /* Check the Break detection length parameter */
;;;479      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;480      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;481      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;482    
;;;483      if (huart->gState == HAL_UART_STATE_RESET)
;;;484      {
;;;485        /* Allocate lock resource and initialize it */
;;;486        huart->Lock = HAL_UNLOCKED;
;;;487    
;;;488    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;489        UART_InitCallbacksToDefault(huart);
;;;490    
;;;491        if (huart->MspInitCallback == NULL)
;;;492        {
;;;493          huart->MspInitCallback = HAL_UART_MspInit;
;;;494        }
;;;495    
;;;496        /* Init the low level hardware */
;;;497        huart->MspInitCallback(huart);
;;;498    #else
;;;499        /* Init the low level hardware : GPIO, CLOCK */
;;;500        HAL_UART_MspInit(huart);
;;;501    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;502      }
;;;503    
;;;504      huart->gState = HAL_UART_STATE_BUSY;
;;;505    
;;;506      /* Disable the peripheral */
;;;507      __HAL_UART_DISABLE(huart);
;;;508    
;;;509      /* Set the UART Communication parameters */
;;;510      UART_SetConfig(huart);
;;;511    
;;;512      /* In LIN mode, the following bits must be kept cleared:
;;;513         - CLKEN bits in the USART_CR2 register,
;;;514         - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
;;;515      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
;;;516      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;517    
;;;518      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;519      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;520    
;;;521      /* Set the USART LIN Break detection length. */
;;;522      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;523      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;524    
;;;525      /* Enable the peripheral */
;;;526      __HAL_UART_ENABLE(huart);
;;;527    
;;;528      /* Initialize the UART state*/
;;;529      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;530      huart->gState = HAL_UART_STATE_READY;
;;;531      huart->RxState = HAL_UART_STATE_READY;
;;;532    
;;;533      return HAL_OK;
;;;534    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  f8940039          LDRB     r0,[r4,#0x39]         ;483
000010  b928              CBNZ     r0,|L4.30|
000012  2000              MOVS     r0,#0                 ;486
000014  f8840038          STRB     r0,[r4,#0x38]         ;486
000018  4620              MOV      r0,r4                 ;500
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L4.30|
00001e  2024              MOVS     r0,#0x24              ;504
000020  f8840039          STRB     r0,[r4,#0x39]         ;504
000024  6820              LDR      r0,[r4,#0]            ;507
000026  68c0              LDR      r0,[r0,#0xc]          ;507
000028  f4205000          BIC      r0,r0,#0x2000         ;507
00002c  6821              LDR      r1,[r4,#0]            ;507
00002e  60c8              STR      r0,[r1,#0xc]          ;507
000030  4620              MOV      r0,r4                 ;510
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;515
000038  6900              LDR      r0,[r0,#0x10]         ;515
00003a  f4206000          BIC      r0,r0,#0x800          ;515
00003e  6821              LDR      r1,[r4,#0]            ;515
000040  6108              STR      r0,[r1,#0x10]         ;515
000042  6820              LDR      r0,[r4,#0]            ;516
000044  6940              LDR      r0,[r0,#0x14]         ;516
000046  f020002a          BIC      r0,r0,#0x2a           ;516
00004a  6821              LDR      r1,[r4,#0]            ;516
00004c  6148              STR      r0,[r1,#0x14]         ;516
00004e  6820              LDR      r0,[r4,#0]            ;519
000050  6900              LDR      r0,[r0,#0x10]         ;519
000052  f4404080          ORR      r0,r0,#0x4000         ;519
000056  6821              LDR      r1,[r4,#0]            ;519
000058  6108              STR      r0,[r1,#0x10]         ;519
00005a  6820              LDR      r0,[r4,#0]            ;522
00005c  6900              LDR      r0,[r0,#0x10]         ;522
00005e  f0200020          BIC      r0,r0,#0x20           ;522
000062  6821              LDR      r1,[r4,#0]            ;522
000064  6108              STR      r0,[r1,#0x10]         ;522
000066  6820              LDR      r0,[r4,#0]            ;523
000068  6900              LDR      r0,[r0,#0x10]         ;523
00006a  4328              ORRS     r0,r0,r5              ;523
00006c  6821              LDR      r1,[r4,#0]            ;523
00006e  6108              STR      r0,[r1,#0x10]         ;523
000070  6820              LDR      r0,[r4,#0]            ;526
000072  68c0              LDR      r0,[r0,#0xc]          ;526
000074  f4405000          ORR      r0,r0,#0x2000         ;526
000078  6821              LDR      r1,[r4,#0]            ;526
00007a  60c8              STR      r0,[r1,#0xc]          ;526
00007c  2000              MOVS     r0,#0                 ;529
00007e  63e0              STR      r0,[r4,#0x3c]         ;529
000080  2020              MOVS     r0,#0x20              ;530
000082  f8840039          STRB     r0,[r4,#0x39]         ;530
000086  f884003a          STRB     r0,[r4,#0x3a]         ;531
00008a  2000              MOVS     r0,#0                 ;533
00008c  e7bd              B        |L4.10|
;;;535    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2307     */
;;;2308   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2309   {
;;;2310     /* Check the parameters */
;;;2311     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2312   
;;;2313     /* Process Locked */
;;;2314     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2315   
;;;2316     huart->gState = HAL_UART_STATE_BUSY;
;;;2317   
;;;2318     /* Send break characters */
;;;2319     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;2320   
;;;2321     huart->gState = HAL_UART_STATE_READY;
;;;2322   
;;;2323     /* Process Unlocked */
;;;2324     __HAL_UNLOCK(huart);
;;;2325   
;;;2326     return HAL_OK;
;;;2327   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2314
000012  f8810038          STRB     r0,[r1,#0x38]         ;2314
000016  bf00              NOP                            ;2314
000018  2024              MOVS     r0,#0x24              ;2316
00001a  f8810039          STRB     r0,[r1,#0x39]         ;2316
00001e  6808              LDR      r0,[r1,#0]            ;2319
000020  68c0              LDR      r0,[r0,#0xc]          ;2319
000022  f0400001          ORR      r0,r0,#1              ;2319
000026  680a              LDR      r2,[r1,#0]            ;2319
000028  60d0              STR      r0,[r2,#0xc]          ;2319
00002a  2020              MOVS     r0,#0x20              ;2321
00002c  f8810039          STRB     r0,[r1,#0x39]         ;2321
000030  bf00              NOP                            ;2324
000032  2000              MOVS     r0,#0                 ;2324
000034  f8810038          STRB     r0,[r1,#0x38]         ;2324
000038  bf00              NOP                            ;2324
00003a  bf00              NOP                            ;2326
00003c  e7e7              B        |L5.14|
;;;2328   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2334     */
;;;2335   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2336   {
;;;2337     /* Check the parameters */
;;;2338     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2339   
;;;2340     /* Process Locked */
;;;2341     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;2342   
;;;2343     huart->gState = HAL_UART_STATE_BUSY;
;;;2344   
;;;2345     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;2346     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2347   
;;;2348     huart->gState = HAL_UART_STATE_READY;
;;;2349   
;;;2350     /* Process Unlocked */
;;;2351     __HAL_UNLOCK(huart);
;;;2352   
;;;2353     return HAL_OK;
;;;2354   }
00000e  4770              BX       lr
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;2341
000012  f8810038          STRB     r0,[r1,#0x38]         ;2341
000016  bf00              NOP                            ;2341
000018  2024              MOVS     r0,#0x24              ;2343
00001a  f8810039          STRB     r0,[r1,#0x39]         ;2343
00001e  6808              LDR      r0,[r1,#0]            ;2346
000020  68c0              LDR      r0,[r0,#0xc]          ;2346
000022  f0400002          ORR      r0,r0,#2              ;2346
000026  680a              LDR      r2,[r1,#0]            ;2346
000028  60d0              STR      r0,[r2,#0xc]          ;2346
00002a  2020              MOVS     r0,#0x20              ;2348
00002c  f8810039          STRB     r0,[r1,#0x39]         ;2348
000030  bf00              NOP                            ;2351
000032  2000              MOVS     r0,#0                 ;2351
000034  f8810038          STRB     r0,[r1,#0x38]         ;2351
000038  bf00              NOP                            ;2351
00003a  bf00              NOP                            ;2353
00003c  e7e7              B        |L6.14|
;;;2355   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;2361     */
;;;2362   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2363   {
;;;2364     /* Check the parameters */
;;;2365     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2366   
;;;2367     /* Process Locked */
;;;2368     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;2369   
;;;2370     huart->gState = HAL_UART_STATE_BUSY;
;;;2371   
;;;2372     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;2373     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2374   
;;;2375     huart->gState = HAL_UART_STATE_READY;
;;;2376   
;;;2377     /* Process Unlocked */
;;;2378     __HAL_UNLOCK(huart);
;;;2379   
;;;2380     return HAL_OK;
;;;2381   }
00000e  4770              BX       lr
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;2368
000012  f8810038          STRB     r0,[r1,#0x38]         ;2368
000016  bf00              NOP                            ;2368
000018  2024              MOVS     r0,#0x24              ;2370
00001a  f8810039          STRB     r0,[r1,#0x39]         ;2370
00001e  6808              LDR      r0,[r1,#0]            ;2373
000020  68c0              LDR      r0,[r0,#0xc]          ;2373
000022  f0200002          BIC      r0,r0,#2              ;2373
000026  680a              LDR      r2,[r1,#0]            ;2373
000028  60d0              STR      r0,[r2,#0xc]          ;2373
00002a  2020              MOVS     r0,#0x20              ;2375
00002c  f8810039          STRB     r0,[r1,#0x39]         ;2375
000030  bf00              NOP                            ;2378
000032  2000              MOVS     r0,#0                 ;2378
000034  f8810038          STRB     r0,[r1,#0x38]         ;2378
000038  bf00              NOP                            ;2378
00003a  bf00              NOP                            ;2380
00003c  e7e7              B        |L7.14|
;;;2382   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;547      */
;;;548    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;549    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;550      /* Check the UART handle allocation */
;;;551      if (huart == NULL)
000008  b90c              CBNZ     r4,|L8.14|
;;;552      {
;;;553        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;554      }
;;;555    
;;;556      /* Check the parameters */
;;;557      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;558    
;;;559      /* Check the Address & wake up method parameters */
;;;560      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;561      assert_param(IS_UART_ADDRESS(Address));
;;;562      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;563      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;564    
;;;565      if (huart->gState == HAL_UART_STATE_RESET)
;;;566      {
;;;567        /* Allocate lock resource and initialize it */
;;;568        huart->Lock = HAL_UNLOCKED;
;;;569    
;;;570    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;571        UART_InitCallbacksToDefault(huart);
;;;572    
;;;573        if (huart->MspInitCallback == NULL)
;;;574        {
;;;575          huart->MspInitCallback = HAL_UART_MspInit;
;;;576        }
;;;577    
;;;578        /* Init the low level hardware */
;;;579        huart->MspInitCallback(huart);
;;;580    #else
;;;581        /* Init the low level hardware : GPIO, CLOCK */
;;;582        HAL_UART_MspInit(huart);
;;;583    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;584      }
;;;585    
;;;586      huart->gState = HAL_UART_STATE_BUSY;
;;;587    
;;;588      /* Disable the peripheral */
;;;589      __HAL_UART_DISABLE(huart);
;;;590    
;;;591      /* Set the UART Communication parameters */
;;;592      UART_SetConfig(huart);
;;;593    
;;;594      /* In Multi-Processor mode, the following bits must be kept cleared:
;;;595         - LINEN and CLKEN bits in the USART_CR2 register,
;;;596         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;597      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;598      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;599    
;;;600      /* Set the USART address node */
;;;601      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;602      SET_BIT(huart->Instance->CR2, Address);
;;;603    
;;;604      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;605      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;606      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;607    
;;;608      /* Enable the peripheral */
;;;609      __HAL_UART_ENABLE(huart);
;;;610    
;;;611      /* Initialize the UART state */
;;;612      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;613      huart->gState = HAL_UART_STATE_READY;
;;;614      huart->RxState = HAL_UART_STATE_READY;
;;;615    
;;;616      return HAL_OK;
;;;617    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  f8940039          LDRB     r0,[r4,#0x39]         ;565
000012  b928              CBNZ     r0,|L8.32|
000014  2000              MOVS     r0,#0                 ;568
000016  f8840038          STRB     r0,[r4,#0x38]         ;568
00001a  4620              MOV      r0,r4                 ;582
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L8.32|
000020  2024              MOVS     r0,#0x24              ;586
000022  f8840039          STRB     r0,[r4,#0x39]         ;586
000026  6820              LDR      r0,[r4,#0]            ;589
000028  68c0              LDR      r0,[r0,#0xc]          ;589
00002a  f4205000          BIC      r0,r0,#0x2000         ;589
00002e  6821              LDR      r1,[r4,#0]            ;589
000030  60c8              STR      r0,[r1,#0xc]          ;589
000032  4620              MOV      r0,r4                 ;592
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;597
00003a  6900              LDR      r0,[r0,#0x10]         ;597
00003c  f4204090          BIC      r0,r0,#0x4800         ;597
000040  6821              LDR      r1,[r4,#0]            ;597
000042  6108              STR      r0,[r1,#0x10]         ;597
000044  6820              LDR      r0,[r4,#0]            ;598
000046  6940              LDR      r0,[r0,#0x14]         ;598
000048  f020002a          BIC      r0,r0,#0x2a           ;598
00004c  6821              LDR      r1,[r4,#0]            ;598
00004e  6148              STR      r0,[r1,#0x14]         ;598
000050  6820              LDR      r0,[r4,#0]            ;601
000052  6900              LDR      r0,[r0,#0x10]         ;601
000054  f020000f          BIC      r0,r0,#0xf            ;601
000058  6821              LDR      r1,[r4,#0]            ;601
00005a  6108              STR      r0,[r1,#0x10]         ;601
00005c  6820              LDR      r0,[r4,#0]            ;602
00005e  6900              LDR      r0,[r0,#0x10]         ;602
000060  4328              ORRS     r0,r0,r5              ;602
000062  6821              LDR      r1,[r4,#0]            ;602
000064  6108              STR      r0,[r1,#0x10]         ;602
000066  6820              LDR      r0,[r4,#0]            ;605
000068  68c0              LDR      r0,[r0,#0xc]          ;605
00006a  f4206000          BIC      r0,r0,#0x800          ;605
00006e  6821              LDR      r1,[r4,#0]            ;605
000070  60c8              STR      r0,[r1,#0xc]          ;605
000072  6820              LDR      r0,[r4,#0]            ;606
000074  68c0              LDR      r0,[r0,#0xc]          ;606
000076  4330              ORRS     r0,r0,r6              ;606
000078  6821              LDR      r1,[r4,#0]            ;606
00007a  60c8              STR      r0,[r1,#0xc]          ;606
00007c  6820              LDR      r0,[r4,#0]            ;609
00007e  68c0              LDR      r0,[r0,#0xc]          ;609
000080  f4405000          ORR      r0,r0,#0x2000         ;609
000084  6821              LDR      r1,[r4,#0]            ;609
000086  60c8              STR      r0,[r1,#0xc]          ;609
000088  2000              MOVS     r0,#0                 ;612
00008a  63e0              STR      r0,[r4,#0x3c]         ;612
00008c  2020              MOVS     r0,#0x20              ;613
00008e  f8840039          STRB     r0,[r4,#0x39]         ;613
000092  f884003a          STRB     r0,[r4,#0x3a]         ;614
000096  2000              MOVS     r0,#0                 ;616
000098  e7b8              B        |L8.12|
;;;618    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1556   */
;;;1557   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1558   {
000002  4604              MOV      r4,r0
;;;1559     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1560     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f42070f0          BIC      r0,r0,#0x1e0
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1561     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1562   
;;;1563     /* Disable the UART DMA Tx request if enabled */
;;;1564     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0000080          AND      r0,r0,#0x80
000024  2880              CMP      r0,#0x80
000026  d117              BNE      |L9.88|
;;;1565     {
;;;1566       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000028  6820              LDR      r0,[r4,#0]
00002a  6940              LDR      r0,[r0,#0x14]
00002c  f0200080          BIC      r0,r0,#0x80
000030  6821              LDR      r1,[r4,#0]
000032  6148              STR      r0,[r1,#0x14]
;;;1567   
;;;1568       /* Abort the UART DMA Tx stream: use blocking DMA Abort API (no callback) */
;;;1569       if (huart->hdmatx != NULL)
000034  6b20              LDR      r0,[r4,#0x30]
000036  b178              CBZ      r0,|L9.88|
;;;1570       {
;;;1571         /* Set the UART DMA Abort callback to Null.
;;;1572            No call back execution at end of DMA abort procedure */
;;;1573         huart->hdmatx->XferAbortCallback = NULL;
000038  2000              MOVS     r0,#0
00003a  6b21              LDR      r1,[r4,#0x30]
00003c  6508              STR      r0,[r1,#0x50]
;;;1574   
;;;1575         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
00003e  6b20              LDR      r0,[r4,#0x30]
000040  f7fffffe          BL       HAL_DMA_Abort
000044  b140              CBZ      r0,|L9.88|
;;;1576         {
;;;1577           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
000046  6b20              LDR      r0,[r4,#0x30]
000048  f7fffffe          BL       HAL_DMA_GetError
00004c  2820              CMP      r0,#0x20
00004e  d103              BNE      |L9.88|
;;;1578           {
;;;1579             /* Set error code to DMA */
;;;1580             huart->ErrorCode = HAL_UART_ERROR_DMA;
000050  2010              MOVS     r0,#0x10
000052  63e0              STR      r0,[r4,#0x3c]
;;;1581   
;;;1582             return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L9.86|
;;;1583           }
;;;1584         }
;;;1585       }
;;;1586     }
;;;1587   
;;;1588     /* Disable the UART DMA Rx request if enabled */
;;;1589     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1590     {
;;;1591       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1592   
;;;1593       /* Abort the UART DMA Rx stream: use blocking DMA Abort API (no callback) */
;;;1594       if (huart->hdmarx != NULL)
;;;1595       {
;;;1596         /* Set the UART DMA Abort callback to Null.
;;;1597            No call back execution at end of DMA abort procedure */
;;;1598         huart->hdmarx->XferAbortCallback = NULL;
;;;1599   
;;;1600         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
;;;1601         {
;;;1602           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
;;;1603           {
;;;1604             /* Set error code to DMA */
;;;1605             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1606   
;;;1607             return HAL_TIMEOUT;
;;;1608           }
;;;1609         }
;;;1610       }
;;;1611     }
;;;1612   
;;;1613     /* Reset Tx and Rx transfer counters */
;;;1614     huart->TxXferCount = 0x00U;
;;;1615     huart->RxXferCount = 0x00U;
;;;1616   
;;;1617     /* Reset ErrorCode */
;;;1618     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1619   
;;;1620     /* Restore huart->RxState and huart->gState to Ready */
;;;1621     huart->RxState = HAL_UART_STATE_READY;
;;;1622     huart->gState = HAL_UART_STATE_READY;
;;;1623   
;;;1624     return HAL_OK;
;;;1625   }
000056  bd10              POP      {r4,pc}
                  |L9.88|
000058  6820              LDR      r0,[r4,#0]            ;1589
00005a  6940              LDR      r0,[r0,#0x14]         ;1589
00005c  f0000040          AND      r0,r0,#0x40           ;1589
000060  2840              CMP      r0,#0x40              ;1589
000062  d117              BNE      |L9.148|
000064  6820              LDR      r0,[r4,#0]            ;1591
000066  6940              LDR      r0,[r0,#0x14]         ;1591
000068  f0200040          BIC      r0,r0,#0x40           ;1591
00006c  6821              LDR      r1,[r4,#0]            ;1591
00006e  6148              STR      r0,[r1,#0x14]         ;1591
000070  6b60              LDR      r0,[r4,#0x34]         ;1594
000072  b178              CBZ      r0,|L9.148|
000074  2000              MOVS     r0,#0                 ;1598
000076  6b61              LDR      r1,[r4,#0x34]         ;1598
000078  6508              STR      r0,[r1,#0x50]         ;1598
00007a  6b60              LDR      r0,[r4,#0x34]         ;1600
00007c  f7fffffe          BL       HAL_DMA_Abort
000080  b140              CBZ      r0,|L9.148|
000082  6b60              LDR      r0,[r4,#0x34]         ;1602
000084  f7fffffe          BL       HAL_DMA_GetError
000088  2820              CMP      r0,#0x20              ;1602
00008a  d103              BNE      |L9.148|
00008c  2010              MOVS     r0,#0x10              ;1605
00008e  63e0              STR      r0,[r4,#0x3c]         ;1605
000090  2003              MOVS     r0,#3                 ;1607
000092  e7e0              B        |L9.86|
                  |L9.148|
000094  2000              MOVS     r0,#0                 ;1614
000096  84e0              STRH     r0,[r4,#0x26]         ;1614
000098  85e0              STRH     r0,[r4,#0x2e]         ;1615
00009a  63e0              STR      r0,[r4,#0x3c]         ;1618
00009c  2020              MOVS     r0,#0x20              ;1621
00009e  f884003a          STRB     r0,[r4,#0x3a]         ;1621
0000a2  f8840039          STRB     r0,[r4,#0x39]         ;1622
0000a6  2000              MOVS     r0,#0                 ;1624
0000a8  e7d5              B        |L9.86|
;;;1626   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2238     */
;;;2239   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2240   {
;;;2241     /* Prevent unused argument(s) compilation warning */
;;;2242     UNUSED(huart);
;;;2243   
;;;2244     /* NOTE : This function should not be modified, when the callback is needed,
;;;2245               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2246      */
;;;2247   }
;;;2248   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1689   */
;;;1690   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1691   {
000002  4604              MOV      r4,r0
;;;1692     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1693     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f4207090          BIC      r0,r0,#0x120
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1694     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1695   
;;;1696     /* Disable the UART DMA Rx request if enabled */
;;;1697     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0000040          AND      r0,r0,#0x40
000024  2840              CMP      r0,#0x40
000026  d117              BNE      |L11.88|
;;;1698     {
;;;1699       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6820              LDR      r0,[r4,#0]
00002a  6940              LDR      r0,[r0,#0x14]
00002c  f0200040          BIC      r0,r0,#0x40
000030  6821              LDR      r1,[r4,#0]
000032  6148              STR      r0,[r1,#0x14]
;;;1700   
;;;1701       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;1702       if (huart->hdmarx != NULL)
000034  6b60              LDR      r0,[r4,#0x34]
000036  b178              CBZ      r0,|L11.88|
;;;1703       {
;;;1704         /* Set the UART DMA Abort callback to Null.
;;;1705            No call back execution at end of DMA abort procedure */
;;;1706         huart->hdmarx->XferAbortCallback = NULL;
000038  2000              MOVS     r0,#0
00003a  6b61              LDR      r1,[r4,#0x34]
00003c  6508              STR      r0,[r1,#0x50]
;;;1707   
;;;1708         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
00003e  6b60              LDR      r0,[r4,#0x34]
000040  f7fffffe          BL       HAL_DMA_Abort
000044  b140              CBZ      r0,|L11.88|
;;;1709         {
;;;1710           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
000046  6b60              LDR      r0,[r4,#0x34]
000048  f7fffffe          BL       HAL_DMA_GetError
00004c  2820              CMP      r0,#0x20
00004e  d103              BNE      |L11.88|
;;;1711           {
;;;1712             /* Set error code to DMA */
;;;1713             huart->ErrorCode = HAL_UART_ERROR_DMA;
000050  2010              MOVS     r0,#0x10
000052  63e0              STR      r0,[r4,#0x3c]
;;;1714   
;;;1715             return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L11.86|
;;;1716           }
;;;1717         }
;;;1718       }
;;;1719     }
;;;1720   
;;;1721     /* Reset Rx transfer counter */
;;;1722     huart->RxXferCount = 0x00U;
;;;1723   
;;;1724     /* Restore huart->RxState to Ready */
;;;1725     huart->RxState = HAL_UART_STATE_READY;
;;;1726   
;;;1727     return HAL_OK;
;;;1728   }
000056  bd10              POP      {r4,pc}
                  |L11.88|
000058  2000              MOVS     r0,#0                 ;1722
00005a  85e0              STRH     r0,[r4,#0x2e]         ;1722
00005c  2020              MOVS     r0,#0x20              ;1725
00005e  f884003a          STRB     r0,[r4,#0x3a]         ;1725
000062  2000              MOVS     r0,#0                 ;1727
000064  e7f7              B        |L11.86|
;;;1729   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2268     */
;;;2269   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2270   {
;;;2271     /* Prevent unused argument(s) compilation warning */
;;;2272     UNUSED(huart);
;;;2273   
;;;2274     /* NOTE : This function should not be modified, when the callback is needed,
;;;2275               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2276      */
;;;2277   }
;;;2278   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1948   */
;;;1949   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1950   {
000002  4604              MOV      r4,r0
;;;1951     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1952     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f4207090          BIC      r0,r0,#0x120
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1953     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1954   
;;;1955     /* Disable the UART DMA Rx request if enabled */
;;;1956     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0000040          AND      r0,r0,#0x40
000024  2840              CMP      r0,#0x40
000026  d11b              BNE      |L13.96|
;;;1957     {
;;;1958       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6820              LDR      r0,[r4,#0]
00002a  6940              LDR      r0,[r0,#0x14]
00002c  f0200040          BIC      r0,r0,#0x40
000030  6821              LDR      r1,[r4,#0]
000032  6148              STR      r0,[r1,#0x14]
;;;1959   
;;;1960       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;1961       if (huart->hdmarx != NULL)
000034  6b60              LDR      r0,[r4,#0x34]
000036  b150              CBZ      r0,|L13.78|
;;;1962       {
;;;1963         /* Set the UART DMA Abort callback :
;;;1964            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1965         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
000038  480e              LDR      r0,|L13.116|
00003a  6b61              LDR      r1,[r4,#0x34]
00003c  6508              STR      r0,[r1,#0x50]
;;;1966   
;;;1967         /* Abort DMA RX */
;;;1968         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00003e  6b60              LDR      r0,[r4,#0x34]
000040  f7fffffe          BL       HAL_DMA_Abort_IT
000044  b1a0              CBZ      r0,|L13.112|
;;;1969         {
;;;1970           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1971           huart->hdmarx->XferAbortCallback(huart->hdmarx);
000046  6b60              LDR      r0,[r4,#0x34]
000048  6d01              LDR      r1,[r0,#0x50]
00004a  4788              BLX      r1
00004c  e010              B        |L13.112|
                  |L13.78|
;;;1972         }
;;;1973       }
;;;1974       else
;;;1975       {
;;;1976         /* Reset Rx transfer counter */
;;;1977         huart->RxXferCount = 0x00U;
00004e  2000              MOVS     r0,#0
000050  85e0              STRH     r0,[r4,#0x2e]
;;;1978   
;;;1979         /* Restore huart->RxState to Ready */
;;;1980         huart->RxState = HAL_UART_STATE_READY;
000052  2020              MOVS     r0,#0x20
000054  f884003a          STRB     r0,[r4,#0x3a]
;;;1981   
;;;1982         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1983   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1984         /* Call registered Abort Receive Complete Callback */
;;;1985         huart->AbortReceiveCpltCallback(huart);
;;;1986   #else
;;;1987         /* Call legacy weak Abort Receive Complete Callback */
;;;1988         HAL_UART_AbortReceiveCpltCallback(huart);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
00005e  e007              B        |L13.112|
                  |L13.96|
;;;1989   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1990       }
;;;1991     }
;;;1992     else
;;;1993     {
;;;1994       /* Reset Rx transfer counter */
;;;1995       huart->RxXferCount = 0x00U;
000060  2000              MOVS     r0,#0
000062  85e0              STRH     r0,[r4,#0x2e]
;;;1996   
;;;1997       /* Restore huart->RxState to Ready */
;;;1998       huart->RxState = HAL_UART_STATE_READY;
000064  2020              MOVS     r0,#0x20
000066  f884003a          STRB     r0,[r4,#0x3a]
;;;1999   
;;;2000       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2001   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2002       /* Call registered Abort Receive Complete Callback */
;;;2003       huart->AbortReceiveCpltCallback(huart);
;;;2004   #else
;;;2005       /* Call legacy weak Abort Receive Complete Callback */
;;;2006       HAL_UART_AbortReceiveCpltCallback(huart);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.112|
;;;2007   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2008     }
;;;2009   
;;;2010     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;2011   }
000072  bd10              POP      {r4,pc}
;;;2012   
                          ENDP

                  |L13.116|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1638   */
;;;1639   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1640   {
000002  4604              MOV      r4,r0
;;;1641     /* Disable TXEIE and TCIE interrupts */
;;;1642     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f02000c0          BIC      r0,r0,#0xc0
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1643   
;;;1644     /* Disable the UART DMA Tx request if enabled */
;;;1645     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0000080          AND      r0,r0,#0x80
000018  2880              CMP      r0,#0x80
00001a  d117              BNE      |L14.76|
;;;1646     {
;;;1647       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6148              STR      r0,[r1,#0x14]
;;;1648   
;;;1649       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;1650       if (huart->hdmatx != NULL)
000028  6b20              LDR      r0,[r4,#0x30]
00002a  b178              CBZ      r0,|L14.76|
;;;1651       {
;;;1652         /* Set the UART DMA Abort callback to Null.
;;;1653            No call back execution at end of DMA abort procedure */
;;;1654         huart->hdmatx->XferAbortCallback = NULL;
00002c  2000              MOVS     r0,#0
00002e  6b21              LDR      r1,[r4,#0x30]
000030  6508              STR      r0,[r1,#0x50]
;;;1655   
;;;1656         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000032  6b20              LDR      r0,[r4,#0x30]
000034  f7fffffe          BL       HAL_DMA_Abort
000038  b140              CBZ      r0,|L14.76|
;;;1657         {
;;;1658           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
00003a  6b20              LDR      r0,[r4,#0x30]
00003c  f7fffffe          BL       HAL_DMA_GetError
000040  2820              CMP      r0,#0x20
000042  d103              BNE      |L14.76|
;;;1659           {
;;;1660             /* Set error code to DMA */
;;;1661             huart->ErrorCode = HAL_UART_ERROR_DMA;
000044  2010              MOVS     r0,#0x10
000046  63e0              STR      r0,[r4,#0x3c]
;;;1662   
;;;1663             return HAL_TIMEOUT;
000048  2003              MOVS     r0,#3
                  |L14.74|
;;;1664           }
;;;1665         }
;;;1666       }
;;;1667     }
;;;1668   
;;;1669     /* Reset Tx transfer counter */
;;;1670     huart->TxXferCount = 0x00U;
;;;1671   
;;;1672     /* Restore huart->gState to Ready */
;;;1673     huart->gState = HAL_UART_STATE_READY;
;;;1674   
;;;1675     return HAL_OK;
;;;1676   }
00004a  bd10              POP      {r4,pc}
                  |L14.76|
00004c  2000              MOVS     r0,#0                 ;1670
00004e  84e0              STRH     r0,[r4,#0x26]         ;1670
000050  2020              MOVS     r0,#0x20              ;1673
000052  f8840039          STRB     r0,[r4,#0x39]         ;1673
000056  2000              MOVS     r0,#0                 ;1675
000058  e7f7              B        |L14.74|
;;;1677   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2253     */
;;;2254   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2255   {
;;;2256     /* Prevent unused argument(s) compilation warning */
;;;2257     UNUSED(huart);
;;;2258   
;;;2259     /* NOTE : This function should not be modified, when the callback is needed,
;;;2260               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2261      */
;;;2262   }
;;;2263   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1871   */
;;;1872   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1873   {
000002  4604              MOV      r4,r0
;;;1874     /* Disable TXEIE and TCIE interrupts */
;;;1875     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f02000c0          BIC      r0,r0,#0xc0
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1876   
;;;1877     /* Disable the UART DMA Tx request if enabled */
;;;1878     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0000080          AND      r0,r0,#0x80
000018  2880              CMP      r0,#0x80
00001a  d11b              BNE      |L16.84|
;;;1879     {
;;;1880       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6148              STR      r0,[r1,#0x14]
;;;1881   
;;;1882       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;1883       if (huart->hdmatx != NULL)
000028  6b20              LDR      r0,[r4,#0x30]
00002a  b150              CBZ      r0,|L16.66|
;;;1884       {
;;;1885         /* Set the UART DMA Abort callback :
;;;1886            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1887         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
00002c  480e              LDR      r0,|L16.104|
00002e  6b21              LDR      r1,[r4,#0x30]
000030  6508              STR      r0,[r1,#0x50]
;;;1888   
;;;1889         /* Abort DMA TX */
;;;1890         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000032  6b20              LDR      r0,[r4,#0x30]
000034  f7fffffe          BL       HAL_DMA_Abort_IT
000038  b1a0              CBZ      r0,|L16.100|
;;;1891         {
;;;1892           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1893           huart->hdmatx->XferAbortCallback(huart->hdmatx);
00003a  6b20              LDR      r0,[r4,#0x30]
00003c  6d01              LDR      r1,[r0,#0x50]
00003e  4788              BLX      r1
000040  e010              B        |L16.100|
                  |L16.66|
;;;1894         }
;;;1895       }
;;;1896       else
;;;1897       {
;;;1898         /* Reset Tx transfer counter */
;;;1899         huart->TxXferCount = 0x00U;
000042  2000              MOVS     r0,#0
000044  84e0              STRH     r0,[r4,#0x26]
;;;1900   
;;;1901         /* Restore huart->gState to Ready */
;;;1902         huart->gState = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  f8840039          STRB     r0,[r4,#0x39]
;;;1903   
;;;1904         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1905   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1906         /* Call registered Abort Transmit Complete Callback */
;;;1907         huart->AbortTransmitCpltCallback(huart);
;;;1908   #else
;;;1909         /* Call legacy weak Abort Transmit Complete Callback */
;;;1910         HAL_UART_AbortTransmitCpltCallback(huart);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
000052  e007              B        |L16.100|
                  |L16.84|
;;;1911   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1912       }
;;;1913     }
;;;1914     else
;;;1915     {
;;;1916       /* Reset Tx transfer counter */
;;;1917       huart->TxXferCount = 0x00U;
000054  2000              MOVS     r0,#0
000056  84e0              STRH     r0,[r4,#0x26]
;;;1918   
;;;1919       /* Restore huart->gState to Ready */
;;;1920       huart->gState = HAL_UART_STATE_READY;
000058  2020              MOVS     r0,#0x20
00005a  f8840039          STRB     r0,[r4,#0x39]
;;;1921   
;;;1922       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1923   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1924       /* Call registered Abort Transmit Complete Callback */
;;;1925       huart->AbortTransmitCpltCallback(huart);
;;;1926   #else
;;;1927       /* Call legacy weak Abort Transmit Complete Callback */
;;;1928       HAL_UART_AbortTransmitCpltCallback(huart);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.100|
;;;1929   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1930     }
;;;1931   
;;;1932     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1933   }
000066  bd10              POP      {r4,pc}
;;;1934   
                          ENDP

                  |L16.104|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1743   */
;;;1744   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1745   {
000002  4604              MOV      r4,r0
;;;1746     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;1747   
;;;1748     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1749     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f42070f0          BIC      r0,r0,#0x1e0
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;1750     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6940              LDR      r0,[r0,#0x14]
000016  f0200001          BIC      r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6148              STR      r0,[r1,#0x14]
;;;1751   
;;;1752     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1753        before any call to DMA Abort functions */
;;;1754     /* DMA Tx Handle is valid */
;;;1755     if (huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b160              CBZ      r0,|L17.60|
;;;1756     {
;;;1757       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1758          Otherwise, set it to NULL */
;;;1759       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d103              BNE      |L17.54|
;;;1760       {
;;;1761         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002e  482a              LDR      r0,|L17.216|
000030  6b21              LDR      r1,[r4,#0x30]
000032  6508              STR      r0,[r1,#0x50]
000034  e002              B        |L17.60|
                  |L17.54|
;;;1762       }
;;;1763       else
;;;1764       {
;;;1765         huart->hdmatx->XferAbortCallback = NULL;
000036  2000              MOVS     r0,#0
000038  6b21              LDR      r1,[r4,#0x30]
00003a  6508              STR      r0,[r1,#0x50]
                  |L17.60|
;;;1766       }
;;;1767     }
;;;1768     /* DMA Rx Handle is valid */
;;;1769     if (huart->hdmarx != NULL)
00003c  6b60              LDR      r0,[r4,#0x34]
00003e  b160              CBZ      r0,|L17.90|
;;;1770     {
;;;1771       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1772          Otherwise, set it to NULL */
;;;1773       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000040  6820              LDR      r0,[r4,#0]
000042  6940              LDR      r0,[r0,#0x14]
000044  f0000040          AND      r0,r0,#0x40
000048  2840              CMP      r0,#0x40
00004a  d103              BNE      |L17.84|
;;;1774       {
;;;1775         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00004c  4823              LDR      r0,|L17.220|
00004e  6b61              LDR      r1,[r4,#0x34]
000050  6508              STR      r0,[r1,#0x50]
000052  e002              B        |L17.90|
                  |L17.84|
;;;1776       }
;;;1777       else
;;;1778       {
;;;1779         huart->hdmarx->XferAbortCallback = NULL;
000054  2000              MOVS     r0,#0
000056  6b61              LDR      r1,[r4,#0x34]
000058  6508              STR      r0,[r1,#0x50]
                  |L17.90|
;;;1780       }
;;;1781     }
;;;1782   
;;;1783     /* Disable the UART DMA Tx request if enabled */
;;;1784     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00005a  6820              LDR      r0,[r4,#0]
00005c  6940              LDR      r0,[r0,#0x14]
00005e  f0000080          AND      r0,r0,#0x80
000062  2880              CMP      r0,#0x80
000064  d110              BNE      |L17.136|
;;;1785     {
;;;1786       /* Disable DMA Tx at UART level */
;;;1787       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000066  6820              LDR      r0,[r4,#0]
000068  6940              LDR      r0,[r0,#0x14]
00006a  f0200080          BIC      r0,r0,#0x80
00006e  6821              LDR      r1,[r4,#0]
000070  6148              STR      r0,[r1,#0x14]
;;;1788   
;;;1789       /* Abort the UART DMA Tx stream : use non blocking DMA Abort API (callback) */
;;;1790       if (huart->hdmatx != NULL)
000072  6b20              LDR      r0,[r4,#0x30]
000074  b140              CBZ      r0,|L17.136|
;;;1791       {
;;;1792         /* UART Tx DMA Abort callback has already been initialised :
;;;1793            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1794   
;;;1795         /* Abort DMA TX */
;;;1796         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000076  6b20              LDR      r0,[r4,#0x30]
000078  f7fffffe          BL       HAL_DMA_Abort_IT
00007c  b118              CBZ      r0,|L17.134|
;;;1797         {
;;;1798           huart->hdmatx->XferAbortCallback = NULL;
00007e  2000              MOVS     r0,#0
000080  6b21              LDR      r1,[r4,#0x30]
000082  6508              STR      r0,[r1,#0x50]
000084  e000              B        |L17.136|
                  |L17.134|
;;;1799         }
;;;1800         else
;;;1801         {
;;;1802           AbortCplt = 0x00U;
000086  2500              MOVS     r5,#0
                  |L17.136|
;;;1803         }
;;;1804       }
;;;1805     }
;;;1806   
;;;1807     /* Disable the UART DMA Rx request if enabled */
;;;1808     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000088  6820              LDR      r0,[r4,#0]
00008a  6940              LDR      r0,[r0,#0x14]
00008c  f0000040          AND      r0,r0,#0x40
000090  2840              CMP      r0,#0x40
000092  d111              BNE      |L17.184|
;;;1809     {
;;;1810       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000094  6820              LDR      r0,[r4,#0]
000096  6940              LDR      r0,[r0,#0x14]
000098  f0200040          BIC      r0,r0,#0x40
00009c  6821              LDR      r1,[r4,#0]
00009e  6148              STR      r0,[r1,#0x14]
;;;1811   
;;;1812       /* Abort the UART DMA Rx stream : use non blocking DMA Abort API (callback) */
;;;1813       if (huart->hdmarx != NULL)
0000a0  6b60              LDR      r0,[r4,#0x34]
0000a2  b148              CBZ      r0,|L17.184|
;;;1814       {
;;;1815         /* UART Rx DMA Abort callback has already been initialised :
;;;1816            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1817   
;;;1818         /* Abort DMA RX */
;;;1819         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000a4  6b60              LDR      r0,[r4,#0x34]
0000a6  f7fffffe          BL       HAL_DMA_Abort_IT
0000aa  b120              CBZ      r0,|L17.182|
;;;1820         {
;;;1821           huart->hdmarx->XferAbortCallback = NULL;
0000ac  2000              MOVS     r0,#0
0000ae  6b61              LDR      r1,[r4,#0x34]
0000b0  6508              STR      r0,[r1,#0x50]
;;;1822           AbortCplt = 0x01U;
0000b2  2501              MOVS     r5,#1
0000b4  e000              B        |L17.184|
                  |L17.182|
;;;1823         }
;;;1824         else
;;;1825         {
;;;1826           AbortCplt = 0x00U;
0000b6  2500              MOVS     r5,#0
                  |L17.184|
;;;1827         }
;;;1828       }
;;;1829     }
;;;1830   
;;;1831     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1832     if (AbortCplt == 0x01U)
0000b8  2d01              CMP      r5,#1
0000ba  d10b              BNE      |L17.212|
;;;1833     {
;;;1834       /* Reset Tx and Rx transfer counters */
;;;1835       huart->TxXferCount = 0x00U;
0000bc  2000              MOVS     r0,#0
0000be  84e0              STRH     r0,[r4,#0x26]
;;;1836       huart->RxXferCount = 0x00U;
0000c0  85e0              STRH     r0,[r4,#0x2e]
;;;1837   
;;;1838       /* Reset ErrorCode */
;;;1839       huart->ErrorCode = HAL_UART_ERROR_NONE;
0000c2  63e0              STR      r0,[r4,#0x3c]
;;;1840   
;;;1841       /* Restore huart->gState and huart->RxState to Ready */
;;;1842       huart->gState  = HAL_UART_STATE_READY;
0000c4  2020              MOVS     r0,#0x20
0000c6  f8840039          STRB     r0,[r4,#0x39]
;;;1843       huart->RxState = HAL_UART_STATE_READY;
0000ca  f884003a          STRB     r0,[r4,#0x3a]
;;;1844   
;;;1845       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1846   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1847       /* Call registered Abort complete callback */
;;;1848       huart->AbortCpltCallback(huart);
;;;1849   #else
;;;1850       /* Call legacy weak Abort complete callback */
;;;1851       HAL_UART_AbortCpltCallback(huart);
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.212|
;;;1852   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1853     }
;;;1854   
;;;1855     return HAL_OK;
0000d4  2000              MOVS     r0,#0
;;;1856   }
0000d6  bd70              POP      {r4-r6,pc}
;;;1857   
                          ENDP

                  |L17.216|
                          DCD      UART_DMATxAbortCallback
                  |L17.220|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1431     */
;;;1432   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1433   {
;;;1434     uint32_t dmarequest = 0x00U;
000002  2200              MOVS     r2,#0
;;;1435   
;;;1436     /* Process Locked */
;;;1437     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L18.18|
00000e  2002              MOVS     r0,#2
                  |L18.16|
;;;1438   
;;;1439     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
;;;1440     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
;;;1441     {
;;;1442       /* Disable the UART DMA Tx request */
;;;1443       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1444     }
;;;1445   
;;;1446     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1447     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1448     {
;;;1449       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1450       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1451       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1452   
;;;1453       /* Disable the UART DMA Rx request */
;;;1454       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1455     }
;;;1456   
;;;1457     /* Process Unlocked */
;;;1458     __HAL_UNLOCK(huart);
;;;1459   
;;;1460     return HAL_OK;
;;;1461   }
000010  4770              BX       lr
                  |L18.18|
000012  2001              MOVS     r0,#1                 ;1437
000014  f8810038          STRB     r0,[r1,#0x38]         ;1437
000018  bf00              NOP                            ;1437
00001a  6808              LDR      r0,[r1,#0]            ;1439
00001c  6940              LDR      r0,[r0,#0x14]         ;1439
00001e  f3c012c0          UBFX     r2,r0,#7,#1           ;1439
000022  f8910039          LDRB     r0,[r1,#0x39]         ;1440
000026  2821              CMP      r0,#0x21              ;1440
000028  d106              BNE      |L18.56|
00002a  b12a              CBZ      r2,|L18.56|
00002c  6808              LDR      r0,[r1,#0]            ;1443
00002e  6940              LDR      r0,[r0,#0x14]         ;1443
000030  f0200080          BIC      r0,r0,#0x80           ;1443
000034  680b              LDR      r3,[r1,#0]            ;1443
000036  6158              STR      r0,[r3,#0x14]         ;1443
                  |L18.56|
000038  6808              LDR      r0,[r1,#0]            ;1446
00003a  6940              LDR      r0,[r0,#0x14]         ;1446
00003c  f3c01280          UBFX     r2,r0,#6,#1           ;1446
000040  f891003a          LDRB     r0,[r1,#0x3a]         ;1447
000044  2822              CMP      r0,#0x22              ;1447
000046  d112              BNE      |L18.110|
000048  b18a              CBZ      r2,|L18.110|
00004a  6808              LDR      r0,[r1,#0]            ;1450
00004c  68c0              LDR      r0,[r0,#0xc]          ;1450
00004e  f4207080          BIC      r0,r0,#0x100          ;1450
000052  680b              LDR      r3,[r1,#0]            ;1450
000054  60d8              STR      r0,[r3,#0xc]          ;1450
000056  6808              LDR      r0,[r1,#0]            ;1451
000058  6940              LDR      r0,[r0,#0x14]         ;1451
00005a  f0200001          BIC      r0,r0,#1              ;1451
00005e  680b              LDR      r3,[r1,#0]            ;1451
000060  6158              STR      r0,[r3,#0x14]         ;1451
000062  6808              LDR      r0,[r1,#0]            ;1454
000064  6940              LDR      r0,[r0,#0x14]         ;1454
000066  f0200040          BIC      r0,r0,#0x40           ;1454
00006a  680b              LDR      r3,[r1,#0]            ;1454
00006c  6158              STR      r0,[r3,#0x14]         ;1454
                  |L18.110|
00006e  bf00              NOP                            ;1458
000070  2000              MOVS     r0,#0                 ;1458
000072  f8810038          STRB     r0,[r1,#0x38]         ;1458
000076  bf00              NOP                            ;1458
000078  bf00              NOP                            ;1460
00007a  e7c9              B        |L18.16|
;;;1462   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1468     */
;;;1469   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1470   {
000002  4601              MOV      r1,r0
;;;1471     /* Process Locked */
;;;1472     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L19.18|
00000e  2002              MOVS     r0,#2
                  |L19.16|
;;;1473   
;;;1474     if (huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1475     {
;;;1476       /* Enable the UART DMA Tx request */
;;;1477       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1478     }
;;;1479   
;;;1480     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1481     {
;;;1482       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1483       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1484   
;;;1485       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1486       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1487       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1488   
;;;1489       /* Enable the UART DMA Rx request */
;;;1490       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1491     }
;;;1492   
;;;1493     /* Process Unlocked */
;;;1494     __HAL_UNLOCK(huart);
;;;1495   
;;;1496     return HAL_OK;
;;;1497   }
000010  bd08              POP      {r3,pc}
                  |L19.18|
000012  2001              MOVS     r0,#1                 ;1472
000014  f8810038          STRB     r0,[r1,#0x38]         ;1472
000018  bf00              NOP                            ;1472
00001a  f8910039          LDRB     r0,[r1,#0x39]         ;1474
00001e  2821              CMP      r0,#0x21              ;1474
000020  d105              BNE      |L19.46|
000022  6808              LDR      r0,[r1,#0]            ;1477
000024  6940              LDR      r0,[r0,#0x14]         ;1477
000026  f0400080          ORR      r0,r0,#0x80           ;1477
00002a  680a              LDR      r2,[r1,#0]            ;1477
00002c  6150              STR      r0,[r2,#0x14]         ;1477
                  |L19.46|
00002e  f891003a          LDRB     r0,[r1,#0x3a]         ;1480
000032  2822              CMP      r0,#0x22              ;1480
000034  d11c              BNE      |L19.112|
000036  bf00              NOP                            ;1483
000038  2000              MOVS     r0,#0                 ;1483
00003a  9000              STR      r0,[sp,#0]            ;1483
00003c  6808              LDR      r0,[r1,#0]            ;1483
00003e  6800              LDR      r0,[r0,#0]            ;1483
000040  9000              STR      r0,[sp,#0]            ;1483
000042  6808              LDR      r0,[r1,#0]            ;1483
000044  6840              LDR      r0,[r0,#4]            ;1483
000046  9000              STR      r0,[sp,#0]            ;1483
000048  bf00              NOP                            ;1483
00004a  bf00              NOP                            ;1483
00004c  6808              LDR      r0,[r1,#0]            ;1486
00004e  68c0              LDR      r0,[r0,#0xc]          ;1486
000050  f4407080          ORR      r0,r0,#0x100          ;1486
000054  680a              LDR      r2,[r1,#0]            ;1486
000056  60d0              STR      r0,[r2,#0xc]          ;1486
000058  6808              LDR      r0,[r1,#0]            ;1487
00005a  6940              LDR      r0,[r0,#0x14]         ;1487
00005c  f0400001          ORR      r0,r0,#1              ;1487
000060  680a              LDR      r2,[r1,#0]            ;1487
000062  6150              STR      r0,[r2,#0x14]         ;1487
000064  6808              LDR      r0,[r1,#0]            ;1490
000066  6940              LDR      r0,[r0,#0x14]         ;1490
000068  f0400040          ORR      r0,r0,#0x40           ;1490
00006c  680a              LDR      r2,[r1,#0]            ;1490
00006e  6150              STR      r0,[r2,#0x14]         ;1490
                  |L19.112|
000070  bf00              NOP                            ;1494
000072  2000              MOVS     r0,#0                 ;1494
000074  f8810038          STRB     r0,[r1,#0x38]         ;1494
000078  bf00              NOP                            ;1494
00007a  bf00              NOP                            ;1496
00007c  e7c8              B        |L19.16|
;;;1498   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1504     */
;;;1505   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1506   {
000002  4604              MOV      r4,r0
;;;1507     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;1508     /* The Lock is not implemented on this API to allow the user application
;;;1509        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1510        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1511        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1512        */
;;;1513   
;;;1514     /* Stop UART DMA Tx request if ongoing */
;;;1515     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000006  6820              LDR      r0,[r4,#0]
000008  6940              LDR      r0,[r0,#0x14]
00000a  f3c015c0          UBFX     r5,r0,#7,#1
;;;1516     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2821              CMP      r0,#0x21
000014  d10e              BNE      |L20.52|
000016  b16d              CBZ      r5,|L20.52|
;;;1517     {
;;;1518       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  6820              LDR      r0,[r4,#0]
00001a  6940              LDR      r0,[r0,#0x14]
00001c  f0200080          BIC      r0,r0,#0x80
000020  6821              LDR      r1,[r4,#0]
000022  6148              STR      r0,[r1,#0x14]
;;;1519   
;;;1520       /* Abort the UART DMA Tx stream */
;;;1521       if (huart->hdmatx != NULL)
000024  6b20              LDR      r0,[r4,#0x30]
000026  b110              CBZ      r0,|L20.46|
;;;1522       {
;;;1523         HAL_DMA_Abort(huart->hdmatx);
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       HAL_DMA_Abort
                  |L20.46|
;;;1524       }
;;;1525       UART_EndTxTransfer(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_EndTxTransfer
                  |L20.52|
;;;1526     }
;;;1527   
;;;1528     /* Stop UART DMA Rx request if ongoing */
;;;1529     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000034  6820              LDR      r0,[r4,#0]
000036  6940              LDR      r0,[r0,#0x14]
000038  f3c01580          UBFX     r5,r0,#6,#1
;;;1530     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00003c  f894003a          LDRB     r0,[r4,#0x3a]
000040  2822              CMP      r0,#0x22
000042  d10e              BNE      |L20.98|
000044  b16d              CBZ      r5,|L20.98|
;;;1531     {
;;;1532       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000046  6820              LDR      r0,[r4,#0]
000048  6940              LDR      r0,[r0,#0x14]
00004a  f0200040          BIC      r0,r0,#0x40
00004e  6821              LDR      r1,[r4,#0]
000050  6148              STR      r0,[r1,#0x14]
;;;1533   
;;;1534       /* Abort the UART DMA Rx stream */
;;;1535       if (huart->hdmarx != NULL)
000052  6b60              LDR      r0,[r4,#0x34]
000054  b110              CBZ      r0,|L20.92|
;;;1536       {
;;;1537         HAL_DMA_Abort(huart->hdmarx);
000056  6b60              LDR      r0,[r4,#0x34]
000058  f7fffffe          BL       HAL_DMA_Abort
                  |L20.92|
;;;1538       }
;;;1539       UART_EndRxTransfer(huart);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       UART_EndRxTransfer
                  |L20.98|
;;;1540     }
;;;1541   
;;;1542     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;1543   }
000064  bd70              POP      {r4-r6,pc}
;;;1544   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;624      */
;;;625    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;626    {
000002  4604              MOV      r4,r0
;;;627      /* Check the UART handle allocation */
;;;628      if (huart == NULL)
000004  b90c              CBNZ     r4,|L21.10|
;;;629      {
;;;630        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L21.8|
;;;631      }
;;;632    
;;;633      /* Check the parameters */
;;;634      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;635    
;;;636      huart->gState = HAL_UART_STATE_BUSY;
;;;637    
;;;638      /* Disable the Peripheral */
;;;639      __HAL_UART_DISABLE(huart);
;;;640    
;;;641    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;642      if (huart->MspDeInitCallback == NULL)
;;;643      {
;;;644        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;645      }
;;;646      /* DeInit the low level hardware */
;;;647      huart->MspDeInitCallback(huart);
;;;648    #else
;;;649      /* DeInit the low level hardware */
;;;650      HAL_UART_MspDeInit(huart);
;;;651    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;652    
;;;653      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;654      huart->gState = HAL_UART_STATE_RESET;
;;;655      huart->RxState = HAL_UART_STATE_RESET;
;;;656    
;;;657      /* Process Unlock */
;;;658      __HAL_UNLOCK(huart);
;;;659    
;;;660      return HAL_OK;
;;;661    }
000008  bd10              POP      {r4,pc}
                  |L21.10|
00000a  2024              MOVS     r0,#0x24              ;636
00000c  f8840039          STRB     r0,[r4,#0x39]         ;636
000010  6820              LDR      r0,[r4,#0]            ;639
000012  68c0              LDR      r0,[r0,#0xc]          ;639
000014  f4205000          BIC      r0,r0,#0x2000         ;639
000018  6821              LDR      r1,[r4,#0]            ;639
00001a  60c8              STR      r0,[r1,#0xc]          ;639
00001c  4620              MOV      r0,r4                 ;650
00001e  f7fffffe          BL       HAL_UART_MspDeInit
000022  2000              MOVS     r0,#0                 ;653
000024  63e0              STR      r0,[r4,#0x3c]         ;653
000026  f8840039          STRB     r0,[r4,#0x39]         ;654
00002a  f884003a          STRB     r0,[r4,#0x3a]         ;655
00002e  bf00              NOP                            ;658
000030  f8840038          STRB     r0,[r4,#0x38]         ;658
000034  bf00              NOP                            ;658
000036  bf00              NOP                            ;660
000038  e7e6              B        |L21.8|
;;;662    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2224     */
;;;2225   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2226   {
;;;2227     /* Prevent unused argument(s) compilation warning */
;;;2228     UNUSED(huart);
;;;2229     /* NOTE: This function should not be modified, when the callback is needed,
;;;2230              the HAL_UART_ErrorCallback could be implemented in the user file
;;;2231      */
;;;2232   }
;;;2233   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2495     */
;;;2496   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2497   {
;;;2498     return huart->ErrorCode;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;2499   }
000004  4770              BX       lr
;;;2500   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2480     */
;;;2481   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2482   {
;;;2483     uint32_t temp1 = 0x00U, temp2 = 0x00U;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;2484     temp1 = huart->gState;
000006  f8912039          LDRB     r2,[r1,#0x39]
;;;2485     temp2 = huart->RxState;
00000a  f891303a          LDRB     r3,[r1,#0x3a]
;;;2486   
;;;2487     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000e  ea420003          ORR      r0,r2,r3
;;;2488   }
000012  4770              BX       lr
;;;2489   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2018     */
;;;2019   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2020   {
000004  4604              MOV      r4,r0
;;;2021     uint32_t isrflags   = READ_REG(huart->Instance->SR);
000006  6820              LDR      r0,[r4,#0]
000008  6805              LDR      r5,[r0,#0]
;;;2022     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  68c6              LDR      r6,[r0,#0xc]
;;;2023     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6947              LDR      r7,[r0,#0x14]
;;;2024     uint32_t errorflags = 0x00U;
000012  f04f0800          MOV      r8,#0
;;;2025     uint32_t dmarequest = 0x00U;
000016  46c1              MOV      r9,r8
;;;2026   
;;;2027     /* If no error occurs */
;;;2028     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
000018  f005080f          AND      r8,r5,#0xf
;;;2029     if (errorflags == RESET)
00001c  f1b80f00          CMP      r8,#0
000020  d10a              BNE      |L25.56|
;;;2030     {
;;;2031       /* UART in mode Receiver -------------------------------------------------*/
;;;2032       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000022  f0050020          AND      r0,r5,#0x20
000026  b138              CBZ      r0,|L25.56|
000028  f0060020          AND      r0,r6,#0x20
00002c  b120              CBZ      r0,|L25.56|
;;;2033       {
;;;2034         UART_Receive_IT(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_Receive_IT
                  |L25.52|
;;;2035         return;
;;;2036       }
;;;2037     }
;;;2038   
;;;2039     /* If some errors occur */
;;;2040     if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
;;;2041     {
;;;2042       /* UART parity error interrupt occurred ----------------------------------*/
;;;2043       if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;2044       {
;;;2045         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;2046       }
;;;2047   
;;;2048       /* UART noise error interrupt occurred -----------------------------------*/
;;;2049       if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2050       {
;;;2051         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;2052       }
;;;2053   
;;;2054       /* UART frame error interrupt occurred -----------------------------------*/
;;;2055       if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2056       {
;;;2057         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;2058       }
;;;2059   
;;;2060       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;2061       if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
;;;2062       {
;;;2063         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;2064       }
;;;2065   
;;;2066       /* Call UART Error Call back function if need be --------------------------*/
;;;2067       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;2068       {
;;;2069         /* UART in mode Receiver -----------------------------------------------*/
;;;2070         if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;2071         {
;;;2072           UART_Receive_IT(huart);
;;;2073         }
;;;2074   
;;;2075         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2076            consider error as blocking */
;;;2077         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;2078         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
;;;2079         {
;;;2080           /* Blocking error : transfer is aborted
;;;2081              Set the UART state ready to be able to start again the process,
;;;2082              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2083           UART_EndRxTransfer(huart);
;;;2084   
;;;2085           /* Disable the UART DMA Rx request if enabled */
;;;2086           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2087           {
;;;2088             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2089   
;;;2090             /* Abort the UART DMA Rx stream */
;;;2091             if (huart->hdmarx != NULL)
;;;2092             {
;;;2093               /* Set the UART DMA Abort callback :
;;;2094                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2095               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;2096               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;2097               {
;;;2098                 /* Call Directly XferAbortCallback function in case of error */
;;;2099                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;2100               }
;;;2101             }
;;;2102             else
;;;2103             {
;;;2104               /* Call user error callback */
;;;2105   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2106               /*Call registered error callback*/
;;;2107               huart->ErrorCallback(huart);
;;;2108   #else
;;;2109               /*Call legacy weak error callback*/
;;;2110               HAL_UART_ErrorCallback(huart);
;;;2111   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2112             }
;;;2113           }
;;;2114           else
;;;2115           {
;;;2116             /* Call user error callback */
;;;2117   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2118             /*Call registered error callback*/
;;;2119             huart->ErrorCallback(huart);
;;;2120   #else
;;;2121             /*Call legacy weak error callback*/
;;;2122             HAL_UART_ErrorCallback(huart);
;;;2123   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2124           }
;;;2125         }
;;;2126         else
;;;2127         {
;;;2128           /* Non Blocking error : transfer could go on.
;;;2129              Error is notified to user through user error callback */
;;;2130   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2131           /*Call registered error callback*/
;;;2132           huart->ErrorCallback(huart);
;;;2133   #else
;;;2134           /*Call legacy weak error callback*/
;;;2135           HAL_UART_ErrorCallback(huart);
;;;2136   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2137   
;;;2138           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2139         }
;;;2140       }
;;;2141       return;
;;;2142     } /* End if some error occurs */
;;;2143   
;;;2144     /* UART in mode Transmitter ------------------------------------------------*/
;;;2145     if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2146     {
;;;2147       UART_Transmit_IT(huart);
;;;2148       return;
;;;2149     }
;;;2150   
;;;2151     /* UART in mode Transmitter end --------------------------------------------*/
;;;2152     if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2153     {
;;;2154       UART_EndTransmit_IT(huart);
;;;2155       return;
;;;2156     }
;;;2157   }
000034  e8bd87f0          POP      {r4-r10,pc}
                  |L25.56|
000038  f1b80f00          CMP      r8,#0                 ;2040
00003c  d072              BEQ      |L25.292|
00003e  f0070001          AND      r0,r7,#1              ;2040
000042  b918              CBNZ     r0,|L25.76|
000044  f4067090          AND      r0,r6,#0x120          ;2040
000048  2800              CMP      r0,#0                 ;2040
00004a  d06b              BEQ      |L25.292|
                  |L25.76|
00004c  f0050001          AND      r0,r5,#1              ;2043
000050  b130              CBZ      r0,|L25.96|
000052  f4067080          AND      r0,r6,#0x100          ;2043
000056  b118              CBZ      r0,|L25.96|
000058  6be0              LDR      r0,[r4,#0x3c]         ;2045
00005a  f0400001          ORR      r0,r0,#1              ;2045
00005e  63e0              STR      r0,[r4,#0x3c]         ;2045
                  |L25.96|
000060  f0050004          AND      r0,r5,#4              ;2049
000064  b130              CBZ      r0,|L25.116|
000066  f0070001          AND      r0,r7,#1              ;2049
00006a  b118              CBZ      r0,|L25.116|
00006c  6be0              LDR      r0,[r4,#0x3c]         ;2051
00006e  f0400002          ORR      r0,r0,#2              ;2051
000072  63e0              STR      r0,[r4,#0x3c]         ;2051
                  |L25.116|
000074  f0050002          AND      r0,r5,#2              ;2055
000078  b130              CBZ      r0,|L25.136|
00007a  f0070001          AND      r0,r7,#1              ;2055
00007e  b118              CBZ      r0,|L25.136|
000080  6be0              LDR      r0,[r4,#0x3c]         ;2057
000082  f0400004          ORR      r0,r0,#4              ;2057
000086  63e0              STR      r0,[r4,#0x3c]         ;2057
                  |L25.136|
000088  f0050008          AND      r0,r5,#8              ;2061
00008c  b148              CBZ      r0,|L25.162|
00008e  f0060020          AND      r0,r6,#0x20           ;2061
000092  b910              CBNZ     r0,|L25.154|
000094  f0070001          AND      r0,r7,#1              ;2061
000098  b118              CBZ      r0,|L25.162|
                  |L25.154|
00009a  6be0              LDR      r0,[r4,#0x3c]         ;2063
00009c  f0400008          ORR      r0,r0,#8              ;2063
0000a0  63e0              STR      r0,[r4,#0x3c]         ;2063
                  |L25.162|
0000a2  6be0              LDR      r0,[r4,#0x3c]         ;2067
0000a4  b370              CBZ      r0,|L25.260|
0000a6  f0050020          AND      r0,r5,#0x20           ;2070
0000aa  b128              CBZ      r0,|L25.184|
0000ac  f0060020          AND      r0,r6,#0x20           ;2070
0000b0  b110              CBZ      r0,|L25.184|
0000b2  4620              MOV      r0,r4                 ;2072
0000b4  f7fffffe          BL       UART_Receive_IT
                  |L25.184|
0000b8  6820              LDR      r0,[r4,#0]            ;2077
0000ba  6940              LDR      r0,[r0,#0x14]         ;2077
0000bc  f3c01980          UBFX     r9,r0,#6,#1           ;2077
0000c0  6be0              LDR      r0,[r4,#0x3c]         ;2078
0000c2  f0000008          AND      r0,r0,#8              ;2078
0000c6  b910              CBNZ     r0,|L25.206|
0000c8  f1b90f00          CMP      r9,#0                 ;2078
0000cc  d023              BEQ      |L25.278|
                  |L25.206|
0000ce  4620              MOV      r0,r4                 ;2083
0000d0  f7fffffe          BL       UART_EndRxTransfer
0000d4  6820              LDR      r0,[r4,#0]            ;2086
0000d6  6940              LDR      r0,[r0,#0x14]         ;2086
0000d8  f0000040          AND      r0,r0,#0x40           ;2086
0000dc  2840              CMP      r0,#0x40              ;2086
0000de  d116              BNE      |L25.270|
0000e0  6820              LDR      r0,[r4,#0]            ;2088
0000e2  6940              LDR      r0,[r0,#0x14]         ;2088
0000e4  f0200040          BIC      r0,r0,#0x40           ;2088
0000e8  6821              LDR      r1,[r4,#0]            ;2088
0000ea  6148              STR      r0,[r1,#0x14]         ;2088
0000ec  6b60              LDR      r0,[r4,#0x34]         ;2091
0000ee  b150              CBZ      r0,|L25.262|
0000f0  4817              LDR      r0,|L25.336|
0000f2  6b61              LDR      r1,[r4,#0x34]         ;2095
0000f4  6508              STR      r0,[r1,#0x50]         ;2095
0000f6  6b60              LDR      r0,[r4,#0x34]         ;2096
0000f8  f7fffffe          BL       HAL_DMA_Abort_IT
0000fc  b110              CBZ      r0,|L25.260|
0000fe  6b60              LDR      r0,[r4,#0x34]         ;2099
000100  6d01              LDR      r1,[r0,#0x50]         ;2099
000102  4788              BLX      r1                    ;2099
                  |L25.260|
000104  e00c              B        |L25.288|
                  |L25.262|
000106  4620              MOV      r0,r4                 ;2110
000108  f7fffffe          BL       HAL_UART_ErrorCallback
00010c  e008              B        |L25.288|
                  |L25.270|
00010e  4620              MOV      r0,r4                 ;2122
000110  f7fffffe          BL       HAL_UART_ErrorCallback
000114  e004              B        |L25.288|
                  |L25.278|
000116  4620              MOV      r0,r4                 ;2135
000118  f7fffffe          BL       HAL_UART_ErrorCallback
00011c  2000              MOVS     r0,#0                 ;2138
00011e  63e0              STR      r0,[r4,#0x3c]         ;2138
                  |L25.288|
000120  e788              B        |L25.52|
000122  e7ff              B        |L25.292|
                  |L25.292|
000124  f0050080          AND      r0,r5,#0x80           ;2145
000128  b130              CBZ      r0,|L25.312|
00012a  f0060080          AND      r0,r6,#0x80           ;2145
00012e  b118              CBZ      r0,|L25.312|
000130  4620              MOV      r0,r4                 ;2147
000132  f7fffffe          BL       UART_Transmit_IT
000136  e77d              B        |L25.52|
                  |L25.312|
000138  f0050040          AND      r0,r5,#0x40           ;2152
00013c  b130              CBZ      r0,|L25.332|
00013e  f0060040          AND      r0,r6,#0x40           ;2152
000142  b118              CBZ      r0,|L25.332|
000144  4620              MOV      r0,r4                 ;2154
000146  f7fffffe          BL       UART_EndTransmit_IT
00014a  e773              B        |L25.52|
                  |L25.332|
00014c  bf00              NOP      
00014e  e771              B        |L25.52|
;;;2158   
                          ENDP

                  |L25.336|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;316      */
;;;317    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319      /* Check the UART handle allocation */
;;;320      if (huart == NULL)
000004  b90c              CBNZ     r4,|L26.10|
;;;321      {
;;;322        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L26.8|
;;;323      }
;;;324    
;;;325      /* Check the parameters */
;;;326      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;327      {
;;;328        /* The hardware flow control is available only for USART1, USART2, USART3 and USART6.
;;;329           Except for STM32F446xx devices, that is available for USART1, USART2, USART3, USART6, UART4 and UART5.
;;;330        */
;;;331        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;332        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;333      }
;;;334      else
;;;335      {
;;;336        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;337      }
;;;338      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;339      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;340    
;;;341      if (huart->gState == HAL_UART_STATE_RESET)
;;;342      {
;;;343        /* Allocate lock resource and initialize it */
;;;344        huart->Lock = HAL_UNLOCKED;
;;;345    
;;;346    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;347        UART_InitCallbacksToDefault(huart);
;;;348    
;;;349        if (huart->MspInitCallback == NULL)
;;;350        {
;;;351          huart->MspInitCallback = HAL_UART_MspInit;
;;;352        }
;;;353    
;;;354        /* Init the low level hardware */
;;;355        huart->MspInitCallback(huart);
;;;356    #else
;;;357        /* Init the low level hardware : GPIO, CLOCK */
;;;358        HAL_UART_MspInit(huart);
;;;359    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;360      }
;;;361    
;;;362      huart->gState = HAL_UART_STATE_BUSY;
;;;363    
;;;364      /* Disable the peripheral */
;;;365      __HAL_UART_DISABLE(huart);
;;;366    
;;;367      /* Set the UART Communication parameters */
;;;368      UART_SetConfig(huart);
;;;369    
;;;370      /* In asynchronous mode, the following bits must be kept cleared:
;;;371         - LINEN and CLKEN bits in the USART_CR2 register,
;;;372         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;373      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;374      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;375    
;;;376      /* Enable the peripheral */
;;;377      __HAL_UART_ENABLE(huart);
;;;378    
;;;379      /* Initialize the UART state */
;;;380      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;381      huart->gState = HAL_UART_STATE_READY;
;;;382      huart->RxState = HAL_UART_STATE_READY;
;;;383    
;;;384      return HAL_OK;
;;;385    }
000008  bd10              POP      {r4,pc}
                  |L26.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;326
00000c  b100              CBZ      r0,|L26.16|
00000e  e000              B        |L26.18|
                  |L26.16|
000010  bf00              NOP                            ;336
                  |L26.18|
000012  f8940039          LDRB     r0,[r4,#0x39]         ;341
000016  b928              CBNZ     r0,|L26.36|
000018  2000              MOVS     r0,#0                 ;344
00001a  f8840038          STRB     r0,[r4,#0x38]         ;344
00001e  4620              MOV      r0,r4                 ;358
000020  f7fffffe          BL       HAL_UART_MspInit
                  |L26.36|
000024  2024              MOVS     r0,#0x24              ;362
000026  f8840039          STRB     r0,[r4,#0x39]         ;362
00002a  6820              LDR      r0,[r4,#0]            ;365
00002c  68c0              LDR      r0,[r0,#0xc]          ;365
00002e  f4205000          BIC      r0,r0,#0x2000         ;365
000032  6821              LDR      r1,[r4,#0]            ;365
000034  60c8              STR      r0,[r1,#0xc]          ;365
000036  4620              MOV      r0,r4                 ;368
000038  f7fffffe          BL       UART_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;373
00003e  6900              LDR      r0,[r0,#0x10]         ;373
000040  f4204090          BIC      r0,r0,#0x4800         ;373
000044  6821              LDR      r1,[r4,#0]            ;373
000046  6108              STR      r0,[r1,#0x10]         ;373
000048  6820              LDR      r0,[r4,#0]            ;374
00004a  6940              LDR      r0,[r0,#0x14]         ;374
00004c  f020002a          BIC      r0,r0,#0x2a           ;374
000050  6821              LDR      r1,[r4,#0]            ;374
000052  6148              STR      r0,[r1,#0x14]         ;374
000054  6820              LDR      r0,[r4,#0]            ;377
000056  68c0              LDR      r0,[r0,#0xc]          ;377
000058  f4405000          ORR      r0,r0,#0x2000         ;377
00005c  6821              LDR      r1,[r4,#0]            ;377
00005e  60c8              STR      r0,[r1,#0xc]          ;377
000060  2000              MOVS     r0,#0                 ;380
000062  63e0              STR      r0,[r4,#0x3c]         ;380
000064  2020              MOVS     r0,#0x20              ;381
000066  f8840039          STRB     r0,[r4,#0x39]         ;381
00006a  f884003a          STRB     r0,[r4,#0x3a]         ;382
00006e  2000              MOVS     r0,#0                 ;384
000070  e7ca              B        |L26.8|
;;;386    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;683      */
;;;684    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;685    {
;;;686      /* Prevent unused argument(s) compilation warning */
;;;687      UNUSED(huart);
;;;688      /* NOTE: This function should not be modified, when the callback is needed,
;;;689               the HAL_UART_MspDeInit could be implemented in the user file
;;;690       */
;;;691    }
;;;692    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;668      */
;;;669    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;670    {
;;;671      /* Prevent unused argument(s) compilation warning */
;;;672      UNUSED(huart);
;;;673      /* NOTE: This function should not be modified, when the callback is needed,
;;;674               the HAL_UART_MspInit could be implemented in the user file
;;;675       */
;;;676    }
;;;677    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1109     */
;;;1110   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1111   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1112     uint16_t *tmp;
;;;1113     uint32_t tickstart = 0U;
00000c  f04f0900          MOV      r9,#0
;;;1114   
;;;1115     /* Check that a Rx process is not already ongoing */
;;;1116     if (huart->RxState == HAL_UART_STATE_READY)
000010  f894003a          LDRB     r0,[r4,#0x3a]
000014  2820              CMP      r0,#0x20
000016  d161              BNE      |L29.220|
;;;1117     {
;;;1118       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L29.28|
00001a  b916              CBNZ     r6,|L29.34|
                  |L29.28|
;;;1119       {
;;;1120         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L29.30|
;;;1121       }
;;;1122   
;;;1123       /* Process Locked */
;;;1124       __HAL_LOCK(huart);
;;;1125   
;;;1126       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1127       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1128   
;;;1129       /* Init tickstart for timeout managment */
;;;1130       tickstart = HAL_GetTick();
;;;1131   
;;;1132       huart->RxXferSize = Size;
;;;1133       huart->RxXferCount = Size;
;;;1134   
;;;1135       /* Process Unlocked */
;;;1136       __HAL_UNLOCK(huart);
;;;1137   
;;;1138       /* Check the remain data to be received */
;;;1139       while (huart->RxXferCount > 0U)
;;;1140       {
;;;1141         huart->RxXferCount--;
;;;1142         if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1143         {
;;;1144           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1145           {
;;;1146             return HAL_TIMEOUT;
;;;1147           }
;;;1148           tmp = (uint16_t *) pData;
;;;1149           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1150           {
;;;1151             *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;1152             pData += 2U;
;;;1153           }
;;;1154           else
;;;1155           {
;;;1156             *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;1157             pData += 1U;
;;;1158           }
;;;1159   
;;;1160         }
;;;1161         else
;;;1162         {
;;;1163           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1164           {
;;;1165             return HAL_TIMEOUT;
;;;1166           }
;;;1167           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1168           {
;;;1169             *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1170           }
;;;1171           else
;;;1172           {
;;;1173             *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1174           }
;;;1175   
;;;1176         }
;;;1177       }
;;;1178   
;;;1179       /* At end of Rx process, restore huart->RxState to Ready */
;;;1180       huart->RxState = HAL_UART_STATE_READY;
;;;1181   
;;;1182       return HAL_OK;
;;;1183     }
;;;1184     else
;;;1185     {
;;;1186       return HAL_BUSY;
;;;1187     }
;;;1188   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L29.34|
000022  bf00              NOP                            ;1124
000024  f8940038          LDRB     r0,[r4,#0x38]         ;1124
000028  2801              CMP      r0,#1                 ;1124
00002a  d101              BNE      |L29.48|
00002c  2002              MOVS     r0,#2                 ;1124
00002e  e7f6              B        |L29.30|
                  |L29.48|
000030  2001              MOVS     r0,#1                 ;1124
000032  f8840038          STRB     r0,[r4,#0x38]         ;1124
000036  bf00              NOP                            ;1124
000038  2000              MOVS     r0,#0                 ;1126
00003a  63e0              STR      r0,[r4,#0x3c]         ;1126
00003c  2022              MOVS     r0,#0x22              ;1127
00003e  f884003a          STRB     r0,[r4,#0x3a]         ;1127
000042  f7fffffe          BL       HAL_GetTick
000046  4681              MOV      r9,r0                 ;1130
000048  85a6              STRH     r6,[r4,#0x2c]         ;1132
00004a  85e6              STRH     r6,[r4,#0x2e]         ;1133
00004c  bf00              NOP                            ;1136
00004e  2000              MOVS     r0,#0                 ;1136
000050  f8840038          STRB     r0,[r4,#0x38]         ;1136
000054  bf00              NOP                            ;1136
000056  e039              B        |L29.204|
                  |L29.88|
000058  8de0              LDRH     r0,[r4,#0x2e]         ;1141
00005a  1e40              SUBS     r0,r0,#1              ;1141
00005c  85e0              STRH     r0,[r4,#0x2e]         ;1141
00005e  68a0              LDR      r0,[r4,#8]            ;1142
000060  f5b05f80          CMP      r0,#0x1000            ;1142
000064  d11b              BNE      |L29.158|
000066  464b              MOV      r3,r9                 ;1144
000068  2200              MOVS     r2,#0                 ;1144
00006a  2120              MOVS     r1,#0x20              ;1144
00006c  4620              MOV      r0,r4                 ;1144
00006e  9700              STR      r7,[sp,#0]            ;1144
000070  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000074  b108              CBZ      r0,|L29.122|
000076  2003              MOVS     r0,#3                 ;1146
000078  e7d1              B        |L29.30|
                  |L29.122|
00007a  46a8              MOV      r8,r5                 ;1148
00007c  6920              LDR      r0,[r4,#0x10]         ;1149
00007e  b938              CBNZ     r0,|L29.144|
000080  6820              LDR      r0,[r4,#0]            ;1151
000082  6840              LDR      r0,[r0,#4]            ;1151
000084  f3c00008          UBFX     r0,r0,#0,#9           ;1151
000088  f8a80000          STRH     r0,[r8,#0]            ;1151
00008c  1cad              ADDS     r5,r5,#2              ;1152
00008e  e01d              B        |L29.204|
                  |L29.144|
000090  6820              LDR      r0,[r4,#0]            ;1156
000092  6840              LDR      r0,[r0,#4]            ;1156
000094  b2c0              UXTB     r0,r0                 ;1156
000096  f8a80000          STRH     r0,[r8,#0]            ;1156
00009a  1c6d              ADDS     r5,r5,#1              ;1157
00009c  e016              B        |L29.204|
                  |L29.158|
00009e  464b              MOV      r3,r9                 ;1163
0000a0  2200              MOVS     r2,#0                 ;1163
0000a2  2120              MOVS     r1,#0x20              ;1163
0000a4  4620              MOV      r0,r4                 ;1163
0000a6  9700              STR      r7,[sp,#0]            ;1163
0000a8  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000ac  b108              CBZ      r0,|L29.178|
0000ae  2003              MOVS     r0,#3                 ;1165
0000b0  e7b5              B        |L29.30|
                  |L29.178|
0000b2  6920              LDR      r0,[r4,#0x10]         ;1167
0000b4  b920              CBNZ     r0,|L29.192|
0000b6  6820              LDR      r0,[r4,#0]            ;1169
0000b8  6840              LDR      r0,[r0,#4]            ;1169
0000ba  f8050b01          STRB     r0,[r5],#1            ;1169
0000be  e005              B        |L29.204|
                  |L29.192|
0000c0  6820              LDR      r0,[r4,#0]            ;1173
0000c2  6840              LDR      r0,[r0,#4]            ;1173
0000c4  f000007f          AND      r0,r0,#0x7f           ;1173
0000c8  f8050b01          STRB     r0,[r5],#1            ;1173
                  |L29.204|
0000cc  8de0              LDRH     r0,[r4,#0x2e]         ;1139
0000ce  2800              CMP      r0,#0                 ;1139
0000d0  d1c2              BNE      |L29.88|
0000d2  2020              MOVS     r0,#0x20              ;1180
0000d4  f884003a          STRB     r0,[r4,#0x3a]         ;1180
0000d8  2000              MOVS     r0,#0                 ;1182
0000da  e7a0              B        |L29.30|
                  |L29.220|
0000dc  2002              MOVS     r0,#2                 ;1186
0000de  e79e              B        |L29.30|
;;;1189   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1364     */
;;;1365   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;1366   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;1367     uint32_t *tmp;
;;;1368   
;;;1369     /* Check that a Rx process is not already ongoing */
;;;1370     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003a          LDRB     r0,[r4,#0x3a]
00000c  2820              CMP      r0,#0x20
00000e  d150              BNE      |L30.178|
;;;1371     {
;;;1372       if ((pData == NULL) || (Size == 0U))
000010  9802              LDR      r0,[sp,#8]
000012  b100              CBZ      r0,|L30.22|
000014  b915              CBNZ     r5,|L30.28|
                  |L30.22|
;;;1373       {
;;;1374         return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L30.24|
;;;1375       }
;;;1376   
;;;1377       /* Process Locked */
;;;1378       __HAL_LOCK(huart);
;;;1379   
;;;1380       huart->pRxBuffPtr = pData;
;;;1381       huart->RxXferSize = Size;
;;;1382   
;;;1383       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1384       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1385   
;;;1386       /* Set the UART DMA transfer complete callback */
;;;1387       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1388   
;;;1389       /* Set the UART DMA Half transfer complete callback */
;;;1390       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1391   
;;;1392       /* Set the DMA error callback */
;;;1393       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1394   
;;;1395       /* Set the DMA abort callback */
;;;1396       huart->hdmarx->XferAbortCallback = NULL;
;;;1397   
;;;1398       /* Enable the DMA stream */
;;;1399       tmp = (uint32_t *)&pData;
;;;1400       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
;;;1401   
;;;1402       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1403       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1404   
;;;1405       /* Process Unlocked */
;;;1406       __HAL_UNLOCK(huart);
;;;1407   
;;;1408       /* Enable the UART Parity Error Interrupt */
;;;1409       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1410   
;;;1411       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1412       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1413   
;;;1414       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1415       in the UART CR3 register */
;;;1416       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1417   
;;;1418       return HAL_OK;
;;;1419     }
;;;1420     else
;;;1421     {
;;;1422       return HAL_BUSY;
;;;1423     }
;;;1424   }
000018  b004              ADD      sp,sp,#0x10
00001a  bd70              POP      {r4-r6,pc}
                  |L30.28|
00001c  bf00              NOP                            ;1378
00001e  f8940038          LDRB     r0,[r4,#0x38]         ;1378
000022  2801              CMP      r0,#1                 ;1378
000024  d101              BNE      |L30.42|
000026  2002              MOVS     r0,#2                 ;1378
000028  e7f6              B        |L30.24|
                  |L30.42|
00002a  2001              MOVS     r0,#1                 ;1378
00002c  f8840038          STRB     r0,[r4,#0x38]         ;1378
000030  bf00              NOP                            ;1378
000032  9802              LDR      r0,[sp,#8]            ;1380
000034  62a0              STR      r0,[r4,#0x28]         ;1380
000036  85a5              STRH     r5,[r4,#0x2c]         ;1381
000038  2000              MOVS     r0,#0                 ;1383
00003a  63e0              STR      r0,[r4,#0x3c]         ;1383
00003c  2022              MOVS     r0,#0x22              ;1384
00003e  f884003a          STRB     r0,[r4,#0x3a]         ;1384
000042  481d              LDR      r0,|L30.184|
000044  6b61              LDR      r1,[r4,#0x34]         ;1387
000046  63c8              STR      r0,[r1,#0x3c]         ;1387
000048  481c              LDR      r0,|L30.188|
00004a  6b61              LDR      r1,[r4,#0x34]         ;1390
00004c  6408              STR      r0,[r1,#0x40]         ;1390
00004e  481c              LDR      r0,|L30.192|
000050  6b61              LDR      r1,[r4,#0x34]         ;1393
000052  64c8              STR      r0,[r1,#0x4c]         ;1393
000054  2000              MOVS     r0,#0                 ;1396
000056  6b61              LDR      r1,[r4,#0x34]         ;1396
000058  6508              STR      r0,[r1,#0x50]         ;1396
00005a  ae02              ADD      r6,sp,#8              ;1399
00005c  6832              LDR      r2,[r6,#0]            ;1400
00005e  6823              LDR      r3,[r4,#0]            ;1400
000060  1d19              ADDS     r1,r3,#4              ;1400
000062  462b              MOV      r3,r5                 ;1400
000064  6b60              LDR      r0,[r4,#0x34]         ;1400
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  bf00              NOP                            ;1403
00006c  2000              MOVS     r0,#0                 ;1403
00006e  9000              STR      r0,[sp,#0]            ;1403
000070  6820              LDR      r0,[r4,#0]            ;1403
000072  6800              LDR      r0,[r0,#0]            ;1403
000074  9000              STR      r0,[sp,#0]            ;1403
000076  6820              LDR      r0,[r4,#0]            ;1403
000078  6840              LDR      r0,[r0,#4]            ;1403
00007a  9000              STR      r0,[sp,#0]            ;1403
00007c  bf00              NOP                            ;1403
00007e  bf00              NOP                            ;1403
000080  bf00              NOP                            ;1406
000082  2000              MOVS     r0,#0                 ;1406
000084  f8840038          STRB     r0,[r4,#0x38]         ;1406
000088  bf00              NOP                            ;1406
00008a  6820              LDR      r0,[r4,#0]            ;1409
00008c  68c0              LDR      r0,[r0,#0xc]          ;1409
00008e  f4407080          ORR      r0,r0,#0x100          ;1409
000092  6821              LDR      r1,[r4,#0]            ;1409
000094  60c8              STR      r0,[r1,#0xc]          ;1409
000096  6820              LDR      r0,[r4,#0]            ;1412
000098  6940              LDR      r0,[r0,#0x14]         ;1412
00009a  f0400001          ORR      r0,r0,#1              ;1412
00009e  6821              LDR      r1,[r4,#0]            ;1412
0000a0  6148              STR      r0,[r1,#0x14]         ;1412
0000a2  6820              LDR      r0,[r4,#0]            ;1416
0000a4  6940              LDR      r0,[r0,#0x14]         ;1416
0000a6  f0400040          ORR      r0,r0,#0x40           ;1416
0000aa  6821              LDR      r1,[r4,#0]            ;1416
0000ac  6148              STR      r0,[r1,#0x14]         ;1416
0000ae  2000              MOVS     r0,#0                 ;1418
0000b0  e7b2              B        |L30.24|
                  |L30.178|
0000b2  2002              MOVS     r0,#2                 ;1422
0000b4  e7b0              B        |L30.24|
;;;1425   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L30.184|
                          DCD      UART_DMAReceiveCplt
                  |L30.188|
                          DCD      UART_DMARxHalfCplt
                  |L30.192|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;1245     */
;;;1246   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1247   {
000002  4603              MOV      r3,r0
;;;1248     /* Check that a Rx process is not already ongoing */
;;;1249     if (huart->RxState == HAL_UART_STATE_READY)
000004  f893003a          LDRB     r0,[r3,#0x3a]
000008  2820              CMP      r0,#0x20
00000a  d12f              BNE      |L31.108|
;;;1250     {
;;;1251       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L31.16|
00000e  b90a              CBNZ     r2,|L31.20|
                  |L31.16|
;;;1252       {
;;;1253         return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L31.18|
;;;1254       }
;;;1255   
;;;1256       /* Process Locked */
;;;1257       __HAL_LOCK(huart);
;;;1258   
;;;1259       huart->pRxBuffPtr = pData;
;;;1260       huart->RxXferSize = Size;
;;;1261       huart->RxXferCount = Size;
;;;1262   
;;;1263       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1264       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1265   
;;;1266       /* Process Unlocked */
;;;1267       __HAL_UNLOCK(huart);
;;;1268   
;;;1269       /* Enable the UART Parity Error Interrupt */
;;;1270       __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;1271   
;;;1272       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1273       __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;1274   
;;;1275       /* Enable the UART Data Register not empty Interrupt */
;;;1276       __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;1277   
;;;1278       return HAL_OK;
;;;1279     }
;;;1280     else
;;;1281     {
;;;1282       return HAL_BUSY;
;;;1283     }
;;;1284   }
000012  bd10              POP      {r4,pc}
                  |L31.20|
000014  bf00              NOP                            ;1257
000016  f8930038          LDRB     r0,[r3,#0x38]         ;1257
00001a  2801              CMP      r0,#1                 ;1257
00001c  d101              BNE      |L31.34|
00001e  2002              MOVS     r0,#2                 ;1257
000020  e7f7              B        |L31.18|
                  |L31.34|
000022  2001              MOVS     r0,#1                 ;1257
000024  f8830038          STRB     r0,[r3,#0x38]         ;1257
000028  bf00              NOP                            ;1257
00002a  6299              STR      r1,[r3,#0x28]         ;1259
00002c  859a              STRH     r2,[r3,#0x2c]         ;1260
00002e  85da              STRH     r2,[r3,#0x2e]         ;1261
000030  2000              MOVS     r0,#0                 ;1263
000032  63d8              STR      r0,[r3,#0x3c]         ;1263
000034  2022              MOVS     r0,#0x22              ;1264
000036  f883003a          STRB     r0,[r3,#0x3a]         ;1264
00003a  bf00              NOP                            ;1267
00003c  2000              MOVS     r0,#0                 ;1267
00003e  f8830038          STRB     r0,[r3,#0x38]         ;1267
000042  bf00              NOP                            ;1267
000044  6818              LDR      r0,[r3,#0]            ;1270
000046  68c0              LDR      r0,[r0,#0xc]          ;1270
000048  f4407080          ORR      r0,r0,#0x100          ;1270
00004c  681c              LDR      r4,[r3,#0]            ;1270
00004e  60e0              STR      r0,[r4,#0xc]          ;1270
000050  6818              LDR      r0,[r3,#0]            ;1273
000052  6940              LDR      r0,[r0,#0x14]         ;1273
000054  f0400001          ORR      r0,r0,#1              ;1273
000058  681c              LDR      r4,[r3,#0]            ;1273
00005a  6160              STR      r0,[r4,#0x14]         ;1273
00005c  6818              LDR      r0,[r3,#0]            ;1276
00005e  68c0              LDR      r0,[r0,#0xc]          ;1276
000060  f0400020          ORR      r0,r0,#0x20           ;1276
000064  681c              LDR      r4,[r3,#0]            ;1276
000066  60e0              STR      r0,[r4,#0xc]          ;1276
000068  2000              MOVS     r0,#0                 ;1278
00006a  e7d2              B        |L31.18|
                  |L31.108|
00006c  2002              MOVS     r0,#2                 ;1282
00006e  e7d0              B        |L31.18|
;;;1285   
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2194     */
;;;2195   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2196   {
;;;2197     /* Prevent unused argument(s) compilation warning */
;;;2198     UNUSED(huart);
;;;2199     /* NOTE: This function should not be modified, when the callback is needed,
;;;2200              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;2201      */
;;;2202   }
;;;2203   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2209     */
;;;2210   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2211   {
;;;2212     /* Prevent unused argument(s) compilation warning */
;;;2213     UNUSED(huart);
;;;2214     /* NOTE: This function should not be modified, when the callback is needed,
;;;2215              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;2216      */
;;;2217   }
;;;2218   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1023     */
;;;1024   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1025   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1026     uint16_t *tmp;
;;;1027     uint32_t tickstart = 0U;
00000c  f04f0900          MOV      r9,#0
;;;1028   
;;;1029     /* Check that a Tx process is not already ongoing */
;;;1030     if (huart->gState == HAL_UART_STATE_READY)
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2820              CMP      r0,#0x20
000016  d15d              BNE      |L34.212|
;;;1031     {
;;;1032       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L34.28|
00001a  b916              CBNZ     r6,|L34.34|
                  |L34.28|
;;;1033       {
;;;1034         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L34.30|
;;;1035       }
;;;1036   
;;;1037       /* Process Locked */
;;;1038       __HAL_LOCK(huart);
;;;1039   
;;;1040       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1041       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1042   
;;;1043       /* Init tickstart for timeout managment */
;;;1044       tickstart = HAL_GetTick();
;;;1045   
;;;1046       huart->TxXferSize = Size;
;;;1047       huart->TxXferCount = Size;
;;;1048   
;;;1049       /* Process Unlocked */
;;;1050       __HAL_UNLOCK(huart);
;;;1051   
;;;1052       while (huart->TxXferCount > 0U)
;;;1053       {
;;;1054         huart->TxXferCount--;
;;;1055         if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1056         {
;;;1057           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1058           {
;;;1059             return HAL_TIMEOUT;
;;;1060           }
;;;1061           tmp = (uint16_t *) pData;
;;;1062           huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;1063           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1064           {
;;;1065             pData += 2U;
;;;1066           }
;;;1067           else
;;;1068           {
;;;1069             pData += 1U;
;;;1070           }
;;;1071         }
;;;1072         else
;;;1073         {
;;;1074           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1075           {
;;;1076             return HAL_TIMEOUT;
;;;1077           }
;;;1078           huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;1079         }
;;;1080       }
;;;1081   
;;;1082       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1083       {
;;;1084         return HAL_TIMEOUT;
;;;1085       }
;;;1086   
;;;1087       /* At end of Tx process, restore huart->gState to Ready */
;;;1088       huart->gState = HAL_UART_STATE_READY;
;;;1089   
;;;1090       return HAL_OK;
;;;1091     }
;;;1092     else
;;;1093     {
;;;1094       return HAL_BUSY;
;;;1095     }
;;;1096   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L34.34|
000022  bf00              NOP                            ;1038
000024  f8940038          LDRB     r0,[r4,#0x38]         ;1038
000028  2801              CMP      r0,#1                 ;1038
00002a  d101              BNE      |L34.48|
00002c  2002              MOVS     r0,#2                 ;1038
00002e  e7f6              B        |L34.30|
                  |L34.48|
000030  2001              MOVS     r0,#1                 ;1038
000032  f8840038          STRB     r0,[r4,#0x38]         ;1038
000036  bf00              NOP                            ;1038
000038  2000              MOVS     r0,#0                 ;1040
00003a  63e0              STR      r0,[r4,#0x3c]         ;1040
00003c  2021              MOVS     r0,#0x21              ;1041
00003e  f8840039          STRB     r0,[r4,#0x39]         ;1041
000042  f7fffffe          BL       HAL_GetTick
000046  4681              MOV      r9,r0                 ;1044
000048  84a6              STRH     r6,[r4,#0x24]         ;1046
00004a  84e6              STRH     r6,[r4,#0x26]         ;1047
00004c  bf00              NOP                            ;1050
00004e  2000              MOVS     r0,#0                 ;1050
000050  f8840038          STRB     r0,[r4,#0x38]         ;1050
000054  bf00              NOP                            ;1050
000056  e02b              B        |L34.176|
                  |L34.88|
000058  8ce0              LDRH     r0,[r4,#0x26]         ;1054
00005a  1e40              SUBS     r0,r0,#1              ;1054
00005c  84e0              STRH     r0,[r4,#0x26]         ;1054
00005e  68a0              LDR      r0,[r4,#8]            ;1055
000060  f5b05f80          CMP      r0,#0x1000            ;1055
000064  d116              BNE      |L34.148|
000066  464b              MOV      r3,r9                 ;1057
000068  2200              MOVS     r2,#0                 ;1057
00006a  2180              MOVS     r1,#0x80              ;1057
00006c  4620              MOV      r0,r4                 ;1057
00006e  9700              STR      r7,[sp,#0]            ;1057
000070  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000074  b108              CBZ      r0,|L34.122|
000076  2003              MOVS     r0,#3                 ;1059
000078  e7d1              B        |L34.30|
                  |L34.122|
00007a  46a8              MOV      r8,r5                 ;1061
00007c  f8b80000          LDRH     r0,[r8,#0]            ;1062
000080  f3c00008          UBFX     r0,r0,#0,#9           ;1062
000084  6821              LDR      r1,[r4,#0]            ;1062
000086  6048              STR      r0,[r1,#4]            ;1062
000088  6920              LDR      r0,[r4,#0x10]         ;1063
00008a  b908              CBNZ     r0,|L34.144|
00008c  1cad              ADDS     r5,r5,#2              ;1065
00008e  e00f              B        |L34.176|
                  |L34.144|
000090  1c6d              ADDS     r5,r5,#1              ;1069
000092  e00d              B        |L34.176|
                  |L34.148|
000094  464b              MOV      r3,r9                 ;1074
000096  2200              MOVS     r2,#0                 ;1074
000098  2180              MOVS     r1,#0x80              ;1074
00009a  4620              MOV      r0,r4                 ;1074
00009c  9700              STR      r7,[sp,#0]            ;1074
00009e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a2  b108              CBZ      r0,|L34.168|
0000a4  2003              MOVS     r0,#3                 ;1076
0000a6  e7ba              B        |L34.30|
                  |L34.168|
0000a8  f8150b01          LDRB     r0,[r5],#1            ;1078
0000ac  6821              LDR      r1,[r4,#0]            ;1078
0000ae  6048              STR      r0,[r1,#4]            ;1078
                  |L34.176|
0000b0  8ce0              LDRH     r0,[r4,#0x26]         ;1052
0000b2  2800              CMP      r0,#0                 ;1052
0000b4  d1d0              BNE      |L34.88|
0000b6  464b              MOV      r3,r9                 ;1082
0000b8  2200              MOVS     r2,#0                 ;1082
0000ba  2140              MOVS     r1,#0x40              ;1082
0000bc  4620              MOV      r0,r4                 ;1082
0000be  9700              STR      r7,[sp,#0]            ;1082
0000c0  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000c4  b108              CBZ      r0,|L34.202|
0000c6  2003              MOVS     r0,#3                 ;1084
0000c8  e7a9              B        |L34.30|
                  |L34.202|
0000ca  2020              MOVS     r0,#0x20              ;1088
0000cc  f8840039          STRB     r0,[r4,#0x39]         ;1088
0000d0  2000              MOVS     r0,#0                 ;1090
0000d2  e7a4              B        |L34.30|
                  |L34.212|
0000d4  2002              MOVS     r0,#2                 ;1094
0000d6  e7a2              B        |L34.30|
;;;1097   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1296     */
;;;1297   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1298   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1299     uint32_t *tmp;
;;;1300   
;;;1301     /* Check that a Tx process is not already ongoing */
;;;1302     if (huart->gState == HAL_UART_STATE_READY)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  2820              CMP      r0,#0x20
00000c  d13d              BNE      |L35.138|
;;;1303     {
;;;1304       if ((pData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L35.20|
000012  b90d              CBNZ     r5,|L35.24|
                  |L35.20|
;;;1305       {
;;;1306         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L35.22|
;;;1307       }
;;;1308   
;;;1309       /* Process Locked */
;;;1310       __HAL_LOCK(huart);
;;;1311   
;;;1312       huart->pTxBuffPtr = pData;
;;;1313       huart->TxXferSize = Size;
;;;1314       huart->TxXferCount = Size;
;;;1315   
;;;1316       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1317       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1318   
;;;1319       /* Set the UART DMA transfer complete callback */
;;;1320       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1321   
;;;1322       /* Set the UART DMA Half transfer complete callback */
;;;1323       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1324   
;;;1325       /* Set the DMA error callback */
;;;1326       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1327   
;;;1328       /* Set the DMA abort callback */
;;;1329       huart->hdmatx->XferAbortCallback = NULL;
;;;1330   
;;;1331       /* Enable the UART transmit DMA stream */
;;;1332       tmp = (uint32_t *)&pData;
;;;1333       HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;1334   
;;;1335       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1336       __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;1337   
;;;1338       /* Process Unlocked */
;;;1339       __HAL_UNLOCK(huart);
;;;1340   
;;;1341       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1342          in the UART CR3 register */
;;;1343       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1344   
;;;1345       return HAL_OK;
;;;1346     }
;;;1347     else
;;;1348     {
;;;1349       return HAL_BUSY;
;;;1350     }
;;;1351   }
000016  bdfe              POP      {r1-r7,pc}
                  |L35.24|
000018  bf00              NOP                            ;1310
00001a  f8940038          LDRB     r0,[r4,#0x38]         ;1310
00001e  2801              CMP      r0,#1                 ;1310
000020  d101              BNE      |L35.38|
000022  2002              MOVS     r0,#2                 ;1310
000024  e7f7              B        |L35.22|
                  |L35.38|
000026  2001              MOVS     r0,#1                 ;1310
000028  f8840038          STRB     r0,[r4,#0x38]         ;1310
00002c  bf00              NOP                            ;1310
00002e  9801              LDR      r0,[sp,#4]            ;1312
000030  6220              STR      r0,[r4,#0x20]         ;1312
000032  84a5              STRH     r5,[r4,#0x24]         ;1313
000034  84e5              STRH     r5,[r4,#0x26]         ;1314
000036  2000              MOVS     r0,#0                 ;1316
000038  63e0              STR      r0,[r4,#0x3c]         ;1316
00003a  2021              MOVS     r0,#0x21              ;1317
00003c  f8840039          STRB     r0,[r4,#0x39]         ;1317
000040  4813              LDR      r0,|L35.144|
000042  6b21              LDR      r1,[r4,#0x30]         ;1320
000044  63c8              STR      r0,[r1,#0x3c]         ;1320
000046  4813              LDR      r0,|L35.148|
000048  6b21              LDR      r1,[r4,#0x30]         ;1323
00004a  6408              STR      r0,[r1,#0x40]         ;1323
00004c  4812              LDR      r0,|L35.152|
00004e  6b21              LDR      r1,[r4,#0x30]         ;1326
000050  64c8              STR      r0,[r1,#0x4c]         ;1326
000052  2000              MOVS     r0,#0                 ;1329
000054  6b21              LDR      r1,[r4,#0x30]         ;1329
000056  6508              STR      r0,[r1,#0x50]         ;1329
000058  ae01              ADD      r6,sp,#4              ;1332
00005a  6823              LDR      r3,[r4,#0]            ;1333
00005c  1d1a              ADDS     r2,r3,#4              ;1333
00005e  6831              LDR      r1,[r6,#0]            ;1333
000060  462b              MOV      r3,r5                 ;1333
000062  6b20              LDR      r0,[r4,#0x30]         ;1333
000064  f7fffffe          BL       HAL_DMA_Start_IT
000068  f06f0040          MVN      r0,#0x40              ;1336
00006c  6821              LDR      r1,[r4,#0]            ;1336
00006e  6008              STR      r0,[r1,#0]            ;1336
000070  bf00              NOP                            ;1339
000072  2000              MOVS     r0,#0                 ;1339
000074  f8840038          STRB     r0,[r4,#0x38]         ;1339
000078  bf00              NOP                            ;1339
00007a  6820              LDR      r0,[r4,#0]            ;1343
00007c  6940              LDR      r0,[r0,#0x14]         ;1343
00007e  f0400080          ORR      r0,r0,#0x80           ;1343
000082  6821              LDR      r1,[r4,#0]            ;1343
000084  6148              STR      r0,[r1,#0x14]         ;1343
000086  2000              MOVS     r0,#0                 ;1345
000088  e7c5              B        |L35.22|
                  |L35.138|
00008a  2002              MOVS     r0,#2                 ;1349
00008c  e7c3              B        |L35.22|
;;;1352   
                          ENDP

00008e  0000              DCW      0x0000
                  |L35.144|
                          DCD      UART_DMATransmitCplt
                  |L35.148|
                          DCD      UART_DMATxHalfCplt
                  |L35.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;1200     */
;;;1201   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1202   {
000002  4603              MOV      r3,r0
;;;1203     /* Check that a Tx process is not already ongoing */
;;;1204     if (huart->gState == HAL_UART_STATE_READY)
000004  f8930039          LDRB     r0,[r3,#0x39]
000008  2820              CMP      r0,#0x20
00000a  d123              BNE      |L36.84|
;;;1205     {
;;;1206       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L36.16|
00000e  b90a              CBNZ     r2,|L36.20|
                  |L36.16|
;;;1207       {
;;;1208         return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L36.18|
;;;1209       }
;;;1210   
;;;1211       /* Process Locked */
;;;1212       __HAL_LOCK(huart);
;;;1213   
;;;1214       huart->pTxBuffPtr = pData;
;;;1215       huart->TxXferSize = Size;
;;;1216       huart->TxXferCount = Size;
;;;1217   
;;;1218       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1219       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1220   
;;;1221       /* Process Unlocked */
;;;1222       __HAL_UNLOCK(huart);
;;;1223   
;;;1224       /* Enable the UART Transmit data register empty Interrupt */
;;;1225       __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;1226   
;;;1227       return HAL_OK;
;;;1228     }
;;;1229     else
;;;1230     {
;;;1231       return HAL_BUSY;
;;;1232     }
;;;1233   }
000012  bd10              POP      {r4,pc}
                  |L36.20|
000014  bf00              NOP                            ;1212
000016  f8930038          LDRB     r0,[r3,#0x38]         ;1212
00001a  2801              CMP      r0,#1                 ;1212
00001c  d101              BNE      |L36.34|
00001e  2002              MOVS     r0,#2                 ;1212
000020  e7f7              B        |L36.18|
                  |L36.34|
000022  2001              MOVS     r0,#1                 ;1212
000024  f8830038          STRB     r0,[r3,#0x38]         ;1212
000028  bf00              NOP                            ;1212
00002a  6219              STR      r1,[r3,#0x20]         ;1214
00002c  849a              STRH     r2,[r3,#0x24]         ;1215
00002e  84da              STRH     r2,[r3,#0x26]         ;1216
000030  2000              MOVS     r0,#0                 ;1218
000032  63d8              STR      r0,[r3,#0x3c]         ;1218
000034  2021              MOVS     r0,#0x21              ;1219
000036  f8830039          STRB     r0,[r3,#0x39]         ;1219
00003a  bf00              NOP                            ;1222
00003c  2000              MOVS     r0,#0                 ;1222
00003e  f8830038          STRB     r0,[r3,#0x38]         ;1222
000042  bf00              NOP                            ;1222
000044  6818              LDR      r0,[r3,#0]            ;1225
000046  68c0              LDR      r0,[r0,#0xc]          ;1225
000048  f0400080          ORR      r0,r0,#0x80           ;1225
00004c  681c              LDR      r4,[r3,#0]            ;1225
00004e  60e0              STR      r0,[r4,#0xc]          ;1225
000050  2000              MOVS     r0,#0                 ;1227
000052  e7de              B        |L36.18|
                  |L36.84|
000054  2002              MOVS     r0,#2                 ;1231
000056  e7dc              B        |L36.18|
;;;1234   
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2164     */
;;;2165   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2166   {
;;;2167     /* Prevent unused argument(s) compilation warning */
;;;2168     UNUSED(huart);
;;;2169     /* NOTE: This function should not be modified, when the callback is needed,
;;;2170              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;2171      */
;;;2172   }
;;;2173   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2179     */
;;;2180   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2181   {
;;;2182     /* Prevent unused argument(s) compilation warning */
;;;2183     UNUSED(huart);
;;;2184     /* NOTE: This function should not be modified, when the callback is needed,
;;;2185              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;2186      */
;;;2187   }
;;;2188   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2750     */
;;;2751   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2752   {
000002  4605              MOV      r5,r0
;;;2753     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2754     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;2755     huart->TxXferCount = 0x00U;
00000a  84e0              STRH     r0,[r4,#0x26]
;;;2756   
;;;2757   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2758     /*Call registered error callback*/
;;;2759     huart->ErrorCallback(huart);
;;;2760   #else
;;;2761     /*Call legacy weak error callback*/
;;;2762     HAL_UART_ErrorCallback(huart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2763   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2764   }
000012  bd70              POP      {r4-r6,pc}
;;;2765   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2646     */
;;;2647   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2648   {
000002  4606              MOV      r6,r0
;;;2649     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;2650     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000006  6bb4              LDR      r4,[r6,#0x38]
;;;2651   
;;;2652     /* Stop UART DMA Tx request if ongoing */
;;;2653     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000008  6820              LDR      r0,[r4,#0]
00000a  6940              LDR      r0,[r0,#0x14]
00000c  f3c015c0          UBFX     r5,r0,#7,#1
;;;2654     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2821              CMP      r0,#0x21
000016  d105              BNE      |L40.36|
000018  b125              CBZ      r5,|L40.36|
;;;2655     {
;;;2656       huart->TxXferCount = 0x00U;
00001a  2000              MOVS     r0,#0
00001c  84e0              STRH     r0,[r4,#0x26]
;;;2657       UART_EndTxTransfer(huart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_EndTxTransfer
                  |L40.36|
;;;2658     }
;;;2659   
;;;2660     /* Stop UART DMA Rx request if ongoing */
;;;2661     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  f3c01580          UBFX     r5,r0,#6,#1
;;;2662     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00002c  f894003a          LDRB     r0,[r4,#0x3a]
000030  2822              CMP      r0,#0x22
000032  d105              BNE      |L40.64|
000034  b125              CBZ      r5,|L40.64|
;;;2663     {
;;;2664       huart->RxXferCount = 0x00U;
000036  2000              MOVS     r0,#0
000038  85e0              STRH     r0,[r4,#0x2e]
;;;2665       UART_EndRxTransfer(huart);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       UART_EndRxTransfer
                  |L40.64|
;;;2666     }
;;;2667   
;;;2668     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000040  6be0              LDR      r0,[r4,#0x3c]
000042  f0400010          ORR      r0,r0,#0x10
000046  63e0              STR      r0,[r4,#0x3c]
;;;2669   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2670     /*Call registered error callback*/
;;;2671     huart->ErrorCallback(huart);
;;;2672   #else
;;;2673     /*Call legacy weak error callback*/
;;;2674     HAL_UART_ErrorCallback(huart);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2675   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2676   }
00004e  bd70              POP      {r4-r6,pc}
;;;2677   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2593     */
;;;2594   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2595   {
000002  4605              MOV      r5,r0
;;;2596     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2597     /* DMA Normal mode*/
;;;2598     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b9b0              CBNZ     r0,|L41.62|
;;;2599     {
;;;2600       huart->RxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  85e0              STRH     r0,[r4,#0x2e]
;;;2601   
;;;2602       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2603       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6820              LDR      r0,[r4,#0]
000016  68c0              LDR      r0,[r0,#0xc]
000018  f4207080          BIC      r0,r0,#0x100
00001c  6821              LDR      r1,[r4,#0]
00001e  60c8              STR      r0,[r1,#0xc]
;;;2604       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000020  6820              LDR      r0,[r4,#0]
000022  6940              LDR      r0,[r0,#0x14]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6148              STR      r0,[r1,#0x14]
;;;2605   
;;;2606       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;2607          in the UART CR3 register */
;;;2608       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6940              LDR      r0,[r0,#0x14]
000030  f0200040          BIC      r0,r0,#0x40
000034  6821              LDR      r1,[r4,#0]
000036  6148              STR      r0,[r1,#0x14]
;;;2609   
;;;2610       /* At end of Rx process, restore huart->RxState to Ready */
;;;2611       huart->RxState = HAL_UART_STATE_READY;
000038  2020              MOVS     r0,#0x20
00003a  f884003a          STRB     r0,[r4,#0x3a]
                  |L41.62|
;;;2612     }
;;;2613   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2614     /*Call registered Rx complete callback*/
;;;2615     huart->RxCpltCallback(huart);
;;;2616   #else
;;;2617     /*Call legacy weak Rx complete callback*/
;;;2618     HAL_UART_RxCpltCallback(huart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2619   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2620   }
000044  bd70              POP      {r4-r6,pc}
;;;2621   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2819     */
;;;2820   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2821   {
000002  4605              MOV      r5,r0
;;;2822     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2823   
;;;2824     huart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6b61              LDR      r1,[r4,#0x34]
00000a  6508              STR      r0,[r1,#0x50]
;;;2825   
;;;2826     /* Check if an Abort process is still ongoing */
;;;2827     if (huart->hdmatx != NULL)
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  b118              CBZ      r0,|L42.24|
;;;2828     {
;;;2829       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6b20              LDR      r0,[r4,#0x30]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L42.24|
                  |L42.22|
;;;2830       {
;;;2831         return;
;;;2832       }
;;;2833     }
;;;2834   
;;;2835     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2836     huart->TxXferCount = 0x00U;
;;;2837     huart->RxXferCount = 0x00U;
;;;2838   
;;;2839     /* Reset ErrorCode */
;;;2840     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2841   
;;;2842     /* Restore huart->gState and huart->RxState to Ready */
;;;2843     huart->gState  = HAL_UART_STATE_READY;
;;;2844     huart->RxState = HAL_UART_STATE_READY;
;;;2845   
;;;2846     /* Call user Abort complete callback */
;;;2847   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2848     /* Call registered Abort complete callback */
;;;2849     huart->AbortCpltCallback(huart);
;;;2850   #else
;;;2851     /* Call legacy weak Abort complete callback */
;;;2852     HAL_UART_AbortCpltCallback(huart);
;;;2853   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2854   }
000016  bd70              POP      {r4-r6,pc}
                  |L42.24|
000018  2000              MOVS     r0,#0                 ;2836
00001a  84e0              STRH     r0,[r4,#0x26]         ;2836
00001c  85e0              STRH     r0,[r4,#0x2e]         ;2837
00001e  63e0              STR      r0,[r4,#0x3c]         ;2840
000020  2020              MOVS     r0,#0x20              ;2843
000022  f8840039          STRB     r0,[r4,#0x39]         ;2843
000026  f884003a          STRB     r0,[r4,#0x3a]         ;2844
00002a  4620              MOV      r0,r4                 ;2852
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
000030  bf00              NOP      
000032  e7f0              B        |L42.22|
;;;2855   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2627     */
;;;2628   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2629   {
000002  4604              MOV      r4,r0
;;;2630     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2631   
;;;2632   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2633     /*Call registered Rx Half complete callback*/
;;;2634     huart->RxHalfCpltCallback(huart);
;;;2635   #else
;;;2636     /*Call legacy weak Rx Half complete callback*/
;;;2637     HAL_UART_RxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2638   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2639   }
00000c  bd70              POP      {r4-r6,pc}
;;;2640   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2892     */
;;;2893   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2894   {
000002  4605              MOV      r5,r0
;;;2895     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2896   
;;;2897     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;2898   
;;;2899     /* Restore huart->RxState to Ready */
;;;2900     huart->RxState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f884003a          STRB     r0,[r4,#0x3a]
;;;2901   
;;;2902     /* Call user Abort complete callback */
;;;2903   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2904     /* Call registered Abort Receive Complete Callback */
;;;2905     huart->AbortReceiveCpltCallback(huart);
;;;2906   #else
;;;2907     /* Call legacy weak Abort Receive Complete Callback */
;;;2908     HAL_UART_AbortReceiveCpltCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2909   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2910   }
000016  bd70              POP      {r4-r6,pc}
;;;2911   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2539     */
;;;2540   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2541   {
000002  4605              MOV      r5,r0
;;;2542     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2543     /* DMA Normal mode*/
;;;2544     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b970              CBNZ     r0,|L45.46|
;;;2545     {
;;;2546       huart->TxXferCount = 0x00U;
000010  2000              MOVS     r0,#0
000012  84e0              STRH     r0,[r4,#0x26]
;;;2547   
;;;2548       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2549          in the UART CR3 register */
;;;2550       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6820              LDR      r0,[r4,#0]
000016  6940              LDR      r0,[r0,#0x14]
000018  f0200080          BIC      r0,r0,#0x80
00001c  6821              LDR      r1,[r4,#0]
00001e  6148              STR      r0,[r1,#0x14]
;;;2551   
;;;2552       /* Enable the UART Transmit Complete Interrupt */
;;;2553       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0400040          ORR      r0,r0,#0x40
000028  6821              LDR      r1,[r4,#0]
00002a  60c8              STR      r0,[r1,#0xc]
00002c  e002              B        |L45.52|
                  |L45.46|
;;;2554   
;;;2555     }
;;;2556     /* DMA Circular mode */
;;;2557     else
;;;2558     {
;;;2559   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2560       /*Call registered Tx complete callback*/
;;;2561       huart->TxCpltCallback(huart);
;;;2562   #else
;;;2563       /*Call legacy weak Tx complete callback*/
;;;2564       HAL_UART_TxCpltCallback(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L45.52|
;;;2565   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2566     }
;;;2567   }
000034  bd70              POP      {r4-r6,pc}
;;;2568   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2774     */
;;;2775   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2776   {
000002  4605              MOV      r5,r0
;;;2777     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2778   
;;;2779     huart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6b21              LDR      r1,[r4,#0x30]
00000a  6508              STR      r0,[r1,#0x50]
;;;2780   
;;;2781     /* Check if an Abort process is still ongoing */
;;;2782     if (huart->hdmarx != NULL)
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  b118              CBZ      r0,|L46.24|
;;;2783     {
;;;2784       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6b60              LDR      r0,[r4,#0x34]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L46.24|
                  |L46.22|
;;;2785       {
;;;2786         return;
;;;2787       }
;;;2788     }
;;;2789   
;;;2790     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2791     huart->TxXferCount = 0x00U;
;;;2792     huart->RxXferCount = 0x00U;
;;;2793   
;;;2794     /* Reset ErrorCode */
;;;2795     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2796   
;;;2797     /* Restore huart->gState and huart->RxState to Ready */
;;;2798     huart->gState  = HAL_UART_STATE_READY;
;;;2799     huart->RxState = HAL_UART_STATE_READY;
;;;2800   
;;;2801     /* Call user Abort complete callback */
;;;2802   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2803     /* Call registered Abort complete callback */
;;;2804     huart->AbortCpltCallback(huart);
;;;2805   #else
;;;2806     /* Call legacy weak Abort complete callback */
;;;2807     HAL_UART_AbortCpltCallback(huart);
;;;2808   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2809   }
000016  bd70              POP      {r4-r6,pc}
                  |L46.24|
000018  2000              MOVS     r0,#0                 ;2791
00001a  84e0              STRH     r0,[r4,#0x26]         ;2791
00001c  85e0              STRH     r0,[r4,#0x2e]         ;2792
00001e  63e0              STR      r0,[r4,#0x3c]         ;2795
000020  2020              MOVS     r0,#0x20              ;2798
000022  f8840039          STRB     r0,[r4,#0x39]         ;2798
000026  f884003a          STRB     r0,[r4,#0x3a]         ;2799
00002a  4620              MOV      r0,r4                 ;2807
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
000030  bf00              NOP      
000032  e7f0              B        |L46.22|
;;;2810   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2574     */
;;;2575   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2576   {
000002  4604              MOV      r4,r0
;;;2577     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2578   
;;;2579   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2580     /*Call registered Tx complete callback*/
;;;2581     huart->TxHalfCpltCallback(huart);
;;;2582   #else
;;;2583     /*Call legacy weak Tx complete callback*/
;;;2584     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2585   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2586   }
00000c  bd70              POP      {r4-r6,pc}
;;;2587   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2864     */
;;;2865   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2866   {
000002  4605              MOV      r5,r0
;;;2867     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2868   
;;;2869     huart->TxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  84e0              STRH     r0,[r4,#0x26]
;;;2870   
;;;2871     /* Restore huart->gState to Ready */
;;;2872     huart->gState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f8840039          STRB     r0,[r4,#0x39]
;;;2873   
;;;2874     /* Call user Abort complete callback */
;;;2875   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2876     /* Call registered Abort Transmit Complete Callback */
;;;2877     huart->AbortTransmitCpltCallback(huart);
;;;2878   #else
;;;2879     /* Call legacy weak Abort Transmit Complete Callback */
;;;2880     HAL_UART_AbortTransmitCpltCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2881   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2882   }
000016  bd70              POP      {r4-r6,pc}
;;;2883   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2733     */
;;;2734   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2735   {
;;;2736     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2737     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  68c9              LDR      r1,[r1,#0xc]
000004  f4217190          BIC      r1,r1,#0x120
000008  6802              LDR      r2,[r0,#0]
00000a  60d1              STR      r1,[r2,#0xc]
;;;2738     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000c  6801              LDR      r1,[r0,#0]
00000e  6949              LDR      r1,[r1,#0x14]
000010  f0210101          BIC      r1,r1,#1
000014  6802              LDR      r2,[r0,#0]
000016  6151              STR      r1,[r2,#0x14]
;;;2739   
;;;2740     /* At end of Rx process, restore huart->RxState to Ready */
;;;2741     huart->RxState = HAL_UART_STATE_READY;
000018  2120              MOVS     r1,#0x20
00001a  f880103a          STRB     r1,[r0,#0x3a]
;;;2742   }
00001e  4770              BX       lr
;;;2743   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2964     */
;;;2965   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2966   {
000002  4604              MOV      r4,r0
;;;2967     /* Disable the UART Transmit Complete Interrupt */
;;;2968     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;2969   
;;;2970     /* Tx process is ended, restore huart->gState to Ready */
;;;2971     huart->gState = HAL_UART_STATE_READY;
000010  2020              MOVS     r0,#0x20
000012  f8840039          STRB     r0,[r4,#0x39]
;;;2972   
;;;2973   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2974     /*Call registered Tx complete callback*/
;;;2975     huart->TxCpltCallback(huart);
;;;2976   #else
;;;2977     /*Call legacy weak Tx complete callback*/
;;;2978     HAL_UART_TxCpltCallback(huart);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2979   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2980   
;;;2981     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;2982   }
00001e  bd10              POP      {r4,pc}
;;;2983   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2719     */
;;;2720   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2721   {
;;;2722     /* Disable TXEIE and TCIE interrupts */
;;;2723     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  68c9              LDR      r1,[r1,#0xc]
000004  f02101c0          BIC      r1,r1,#0xc0
000008  6802              LDR      r2,[r0,#0]
00000a  60d1              STR      r1,[r2,#0xc]
;;;2724   
;;;2725     /* At end of Tx process, restore huart->gState to Ready */
;;;2726     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  f8801039          STRB     r1,[r0,#0x39]
;;;2727   }
000012  4770              BX       lr
;;;2728   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2989     */
;;;2990   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2991   {
000002  4604              MOV      r4,r0
;;;2992     uint16_t *tmp;
;;;2993   
;;;2994     /* Check that a Rx process is ongoing */
;;;2995     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000004  f894003a          LDRB     r0,[r4,#0x3a]
000008  2822              CMP      r0,#0x22
00000a  d14a              BNE      |L52.162|
;;;2996     {
;;;2997       if (huart->Init.WordLength == UART_WORDLENGTH_9B)
00000c  68a0              LDR      r0,[r4,#8]
00000e  f5b05f80          CMP      r0,#0x1000
000012  d113              BNE      |L52.60|
;;;2998       {
;;;2999         tmp = (uint16_t *) huart->pRxBuffPtr;
000014  6aa5              LDR      r5,[r4,#0x28]
;;;3000         if (huart->Init.Parity == UART_PARITY_NONE)
000016  6920              LDR      r0,[r4,#0x10]
000018  b940              CBNZ     r0,|L52.44|
;;;3001         {
;;;3002           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f3c00008          UBFX     r0,r0,#0,#9
000022  8028              STRH     r0,[r5,#0]
;;;3003           huart->pRxBuffPtr += 2U;
000024  6aa0              LDR      r0,[r4,#0x28]
000026  1c80              ADDS     r0,r0,#2
000028  62a0              STR      r0,[r4,#0x28]
00002a  e019              B        |L52.96|
                  |L52.44|
;;;3004         }
;;;3005         else
;;;3006         {
;;;3007           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  b2c0              UXTB     r0,r0
000032  8028              STRH     r0,[r5,#0]
;;;3008           huart->pRxBuffPtr += 1U;
000034  6aa0              LDR      r0,[r4,#0x28]
000036  1c40              ADDS     r0,r0,#1
000038  62a0              STR      r0,[r4,#0x28]
00003a  e011              B        |L52.96|
                  |L52.60|
;;;3009         }
;;;3010       }
;;;3011       else
;;;3012       {
;;;3013         if (huart->Init.Parity == UART_PARITY_NONE)
00003c  6920              LDR      r0,[r4,#0x10]
00003e  b938              CBNZ     r0,|L52.80|
;;;3014         {
;;;3015           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
000040  6820              LDR      r0,[r4,#0]
000042  6840              LDR      r0,[r0,#4]
000044  b2c1              UXTB     r1,r0
000046  6aa2              LDR      r2,[r4,#0x28]
000048  1c50              ADDS     r0,r2,#1
00004a  62a0              STR      r0,[r4,#0x28]
00004c  7011              STRB     r1,[r2,#0]
00004e  e007              B        |L52.96|
                  |L52.80|
;;;3016         }
;;;3017         else
;;;3018         {
;;;3019           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
000050  6820              LDR      r0,[r4,#0]
000052  6840              LDR      r0,[r0,#4]
000054  f000017f          AND      r1,r0,#0x7f
000058  6aa2              LDR      r2,[r4,#0x28]
00005a  1c50              ADDS     r0,r2,#1
00005c  62a0              STR      r0,[r4,#0x28]
00005e  7011              STRB     r1,[r2,#0]
                  |L52.96|
;;;3020         }
;;;3021       }
;;;3022   
;;;3023       if (--huart->RxXferCount == 0U)
000060  8de0              LDRH     r0,[r4,#0x2e]
000062  1e40              SUBS     r0,r0,#1
000064  b280              UXTH     r0,r0
000066  85e0              STRH     r0,[r4,#0x2e]
000068  b9c8              CBNZ     r0,|L52.158|
;;;3024       {
;;;3025         /* Disable the UART Data Register not empty Interrupt */
;;;3026         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
00006a  6820              LDR      r0,[r4,#0]
00006c  68c0              LDR      r0,[r0,#0xc]
00006e  f0200020          BIC      r0,r0,#0x20
000072  6821              LDR      r1,[r4,#0]
000074  60c8              STR      r0,[r1,#0xc]
;;;3027   
;;;3028         /* Disable the UART Parity Error Interrupt */
;;;3029         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000076  6820              LDR      r0,[r4,#0]
000078  68c0              LDR      r0,[r0,#0xc]
00007a  f4207080          BIC      r0,r0,#0x100
00007e  6821              LDR      r1,[r4,#0]
000080  60c8              STR      r0,[r1,#0xc]
;;;3030   
;;;3031         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3032         __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
000082  6820              LDR      r0,[r4,#0]
000084  6940              LDR      r0,[r0,#0x14]
000086  f0200001          BIC      r0,r0,#1
00008a  6821              LDR      r1,[r4,#0]
00008c  6148              STR      r0,[r1,#0x14]
;;;3033   
;;;3034         /* Rx process is completed, restore huart->RxState to Ready */
;;;3035         huart->RxState = HAL_UART_STATE_READY;
00008e  2020              MOVS     r0,#0x20
000090  f884003a          STRB     r0,[r4,#0x3a]
;;;3036   
;;;3037   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3038         /*Call registered Rx complete callback*/
;;;3039         huart->RxCpltCallback(huart);
;;;3040   #else
;;;3041         /*Call legacy weak Rx complete callback*/
;;;3042         HAL_UART_RxCpltCallback(huart);
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;3043   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3044   
;;;3045         return HAL_OK;
00009a  2000              MOVS     r0,#0
                  |L52.156|
;;;3046       }
;;;3047       return HAL_OK;
;;;3048     }
;;;3049     else
;;;3050     {
;;;3051       return HAL_BUSY;
;;;3052     }
;;;3053   }
00009c  bd70              POP      {r4-r6,pc}
                  |L52.158|
00009e  2000              MOVS     r0,#0                 ;3047
0000a0  e7fc              B        |L52.156|
                  |L52.162|
0000a2  2002              MOVS     r0,#2                 ;3051
0000a4  e7fa              B        |L52.156|
;;;3054   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3060     */
;;;3061   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3062   {
000004  4604              MOV      r4,r0
;;;3063     uint32_t tmpreg;
;;;3064     uint32_t pclk;
;;;3065   
;;;3066     /* Check the parameters */
;;;3067     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3068     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3069     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3070     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3071   
;;;3072     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3073     /* Configure the UART Stop Bits: Set STOP[13:12] bits
;;;3074        according to huart->Init.StopBits value */
;;;3075     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6900              LDR      r0,[r0,#0x10]
00000a  f4205040          BIC      r0,r0,#0x3000
00000e  68e1              LDR      r1,[r4,#0xc]
000010  4308              ORRS     r0,r0,r1
000012  6821              LDR      r1,[r4,#0]
000014  6108              STR      r0,[r1,#0x10]
;;;3076   
;;;3077     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3078     /* Configure the UART Word Length, Parity and mode:
;;;3079        Set the M bits according to huart->Init.WordLength value
;;;3080        Set PCE and PS bits according to huart->Init.Parity value
;;;3081        Set TE and RE bits according to huart->Init.Mode value
;;;3082        Set OVER8 bit according to huart->Init.OverSampling value */
;;;3083   
;;;3084     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
000016  6921              LDR      r1,[r4,#0x10]
000018  68a0              LDR      r0,[r4,#8]
00001a  4308              ORRS     r0,r0,r1
00001c  6961              LDR      r1,[r4,#0x14]
00001e  4308              ORRS     r0,r0,r1
000020  69e1              LDR      r1,[r4,#0x1c]
000022  4308              ORRS     r0,r0,r1
000024  9000              STR      r0,[sp,#0]
;;;3085     MODIFY_REG(huart->Instance->CR1,
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f249610c          MOV      r1,#0x960c
00002e  4388              BICS     r0,r0,r1
000030  9900              LDR      r1,[sp,#0]
000032  4308              ORRS     r0,r0,r1
000034  6821              LDR      r1,[r4,#0]
000036  60c8              STR      r0,[r1,#0xc]
;;;3086                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;3087                tmpreg);
;;;3088   
;;;3089     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3090     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;3091     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
000038  6820              LDR      r0,[r4,#0]
00003a  6940              LDR      r0,[r0,#0x14]
00003c  f4207040          BIC      r0,r0,#0x300
000040  69a1              LDR      r1,[r4,#0x18]
000042  4308              ORRS     r0,r0,r1
000044  6821              LDR      r1,[r4,#0]
000046  6148              STR      r0,[r1,#0x14]
;;;3092   
;;;3093     /* Check the Over Sampling */
;;;3094     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000048  69e0              LDR      r0,[r4,#0x1c]
00004a  f5b04f00          CMP      r0,#0x8000
00004e  d17d              BNE      |L53.332|
;;;3095     {
;;;3096       /*-------------------------- USART BRR Configuration ---------------------*/
;;;3097   #if defined(USART6) && defined(UART9) && defined(UART10)
;;;3098       if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
000050  49eb              LDR      r1,|L53.1024|
000052  6820              LDR      r0,[r4,#0]
000054  4288              CMP      r0,r1
000056  d00b              BEQ      |L53.112|
000058  49ea              LDR      r1,|L53.1028|
00005a  6820              LDR      r0,[r4,#0]
00005c  4288              CMP      r0,r1
00005e  d007              BEQ      |L53.112|
000060  49e9              LDR      r1,|L53.1032|
000062  6820              LDR      r0,[r4,#0]
000064  4288              CMP      r0,r1
000066  d003              BEQ      |L53.112|
000068  49e8              LDR      r1,|L53.1036|
00006a  6820              LDR      r0,[r4,#0]
00006c  4288              CMP      r0,r1
00006e  d16f              BNE      |L53.336|
                  |L53.112|
;;;3099       {
;;;3100         pclk = HAL_RCC_GetPCLK2Freq();
000070  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000074  4681              MOV      r9,r0
;;;3101         huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
000076  2002              MOVS     r0,#2
000078  6861              LDR      r1,[r4,#4]
00007a  fba05101          UMULL    r5,r1,r0,r1
00007e  460b              MOV      r3,r1
000080  2019              MOVS     r0,#0x19
000082  fba97100          UMULL    r7,r1,r9,r0
000086  462a              MOV      r2,r5
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       __aeabi_uldivmod
00008e  2164              MOVS     r1,#0x64
000090  fbb0f0f1          UDIV     r0,r0,r1
000094  ea4f1a00          LSL      r10,r0,#4
000098  2002              MOVS     r0,#2
00009a  6861              LDR      r1,[r4,#4]
00009c  fba05101          UMULL    r5,r1,r0,r1
0000a0  460b              MOV      r3,r1
0000a2  2019              MOVS     r0,#0x19
0000a4  fba97100          UMULL    r7,r1,r9,r0
0000a8  462a              MOV      r2,r5
0000aa  4638              MOV      r0,r7
0000ac  f7fffffe          BL       __aeabi_uldivmod
0000b0  4607              MOV      r7,r0
0000b2  2002              MOVS     r0,#2
0000b4  6861              LDR      r1,[r4,#4]
0000b6  fba05101          UMULL    r5,r1,r0,r1
0000ba  460b              MOV      r3,r1
0000bc  2019              MOVS     r0,#0x19
0000be  fba9b100          UMULL    r11,r1,r9,r0
0000c2  462a              MOV      r2,r5
0000c4  4658              MOV      r0,r11
0000c6  f7fffffe          BL       __aeabi_uldivmod
0000ca  2164              MOVS     r1,#0x64
0000cc  fbb0f0f1          UDIV     r0,r0,r1
0000d0  eb0001c0          ADD      r1,r0,r0,LSL #3
0000d4  eb011000          ADD      r0,r1,r0,LSL #4
0000d8  eba70080          SUB      r0,r7,r0,LSL #2
0000dc  2132              MOVS     r1,#0x32
0000de  eb0100c0          ADD      r0,r1,r0,LSL #3
0000e2  2164              MOVS     r1,#0x64
0000e4  fbb0f0f1          UDIV     r0,r0,r1
0000e8  f00000f8          AND      r0,r0,#0xf8
0000ec  eb0a0a40          ADD      r10,r10,r0,LSL #1
0000f0  2002              MOVS     r0,#2
0000f2  6861              LDR      r1,[r4,#4]
0000f4  fba05101          UMULL    r5,r1,r0,r1
0000f8  460b              MOV      r3,r1
0000fa  2019              MOVS     r0,#0x19
0000fc  fba97100          UMULL    r7,r1,r9,r0
000100  462a              MOV      r2,r5
000102  4638              MOV      r0,r7
000104  f7fffffe          BL       __aeabi_uldivmod
000108  4607              MOV      r7,r0
00010a  2002              MOVS     r0,#2
00010c  6861              LDR      r1,[r4,#4]
00010e  fba05101          UMULL    r5,r1,r0,r1
000112  460b              MOV      r3,r1
000114  2019              MOVS     r0,#0x19
000116  fba9b100          UMULL    r11,r1,r9,r0
00011a  462a              MOV      r2,r5
00011c  4658              MOV      r0,r11
00011e  f7fffffe          BL       __aeabi_uldivmod
000122  2164              MOVS     r1,#0x64
000124  fbb0f0f1          UDIV     r0,r0,r1
000128  eb0001c0          ADD      r1,r0,r0,LSL #3
00012c  eb011000          ADD      r0,r1,r0,LSL #4
000130  eba70080          SUB      r0,r7,r0,LSL #2
000134  2132              MOVS     r1,#0x32
000136  eb0100c0          ADD      r0,r1,r0,LSL #3
00013a  2164              MOVS     r1,#0x64
00013c  fbb0f0f1          UDIV     r0,r0,r1
000140  f0000007          AND      r0,r0,#7
000144  4450              ADD      r0,r0,r10
000146  6821              LDR      r1,[r4,#0]
000148  6088              STR      r0,[r1,#8]
00014a  e157              B        |L53.1020|
                  |L53.332|
00014c  e06e              B        |L53.556|
00014e  e7ff              B        |L53.336|
                  |L53.336|
;;;3102       }
;;;3103   #elif defined(USART6)
;;;3104       if ((huart->Instance == USART1) || (huart->Instance == USART6))
;;;3105       {
;;;3106         pclk = HAL_RCC_GetPCLK2Freq();
;;;3107         huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
;;;3108       }
;;;3109   #else
;;;3110       if (huart->Instance == USART1)
;;;3111       {
;;;3112         pclk = HAL_RCC_GetPCLK2Freq();
;;;3113         huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
;;;3114       }
;;;3115   #endif /* USART6 */
;;;3116       else
;;;3117       {
;;;3118         pclk = HAL_RCC_GetPCLK1Freq();
000150  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000154  4681              MOV      r9,r0
;;;3119         huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
000156  2002              MOVS     r0,#2
000158  6861              LDR      r1,[r4,#4]
00015a  fba05101          UMULL    r5,r1,r0,r1
00015e  460b              MOV      r3,r1
000160  2019              MOVS     r0,#0x19
000162  fba97100          UMULL    r7,r1,r9,r0
000166  462a              MOV      r2,r5
000168  4638              MOV      r0,r7
00016a  f7fffffe          BL       __aeabi_uldivmod
00016e  2164              MOVS     r1,#0x64
000170  fbb0f0f1          UDIV     r0,r0,r1
000174  ea4f1a00          LSL      r10,r0,#4
000178  2002              MOVS     r0,#2
00017a  6861              LDR      r1,[r4,#4]
00017c  fba05101          UMULL    r5,r1,r0,r1
000180  460b              MOV      r3,r1
000182  2019              MOVS     r0,#0x19
000184  fba97100          UMULL    r7,r1,r9,r0
000188  462a              MOV      r2,r5
00018a  4638              MOV      r0,r7
00018c  f7fffffe          BL       __aeabi_uldivmod
000190  4607              MOV      r7,r0
000192  2002              MOVS     r0,#2
000194  6861              LDR      r1,[r4,#4]
000196  fba05101          UMULL    r5,r1,r0,r1
00019a  460b              MOV      r3,r1
00019c  2019              MOVS     r0,#0x19
00019e  fba9b100          UMULL    r11,r1,r9,r0
0001a2  462a              MOV      r2,r5
0001a4  4658              MOV      r0,r11
0001a6  f7fffffe          BL       __aeabi_uldivmod
0001aa  2164              MOVS     r1,#0x64
0001ac  fbb0f0f1          UDIV     r0,r0,r1
0001b0  eb0001c0          ADD      r1,r0,r0,LSL #3
0001b4  eb011000          ADD      r0,r1,r0,LSL #4
0001b8  eba70080          SUB      r0,r7,r0,LSL #2
0001bc  2132              MOVS     r1,#0x32
0001be  eb0100c0          ADD      r0,r1,r0,LSL #3
0001c2  2164              MOVS     r1,#0x64
0001c4  fbb0f0f1          UDIV     r0,r0,r1
0001c8  f00000f8          AND      r0,r0,#0xf8
0001cc  eb0a0a40          ADD      r10,r10,r0,LSL #1
0001d0  2002              MOVS     r0,#2
0001d2  6861              LDR      r1,[r4,#4]
0001d4  fba05101          UMULL    r5,r1,r0,r1
0001d8  460b              MOV      r3,r1
0001da  2019              MOVS     r0,#0x19
0001dc  fba97100          UMULL    r7,r1,r9,r0
0001e0  462a              MOV      r2,r5
0001e2  4638              MOV      r0,r7
0001e4  f7fffffe          BL       __aeabi_uldivmod
0001e8  4607              MOV      r7,r0
0001ea  2002              MOVS     r0,#2
0001ec  6861              LDR      r1,[r4,#4]
0001ee  fba05001          UMULL    r5,r0,r0,r1
0001f2  4603              MOV      r3,r0
0001f4  2019              MOVS     r0,#0x19
0001f6  fba9b100          UMULL    r11,r1,r9,r0
0001fa  462a              MOV      r2,r5
0001fc  4658              MOV      r0,r11
0001fe  f7fffffe          BL       __aeabi_uldivmod
000202  2164              MOVS     r1,#0x64
000204  fbb0f0f1          UDIV     r0,r0,r1
000208  eb0001c0          ADD      r1,r0,r0,LSL #3
00020c  eb011000          ADD      r0,r1,r0,LSL #4
000210  eba70080          SUB      r0,r7,r0,LSL #2
000214  2132              MOVS     r1,#0x32
000216  eb0100c0          ADD      r0,r1,r0,LSL #3
00021a  2164              MOVS     r1,#0x64
00021c  fbb0f0f1          UDIV     r0,r0,r1
000220  f0000007          AND      r0,r0,#7
000224  4450              ADD      r0,r0,r10
000226  6821              LDR      r1,[r4,#0]
000228  6088              STR      r0,[r1,#8]
00022a  e0e7              B        |L53.1020|
                  |L53.556|
;;;3120       }
;;;3121     }
;;;3122     else
;;;3123     {
;;;3124       /*-------------------------- USART BRR Configuration ---------------------*/
;;;3125   #if defined(USART6) && defined(UART9) && defined(UART10)
;;;3126       if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
00022c  4974              LDR      r1,|L53.1024|
00022e  6820              LDR      r0,[r4,#0]
000230  4288              CMP      r0,r1
000232  d00b              BEQ      |L53.588|
000234  4973              LDR      r1,|L53.1028|
000236  6820              LDR      r0,[r4,#0]
000238  4288              CMP      r0,r1
00023a  d007              BEQ      |L53.588|
00023c  4972              LDR      r1,|L53.1032|
00023e  6820              LDR      r0,[r4,#0]
000240  4288              CMP      r0,r1
000242  d003              BEQ      |L53.588|
000244  4971              LDR      r1,|L53.1036|
000246  6820              LDR      r0,[r4,#0]
000248  4288              CMP      r0,r1
00024a  d16b              BNE      |L53.804|
                  |L53.588|
;;;3127       {
;;;3128         pclk = HAL_RCC_GetPCLK2Freq();
00024c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000250  4681              MOV      r9,r0
;;;3129         huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
000252  2004              MOVS     r0,#4
000254  6861              LDR      r1,[r4,#4]
000256  fba05101          UMULL    r5,r1,r0,r1
00025a  460b              MOV      r3,r1
00025c  2019              MOVS     r0,#0x19
00025e  fba97100          UMULL    r7,r1,r9,r0
000262  462a              MOV      r2,r5
000264  4638              MOV      r0,r7
000266  f7fffffe          BL       __aeabi_uldivmod
00026a  4682              MOV      r10,r0
00026c  2004              MOVS     r0,#4
00026e  6861              LDR      r1,[r4,#4]
000270  fba05001          UMULL    r5,r0,r0,r1
000274  4603              MOV      r3,r0
000276  2019              MOVS     r0,#0x19
000278  fba97100          UMULL    r7,r1,r9,r0
00027c  462a              MOV      r2,r5
00027e  4638              MOV      r0,r7
000280  f7fffffe          BL       __aeabi_uldivmod
000284  2164              MOVS     r1,#0x64
000286  fbb0f0f1          UDIV     r0,r0,r1
00028a  eb0001c0          ADD      r1,r0,r0,LSL #3
00028e  eb011000          ADD      r0,r1,r0,LSL #4
000292  ebaa0080          SUB      r0,r10,r0,LSL #2
000296  2132              MOVS     r1,#0x32
000298  eb011000          ADD      r0,r1,r0,LSL #4
00029c  2164              MOVS     r1,#0x64
00029e  fbb0f0f1          UDIV     r0,r0,r1
0002a2  f0000af0          AND      r10,r0,#0xf0
0002a6  2004              MOVS     r0,#4
0002a8  6861              LDR      r1,[r4,#4]
0002aa  fba05001          UMULL    r5,r0,r0,r1
0002ae  4603              MOV      r3,r0
0002b0  2019              MOVS     r0,#0x19
0002b2  fba97100          UMULL    r7,r1,r9,r0
0002b6  462a              MOV      r2,r5
0002b8  4638              MOV      r0,r7
0002ba  f7fffffe          BL       __aeabi_uldivmod
0002be  2164              MOVS     r1,#0x64
0002c0  fbb0f0f1          UDIV     r0,r0,r1
0002c4  eb0a1a00          ADD      r10,r10,r0,LSL #4
0002c8  2004              MOVS     r0,#4
0002ca  6861              LDR      r1,[r4,#4]
0002cc  fba05101          UMULL    r5,r1,r0,r1
0002d0  460b              MOV      r3,r1
0002d2  2019              MOVS     r0,#0x19
0002d4  fba97100          UMULL    r7,r1,r9,r0
0002d8  462a              MOV      r2,r5
0002da  4638              MOV      r0,r7
0002dc  f7fffffe          BL       __aeabi_uldivmod
0002e0  4607              MOV      r7,r0
0002e2  2004              MOVS     r0,#4
0002e4  6861              LDR      r1,[r4,#4]
0002e6  fba05001          UMULL    r5,r0,r0,r1
0002ea  4603              MOV      r3,r0
0002ec  2019              MOVS     r0,#0x19
0002ee  fba9b100          UMULL    r11,r1,r9,r0
0002f2  462a              MOV      r2,r5
0002f4  4658              MOV      r0,r11
0002f6  f7fffffe          BL       __aeabi_uldivmod
0002fa  2164              MOVS     r1,#0x64
0002fc  fbb0f0f1          UDIV     r0,r0,r1
000300  eb0001c0          ADD      r1,r0,r0,LSL #3
000304  eb011000          ADD      r0,r1,r0,LSL #4
000308  eba70080          SUB      r0,r7,r0,LSL #2
00030c  2132              MOVS     r1,#0x32
00030e  eb011000          ADD      r0,r1,r0,LSL #4
000312  2164              MOVS     r1,#0x64
000314  fbb0f0f1          UDIV     r0,r0,r1
000318  f000000f          AND      r0,r0,#0xf
00031c  4450              ADD      r0,r0,r10
00031e  6821              LDR      r1,[r4,#0]
000320  6088              STR      r0,[r1,#8]
000322  e06b              B        |L53.1020|
                  |L53.804|
;;;3130       }
;;;3131   #elif defined(USART6)
;;;3132       if ((huart->Instance == USART1) || (huart->Instance == USART6))
;;;3133       {
;;;3134         pclk = HAL_RCC_GetPCLK2Freq();
;;;3135         huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
;;;3136       }
;;;3137   #else
;;;3138       if (huart->Instance == USART1)
;;;3139       {
;;;3140         pclk = HAL_RCC_GetPCLK2Freq();
;;;3141         huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
;;;3142       }
;;;3143   #endif /* USART6 */
;;;3144       else
;;;3145       {
;;;3146         pclk = HAL_RCC_GetPCLK1Freq();
000324  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000328  4681              MOV      r9,r0
;;;3147         huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
00032a  2004              MOVS     r0,#4
00032c  6861              LDR      r1,[r4,#4]
00032e  fba05001          UMULL    r5,r0,r0,r1
000332  4603              MOV      r3,r0
000334  2019              MOVS     r0,#0x19
000336  fba97100          UMULL    r7,r1,r9,r0
00033a  462a              MOV      r2,r5
00033c  4638              MOV      r0,r7
00033e  f7fffffe          BL       __aeabi_uldivmod
000342  4682              MOV      r10,r0
000344  2004              MOVS     r0,#4
000346  6861              LDR      r1,[r4,#4]
000348  fba05001          UMULL    r5,r0,r0,r1
00034c  4603              MOV      r3,r0
00034e  2019              MOVS     r0,#0x19
000350  fba97100          UMULL    r7,r1,r9,r0
000354  462a              MOV      r2,r5
000356  4638              MOV      r0,r7
000358  f7fffffe          BL       __aeabi_uldivmod
00035c  2164              MOVS     r1,#0x64
00035e  fbb0f0f1          UDIV     r0,r0,r1
000362  eb0001c0          ADD      r1,r0,r0,LSL #3
000366  eb011000          ADD      r0,r1,r0,LSL #4
00036a  ebaa0080          SUB      r0,r10,r0,LSL #2
00036e  2132              MOVS     r1,#0x32
000370  eb011000          ADD      r0,r1,r0,LSL #4
000374  2164              MOVS     r1,#0x64
000376  fbb0f0f1          UDIV     r0,r0,r1
00037a  f0000af0          AND      r10,r0,#0xf0
00037e  2004              MOVS     r0,#4
000380  6861              LDR      r1,[r4,#4]
000382  fba05001          UMULL    r5,r0,r0,r1
000386  4603              MOV      r3,r0
000388  2019              MOVS     r0,#0x19
00038a  fba97000          UMULL    r7,r0,r9,r0
00038e  4601              MOV      r1,r0
000390  462a              MOV      r2,r5
000392  4638              MOV      r0,r7
000394  f7fffffe          BL       __aeabi_uldivmod
000398  2164              MOVS     r1,#0x64
00039a  fbb0f0f1          UDIV     r0,r0,r1
00039e  eb0a1a00          ADD      r10,r10,r0,LSL #4
0003a2  2004              MOVS     r0,#4
0003a4  6861              LDR      r1,[r4,#4]
0003a6  fba07001          UMULL    r7,r0,r0,r1
0003aa  4603              MOV      r3,r0
0003ac  2019              MOVS     r0,#0x19
0003ae  fba95100          UMULL    r5,r1,r9,r0
0003b2  463a              MOV      r2,r7
0003b4  4628              MOV      r0,r5
0003b6  f7fffffe          BL       __aeabi_uldivmod
0003ba  4607              MOV      r7,r0
0003bc  2004              MOVS     r0,#4
0003be  6861              LDR      r1,[r4,#4]
0003c0  fba05001          UMULL    r5,r0,r0,r1
0003c4  4603              MOV      r3,r0
0003c6  2019              MOVS     r0,#0x19
0003c8  fba9b100          UMULL    r11,r1,r9,r0
0003cc  462a              MOV      r2,r5
0003ce  4658              MOV      r0,r11
0003d0  f7fffffe          BL       __aeabi_uldivmod
0003d4  2164              MOVS     r1,#0x64
0003d6  fbb0f0f1          UDIV     r0,r0,r1
0003da  eb0001c0          ADD      r1,r0,r0,LSL #3
0003de  eb011000          ADD      r0,r1,r0,LSL #4
0003e2  eba70080          SUB      r0,r7,r0,LSL #2
0003e6  2132              MOVS     r1,#0x32
0003e8  eb011000          ADD      r0,r1,r0,LSL #4
0003ec  2164              MOVS     r1,#0x64
0003ee  fbb0f0f1          UDIV     r0,r0,r1
0003f2  f000000f          AND      r0,r0,#0xf
0003f6  4450              ADD      r0,r0,r10
0003f8  6821              LDR      r1,[r4,#0]
0003fa  6088              STR      r0,[r1,#8]
                  |L53.1020|
;;;3148       }
;;;3149     }
;;;3150   }
0003fc  e8bd8ff8          POP      {r3-r11,pc}
;;;3151   
                          ENDP

                  |L53.1024|
                          DCD      0x40011000
                  |L53.1028|
                          DCD      0x40011400
                  |L53.1032|
                          DCD      0x40011800
                  |L53.1036|
                          DCD      0x40011c00

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2917     */
;;;2918   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2919   {
;;;2920     uint16_t *tmp;
;;;2921   
;;;2922     /* Check that a Tx process is ongoing */
;;;2923     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  f8910039          LDRB     r0,[r1,#0x39]
000006  2821              CMP      r0,#0x21
000008  d12c              BNE      |L54.100|
;;;2924     {
;;;2925       if (huart->Init.WordLength == UART_WORDLENGTH_9B)
00000a  6888              LDR      r0,[r1,#8]
00000c  f5b05f80          CMP      r0,#0x1000
000010  d10f              BNE      |L54.50|
;;;2926       {
;;;2927         tmp = (uint16_t *) huart->pTxBuffPtr;
000012  6a0a              LDR      r2,[r1,#0x20]
;;;2928         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000014  8810              LDRH     r0,[r2,#0]
000016  f3c00008          UBFX     r0,r0,#0,#9
00001a  680b              LDR      r3,[r1,#0]
00001c  6058              STR      r0,[r3,#4]
;;;2929         if (huart->Init.Parity == UART_PARITY_NONE)
00001e  6908              LDR      r0,[r1,#0x10]
000020  b918              CBNZ     r0,|L54.42|
;;;2930         {
;;;2931           huart->pTxBuffPtr += 2U;
000022  6a08              LDR      r0,[r1,#0x20]
000024  1c80              ADDS     r0,r0,#2
000026  6208              STR      r0,[r1,#0x20]
000028  e009              B        |L54.62|
                  |L54.42|
;;;2932         }
;;;2933         else
;;;2934         {
;;;2935           huart->pTxBuffPtr += 1U;
00002a  6a08              LDR      r0,[r1,#0x20]
00002c  1c40              ADDS     r0,r0,#1
00002e  6208              STR      r0,[r1,#0x20]
000030  e005              B        |L54.62|
                  |L54.50|
;;;2936         }
;;;2937       }
;;;2938       else
;;;2939       {
;;;2940         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
000032  6a0b              LDR      r3,[r1,#0x20]
000034  1c58              ADDS     r0,r3,#1
000036  6208              STR      r0,[r1,#0x20]
000038  7818              LDRB     r0,[r3,#0]
00003a  680b              LDR      r3,[r1,#0]
00003c  6058              STR      r0,[r3,#4]
                  |L54.62|
;;;2941       }
;;;2942   
;;;2943       if (--huart->TxXferCount == 0U)
00003e  8cc8              LDRH     r0,[r1,#0x26]
000040  1e40              SUBS     r0,r0,#1
000042  b280              UXTH     r0,r0
000044  84c8              STRH     r0,[r1,#0x26]
000046  b958              CBNZ     r0,|L54.96|
;;;2944       {
;;;2945         /* Disable the UART Transmit Complete Interrupt */
;;;2946         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
000048  6808              LDR      r0,[r1,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  f0200080          BIC      r0,r0,#0x80
000050  680b              LDR      r3,[r1,#0]
000052  60d8              STR      r0,[r3,#0xc]
;;;2947   
;;;2948         /* Enable the UART Transmit Complete Interrupt */
;;;2949         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
000054  6808              LDR      r0,[r1,#0]
000056  68c0              LDR      r0,[r0,#0xc]
000058  f0400040          ORR      r0,r0,#0x40
00005c  680b              LDR      r3,[r1,#0]
00005e  60d8              STR      r0,[r3,#0xc]
                  |L54.96|
;;;2950       }
;;;2951       return HAL_OK;
000060  2000              MOVS     r0,#0
                  |L54.98|
;;;2952     }
;;;2953     else
;;;2954     {
;;;2955       return HAL_BUSY;
;;;2956     }
;;;2957   }
000062  4770              BX       lr
                  |L54.100|
000064  2002              MOVS     r0,#2                 ;2955
000066  e7fc              B        |L54.98|
;;;2958   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2687     */
;;;2688   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2689   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e06              LDR      r6,[sp,#0x18]
;;;2690     /* Wait until flag is set */
;;;2691     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  e021              B        |L55.84|
                  |L55.16|
;;;2692     {
;;;2693       /* Check for the Timeout */
;;;2694       if (Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b1f8              CBZ      r0,|L55.84|
;;;2695       {
;;;2696         if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
000014  b12e              CBZ      r6,|L55.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d918              BLS      |L55.84|
                  |L55.34|
;;;2697         {
;;;2698           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2699           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000022  6820              LDR      r0,[r4,#0]
000024  68c0              LDR      r0,[r0,#0xc]
000026  f42070d0          BIC      r0,r0,#0x1a0
00002a  6821              LDR      r1,[r4,#0]
00002c  60c8              STR      r0,[r1,#0xc]
;;;2700           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00002e  6820              LDR      r0,[r4,#0]
000030  6940              LDR      r0,[r0,#0x14]
000032  f0200001          BIC      r0,r0,#1
000036  6821              LDR      r1,[r4,#0]
000038  6148              STR      r0,[r1,#0x14]
;;;2701   
;;;2702           huart->gState  = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  f8840039          STRB     r0,[r4,#0x39]
;;;2703           huart->RxState = HAL_UART_STATE_READY;
000040  f884003a          STRB     r0,[r4,#0x3a]
;;;2704   
;;;2705           /* Process Unlocked */
;;;2706           __HAL_UNLOCK(huart);
000044  bf00              NOP      
000046  2000              MOVS     r0,#0
000048  f8840038          STRB     r0,[r4,#0x38]
00004c  bf00              NOP      
;;;2707   
;;;2708           return HAL_TIMEOUT;
00004e  2003              MOVS     r0,#3
                  |L55.80|
;;;2709         }
;;;2710       }
;;;2711     }
;;;2712     return HAL_OK;
;;;2713   }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L55.84|
000054  6820              LDR      r0,[r4,#0]            ;2691
000056  6800              LDR      r0,[r0,#0]            ;2691
000058  4028              ANDS     r0,r0,r5              ;2691
00005a  42a8              CMP      r0,r5                 ;2691
00005c  d101              BNE      |L55.98|
00005e  2001              MOVS     r0,#1                 ;2691
000060  e000              B        |L55.100|
                  |L55.98|
000062  2000              MOVS     r0,#0                 ;2691
                  |L55.100|
000064  42b8              CMP      r0,r7                 ;2691
000066  d0d3              BEQ      |L55.16|
000068  2000              MOVS     r0,#0                 ;2712
00006a  e7f1              B        |L55.80|
;;;2714   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH|
#line 478
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX|
#line 665
|__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
